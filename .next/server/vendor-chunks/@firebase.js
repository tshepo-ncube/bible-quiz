"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PlatformLoggerServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    // In initial implementation, this will be called by installations on\r\n    // auth token refresh, and installations will send this string.\r\n    getPlatformInfoString() {\r\n        const providers = this.container.getProviders();\r\n        // Loop through providers and get library/version pairs from any that are\r\n        // version components.\r\n        return providers\r\n            .map(provider => {\r\n            if (isVersionServiceProvider(provider)) {\r\n                const service = provider.getImmediate();\r\n                return `${service.library}/${service.version}`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        })\r\n            .filter(logString => logString)\r\n            .join(' ');\r\n    }\r\n}\r\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\r\nfunction isVersionServiceProvider(provider) {\r\n    const component = provider.getComponent();\r\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\r\n}\n\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.10.2\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$n = \"@firebase/app-compat\";\n\nconst name$m = \"@firebase/analytics-compat\";\n\nconst name$l = \"@firebase/analytics\";\n\nconst name$k = \"@firebase/app-check-compat\";\n\nconst name$j = \"@firebase/app-check\";\n\nconst name$i = \"@firebase/auth\";\n\nconst name$h = \"@firebase/auth-compat\";\n\nconst name$g = \"@firebase/database\";\n\nconst name$f = \"@firebase/database-compat\";\n\nconst name$e = \"@firebase/functions\";\n\nconst name$d = \"@firebase/functions-compat\";\n\nconst name$c = \"@firebase/installations\";\n\nconst name$b = \"@firebase/installations-compat\";\n\nconst name$a = \"@firebase/messaging\";\n\nconst name$9 = \"@firebase/messaging-compat\";\n\nconst name$8 = \"@firebase/performance\";\n\nconst name$7 = \"@firebase/performance-compat\";\n\nconst name$6 = \"@firebase/remote-config\";\n\nconst name$5 = \"@firebase/remote-config-compat\";\n\nconst name$4 = \"@firebase/storage\";\n\nconst name$3 = \"@firebase/storage-compat\";\n\nconst name$2 = \"@firebase/firestore\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"10.11.1\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\nconst PLATFORM_LOG_STRING = {\r\n    [name$o]: 'fire-core',\r\n    [name$n]: 'fire-core-compat',\r\n    [name$l]: 'fire-analytics',\r\n    [name$m]: 'fire-analytics-compat',\r\n    [name$j]: 'fire-app-check',\r\n    [name$k]: 'fire-app-check-compat',\r\n    [name$i]: 'fire-auth',\r\n    [name$h]: 'fire-auth-compat',\r\n    [name$g]: 'fire-rtdb',\r\n    [name$f]: 'fire-rtdb-compat',\r\n    [name$e]: 'fire-fn',\r\n    [name$d]: 'fire-fn-compat',\r\n    [name$c]: 'fire-iid',\r\n    [name$b]: 'fire-iid-compat',\r\n    [name$a]: 'fire-fcm',\r\n    [name$9]: 'fire-fcm-compat',\r\n    [name$8]: 'fire-perf',\r\n    [name$7]: 'fire-perf-compat',\r\n    [name$6]: 'fire-rc',\r\n    [name$5]: 'fire-rc-compat',\r\n    [name$4]: 'fire-gcs',\r\n    [name$3]: 'fire-gcs-compat',\r\n    [name$2]: 'fire-fst',\r\n    [name$1]: 'fire-fst-compat',\r\n    'fire-js': 'fire-js',\r\n    [name]: 'fire-js-all'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nconst _apps = new Map();\r\n/**\r\n * @internal\r\n */\r\nconst _serverApps = new Map();\r\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst _components = new Map();\r\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\r\nfunction _addComponent(app, component) {\r\n    try {\r\n        app.container.addComponent(component);\r\n    }\r\n    catch (e) {\r\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n */\r\nfunction _addOrOverwriteComponent(app, component) {\r\n    app.container.addOrOverwriteComponent(component);\r\n}\r\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\r\nfunction _registerComponent(component) {\r\n    const componentName = component.name;\r\n    if (_components.has(componentName)) {\r\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\r\n        return false;\r\n    }\r\n    _components.set(componentName, component);\r\n    // add the component to existing app instances\r\n    for (const app of _apps.values()) {\r\n        _addComponent(app, component);\r\n    }\r\n    for (const serverApp of _serverApps.values()) {\r\n        _addComponent(serverApp, component);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\r\nfunction _getProvider(app, name) {\r\n    const heartbeatController = app.container\r\n        .getProvider('heartbeat')\r\n        .getImmediate({ optional: true });\r\n    if (heartbeatController) {\r\n        void heartbeatController.triggerHeartbeat();\r\n    }\r\n    return app.container.getProvider(name);\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\r\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\r\n    _getProvider(app, name).clearInstance(instanceIdentifier);\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseApp(obj) {\r\n    return obj.options !== undefined;\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseServerApp(obj) {\r\n    return obj.settings !== undefined;\r\n}\r\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\r\nfunction _clearComponents() {\r\n    _components.clear();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\r\n        'call initializeApp() first',\r\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\r\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\r\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\r\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\r\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\r\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\r\n        'Firebase App instance.',\r\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\r\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\r\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\r\n};\r\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseAppImpl {\r\n    constructor(options, config, container) {\r\n        this._isDeleted = false;\r\n        this._options = Object.assign({}, options);\r\n        this._config = Object.assign({}, config);\r\n        this._name = config.name;\r\n        this._automaticDataCollectionEnabled =\r\n            config.automaticDataCollectionEnabled;\r\n        this._container = container;\r\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    }\r\n    get automaticDataCollectionEnabled() {\r\n        this.checkDestroyed();\r\n        return this._automaticDataCollectionEnabled;\r\n    }\r\n    set automaticDataCollectionEnabled(val) {\r\n        this.checkDestroyed();\r\n        this._automaticDataCollectionEnabled = val;\r\n    }\r\n    get name() {\r\n        this.checkDestroyed();\r\n        return this._name;\r\n    }\r\n    get options() {\r\n        this.checkDestroyed();\r\n        return this._options;\r\n    }\r\n    get config() {\r\n        this.checkDestroyed();\r\n        return this._config;\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    get isDeleted() {\r\n        return this._isDeleted;\r\n    }\r\n    set isDeleted(val) {\r\n        this._isDeleted = val;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\r\n    constructor(options, serverConfig, name, container) {\r\n        // Build configuration parameters for the FirebaseAppImpl base class.\r\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\r\n            ? serverConfig.automaticDataCollectionEnabled\r\n            : false;\r\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\r\n        const config = {\r\n            name,\r\n            automaticDataCollectionEnabled\r\n        };\r\n        if (options.apiKey !== undefined) {\r\n            // Construct the parent FirebaseAppImp object.\r\n            super(options, config, container);\r\n        }\r\n        else {\r\n            const appImpl = options;\r\n            super(appImpl.options, config, container);\r\n        }\r\n        // Now construct the data for the FirebaseServerAppImpl.\r\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\r\n        this._finalizationRegistry = new FinalizationRegistry(() => {\r\n            this.automaticCleanup();\r\n        });\r\n        this._refCount = 0;\r\n        this.incRefCount(this._serverConfig.releaseOnDeref);\r\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\r\n        // will never trigger.\r\n        this._serverConfig.releaseOnDeref = undefined;\r\n        serverConfig.releaseOnDeref = undefined;\r\n        registerVersion(name$o, version$1, 'serverapp');\r\n    }\r\n    toJSON() {\r\n        return undefined;\r\n    }\r\n    get refCount() {\r\n        return this._refCount;\r\n    }\r\n    // Increment the reference count of this server app. If an object is provided, register it\r\n    // with the finalization registry.\r\n    incRefCount(obj) {\r\n        if (this.isDeleted) {\r\n            return;\r\n        }\r\n        this._refCount++;\r\n        if (obj !== undefined) {\r\n            this._finalizationRegistry.register(obj, this);\r\n        }\r\n    }\r\n    // Decrement the reference count.\r\n    decRefCount() {\r\n        if (this.isDeleted) {\r\n            return 0;\r\n        }\r\n        return --this._refCount;\r\n    }\r\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\r\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\r\n    // handles this is in deleteApp(...).\r\n    automaticCleanup() {\r\n        void deleteApp(this);\r\n    }\r\n    get settings() {\r\n        this.checkDestroyed();\r\n        return this._serverConfig;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\r\nconst SDK_VERSION = version;\r\nfunction initializeApp(_options, rawConfig = {}) {\r\n    let options = _options;\r\n    if (typeof rawConfig !== 'object') {\r\n        const name = rawConfig;\r\n        rawConfig = { name };\r\n    }\r\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\r\n    const name = config.name;\r\n    if (typeof name !== 'string' || !name) {\r\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\r\n            appName: String(name)\r\n        });\r\n    }\r\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\r\n    if (!options) {\r\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\r\n    }\r\n    const existingApp = _apps.get(name);\r\n    if (existingApp) {\r\n        // return the existing app if options and config deep equal the ones in the existing app.\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\r\n            return existingApp;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\r\n        }\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseAppImpl(options, config, container);\r\n    _apps.set(name, newApp);\r\n    return newApp;\r\n}\r\nfunction initializeServerApp(_options, _serverAppConfig) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)()) {\r\n        // FirebaseServerApp isn't designed to be run in browsers.\r\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\r\n    }\r\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\r\n        _serverAppConfig.automaticDataCollectionEnabled = false;\r\n    }\r\n    let appOptions;\r\n    if (_isFirebaseApp(_options)) {\r\n        appOptions = _options.options;\r\n    }\r\n    else {\r\n        appOptions = _options;\r\n    }\r\n    // Build an app name based on a hash of the configuration options.\r\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\r\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\r\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\r\n    if (nameObj.releaseOnDeref !== undefined) {\r\n        delete nameObj.releaseOnDeref;\r\n    }\r\n    const hashCode = (s) => {\r\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\r\n    };\r\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\r\n        if (typeof FinalizationRegistry === 'undefined') {\r\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\r\n        }\r\n    }\r\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\r\n    const existingApp = _serverApps.get(nameString);\r\n    if (existingApp) {\r\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\r\n        return existingApp;\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\r\n    _serverApps.set(nameString, newApp);\r\n    return newApp;\r\n}\r\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\r\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\r\n    const app = _apps.get(name);\r\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\r\n        return initializeApp();\r\n    }\r\n    if (!app) {\r\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\r\n    }\r\n    return app;\r\n}\r\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\r\nfunction getApps() {\r\n    return Array.from(_apps.values());\r\n}\r\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\r\nasync function deleteApp(app) {\r\n    let cleanupProviders = false;\r\n    const name = app.name;\r\n    if (_apps.has(name)) {\r\n        cleanupProviders = true;\r\n        _apps.delete(name);\r\n    }\r\n    else if (_serverApps.has(name)) {\r\n        const firebaseServerApp = app;\r\n        if (firebaseServerApp.decRefCount() <= 0) {\r\n            _serverApps.delete(name);\r\n            cleanupProviders = true;\r\n        }\r\n    }\r\n    if (cleanupProviders) {\r\n        await Promise.all(app.container\r\n            .getProviders()\r\n            .map(provider => provider.delete()));\r\n        app.isDeleted = true;\r\n    }\r\n}\r\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\r\nfunction registerVersion(libraryKeyOrName, version, variant) {\r\n    var _a;\r\n    // TODO: We can use this check to whitelist strings when/if we set up\r\n    // a good whitelist system.\r\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\r\n    if (variant) {\r\n        library += `-${variant}`;\r\n    }\r\n    const libraryMismatch = library.match(/\\s|\\//);\r\n    const versionMismatch = version.match(/\\s|\\//);\r\n    if (libraryMismatch || versionMismatch) {\r\n        const warning = [\r\n            `Unable to register library \"${library}\" with version \"${version}\":`\r\n        ];\r\n        if (libraryMismatch) {\r\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        if (libraryMismatch && versionMismatch) {\r\n            warning.push('and');\r\n        }\r\n        if (versionMismatch) {\r\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        logger.warn(warning.join(' '));\r\n        return;\r\n    }\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\r\n}\r\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\r\nfunction onLog(logCallback, options) {\r\n    if (logCallback !== null && typeof logCallback !== 'function') {\r\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\r\n    }\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\r\n}\r\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-heartbeat-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-heartbeat-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        try {\r\n                            db.createObjectStore(STORE_NAME);\r\n                        }\r\n                        catch (e) {\r\n                            // Safari/iOS browsers throw occasional exceptions on\r\n                            // db.createObjectStore() that may be a bug. Avoid blocking\r\n                            // the rest of the app functionality.\r\n                            console.warn(e);\r\n                        }\r\n                }\r\n            }\r\n        }).catch(e => {\r\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\r\n                originalErrorMessage: e.message\r\n            });\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\nasync function readHeartbeatsFromIndexedDB(app) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME);\r\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\r\n        // We already have the value but tx.done can throw,\r\n        // so we need to await it here to catch errors\r\n        await tx.done;\r\n        return result;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME, 'readwrite');\r\n        const objectStore = tx.objectStore(STORE_NAME);\r\n        await objectStore.put(heartbeatObject, computeKey(app));\r\n        await tx.done;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.name}!${app.options.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_HEADER_BYTES = 1024;\r\n// 30 days\r\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\r\nclass HeartbeatServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */\r\n        this._heartbeatsCache = null;\r\n        const app = this.container.getProvider('app').getImmediate();\r\n        this._storage = new HeartbeatStorageImpl(app);\r\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\r\n            this._heartbeatsCache = result;\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */\r\n    async triggerHeartbeat() {\r\n        var _a, _b;\r\n        const platformLogger = this.container\r\n            .getProvider('platform-logger')\r\n            .getImmediate();\r\n        // This is the \"Firebase user agent\" string from the platform logger\r\n        // service, not the browser user agent.\r\n        const agent = platformLogger.getPlatformInfoString();\r\n        const date = getUTCDateString();\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\r\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\r\n            // If we failed to construct a heartbeats cache, then return immediately.\r\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\r\n                return;\r\n            }\r\n        }\r\n        // Do not store a heartbeat if one is already stored for this day\r\n        // or if a header has already been sent today.\r\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\r\n            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\r\n            return;\r\n        }\r\n        else {\r\n            // There is no entry for this date. Create one.\r\n            this._heartbeatsCache.heartbeats.push({ date, agent });\r\n        }\r\n        // Remove entries older than 30 days.\r\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\r\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\r\n            const now = Date.now();\r\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\r\n        });\r\n        return this._storage.overwrite(this._heartbeatsCache);\r\n    }\r\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */\r\n    async getHeartbeatsHeader() {\r\n        var _a;\r\n        if (this._heartbeatsCache === null) {\r\n            await this._heartbeatsCachePromise;\r\n        }\r\n        // If it's still null or the array is empty, there is no data to send.\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\r\n            this._heartbeatsCache.heartbeats.length === 0) {\r\n            return '';\r\n        }\r\n        const date = getUTCDateString();\r\n        // Extract as many heartbeats from the cache as will fit under the size limit.\r\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\r\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\r\n        // Store last sent date to prevent another being logged/sent for the same day.\r\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\r\n        if (unsentEntries.length > 0) {\r\n            // Store any unsent entries if they exist.\r\n            this._heartbeatsCache.heartbeats = unsentEntries;\r\n            // This seems more likely than emptying the array (below) to lead to some odd state\r\n            // since the cache isn't empty and this will be called again on the next request,\r\n            // and is probably safest if we await it.\r\n            await this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        else {\r\n            this._heartbeatsCache.heartbeats = [];\r\n            // Do not wait for this, to reduce latency.\r\n            void this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        return headerString;\r\n    }\r\n}\r\nfunction getUTCDateString() {\r\n    const today = new Date();\r\n    // Returns date format 'YYYY-MM-DD'\r\n    return today.toISOString().substring(0, 10);\r\n}\r\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\r\n    // Heartbeats grouped by user agent in the standard format to be sent in\r\n    // the header.\r\n    const heartbeatsToSend = [];\r\n    // Single date format heartbeats that are not sent.\r\n    let unsentEntries = heartbeatsCache.slice();\r\n    for (const singleDateHeartbeat of heartbeatsCache) {\r\n        // Look for an existing entry with the same user agent.\r\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\r\n        if (!heartbeatEntry) {\r\n            // If no entry for this user agent exists, create one.\r\n            heartbeatsToSend.push({\r\n                agent: singleDateHeartbeat.agent,\r\n                dates: [singleDateHeartbeat.date]\r\n            });\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                // If the header would exceed max size, remove the added heartbeat\r\n                // entry and stop adding to the header.\r\n                heartbeatsToSend.pop();\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\r\n            // If the header would exceed max size, remove the added date\r\n            // and stop adding to the header.\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                heartbeatEntry.dates.pop();\r\n                break;\r\n            }\r\n        }\r\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\r\n        // quota and the loop breaks early.)\r\n        unsentEntries = unsentEntries.slice(1);\r\n    }\r\n    return {\r\n        heartbeatsToSend,\r\n        unsentEntries\r\n    };\r\n}\r\nclass HeartbeatStorageImpl {\r\n    constructor(app) {\r\n        this.app = app;\r\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\r\n    }\r\n    async runIndexedDBEnvironmentCheck() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\r\n                .then(() => true)\r\n                .catch(() => false);\r\n        }\r\n    }\r\n    /**\r\n     * Read all heartbeats.\r\n     */\r\n    async read() {\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return { heartbeats: [] };\r\n        }\r\n        else {\r\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\r\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\r\n                return idbHeartbeatObject;\r\n            }\r\n            else {\r\n                return { heartbeats: [] };\r\n            }\r\n        }\r\n    }\r\n    // overwrite the storage with the provided heartbeats\r\n    async overwrite(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: heartbeatsObject.heartbeats\r\n            });\r\n        }\r\n    }\r\n    // add heartbeats\r\n    async add(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: [\r\n                    ...existingHeartbeatsObject.heartbeats,\r\n                    ...heartbeatsObject.heartbeats\r\n                ]\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */\r\nfunction countBytes(heartbeatsCache) {\r\n    // base64 has a restricted set of characters, all of which should be 1 byte.\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\r\n    // heartbeatsCache wrapper properties\r\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerCoreComponents(variant) {\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    // Register `app` package.\r\n    registerVersion(name$o, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name$o, version$1, 'esm2017');\r\n    // Register platform SDK identifier (no version).\r\n    registerVersion('fire-js', '');\r\n}\n\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\r\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzZGO0FBQ3pJO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQixzQ0FBc0MsU0FBUztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEYsMEVBQTBFLFNBQVM7QUFDbkYsc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQSxpR0FBaUcsc0JBQXNCO0FBQ3ZILG9HQUFvRyxzQkFBc0I7QUFDMUgsb0dBQW9HLHNCQUFzQjtBQUMxSCwyR0FBMkcsc0JBQXNCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBWTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixxQkFBcUI7QUFDeEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxtQ0FBbUMsaUVBQWlFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLG1FQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBLDBCQUEwQixtRUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xELDZCQUE2Qiw2RUFBNkIsa0JBQWtCLDBDQUEwQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlibGUtcXVpei8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MWEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuMTAuMlwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbiA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDEgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmUtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUgPSBcImZpcmViYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxMC4xMS4xXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xyXG5jb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xyXG4gICAgW25hbWUkb106ICdmaXJlLWNvcmUnLFxyXG4gICAgW25hbWUkbl06ICdmaXJlLWNvcmUtY29tcGF0JyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hbmFseXRpY3MnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWFwcC1jaGVjaycsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRpXTogJ2ZpcmUtYXV0aCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxyXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGInLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLXJ0ZGItY29tcGF0JyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbicsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtZm4tY29tcGF0JyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQnLFxyXG4gICAgW25hbWUkYl06ICdmaXJlLWlpZC1jb21wYXQnLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbScsXHJcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtZmNtLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ4XTogJ2ZpcmUtcGVyZicsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjJyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1yYy1jb21wYXQnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcycsXHJcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtZnN0JyxcclxuICAgIFtuYW1lJDFdOiAnZmlyZS1mc3QtY29tcGF0JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9J1wiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi9dOiAnRmlyZWJhc2UgU2VydmVyIEFwcCBoYXMgYmVlbiBkZWxldGVkJyxcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBkZWxldGVPbkRlcmVmIGZpZWxkIGRlZmluZWQgYnV0IHRoZSBKUyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgRmluYWxpemF0aW9uUmVnaXN0cnkuJyxcclxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cclxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXHJcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmNSZWZDb3VudCh0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIC8vIERvIG5vdCByZXRhaW4gYSBoYXJkIHJlZmVyZW5jZSB0byB0aGUgZHJlZiBvYmplY3QsIG90aGVyd2lzZSB0aGUgRmluYWxpemF0aW9uUmVnaXNyeVxyXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xyXG4gICAgfVxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XHJcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXHJcbiAgICBpbmNSZWZDb3VudChvYmopIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmosIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50LlxyXG4gICAgZGVjUmVmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcclxuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XHJcbiAgICAvLyBoYW5kbGVzIHRoaXMgaXMgaW4gZGVsZXRlQXBwKC4uLikuXHJcbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xyXG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKF9vcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XHJcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlIH0sIHJhd0NvbmZpZyk7XHJcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi8sIHtcclxuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxyXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcclxuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNlcnZlckFwcChfb3B0aW9ucywgX3NlcnZlckFwcENvbmZpZykge1xyXG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XHJcbiAgICAgICAgLy8gRmlyZWJhc2VTZXJ2ZXJBcHAgaXNuJ3QgZGVzaWduZWQgdG8gYmUgcnVuIGluIGJyb3dzZXJzLlxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcclxuICAgIH1cclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBhcHBPcHRpb25zO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XHJcbiAgICAvLyBIb3dldmVyLCBEbyBub3QgbWFuZ2xlIHRoZSBuYW1lIGJhc2VkIG9uIHJlbGVhc2VPbkRlcmVmLCBzaW5jZSBpdCB3aWxsIHZhcnkgYmV0d2VlbiB0aGVcclxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIG5hbWVPYmoucmVsZWFzZU9uRGVyZWY7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5zXS5yZWR1Y2UoKGhhc2gsIGMpID0+IChNYXRoLmltdWwoMzEsIGhhc2gpICsgYy5jaGFyQ29kZUF0KDApKSB8IDAsIDApO1xyXG4gICAgfTtcclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcclxuICAgIGlmIChleGlzdGluZ0FwcCkge1xyXG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZVN0cmluZyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcclxuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xyXG4gICAgcmV0dXJuIG5ld0FwcDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXHJcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cclxuICogaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxyXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXHJcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcclxuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxyXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHA7XHJcbn1cclxuLyoqXHJcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogZGVsZXRlQXBwKGFwcClcclxuICogICAudGhlbihmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gKiAgIH0pXHJcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xyXG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcclxuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcclxuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcclxuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcclxuICAgICAgICBpZiAoZmlyZWJhc2VTZXJ2ZXJBcHAuZGVjUmVmQ291bnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XHJcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXHJcbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcclxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxyXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xyXG4gICAgaWYgKHZhcmlhbnQpIHtcclxuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXHJcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGIuY3JlYXRlT2JqZWN0U3RvcmUoKSB0aGF0IG1heSBiZSBhIGJ1Zy4gQXZvaWQgYmxvY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYlByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcclxuICAgICAgICAgICAgLmdldFByb3ZpZGVyKCdwbGF0Zm9ybS1sb2dnZXInKVxyXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxyXG4gICAgICAgIC8vIHNlcnZpY2UsIG5vdCB0aGUgYnJvd3NlciB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxyXG4gICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5wdXNoKHsgZGF0ZSwgYWdlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxyXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxyXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxyXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XHJcbiAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcclxuICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xyXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XHJcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cclxuICAgIC8vIHRoZSBoZWFkZXIuXHJcbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XHJcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cclxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XHJcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcclxuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxyXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiSGVhcnRiZWF0T2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxyXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxyXG4gKiB0byBiYXNlIDY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cclxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcclxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcclxuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkbywgdmVyc2lvbiQxLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmViYXNlIEFwcFxyXG4gKlxyXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlibGUtcXVpei8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MmU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* binding */ LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* binding */ AutoId),\n/* harmony export */   _ByteString: () => (/* binding */ ByteString),\n/* harmony export */   _DatabaseId: () => (/* binding */ DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* binding */ DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* binding */ FieldPath$1),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* binding */ cast),\n/* harmony export */   _debugAssert: () => (/* binding */ debugAssert),\n/* harmony export */   _isBase64Available: () => (/* binding */ isBase64Available),\n/* harmony export */   _logWarn: () => (/* binding */ logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   disableNetwork: () => (/* binding */ disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* binding */ enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* binding */ loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* binding */ namedQuery),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   waitForPendingWrites: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/webchannel-wrapper */ \"(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/esm/index.esm2017.js\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"4.6.1\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Simple wrapper around a nullable UID. Mostly exists to make code more\r\n * readable.\r\n */\r\nclass User {\r\n    constructor(uid) {\r\n        this.uid = uid;\r\n    }\r\n    isAuthenticated() {\r\n        return this.uid != null;\r\n    }\r\n    /**\r\n     * Returns a key representing this user, suitable for inclusion in a\r\n     * dictionary.\r\n     */\r\n    toKey() {\r\n        if (this.isAuthenticated()) {\r\n            return 'uid:' + this.uid;\r\n        }\r\n        else {\r\n            return 'anonymous-user';\r\n        }\r\n    }\r\n    isEqual(otherUser) {\r\n        return otherUser.uid === this.uid;\r\n    }\r\n}\r\n/** A user with a null UID. */\r\nUser.UNAUTHENTICATED = new User(null);\r\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\r\n// non-FirebaseAuth providers.\r\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\r\nUser.FIRST_PARTY = new User('first-party-uid');\r\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"10.11.1\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet SDK_VERSION = version;\r\nfunction setSDKVersion(version) {\r\n    SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Formats an object as a JSON string, suitable for logging. */\r\nfunction formatJSON(value) {\r\n    // util.inspect() results in much more readable output than JSON.stringify()\r\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\r\n// Helper methods are needed because variables can't be exported as read/write\r\nfunction getLogLevel() {\r\n    return logClient.logLevel;\r\n}\r\n/**\r\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\r\n *\r\n * @param logLevel - The verbosity you set for activity and error logging. Can\r\n *   be any of the following values:\r\n *\r\n *   <ul>\r\n *     <li>`debug` for the most verbose logging level, primarily for\r\n *     debugging.</li>\r\n *     <li>`error` to log errors only.</li>\r\n *     <li><code>`silent` to turn off logging.</li>\r\n *   </ul>\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    logClient.setLogLevel(logLevel);\r\n}\r\nfunction logDebug(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n        const args = obj.map(argToString);\r\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\nfunction logError(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\r\n        const args = obj.map(argToString);\r\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction logWarn(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\r\n        const args = obj.map(argToString);\r\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * Converts an additional log parameter to a string representation.\r\n */\r\nfunction argToString(obj) {\r\n    if (typeof obj === 'string') {\r\n        return obj;\r\n    }\r\n    else {\r\n        try {\r\n            return formatJSON(obj);\r\n        }\r\n        catch (e) {\r\n            // Converting to JSON failed, just log the object directly\r\n            return obj;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Unconditionally fails, throwing an Error with the given message.\r\n * Messages are stripped in production builds.\r\n *\r\n * Returns `never` and can be used in expressions:\r\n * @example\r\n * let futureVar = fail('not implemented yet');\r\n */\r\nfunction fail(failure = 'Unexpected state') {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\r\n    logError(message);\r\n    // NOTE: We don't use FirestoreError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * Messages are stripped in production builds.\r\n */\r\nfunction hardAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * The code of callsites invoking this function are stripped out in production\r\n * builds. Any side-effects of code within the debugAssert() invocation will not\r\n * happen in this case.\r\n *\r\n * @internal\r\n */\r\nfunction debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\r\n * instance of `T` before casting.\r\n */\r\nfunction debugCast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst Code = {\r\n    // Causes are copied from:\r\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n    /** Not an error; returned on success. */\r\n    OK: 'ok',\r\n    /** The operation was cancelled (typically by the caller). */\r\n    CANCELLED: 'cancelled',\r\n    /** Unknown error or an error from a different error domain. */\r\n    UNKNOWN: 'unknown',\r\n    /**\r\n     * Client specified an invalid argument. Note that this differs from\r\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\r\n     * problematic regardless of the state of the system (e.g., a malformed file\r\n     * name).\r\n     */\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    /**\r\n     * Deadline expired before operation could complete. For operations that\r\n     * change the state of the system, this error may be returned even if the\r\n     * operation has completed successfully. For example, a successful response\r\n     * from a server could have been delayed long enough for the deadline to\r\n     * expire.\r\n     */\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    /** Some requested entity (e.g., file or directory) was not found. */\r\n    NOT_FOUND: 'not-found',\r\n    /**\r\n     * Some entity that we attempted to create (e.g., file or directory) already\r\n     * exists.\r\n     */\r\n    ALREADY_EXISTS: 'already-exists',\r\n    /**\r\n     * The caller does not have permission to execute the specified operation.\r\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\r\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\r\n     * PERMISSION_DENIED must not be used if the caller can not be identified\r\n     * (use UNAUTHENTICATED instead for those errors).\r\n     */\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    /**\r\n     * The request does not have valid authentication credentials for the\r\n     * operation.\r\n     */\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    /**\r\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\r\n     * entire file system is out of space.\r\n     */\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    /**\r\n     * Operation was rejected because the system is not in a state required for\r\n     * the operation's execution. For example, directory to be deleted may be\r\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\r\n     *\r\n     * A litmus test that may help a service implementor in deciding\r\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\r\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\r\n     *  (b) Use ABORTED if the client should retry at a higher-level\r\n     *      (e.g., restarting a read-modify-write sequence).\r\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\r\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\r\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\r\n     *      should be returned since the client should not retry unless\r\n     *      they have first fixed up the directory by deleting files from it.\r\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\r\n     *      REST Get/Update/Delete on a resource and the resource on the\r\n     *      server does not match the condition. E.g., conflicting\r\n     *      read-modify-write on the same resource.\r\n     */\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    /**\r\n     * The operation was aborted, typically due to a concurrency issue like\r\n     * sequencer check failures, transaction aborts, etc.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    ABORTED: 'aborted',\r\n    /**\r\n     * Operation was attempted past the valid range. E.g., seeking or reading\r\n     * past end of file.\r\n     *\r\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\r\n     * if the system state changes. For example, a 32-bit file system will\r\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\r\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\r\n     * an offset past the current file size.\r\n     *\r\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\r\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\r\n     * when it applies so that callers who are iterating through a space can\r\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\r\n     */\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    /** Operation is not implemented or not supported/enabled in this service. */\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    /**\r\n     * Internal errors. Means some invariants expected by underlying System has\r\n     * been broken. If you see one of these errors, Something is very broken.\r\n     */\r\n    INTERNAL: 'internal',\r\n    /**\r\n     * The service is currently unavailable. This is a most likely a transient\r\n     * condition and may be corrected by retrying with a backoff.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    UNAVAILABLE: 'unavailable',\r\n    /** Unrecoverable data loss or corruption. */\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/** An error returned by a Firestore operation. */\r\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /**\r\n     * The backend error code associated with this error.\r\n     */\r\n    code, \r\n    /**\r\n     * A custom error description.\r\n     */\r\n    message) {\r\n        super(code, message);\r\n        this.code = code;\r\n        this.message = message;\r\n        // HACK: We write a toString property directly because Error is not a real\r\n        // class and so inheritance does not work correctly. We could alternatively\r\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\r\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass OAuthToken {\r\n    constructor(value, user) {\r\n        this.user = user;\r\n        this.type = 'OAuth';\r\n        this.headers = new Map();\r\n        this.headers.set('Authorization', `Bearer ${value}`);\r\n    }\r\n}\r\n/**\r\n * A CredentialsProvider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAuthCredentialsProvider {\r\n    getToken() {\r\n        return Promise.resolve(null);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\r\n    }\r\n    shutdown() { }\r\n}\r\n/**\r\n * A CredentialsProvider that always returns a constant token. Used for\r\n * emulator token mocking.\r\n */\r\nclass EmulatorAuthCredentialsProvider {\r\n    constructor(token) {\r\n        this.token = token;\r\n        /**\r\n         * Stores the listener registered with setChangeListener()\r\n         * This isn't actually necessary since the UID never changes, but we use this\r\n         * to verify the listen contract is adhered to in tests.\r\n         */\r\n        this.changeListener = null;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(this.token);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        this.changeListener = changeListener;\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\r\n    }\r\n    shutdown() {\r\n        this.changeListener = null;\r\n    }\r\n}\r\nclass FirebaseAuthCredentialsProvider {\r\n    constructor(authProvider) {\r\n        this.authProvider = authProvider;\r\n        /** Tracks the current User. */\r\n        this.currentUser = User.UNAUTHENTICATED;\r\n        /**\r\n         * Counter used to detect if the token changed while a getToken request was\r\n         * outstanding.\r\n         */\r\n        this.tokenCounter = 0;\r\n        this.forceRefresh = false;\r\n        this.auth = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        let lastTokenId = this.tokenCounter;\r\n        // A change listener that prevents double-firing for the same token change.\r\n        const guardedChangeListener = user => {\r\n            if (this.tokenCounter !== lastTokenId) {\r\n                lastTokenId = this.tokenCounter;\r\n                return changeListener(user);\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        // A promise that can be waited on to block on the next token change.\r\n        // This promise is re-created after each change.\r\n        let nextToken = new Deferred();\r\n        this.tokenListener = () => {\r\n            this.tokenCounter++;\r\n            this.currentUser = this.getUser();\r\n            nextToken.resolve();\r\n            nextToken = new Deferred();\r\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\r\n        };\r\n        const awaitNextToken = () => {\r\n            const currentTokenAttempt = nextToken;\r\n            asyncQueue.enqueueRetryable(async () => {\r\n                await currentTokenAttempt.promise;\r\n                await guardedChangeListener(this.currentUser);\r\n            });\r\n        };\r\n        const registerAuth = (auth) => {\r\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\r\n            this.auth = auth;\r\n            this.auth.addAuthTokenListener(this.tokenListener);\r\n            awaitNextToken();\r\n        };\r\n        this.authProvider.onInit(auth => registerAuth(auth));\r\n        // Our users can initialize Auth right after Firestore, so we give it\r\n        // a chance to register itself with the component framework before we\r\n        // determine whether to start up in unauthenticated mode.\r\n        setTimeout(() => {\r\n            if (!this.auth) {\r\n                const auth = this.authProvider.getImmediate({ optional: true });\r\n                if (auth) {\r\n                    registerAuth(auth);\r\n                }\r\n                else {\r\n                    // If auth is still not available, proceed with `null` user\r\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\r\n                    nextToken.resolve();\r\n                    nextToken = new Deferred();\r\n                }\r\n            }\r\n        }, 0);\r\n        awaitNextToken();\r\n    }\r\n    getToken() {\r\n        // Take note of the current value of the tokenCounter so that this method\r\n        // can fail (with an ABORTED error) if there is a token change while the\r\n        // request is outstanding.\r\n        const initialTokenCounter = this.tokenCounter;\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.auth) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.auth.getToken(forceRefresh).then(tokenData => {\r\n            // Cancel the request since the token changed while the request was\r\n            // outstanding so the response is potentially for a previous user (which\r\n            // user, we can't be sure).\r\n            if (this.tokenCounter !== initialTokenCounter) {\r\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\r\n                return this.getToken();\r\n            }\r\n            else {\r\n                if (tokenData) {\r\n                    hardAssert(typeof tokenData.accessToken === 'string');\r\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.auth) {\r\n            this.auth.removeAuthTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n    // Auth.getUid() can return null even with a user logged in. It is because\r\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\r\n    // This method should only be called in the AuthTokenListener callback\r\n    // to guarantee to get the actual user.\r\n    getUser() {\r\n        const currentUid = this.auth && this.auth.getUid();\r\n        hardAssert(currentUid === null || typeof currentUid === 'string');\r\n        return new User(currentUid);\r\n    }\r\n}\r\n/*\r\n * FirstPartyToken provides a fresh token each time its value\r\n * is requested, because if the token is too old, requests will be rejected.\r\n * Technically this may no longer be necessary since the SDK should gracefully\r\n * recover from unauthenticated errors (see b/33147818 for context), but it's\r\n * safer to keep the implementation as-is.\r\n */\r\nclass FirstPartyToken {\r\n    constructor(sessionIndex, iamToken, authTokenFactory) {\r\n        this.sessionIndex = sessionIndex;\r\n        this.iamToken = iamToken;\r\n        this.authTokenFactory = authTokenFactory;\r\n        this.type = 'FirstParty';\r\n        this.user = User.FIRST_PARTY;\r\n        this._headers = new Map();\r\n    }\r\n    /**\r\n     * Gets an authorization token, using a provided factory function, or return\r\n     * null.\r\n     */\r\n    getAuthToken() {\r\n        if (this.authTokenFactory) {\r\n            return this.authTokenFactory();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    get headers() {\r\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\r\n        // Use array notation to prevent minification\r\n        const authHeaderTokenValue = this.getAuthToken();\r\n        if (authHeaderTokenValue) {\r\n            this._headers.set('Authorization', authHeaderTokenValue);\r\n        }\r\n        if (this.iamToken) {\r\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\r\n        }\r\n        return this._headers;\r\n    }\r\n}\r\n/*\r\n * Provides user credentials required for the Firestore JavaScript SDK\r\n * to authenticate the user, using technique that is only available\r\n * to applications hosted by Google.\r\n */\r\nclass FirstPartyAuthCredentialsProvider {\r\n    constructor(sessionIndex, iamToken, authTokenFactory) {\r\n        this.sessionIndex = sessionIndex;\r\n        this.iamToken = iamToken;\r\n        this.authTokenFactory = authTokenFactory;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial uid.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\r\n    }\r\n    shutdown() { }\r\n    invalidateToken() { }\r\n}\r\nclass AppCheckToken {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.type = 'AppCheck';\r\n        this.headers = new Map();\r\n        if (value && value.length > 0) {\r\n            this.headers.set('x-firebase-appcheck', this.value);\r\n        }\r\n    }\r\n}\r\nclass FirebaseAppCheckTokenProvider {\r\n    constructor(appCheckProvider) {\r\n        this.appCheckProvider = appCheckProvider;\r\n        this.forceRefresh = false;\r\n        this.appCheck = null;\r\n        this.latestAppCheckToken = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        const onTokenChanged = tokenResult => {\r\n            if (tokenResult.error != null) {\r\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\r\n            }\r\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\r\n            this.latestAppCheckToken = tokenResult.token;\r\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\r\n            return tokenUpdated\r\n                ? changeListener(tokenResult.token)\r\n                : Promise.resolve();\r\n        };\r\n        this.tokenListener = (tokenResult) => {\r\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\r\n        };\r\n        const registerAppCheck = (appCheck) => {\r\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\r\n            this.appCheck = appCheck;\r\n            this.appCheck.addTokenListener(this.tokenListener);\r\n        };\r\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\r\n        // Our users can initialize AppCheck after Firestore, so we give it\r\n        // a chance to register itself with the component framework.\r\n        setTimeout(() => {\r\n            if (!this.appCheck) {\r\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\r\n                if (appCheck) {\r\n                    registerAppCheck(appCheck);\r\n                }\r\n                else {\r\n                    // If AppCheck is still not available, proceed without it.\r\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\r\n                }\r\n            }\r\n        }, 0);\r\n    }\r\n    getToken() {\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.appCheck) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\r\n            if (tokenResult) {\r\n                hardAssert(typeof tokenResult.token === 'string');\r\n                this.latestAppCheckToken = tokenResult.token;\r\n                return new AppCheckToken(tokenResult.token);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.appCheck) {\r\n            this.appCheck.removeTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n}\r\n/**\r\n * An AppCheck token provider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAppCheckTokenProvider {\r\n    getToken() {\r\n        return Promise.resolve(new AppCheckToken(''));\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) { }\r\n    shutdown() { }\r\n}\r\n/**\r\n * Builds a CredentialsProvider depending on the type of\r\n * the credentials passed in.\r\n */\r\nfunction makeAuthCredentialsProvider(credentials) {\r\n    if (!credentials) {\r\n        return new EmptyAuthCredentialsProvider();\r\n    }\r\n    switch (credentials['type']) {\r\n        case 'firstParty':\r\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\r\n        case 'provider':\r\n            return credentials['client'];\r\n        default:\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Generates `nBytes` of random bytes.\r\n *\r\n * If `nBytes < 0` , an error will be thrown.\r\n */\r\nfunction randomBytes(nBytes) {\r\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A utility class for generating unique alphanumeric IDs of a specified length.\r\n *\r\n * @internal\r\n * Exported internally for testing purposes.\r\n */\r\nclass AutoId {\r\n    static newId() {\r\n        // Alphanumeric characters\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        // The largest byte value that is a multiple of `char.length`.\r\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\r\n        let autoId = '';\r\n        const targetLength = 20;\r\n        while (autoId.length < targetLength) {\r\n            const bytes = randomBytes(40);\r\n            for (let i = 0; i < bytes.length; ++i) {\r\n                // Only accept values that are [0, maxMultiple), this ensures they can\r\n                // be evenly mapped to indices of `chars` via a modulo operation.\r\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\r\n                    autoId += chars.charAt(bytes[i] % chars.length);\r\n                }\r\n            }\r\n        }\r\n        return autoId;\r\n    }\r\n}\r\nfunction primitiveComparator(left, right) {\r\n    if (left < right) {\r\n        return -1;\r\n    }\r\n    if (left > right) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n/** Helper to compare arrays using isEqual(). */\r\nfunction arrayEquals(left, right, comparator) {\r\n    if (left.length !== right.length) {\r\n        return false;\r\n    }\r\n    return left.every((value, index) => comparator(value, right[index]));\r\n}\r\n/**\r\n * Returns the immediate lexicographically-following string. This is useful to\r\n * construct an inclusive range for indexeddb iterators.\r\n */\r\nfunction immediateSuccessor(s) {\r\n    // Return the input string, with an additional NUL byte appended.\r\n    return s + '\\0';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\r\nconst MIN_SECONDS = -62135596800;\r\n// Number of nanoseconds in a millisecond.\r\nconst MS_TO_NANOS = 1e6;\r\n/**\r\n * A `Timestamp` represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time.\r\n *\r\n * It is encoded using the Proleptic Gregorian Calendar which extends the\r\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\r\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\r\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\r\n * 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * For examples and further specifications, refer to the\r\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\r\n */\r\nclass Timestamp {\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @param seconds - The number of seconds of UTC time since Unix epoch\r\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     *     9999-12-31T23:59:59Z inclusive.\r\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\r\n     *     resolution. Negative second values with fractions must still have\r\n     *     non-negative nanoseconds values that count forward in time. Must be\r\n     *     from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(\r\n    /**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    seconds, \r\n    /**\r\n     * The fractions of a second at nanosecond resolution.*\r\n     */\r\n    nanoseconds) {\r\n        this.seconds = seconds;\r\n        this.nanoseconds = nanoseconds;\r\n        if (nanoseconds < 0) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (nanoseconds >= 1e9) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (seconds < MIN_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n        // This will break in the year 10,000.\r\n        if (seconds >= 253402300800) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @returns a new timestamp representing the current date.\r\n     */\r\n    static now() {\r\n        return Timestamp.fromMillis(Date.now());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @param date - The date to initialize the `Timestamp` from.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     date.\r\n     */\r\n    static fromDate(date) {\r\n        return Timestamp.fromMillis(date.getTime());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @param milliseconds - Number of milliseconds since Unix epoch\r\n     *     1970-01-01T00:00:00Z.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\r\n        return new Timestamp(seconds, nanos);\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\r\n     * causes a loss of precision since `Date` objects only support millisecond\r\n     * precision.\r\n     *\r\n     * @returns JavaScript `Date` object representing the same point in time as\r\n     *     this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate() {\r\n        return new Date(this.toMillis());\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\r\n     * epoch). This operation causes a loss of precision.\r\n     *\r\n     * @returns The point in time corresponding to this timestamp, represented as\r\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis() {\r\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\r\n    }\r\n    _compareTo(other) {\r\n        if (this.seconds === other.seconds) {\r\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\r\n        }\r\n        return primitiveComparator(this.seconds, other.seconds);\r\n    }\r\n    /**\r\n     * Returns true if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @param other - The `Timestamp` to compare against.\r\n     * @returns true if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\r\n    }\r\n    /** Returns a textual representation of this `Timestamp`. */\r\n    toString() {\r\n        return ('Timestamp(seconds=' +\r\n            this.seconds +\r\n            ', nanoseconds=' +\r\n            this.nanoseconds +\r\n            ')');\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\r\n    toJSON() {\r\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\r\n    }\r\n    /**\r\n     * Converts this object to a primitive string, which allows `Timestamp` objects\r\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\r\n     */\r\n    valueOf() {\r\n        // This method returns a string of the form <seconds>.<nanoseconds> where\r\n        // <seconds> is translated to have a non-negative value and both <seconds>\r\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\r\n        // Strings with this format then have a lexiographical ordering that matches\r\n        // the expected ordering. The <seconds> translation is done to avoid having\r\n        // a leading negative sign (i.e. a leading '-' character) in its string\r\n        // representation, which would affect its lexiographical ordering.\r\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\r\n        // Note: Up to 12 decimal digits are required to represent all valid\r\n        // 'seconds' values.\r\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\r\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\r\n        return formattedSeconds + '.' + formattedNanoseconds;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A version of a document in Firestore. This corresponds to the version\r\n * timestamp, such as update_time or read_time.\r\n */\r\nclass SnapshotVersion {\r\n    constructor(timestamp) {\r\n        this.timestamp = timestamp;\r\n    }\r\n    static fromTimestamp(value) {\r\n        return new SnapshotVersion(value);\r\n    }\r\n    static min() {\r\n        return new SnapshotVersion(new Timestamp(0, 0));\r\n    }\r\n    static max() {\r\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\r\n    }\r\n    compareTo(other) {\r\n        return this.timestamp._compareTo(other.timestamp);\r\n    }\r\n    isEqual(other) {\r\n        return this.timestamp.isEqual(other.timestamp);\r\n    }\r\n    /** Returns a number representation of the version for use in spec tests. */\r\n    toMicroseconds() {\r\n        // Convert to microseconds.\r\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\r\n    }\r\n    toString() {\r\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\r\n    }\r\n    toTimestamp() {\r\n        return this.timestamp;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DOCUMENT_KEY_NAME = '__name__';\r\n/**\r\n * Path represents an ordered sequence of string segments.\r\n */\r\nclass BasePath {\r\n    constructor(segments, offset, length) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n        else if (offset > segments.length) {\r\n            fail();\r\n        }\r\n        if (length === undefined) {\r\n            length = segments.length - offset;\r\n        }\r\n        else if (length > segments.length - offset) {\r\n            fail();\r\n        }\r\n        this.segments = segments;\r\n        this.offset = offset;\r\n        this.len = length;\r\n    }\r\n    get length() {\r\n        return this.len;\r\n    }\r\n    isEqual(other) {\r\n        return BasePath.comparator(this, other) === 0;\r\n    }\r\n    child(nameOrPath) {\r\n        const segments = this.segments.slice(this.offset, this.limit());\r\n        if (nameOrPath instanceof BasePath) {\r\n            nameOrPath.forEach(segment => {\r\n                segments.push(segment);\r\n            });\r\n        }\r\n        else {\r\n            segments.push(nameOrPath);\r\n        }\r\n        return this.construct(segments);\r\n    }\r\n    /** The index of one past the last segment of the path. */\r\n    limit() {\r\n        return this.offset + this.length;\r\n    }\r\n    popFirst(size) {\r\n        size = size === undefined ? 1 : size;\r\n        return this.construct(this.segments, this.offset + size, this.length - size);\r\n    }\r\n    popLast() {\r\n        return this.construct(this.segments, this.offset, this.length - 1);\r\n    }\r\n    firstSegment() {\r\n        return this.segments[this.offset];\r\n    }\r\n    lastSegment() {\r\n        return this.get(this.length - 1);\r\n    }\r\n    get(index) {\r\n        return this.segments[this.offset + index];\r\n    }\r\n    isEmpty() {\r\n        return this.length === 0;\r\n    }\r\n    isPrefixOf(other) {\r\n        if (other.length < this.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== other.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    isImmediateParentOf(potentialChild) {\r\n        if (this.length + 1 !== potentialChild.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== potentialChild.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    forEach(fn) {\r\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\r\n            fn(this.segments[i]);\r\n        }\r\n    }\r\n    toArray() {\r\n        return this.segments.slice(this.offset, this.limit());\r\n    }\r\n    static comparator(p1, p2) {\r\n        const len = Math.min(p1.length, p2.length);\r\n        for (let i = 0; i < len; i++) {\r\n            const left = p1.get(i);\r\n            const right = p2.get(i);\r\n            if (left < right) {\r\n                return -1;\r\n            }\r\n            if (left > right) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (p1.length < p2.length) {\r\n            return -1;\r\n        }\r\n        if (p1.length > p2.length) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n/**\r\n * A slash-separated path for navigating resources (documents and collections)\r\n * within Firestore.\r\n *\r\n * @internal\r\n */\r\nclass ResourcePath extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new ResourcePath(segments, offset, length);\r\n    }\r\n    canonicalString() {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        return this.toArray().join('/');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Returns a string representation of this path\r\n     * where each path segment has been encoded with\r\n     * `encodeURIComponent`.\r\n     */\r\n    toUriEncodedString() {\r\n        return this.toArray().map(encodeURIComponent).join('/');\r\n    }\r\n    /**\r\n     * Creates a resource path from the given slash-delimited string. If multiple\r\n     * arguments are provided, all components are combined. Leading and trailing\r\n     * slashes from all components are ignored.\r\n     */\r\n    static fromString(...pathComponents) {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        const segments = [];\r\n        for (const path of pathComponents) {\r\n            if (path.indexOf('//') >= 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\r\n            }\r\n            // Strip leading and traling slashed.\r\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\r\n        }\r\n        return new ResourcePath(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new ResourcePath([]);\r\n    }\r\n}\r\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\r\n/**\r\n * A dot-separated path for navigating sub-objects within a document.\r\n * @internal\r\n */\r\nclass FieldPath$1 extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new FieldPath$1(segments, offset, length);\r\n    }\r\n    /**\r\n     * Returns true if the string could be used as a segment in a field path\r\n     * without escaping.\r\n     */\r\n    static isValidIdentifier(segment) {\r\n        return identifierRegExp.test(segment);\r\n    }\r\n    canonicalString() {\r\n        return this.toArray()\r\n            .map(str => {\r\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\r\n            if (!FieldPath$1.isValidIdentifier(str)) {\r\n                str = '`' + str + '`';\r\n            }\r\n            return str;\r\n        })\r\n            .join('.');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Returns true if this field references the key of a document.\r\n     */\r\n    isKeyField() {\r\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\r\n    }\r\n    /**\r\n     * The field designating the key of a document.\r\n     */\r\n    static keyField() {\r\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\r\n    }\r\n    /**\r\n     * Parses a field string from the given server-formatted string.\r\n     *\r\n     * - Splitting the empty string is not allowed (for now at least).\r\n     * - Empty segments within the string (e.g. if there are two consecutive\r\n     *   separators) are not allowed.\r\n     *\r\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\r\n     * non-identifier path components, even if they aren't escaped.\r\n     */\r\n    static fromServerFormat(path) {\r\n        const segments = [];\r\n        let current = '';\r\n        let i = 0;\r\n        const addCurrentSegment = () => {\r\n            if (current.length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\r\n                    `with '.', end with '.', or contain '..'`);\r\n            }\r\n            segments.push(current);\r\n            current = '';\r\n        };\r\n        let inBackticks = false;\r\n        while (i < path.length) {\r\n            const c = path[i];\r\n            if (c === '\\\\') {\r\n                if (i + 1 === path.length) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\r\n                }\r\n                const next = path[i + 1];\r\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\r\n                }\r\n                current += next;\r\n                i += 2;\r\n            }\r\n            else if (c === '`') {\r\n                inBackticks = !inBackticks;\r\n                i++;\r\n            }\r\n            else if (c === '.' && !inBackticks) {\r\n                addCurrentSegment();\r\n                i++;\r\n            }\r\n            else {\r\n                current += c;\r\n                i++;\r\n            }\r\n        }\r\n        addCurrentSegment();\r\n        if (inBackticks) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\r\n        }\r\n        return new FieldPath$1(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new FieldPath$1([]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nclass DocumentKey {\r\n    constructor(path) {\r\n        this.path = path;\r\n    }\r\n    static fromPath(path) {\r\n        return new DocumentKey(ResourcePath.fromString(path));\r\n    }\r\n    static fromName(name) {\r\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\r\n    }\r\n    static empty() {\r\n        return new DocumentKey(ResourcePath.emptyPath());\r\n    }\r\n    get collectionGroup() {\r\n        return this.path.popLast().lastSegment();\r\n    }\r\n    /** Returns true if the document is in the specified collectionId. */\r\n    hasCollectionId(collectionId) {\r\n        return (this.path.length >= 2 &&\r\n            this.path.get(this.path.length - 2) === collectionId);\r\n    }\r\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\r\n    getCollectionGroup() {\r\n        return this.path.get(this.path.length - 2);\r\n    }\r\n    /** Returns the fully qualified path to the parent collection. */\r\n    getCollectionPath() {\r\n        return this.path.popLast();\r\n    }\r\n    isEqual(other) {\r\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\r\n    }\r\n    toString() {\r\n        return this.path.toString();\r\n    }\r\n    static comparator(k1, k2) {\r\n        return ResourcePath.comparator(k1.path, k2.path);\r\n    }\r\n    static isDocumentKey(path) {\r\n        return path.length % 2 === 0;\r\n    }\r\n    /**\r\n     * Creates and returns a new document key with the given segments.\r\n     *\r\n     * @param segments - The segments of the path to the document\r\n     * @returns A new instance of DocumentKey\r\n     */\r\n    static fromSegments(segments) {\r\n        return new DocumentKey(new ResourcePath(segments.slice()));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The initial mutation batch id for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_LARGEST_BATCH_ID = -1;\r\n/**\r\n * The initial sequence number for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_SEQUENCE_NUMBER = 0;\r\n/**\r\n * An index definition for field indexes in Firestore.\r\n *\r\n * Every index is associated with a collection. The definition contains a list\r\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\r\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\r\n *\r\n * Unlike the backend, the SDK does not differentiate between collection or\r\n * collection group-scoped indices. Every index can be used for both single\r\n * collection and collection group queries.\r\n */\r\nclass FieldIndex {\r\n    constructor(\r\n    /**\r\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\r\n     * has not yet been persisted).\r\n     */\r\n    indexId, \r\n    /** The collection ID this index applies to. */\r\n    collectionGroup, \r\n    /** The field segments for this index. */\r\n    fields, \r\n    /** Shows how up-to-date the index is for the current user. */\r\n    indexState) {\r\n        this.indexId = indexId;\r\n        this.collectionGroup = collectionGroup;\r\n        this.fields = fields;\r\n        this.indexState = indexState;\r\n    }\r\n}\r\n/** An ID for an index that has not yet been added to persistence.  */\r\nFieldIndex.UNKNOWN_ID = -1;\r\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\r\nfunction fieldIndexGetArraySegment(fieldIndex) {\r\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\r\n}\r\n/** Returns all directional (ascending/descending) segments for this index. */\r\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\r\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\r\n}\r\n/**\r\n * Returns the order of the document key component for the given index.\r\n *\r\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\r\n */\r\nfunction fieldIndexGetKeyOrder(fieldIndex) {\r\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\r\n    return directionalSegments.length === 0\r\n        ? 0 /* IndexKind.ASCENDING */\r\n        : directionalSegments[directionalSegments.length - 1].kind;\r\n}\r\n/**\r\n * Compares indexes by collection group and segments. Ignores update time and\r\n * index ID.\r\n */\r\nfunction fieldIndexSemanticComparator(left, right) {\r\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\r\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\r\n        if (cmp !== 0) {\r\n            return cmp;\r\n        }\r\n    }\r\n    return primitiveComparator(left.fields.length, right.fields.length);\r\n}\r\n/** Returns a debug representation of the field index */\r\nfunction fieldIndexToString(fieldIndex) {\r\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\r\n}\r\n/** An index component consisting of field path and index type.  */\r\nclass IndexSegment {\r\n    constructor(\r\n    /** The field path of the component. */\r\n    fieldPath, \r\n    /** The fields sorting order. */\r\n    kind) {\r\n        this.fieldPath = fieldPath;\r\n        this.kind = kind;\r\n    }\r\n}\r\nfunction indexSegmentComparator(left, right) {\r\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left.kind, right.kind);\r\n}\r\n/**\r\n * Stores the \"high water mark\" that indicates how updated the Index is for the\r\n * current user.\r\n */\r\nclass IndexState {\r\n    constructor(\r\n    /**\r\n     * Indicates when the index was last updated (relative to other indexes).\r\n     */\r\n    sequenceNumber, \r\n    /** The the latest indexed read time, document and batch id. */\r\n    offset) {\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.offset = offset;\r\n    }\r\n    /** The state of an index that has not yet been backfilled. */\r\n    static empty() {\r\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\r\n    }\r\n}\r\n/**\r\n * Creates an offset that matches all documents with a read time higher than\r\n * `readTime`.\r\n */\r\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\r\n    // We want to create an offset that matches all documents with a read time\r\n    // greater than the provided read time. To do so, we technically need to\r\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\r\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\r\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\r\n    // all valid document IDs.\r\n    const successorSeconds = readTime.toTimestamp().seconds;\r\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\r\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\r\n        ? new Timestamp(successorSeconds + 1, 0)\r\n        : new Timestamp(successorSeconds, successorNanos));\r\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\r\n}\r\n/** Creates a new offset based on the provided document. */\r\nfunction newIndexOffsetFromDocument(document) {\r\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\r\n}\r\n/**\r\n * Stores the latest read time, document and batch ID that were processed for an\r\n * index.\r\n */\r\nclass IndexOffset {\r\n    constructor(\r\n    /**\r\n     * The latest read time version that has been indexed by Firestore for this\r\n     * field index.\r\n     */\r\n    readTime, \r\n    /**\r\n     * The key of the last document that was indexed for this query. Use\r\n     * `DocumentKey.empty()` if no document has been indexed.\r\n     */\r\n    documentKey, \r\n    /*\r\n     * The largest mutation batch id that's been processed by Firestore.\r\n     */\r\n    largestBatchId) {\r\n        this.readTime = readTime;\r\n        this.documentKey = documentKey;\r\n        this.largestBatchId = largestBatchId;\r\n    }\r\n    /** Returns an offset that sorts before all regular offsets. */\r\n    static min() {\r\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\r\n    }\r\n    /** Returns an offset that sorts after all regular offsets. */\r\n    static max() {\r\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\r\n    }\r\n}\r\nfunction indexOffsetComparator(left, right) {\r\n    let cmp = left.readTime.compareTo(right.readTime);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\r\n    'It might be necessary to refresh the browser tab.';\r\n/**\r\n * A base class representing a persistence transaction, encapsulating both the\r\n * transaction's sequence numbers as well as a list of onCommitted listeners.\r\n *\r\n * When you call Persistence.runTransaction(), it will create a transaction and\r\n * pass it to your callback. You then pass it to any method that operates\r\n * on persistence.\r\n */\r\nclass PersistenceTransaction {\r\n    constructor() {\r\n        this.onCommittedListeners = [];\r\n    }\r\n    addOnCommittedListener(listener) {\r\n        this.onCommittedListeners.push(listener);\r\n    }\r\n    raiseOnCommittedEvent() {\r\n        this.onCommittedListeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\r\n * operation fails because the primary lease has been taken by another client,\r\n * we ignore the error (the persistence layer will immediately call\r\n * `applyPrimaryLease` to propagate the primary state change). All other errors\r\n * are re-thrown.\r\n *\r\n * @param err - An error returned by a LocalStore operation.\r\n * @returns A Promise that resolves after we recovered, or the original error.\r\n */\r\nasync function ignoreIfPrimaryLeaseLoss(err) {\r\n    if (err.code === Code.FAILED_PRECONDITION &&\r\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\r\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * PersistencePromise is essentially a re-implementation of Promise except\r\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\r\n * are executed synchronously when a PersistencePromise resolves rather than\r\n * asynchronously (Promise implementations use setImmediate() or similar).\r\n *\r\n * This is necessary to interoperate with IndexedDB which will automatically\r\n * commit transactions if control is returned to the event loop without\r\n * synchronously initiating another operation on the transaction.\r\n *\r\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\r\n * Promises.\r\n */\r\nclass PersistencePromise {\r\n    constructor(callback) {\r\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\r\n        // not the user's raw next() or catch() callbacks.\r\n        this.nextCallback = null;\r\n        this.catchCallback = null;\r\n        // When the operation resolves, we'll set result or error and mark isDone.\r\n        this.result = undefined;\r\n        this.error = undefined;\r\n        this.isDone = false;\r\n        // Set to true when .then() or .catch() are called and prevents additional\r\n        // chaining.\r\n        this.callbackAttached = false;\r\n        callback(value => {\r\n            this.isDone = true;\r\n            this.result = value;\r\n            if (this.nextCallback) {\r\n                // value should be defined unless T is Void, but we can't express\r\n                // that in the type system.\r\n                this.nextCallback(value);\r\n            }\r\n        }, error => {\r\n            this.isDone = true;\r\n            this.error = error;\r\n            if (this.catchCallback) {\r\n                this.catchCallback(error);\r\n            }\r\n        });\r\n    }\r\n    catch(fn) {\r\n        return this.next(undefined, fn);\r\n    }\r\n    next(nextFn, catchFn) {\r\n        if (this.callbackAttached) {\r\n            fail();\r\n        }\r\n        this.callbackAttached = true;\r\n        if (this.isDone) {\r\n            if (!this.error) {\r\n                return this.wrapSuccess(nextFn, this.result);\r\n            }\r\n            else {\r\n                return this.wrapFailure(catchFn, this.error);\r\n            }\r\n        }\r\n        else {\r\n            return new PersistencePromise((resolve, reject) => {\r\n                this.nextCallback = (value) => {\r\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\r\n                };\r\n                this.catchCallback = (error) => {\r\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\r\n                };\r\n            });\r\n        }\r\n    }\r\n    toPromise() {\r\n        return new Promise((resolve, reject) => {\r\n            this.next(resolve, reject);\r\n        });\r\n    }\r\n    wrapUserFunction(fn) {\r\n        try {\r\n            const result = fn();\r\n            if (result instanceof PersistencePromise) {\r\n                return result;\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(result);\r\n            }\r\n        }\r\n        catch (e) {\r\n            return PersistencePromise.reject(e);\r\n        }\r\n    }\r\n    wrapSuccess(nextFn, value) {\r\n        if (nextFn) {\r\n            return this.wrapUserFunction(() => nextFn(value));\r\n        }\r\n        else {\r\n            // If there's no nextFn, then R must be the same as T\r\n            return PersistencePromise.resolve(value);\r\n        }\r\n    }\r\n    wrapFailure(catchFn, error) {\r\n        if (catchFn) {\r\n            return this.wrapUserFunction(() => catchFn(error));\r\n        }\r\n        else {\r\n            return PersistencePromise.reject(error);\r\n        }\r\n    }\r\n    static resolve(result) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            resolve(result);\r\n        });\r\n    }\r\n    static reject(error) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            reject(error);\r\n        });\r\n    }\r\n    static waitFor(\r\n    // Accept all Promise types in waitFor().\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    all) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            let expectedCount = 0;\r\n            let resolvedCount = 0;\r\n            let done = false;\r\n            all.forEach(element => {\r\n                ++expectedCount;\r\n                element.next(() => {\r\n                    ++resolvedCount;\r\n                    if (done && resolvedCount === expectedCount) {\r\n                        resolve();\r\n                    }\r\n                }, err => reject(err));\r\n            });\r\n            done = true;\r\n            if (resolvedCount === expectedCount) {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Given an array of predicate functions that asynchronously evaluate to a\r\n     * boolean, implements a short-circuiting `or` between the results. Predicates\r\n     * will be evaluated until one of them returns `true`, then stop. The final\r\n     * result will be whether any of them returned `true`.\r\n     */\r\n    static or(predicates) {\r\n        let p = PersistencePromise.resolve(false);\r\n        for (const predicate of predicates) {\r\n            p = p.next(isTrue => {\r\n                if (isTrue) {\r\n                    return PersistencePromise.resolve(isTrue);\r\n                }\r\n                else {\r\n                    return predicate();\r\n                }\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    static forEach(collection, f) {\r\n        const promises = [];\r\n        collection.forEach((r, s) => {\r\n            promises.push(f.call(this, r, s));\r\n        });\r\n        return this.waitFor(promises);\r\n    }\r\n    /**\r\n     * Concurrently map all array elements through asynchronous function.\r\n     */\r\n    static mapArray(array, f) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            const expectedCount = array.length;\r\n            const results = new Array(expectedCount);\r\n            let resolvedCount = 0;\r\n            for (let i = 0; i < expectedCount; i++) {\r\n                const current = i;\r\n                f(array[current]).next(result => {\r\n                    results[current] = result;\r\n                    ++resolvedCount;\r\n                    if (resolvedCount === expectedCount) {\r\n                        resolve(results);\r\n                    }\r\n                }, err => reject(err));\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * An alternative to recursive PersistencePromise calls, that avoids\r\n     * potential memory problems from unbounded chains of promises.\r\n     *\r\n     * The `action` will be called repeatedly while `condition` is true.\r\n     */\r\n    static doWhile(condition, action) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            const process = () => {\r\n                if (condition() === true) {\r\n                    action().next(() => {\r\n                        process();\r\n                    }, reject);\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            };\r\n            process();\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// References to `window` are guarded by SimpleDb.isAvailable()\r\n/* eslint-disable no-restricted-globals */\r\nconst LOG_TAG$i = 'SimpleDb';\r\n/**\r\n * The maximum number of retry attempts for an IndexedDb transaction that fails\r\n * with a DOMException.\r\n */\r\nconst TRANSACTION_RETRY_COUNT = 3;\r\n/**\r\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\r\n * specific object store.\r\n */\r\nclass SimpleDbTransaction {\r\n    constructor(action, transaction) {\r\n        this.action = action;\r\n        this.transaction = transaction;\r\n        this.aborted = false;\r\n        /**\r\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\r\n         */\r\n        this.completionDeferred = new Deferred();\r\n        this.transaction.oncomplete = () => {\r\n            this.completionDeferred.resolve();\r\n        };\r\n        this.transaction.onabort = () => {\r\n            if (transaction.error) {\r\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\r\n            }\r\n            else {\r\n                this.completionDeferred.resolve();\r\n            }\r\n        };\r\n        this.transaction.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\r\n        };\r\n    }\r\n    static open(db, action, mode, objectStoreNames) {\r\n        try {\r\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\r\n        }\r\n        catch (e) {\r\n            throw new IndexedDbTransactionError(action, e);\r\n        }\r\n    }\r\n    get completionPromise() {\r\n        return this.completionDeferred.promise;\r\n    }\r\n    abort(error) {\r\n        if (error) {\r\n            this.completionDeferred.reject(error);\r\n        }\r\n        if (!this.aborted) {\r\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\r\n            this.aborted = true;\r\n            this.transaction.abort();\r\n        }\r\n    }\r\n    maybeCommit() {\r\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\r\n        // speed up index DB processing if the event loop remains blocks.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const maybeV3IndexedDb = this.transaction;\r\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\r\n            maybeV3IndexedDb.commit();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\r\n     * operations performed on the SimpleDbStore happen within the context of this\r\n     * transaction and it cannot be used anymore once the transaction is\r\n     * completed.\r\n     *\r\n     * Note that we can't actually enforce that the KeyType and ValueType are\r\n     * correct, but they allow type safety through the rest of the consuming code.\r\n     */\r\n    store(storeName) {\r\n        const store = this.transaction.objectStore(storeName);\r\n        return new SimpleDbStore(store);\r\n    }\r\n}\r\n/**\r\n * Provides a wrapper around IndexedDb with a simplified interface that uses\r\n * Promise-like return values to chain operations. Real promises cannot be used\r\n * since .then() continuations are executed asynchronously (e.g. via\r\n * .setImmediate), which would cause IndexedDB to end the transaction.\r\n * See PersistencePromise for more details.\r\n */\r\nclass SimpleDb {\r\n    /*\r\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\r\n     *\r\n     * Note that `version` must not be a downgrade. IndexedDB does not support\r\n     * downgrading the schema version. We currently do not support any way to do\r\n     * versioning outside of IndexedDB's versioning mechanism, as only\r\n     * version-upgrade transactions are allowed to do things like create\r\n     * objectstores.\r\n     */\r\n    constructor(name, version, schemaConverter) {\r\n        this.name = name;\r\n        this.version = version;\r\n        this.schemaConverter = schemaConverter;\r\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\r\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\r\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\r\n        // log on 12.2.\r\n        if (iOSVersion === 12.2) {\r\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\r\n                'Safari that may cause your app to stop working. See ' +\r\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\r\n                'and a potential workaround.');\r\n        }\r\n    }\r\n    /** Deletes the specified database. */\r\n    static delete(name) {\r\n        logDebug(LOG_TAG$i, 'Removing database:', name);\r\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\r\n    }\r\n    /** Returns true if IndexedDB is available in the current environment. */\r\n    static isAvailable() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        if (SimpleDb.isMockPersistence()) {\r\n            return true;\r\n        }\r\n        // We extensively use indexed array values and compound keys,\r\n        // which IE and Edge do not support. However, they still have indexedDB\r\n        // defined on the window, so we need to check for them here and make sure\r\n        // to return that persistence is not enabled for those browsers.\r\n        // For tracking support of this feature, see here:\r\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\r\n        // Check the UA string to find out the browser.\r\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\r\n        // IE 10\r\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\r\n        // IE 11\r\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\r\n        // Edge\r\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\r\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\r\n        // iOS Safari: Disable for users running iOS version < 10.\r\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\r\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\r\n        // Android browser: Disable for userse running version < 4.5.\r\n        const androidVersion = getAndroidVersion(ua);\r\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\r\n        if (ua.indexOf('MSIE ') > 0 ||\r\n            ua.indexOf('Trident/') > 0 ||\r\n            ua.indexOf('Edge/') > 0 ||\r\n            isUnsupportedIOS ||\r\n            isUnsupportedAndroid) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\r\n     * (see https://github.com/axemclion/IndexedDBShim).\r\n     */\r\n    static isMockPersistence() {\r\n        var _a;\r\n        return (typeof process !== 'undefined' &&\r\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\r\n    }\r\n    /** Helper to get a typed SimpleDbStore from a transaction. */\r\n    static getStore(txn, store) {\r\n        return txn.store(store);\r\n    }\r\n    // visible for testing\r\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\r\n    static getIOSVersion(ua) {\r\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\r\n        const version = iOSVersionRegex\r\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\r\n            : '-1';\r\n        return Number(version);\r\n    }\r\n    /**\r\n     * Opens the specified database, creating or upgrading it if necessary.\r\n     */\r\n    async ensureDb(action) {\r\n        if (!this.db) {\r\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\r\n            this.db = await new Promise((resolve, reject) => {\r\n                // TODO(mikelehen): Investigate browser compatibility.\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\r\n                // suggests IE9 and older WebKit browsers handle upgrade\r\n                // differently. They expect setVersion, as described here:\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\r\n                const request = indexedDB.open(this.name, this.version);\r\n                request.onsuccess = (event) => {\r\n                    const db = event.target.result;\r\n                    resolve(db);\r\n                };\r\n                request.onblocked = () => {\r\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\r\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\r\n                };\r\n                request.onerror = (event) => {\r\n                    const error = event.target.error;\r\n                    if (error.name === 'VersionError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\r\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\r\n                            'will operate with persistence disabled. If you need persistence, please ' +\r\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\r\n                            'data for your app to start fresh.'));\r\n                    }\r\n                    else if (error.name === 'InvalidStateError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\r\n                            'private browsing session on a browser whose private browsing sessions do not ' +\r\n                            'support IndexedDB: ' +\r\n                            error));\r\n                    }\r\n                    else {\r\n                        reject(new IndexedDbTransactionError(action, error));\r\n                    }\r\n                };\r\n                request.onupgradeneeded = (event) => {\r\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\r\n                    const db = event.target.result;\r\n                    this.schemaConverter\r\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\r\n                        .next(() => {\r\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\r\n                    });\r\n                };\r\n            });\r\n        }\r\n        if (this.versionchangelistener) {\r\n            this.db.onversionchange = event => this.versionchangelistener(event);\r\n        }\r\n        return this.db;\r\n    }\r\n    setVersionChangeListener(versionChangeListener) {\r\n        this.versionchangelistener = versionChangeListener;\r\n        if (this.db) {\r\n            this.db.onversionchange = (event) => {\r\n                return versionChangeListener(event);\r\n            };\r\n        }\r\n    }\r\n    async runTransaction(action, mode, objectStores, transactionFn) {\r\n        const readonly = mode === 'readonly';\r\n        let attemptNumber = 0;\r\n        while (true) {\r\n            ++attemptNumber;\r\n            try {\r\n                this.db = await this.ensureDb(action);\r\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\r\n                const transactionFnResult = transactionFn(transaction)\r\n                    .next(result => {\r\n                    transaction.maybeCommit();\r\n                    return result;\r\n                })\r\n                    .catch(error => {\r\n                    // Abort the transaction if there was an error.\r\n                    transaction.abort(error);\r\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\r\n                    // completion promise to be rejected. This in turn means that we won't use\r\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\r\n                    // possibility of returning `void` to the type of `transactionFnResult`.\r\n                    return PersistencePromise.reject(error);\r\n                })\r\n                    .toPromise();\r\n                // As noted above, errors are propagated by aborting the transaction. So\r\n                // we swallow any error here to avoid the browser logging it as unhandled.\r\n                transactionFnResult.catch(() => { });\r\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\r\n                // fire), but still return the original transactionFnResult back to the\r\n                // caller.\r\n                await transaction.completionPromise;\r\n                return transactionFnResult;\r\n            }\r\n            catch (e) {\r\n                const error = e;\r\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\r\n                // not retry exceptions that are likely unrecoverable (such as quota\r\n                // exceeded errors).\r\n                // Note: We cannot use an instanceof check for FirestoreException, since the\r\n                // exception is wrapped in a generic error by our async/await handling.\r\n                const retryable = error.name !== 'FirebaseError' &&\r\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\r\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\r\n                this.close();\r\n                if (!retryable) {\r\n                    return Promise.reject(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    close() {\r\n        if (this.db) {\r\n            this.db.close();\r\n        }\r\n        this.db = undefined;\r\n    }\r\n}\r\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\r\nfunction getAndroidVersion(ua) {\r\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\r\n    const version = androidVersionRegex\r\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\r\n        : '-1';\r\n    return Number(version);\r\n}\r\n/**\r\n * A controller for iterating over a key range or index. It allows an iterate\r\n * callback to delete the currently-referenced object, or jump to a new key\r\n * within the key range or index.\r\n */\r\nclass IterationController {\r\n    constructor(dbCursor) {\r\n        this.dbCursor = dbCursor;\r\n        this.shouldStop = false;\r\n        this.nextKey = null;\r\n    }\r\n    get isDone() {\r\n        return this.shouldStop;\r\n    }\r\n    get skipToKey() {\r\n        return this.nextKey;\r\n    }\r\n    set cursor(value) {\r\n        this.dbCursor = value;\r\n    }\r\n    /**\r\n     * This function can be called to stop iteration at any point.\r\n     */\r\n    done() {\r\n        this.shouldStop = true;\r\n    }\r\n    /**\r\n     * This function can be called to skip to that next key, which could be\r\n     * an index or a primary key.\r\n     */\r\n    skip(key) {\r\n        this.nextKey = key;\r\n    }\r\n    /**\r\n     * Delete the current cursor value from the object store.\r\n     *\r\n     * NOTE: You CANNOT do this with a keysOnly query.\r\n     */\r\n    delete() {\r\n        return wrapRequest(this.dbCursor.delete());\r\n    }\r\n}\r\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\r\nclass IndexedDbTransactionError extends FirestoreError {\r\n    constructor(actionName, cause) {\r\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\r\n        this.name = 'IndexedDbTransactionError';\r\n    }\r\n}\r\n/** Verifies whether `e` is an IndexedDbTransactionError. */\r\nfunction isIndexedDbTransactionError(e) {\r\n    // Use name equality, as instanceof checks on errors don't work with errors\r\n    // that wrap other errors.\r\n    return e.name === 'IndexedDbTransactionError';\r\n}\r\n/**\r\n * A wrapper around an IDBObjectStore providing an API that:\r\n *\r\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\r\n * methods for acting against the object store.\r\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\r\n * method return a PersistencePromise instead.\r\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\r\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\r\n */\r\nclass SimpleDbStore {\r\n    constructor(store) {\r\n        this.store = store;\r\n    }\r\n    put(keyOrValue, value) {\r\n        let request;\r\n        if (value !== undefined) {\r\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\r\n            request = this.store.put(value, keyOrValue);\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\r\n            request = this.store.put(keyOrValue);\r\n        }\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Adds a new value into an Object Store and returns the new key. Similar to\r\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\r\n     *\r\n     * @param value - The object to write.\r\n     * @returns The key of the value to add.\r\n     */\r\n    add(value) {\r\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\r\n        const request = this.store.add(value);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Gets the object with the specified key from the specified store, or null\r\n     * if no object exists with the specified key.\r\n     *\r\n     * @key The key of the object to get.\r\n     * @returns The object with the specified key or null if no object exists.\r\n     */\r\n    get(key) {\r\n        const request = this.store.get(key);\r\n        // We're doing an unsafe cast to ValueType.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return wrapRequest(request).next(result => {\r\n            // Normalize nonexistence to null.\r\n            if (result === undefined) {\r\n                result = null;\r\n            }\r\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\r\n            return result;\r\n        });\r\n    }\r\n    delete(key) {\r\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\r\n        const request = this.store.delete(key);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * If we ever need more of the count variants, we can add overloads. For now,\r\n     * all we need is to count everything in a store.\r\n     *\r\n     * Returns the number of rows in the store.\r\n     */\r\n    count() {\r\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\r\n        const request = this.store.count();\r\n        return wrapRequest(request);\r\n    }\r\n    loadAll(indexOrRange, range) {\r\n        const iterateOptions = this.options(indexOrRange, range);\r\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\r\n        // 20% faster.\r\n        const store = iterateOptions.index\r\n            ? this.store.index(iterateOptions.index)\r\n            : this.store;\r\n        if (typeof store.getAll === 'function') {\r\n            const request = store.getAll(iterateOptions.range);\r\n            return new PersistencePromise((resolve, reject) => {\r\n                request.onerror = (event) => {\r\n                    reject(event.target.error);\r\n                };\r\n                request.onsuccess = (event) => {\r\n                    resolve(event.target.result);\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            const cursor = this.cursor(iterateOptions);\r\n            const results = [];\r\n            return this.iterateCursor(cursor, (key, value) => {\r\n                results.push(value);\r\n            }).next(() => {\r\n                return results;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Loads the first `count` elements from the provided index range. Loads all\r\n     * elements if no limit is provided.\r\n     */\r\n    loadFirst(range, count) {\r\n        const request = this.store.getAll(range, count === null ? undefined : count);\r\n        return new PersistencePromise((resolve, reject) => {\r\n            request.onerror = (event) => {\r\n                reject(event.target.error);\r\n            };\r\n            request.onsuccess = (event) => {\r\n                resolve(event.target.result);\r\n            };\r\n        });\r\n    }\r\n    deleteAll(indexOrRange, range) {\r\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\r\n        const options = this.options(indexOrRange, range);\r\n        options.keysOnly = false;\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, (key, value, control) => {\r\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\r\n            // calling delete() on an object store with a single key\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\r\n            // however, this requires us *not* to use a keysOnly cursor\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\r\n            // may want to compare the performance of each method.\r\n            return control.delete();\r\n        });\r\n    }\r\n    iterate(optionsOrCallback, callback) {\r\n        let options;\r\n        if (!callback) {\r\n            options = {};\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, callback);\r\n    }\r\n    /**\r\n     * Iterates over a store, but waits for the given callback to complete for\r\n     * each entry before iterating the next entry. This allows the callback to do\r\n     * asynchronous work to determine if this iteration should continue.\r\n     *\r\n     * The provided callback should return `true` to continue iteration, and\r\n     * `false` otherwise.\r\n     */\r\n    iterateSerial(callback) {\r\n        const cursorRequest = this.cursor({});\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                const error = checkForAndReportiOSError(event.target.error);\r\n                reject(error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\r\n                    if (shouldContinue) {\r\n                        cursor.continue();\r\n                    }\r\n                    else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            };\r\n        });\r\n    }\r\n    iterateCursor(cursorRequest, fn) {\r\n        const results = [];\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                reject(event.target.error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const controller = new IterationController(cursor);\r\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\r\n                if (userResult instanceof PersistencePromise) {\r\n                    const userPromise = userResult.catch(err => {\r\n                        controller.done();\r\n                        return PersistencePromise.reject(err);\r\n                    });\r\n                    results.push(userPromise);\r\n                }\r\n                if (controller.isDone) {\r\n                    resolve();\r\n                }\r\n                else if (controller.skipToKey === null) {\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    cursor.continue(controller.skipToKey);\r\n                }\r\n            };\r\n        }).next(() => PersistencePromise.waitFor(results));\r\n    }\r\n    options(indexOrRange, range) {\r\n        let indexName = undefined;\r\n        if (indexOrRange !== undefined) {\r\n            if (typeof indexOrRange === 'string') {\r\n                indexName = indexOrRange;\r\n            }\r\n            else {\r\n                range = indexOrRange;\r\n            }\r\n        }\r\n        return { index: indexName, range };\r\n    }\r\n    cursor(options) {\r\n        let direction = 'next';\r\n        if (options.reverse) {\r\n            direction = 'prev';\r\n        }\r\n        if (options.index) {\r\n            const index = this.store.index(options.index);\r\n            if (options.keysOnly) {\r\n                return index.openKeyCursor(options.range, direction);\r\n            }\r\n            else {\r\n                return index.openCursor(options.range, direction);\r\n            }\r\n        }\r\n        else {\r\n            return this.store.openCursor(options.range, direction);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\r\n * handlers to resolve / reject the PersistencePromise as appropriate.\r\n */\r\nfunction wrapRequest(request) {\r\n    return new PersistencePromise((resolve, reject) => {\r\n        request.onsuccess = (event) => {\r\n            const result = event.target.result;\r\n            resolve(result);\r\n        };\r\n        request.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            reject(error);\r\n        };\r\n    });\r\n}\r\n// Guard so we only report the error once.\r\nlet reportedIOSError = false;\r\nfunction checkForAndReportiOSError(error) {\r\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\r\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\r\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\r\n            // Wrap error in a more descriptive one.\r\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\r\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\r\n                `for details and a potential workaround.`);\r\n            if (!reportedIOSError) {\r\n                reportedIOSError = true;\r\n                // Throw a global exception outside of this promise chain, for the user to\r\n                // potentially catch.\r\n                setTimeout(() => {\r\n                    throw newError;\r\n                }, 0);\r\n            }\r\n            return newError;\r\n        }\r\n    }\r\n    return error;\r\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\r\n/** How long we wait to try running index backfill after SDK initialization. */\r\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\r\n/** Minimum amount of time between backfill checks, after the first one. */\r\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\r\n/** The maximum number of documents to process each time backfill() is called. */\r\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\r\n/** This class is responsible for the scheduling of Index Backfiller. */\r\nclass IndexBackfillerScheduler {\r\n    constructor(asyncQueue, backfiller) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.backfiller = backfiller;\r\n        this.task = null;\r\n    }\r\n    start() {\r\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\r\n    }\r\n    stop() {\r\n        if (this.task) {\r\n            this.task.cancel();\r\n            this.task = null;\r\n        }\r\n    }\r\n    get started() {\r\n        return this.task !== null;\r\n    }\r\n    schedule(delay) {\r\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\r\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\r\n            this.task = null;\r\n            try {\r\n                const documentsProcessed = await this.backfiller.backfill();\r\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\r\n            }\r\n            catch (e) {\r\n                if (isIndexedDbTransactionError(e)) {\r\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\r\n                }\r\n                else {\r\n                    await ignoreIfPrimaryLeaseLoss(e);\r\n                }\r\n            }\r\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\r\n        });\r\n    }\r\n}\r\n/** Implements the steps for backfilling indexes. */\r\nclass IndexBackfiller {\r\n    constructor(\r\n    /**\r\n     * LocalStore provides access to IndexManager and LocalDocumentView.\r\n     * These properties will update when the user changes. Consequently,\r\n     * making a local copy of IndexManager and LocalDocumentView will require\r\n     * updates over time. The simpler solution is to rely on LocalStore to have\r\n     * an up-to-date references to IndexManager and LocalDocumentStore.\r\n     */\r\n    localStore, persistence) {\r\n        this.localStore = localStore;\r\n        this.persistence = persistence;\r\n    }\r\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\r\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\r\n    }\r\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\r\n    writeIndexEntries(transation, maxDocumentsToProcess) {\r\n        const processedCollectionGroups = new Set();\r\n        let documentsRemaining = maxDocumentsToProcess;\r\n        let continueLoop = true;\r\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\r\n            return this.localStore.indexManager\r\n                .getNextCollectionGroupToUpdate(transation)\r\n                .next((collectionGroup) => {\r\n                if (collectionGroup === null ||\r\n                    processedCollectionGroups.has(collectionGroup)) {\r\n                    continueLoop = false;\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\r\n                    return this.writeEntriesForCollectionGroup(transation, collectionGroup, documentsRemaining).next(documentsProcessed => {\r\n                        documentsRemaining -= documentsProcessed;\r\n                        processedCollectionGroups.add(collectionGroup);\r\n                    });\r\n                }\r\n            });\r\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\r\n    }\r\n    /**\r\n     * Writes entries for the provided collection group. Returns the number of documents processed.\r\n     */\r\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\r\n        // Use the earliest offset of all field indexes to query the local cache.\r\n        return this.localStore.indexManager\r\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\r\n            .next(existingOffset => this.localStore.localDocuments\r\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\r\n            .next(nextBatch => {\r\n            const docs = nextBatch.changes;\r\n            return this.localStore.indexManager\r\n                .updateIndexEntries(transaction, docs)\r\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\r\n                .next(newOffset => {\r\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\r\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\r\n            })\r\n                .next(() => docs.size);\r\n        }));\r\n    }\r\n    /** Returns the next offset based on the provided documents. */\r\n    getNewOffset(existingOffset, lookupResult) {\r\n        let maxOffset = existingOffset;\r\n        lookupResult.changes.forEach((key, document) => {\r\n            const newOffset = newIndexOffsetFromDocument(document);\r\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\r\n                maxOffset = newOffset;\r\n            }\r\n        });\r\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\r\n * exceed. All subsequent calls to next will return increasing values. If provided with a\r\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\r\n * well as write out sequence numbers that it produces via `next()`.\r\n */\r\nclass ListenSequence {\r\n    constructor(previousValue, sequenceNumberSyncer) {\r\n        this.previousValue = previousValue;\r\n        if (sequenceNumberSyncer) {\r\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\r\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\r\n        }\r\n    }\r\n    setPreviousValue(externalPreviousValue) {\r\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\r\n        return this.previousValue;\r\n    }\r\n    next() {\r\n        const nextValue = ++this.previousValue;\r\n        if (this.writeNewSequenceNumber) {\r\n            this.writeNewSequenceNumber(nextValue);\r\n        }\r\n        return nextValue;\r\n    }\r\n}\r\nListenSequence.INVALID = -1;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst escapeChar = '\\u0001';\r\nconst encodedSeparatorChar = '\\u0001';\r\nconst encodedNul = '\\u0010';\r\nconst encodedEscape = '\\u0011';\r\n/**\r\n * Encodes a resource path into a IndexedDb-compatible string form.\r\n */\r\nfunction encodeResourcePath(path) {\r\n    let result = '';\r\n    for (let i = 0; i < path.length; i++) {\r\n        if (result.length > 0) {\r\n            result = encodeSeparator(result);\r\n        }\r\n        result = encodeSegment(path.get(i), result);\r\n    }\r\n    return encodeSeparator(result);\r\n}\r\n/** Encodes a single segment of a resource path into the given result */\r\nfunction encodeSegment(segment, resultBuf) {\r\n    let result = resultBuf;\r\n    const length = segment.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const c = segment.charAt(i);\r\n        switch (c) {\r\n            case '\\0':\r\n                result += escapeChar + encodedNul;\r\n                break;\r\n            case escapeChar:\r\n                result += escapeChar + encodedEscape;\r\n                break;\r\n            default:\r\n                result += c;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/** Encodes a path separator into the given result */\r\nfunction encodeSeparator(result) {\r\n    return result + escapeChar + encodedSeparatorChar;\r\n}\r\n/**\r\n * Decodes the given IndexedDb-compatible string form of a resource path into\r\n * a ResourcePath instance. Note that this method is not suitable for use with\r\n * decoding resource names from the server; those are One Platform format\r\n * strings.\r\n */\r\nfunction decodeResourcePath(path) {\r\n    // Event the empty path must encode as a path of at least length 2. A path\r\n    // with exactly 2 must be the empty path.\r\n    const length = path.length;\r\n    hardAssert(length >= 2);\r\n    if (length === 2) {\r\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    // Escape characters cannot exist past the second-to-last position in the\r\n    // source value.\r\n    const lastReasonableEscapeIndex = length - 2;\r\n    const segments = [];\r\n    let segmentBuilder = '';\r\n    for (let start = 0; start < length;) {\r\n        // The last two characters of a valid encoded path must be a separator, so\r\n        // there must be an end to this segment.\r\n        const end = path.indexOf(escapeChar, start);\r\n        if (end < 0 || end > lastReasonableEscapeIndex) {\r\n            fail();\r\n        }\r\n        const next = path.charAt(end + 1);\r\n        switch (next) {\r\n            case encodedSeparatorChar:\r\n                const currentPiece = path.substring(start, end);\r\n                let segment;\r\n                if (segmentBuilder.length === 0) {\r\n                    // Avoid copying for the common case of a segment that excludes \\0\r\n                    // and \\001\r\n                    segment = currentPiece;\r\n                }\r\n                else {\r\n                    segmentBuilder += currentPiece;\r\n                    segment = segmentBuilder;\r\n                    segmentBuilder = '';\r\n                }\r\n                segments.push(segment);\r\n                break;\r\n            case encodedNul:\r\n                segmentBuilder += path.substring(start, end);\r\n                segmentBuilder += '\\0';\r\n                break;\r\n            case encodedEscape:\r\n                // The escape character can be used in the output to encode itself.\r\n                segmentBuilder += path.substring(start, end + 1);\r\n                break;\r\n            default:\r\n                fail();\r\n        }\r\n        start = end + 2;\r\n    }\r\n    return new ResourcePath(segments);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Name of the IndexedDb object store.\r\n *\r\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\r\n * older clients that only supported single locked access to the persistence\r\n * layer.\r\n */\r\nconst DbPrimaryClientStore = 'owner';\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbPrimaryClient store.\r\n */\r\nconst DbPrimaryClientKey = 'owner';\r\n/** Name of the IndexedDb object store.  */\r\nconst DbMutationQueueStore = 'mutationQueues';\r\n/** Keys are automatically assigned via the userId property. */\r\nconst DbMutationQueueKeyPath = 'userId';\r\n/** Name of the IndexedDb object store.  */\r\nconst DbMutationBatchStore = 'mutations';\r\n/** Keys are automatically assigned via the userId, batchId properties. */\r\nconst DbMutationBatchKeyPath = 'batchId';\r\n/** The index name for lookup of mutations by user. */\r\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\r\n/** The user mutations index is keyed by [userId, batchId] pairs. */\r\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\r\n/**\r\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\r\n * over all of a user's document mutations.\r\n */\r\nfunction newDbDocumentMutationPrefixForUser(userId) {\r\n    return [userId];\r\n}\r\n/**\r\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\r\n * index to iterate over all at document mutations for a given path or lower.\r\n */\r\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\r\n    return [userId, encodeResourcePath(path)];\r\n}\r\n/**\r\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\r\n * and deleting into the DbDocumentMutations index.\r\n */\r\nfunction newDbDocumentMutationKey(userId, path, batchId) {\r\n    return [userId, encodeResourcePath(path), batchId];\r\n}\r\n/**\r\n * Because we store all the useful information for this store in the key,\r\n * there is no useful information to store as the value. The raw (unencoded)\r\n * path cannot be stored because IndexedDb doesn't store prototype\r\n * information.\r\n */\r\nconst DbDocumentMutationPlaceholder = {};\r\nconst DbDocumentMutationStore = 'documentMutations';\r\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\r\n/**\r\n * The primary key of the remote documents store, which allows for efficient\r\n * access by collection path and read time.\r\n */\r\nconst DbRemoteDocumentKeyPath = [\r\n    'prefixPath',\r\n    'collectionGroup',\r\n    'readTime',\r\n    'documentId'\r\n];\r\n/** An index that provides access to documents by key. */\r\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\r\nconst DbRemoteDocumentDocumentKeyIndexPath = [\r\n    'prefixPath',\r\n    'collectionGroup',\r\n    'documentId'\r\n];\r\n/**\r\n * An index that provides access to documents by collection group and read\r\n * time.\r\n *\r\n * This index is used by the index backfiller.\r\n */\r\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\r\nconst DbRemoteDocumentCollectionGroupIndexPath = [\r\n    'collectionGroup',\r\n    'readTime',\r\n    'prefixPath',\r\n    'documentId'\r\n];\r\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\r\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\r\nconst DbTargetStore = 'targets';\r\n/** Keys are automatically assigned via the targetId property. */\r\nconst DbTargetKeyPath = 'targetId';\r\n/** The name of the queryTargets index. */\r\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\r\n/**\r\n * The index of all canonicalIds to the targets that they match. This is not\r\n * a unique mapping because canonicalId does not promise a unique name for all\r\n * possible queries, so we append the targetId to make the mapping unique.\r\n */\r\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\r\n/** Name of the IndexedDb object store.  */\r\nconst DbTargetDocumentStore = 'targetDocuments';\r\n/** Keys are automatically assigned via the targetId, path properties. */\r\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\r\n/** The index name for the reverse index. */\r\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\r\n/** We also need to create the reverse index for these properties. */\r\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbTargetGlobal store.\r\n */\r\nconst DbTargetGlobalKey = 'targetGlobalKey';\r\nconst DbTargetGlobalStore = 'targetGlobal';\r\n/** Name of the IndexedDb object store. */\r\nconst DbCollectionParentStore = 'collectionParents';\r\n/** Keys are automatically assigned via the collectionId, parent properties. */\r\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\r\n/** Name of the IndexedDb object store. */\r\nconst DbClientMetadataStore = 'clientMetadata';\r\n/** Keys are automatically assigned via the clientId properties. */\r\nconst DbClientMetadataKeyPath = 'clientId';\r\n/** Name of the IndexedDb object store. */\r\nconst DbBundleStore = 'bundles';\r\nconst DbBundleKeyPath = 'bundleId';\r\n/** Name of the IndexedDb object store. */\r\nconst DbNamedQueryStore = 'namedQueries';\r\nconst DbNamedQueryKeyPath = 'name';\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexConfigurationStore = 'indexConfiguration';\r\nconst DbIndexConfigurationKeyPath = 'indexId';\r\n/**\r\n * An index that provides access to the index configurations by collection\r\n * group.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\r\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexStateStore = 'indexState';\r\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\r\n/**\r\n * An index that provides access to documents in a collection sorted by last\r\n * update time. Used by the backfiller.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\r\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\r\n/** Name of the IndexedDb object store. */\r\nconst DbIndexEntryStore = 'indexEntries';\r\nconst DbIndexEntryKeyPath = [\r\n    'indexId',\r\n    'uid',\r\n    'arrayValue',\r\n    'directionalValue',\r\n    'orderedDocumentKey',\r\n    'documentKey'\r\n];\r\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\r\nconst DbIndexEntryDocumentKeyIndexPath = [\r\n    'indexId',\r\n    'uid',\r\n    'orderedDocumentKey'\r\n];\r\n/** Name of the IndexedDb object store. */\r\nconst DbDocumentOverlayStore = 'documentOverlays';\r\nconst DbDocumentOverlayKeyPath = [\r\n    'userId',\r\n    'collectionPath',\r\n    'documentId'\r\n];\r\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\r\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\r\n    'userId',\r\n    'collectionPath',\r\n    'largestBatchId'\r\n];\r\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\r\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\r\n    'userId',\r\n    'collectionGroup',\r\n    'largestBatchId'\r\n];\r\n// Visible for testing\r\nconst V1_STORES = [\r\n    DbMutationQueueStore,\r\n    DbMutationBatchStore,\r\n    DbDocumentMutationStore,\r\n    DbRemoteDocumentStore$1,\r\n    DbTargetStore,\r\n    DbPrimaryClientStore,\r\n    DbTargetGlobalStore,\r\n    DbTargetDocumentStore\r\n];\r\n// Visible for testing\r\nconst V3_STORES = V1_STORES;\r\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\r\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\r\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\r\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\r\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\r\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\r\nconst V13_STORES = [\r\n    DbMutationQueueStore,\r\n    DbMutationBatchStore,\r\n    DbDocumentMutationStore,\r\n    DbRemoteDocumentStore,\r\n    DbTargetStore,\r\n    DbPrimaryClientStore,\r\n    DbTargetGlobalStore,\r\n    DbTargetDocumentStore,\r\n    DbClientMetadataStore,\r\n    DbRemoteDocumentGlobalStore,\r\n    DbCollectionParentStore,\r\n    DbBundleStore,\r\n    DbNamedQueryStore,\r\n    DbDocumentOverlayStore\r\n];\r\nconst V14_STORES = V13_STORES;\r\nconst V15_STORES = [\r\n    ...V14_STORES,\r\n    DbIndexConfigurationStore,\r\n    DbIndexStateStore,\r\n    DbIndexEntryStore\r\n];\r\nconst V16_STORES = V15_STORES;\r\n/** Returns the object stores for the provided schema. */\r\nfunction getObjectStores(schemaVersion) {\r\n    if (schemaVersion === 16) {\r\n        return V16_STORES;\r\n    }\r\n    else if (schemaVersion === 15) {\r\n        return V15_STORES;\r\n    }\r\n    else if (schemaVersion === 14) {\r\n        return V14_STORES;\r\n    }\r\n    else if (schemaVersion === 13) {\r\n        return V13_STORES;\r\n    }\r\n    else if (schemaVersion === 12) {\r\n        return V12_STORES;\r\n    }\r\n    else if (schemaVersion === 11) {\r\n        return V11_STORES;\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTransaction extends PersistenceTransaction {\r\n    constructor(simpleDbTransaction, currentSequenceNumber) {\r\n        super();\r\n        this.simpleDbTransaction = simpleDbTransaction;\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nfunction getStore(txn, store) {\r\n    const indexedDbTransaction = debugCast(txn);\r\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction objectSize(obj) {\r\n    let count = 0;\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}\r\nfunction forEach(obj, fn) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\nfunction mapToArray(obj, fn) {\r\n    const result = [];\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            result.push(fn(obj[key], key, obj));\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n// tree.\r\nclass SortedMap {\r\n    constructor(comparator, root) {\r\n        this.comparator = comparator;\r\n        this.root = root ? root : LLRBNode.EMPTY;\r\n    }\r\n    // Returns a copy of the map, with the specified key/value added or replaced.\r\n    insert(key, value) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .insert(key, value, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns a copy of the map, with the specified key removed.\r\n    remove(key) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .remove(key, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns the value of the node with the given key, or null.\r\n    get(key) {\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\r\n    // exist.\r\n    indexOf(key) {\r\n        // Number of nodes that were pruned when descending right\r\n        let prunedNodes = 0;\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return prunedNodes + node.left.size;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else {\r\n                // Count all nodes left of the node plus the node itself\r\n                prunedNodes += node.left.size + 1;\r\n                node = node.right;\r\n            }\r\n        }\r\n        // Node not found\r\n        return -1;\r\n    }\r\n    isEmpty() {\r\n        return this.root.isEmpty();\r\n    }\r\n    // Returns the total number of nodes in the map.\r\n    get size() {\r\n        return this.root.size;\r\n    }\r\n    // Returns the minimum key in the map.\r\n    minKey() {\r\n        return this.root.minKey();\r\n    }\r\n    // Returns the maximum key in the map.\r\n    maxKey() {\r\n        return this.root.maxKey();\r\n    }\r\n    // Traverses the map in key order and calls the specified action function\r\n    // for each key/value pair. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return this.root.inorderTraversal(action);\r\n    }\r\n    forEach(fn) {\r\n        this.inorderTraversal((k, v) => {\r\n            fn(k, v);\r\n            return false;\r\n        });\r\n    }\r\n    toString() {\r\n        const descriptions = [];\r\n        this.inorderTraversal((k, v) => {\r\n            descriptions.push(`${k}:${v}`);\r\n            return false;\r\n        });\r\n        return `{${descriptions.join(', ')}}`;\r\n    }\r\n    // Traverses the map in reverse key order and calls the specified action\r\n    // function for each key/value pair. If action returns true, traversal is\r\n    // aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return this.root.reverseTraversal(action);\r\n    }\r\n    // Returns an iterator over the SortedMap.\r\n    getIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, false);\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, false);\r\n    }\r\n    getReverseIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, true);\r\n    }\r\n    getReverseIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, true);\r\n    }\r\n} // end SortedMap\r\n// An iterator over an LLRBNode.\r\nclass SortedMapIterator {\r\n    constructor(node, startKey, comparator, isReverse) {\r\n        this.isReverse = isReverse;\r\n        this.nodeStack = [];\r\n        let cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (startKey && isReverse) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack,\r\n                // but stop iterating;\r\n                this.nodeStack.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move\r\n                // to the next one\r\n                this.nodeStack.push(node);\r\n                if (this.isReverse) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getNext() {\r\n        let node = this.nodeStack.pop();\r\n        const result = { key: node.key, value: node.value };\r\n        if (this.isReverse) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    hasNext() {\r\n        return this.nodeStack.length > 0;\r\n    }\r\n    peek() {\r\n        if (this.nodeStack.length === 0) {\r\n            return null;\r\n        }\r\n        const node = this.nodeStack[this.nodeStack.length - 1];\r\n        return { key: node.key, value: node.value };\r\n    }\r\n} // end SortedMapIterator\r\n// Represents a node in a Left-leaning Red-Black tree.\r\nclass LLRBNode {\r\n    constructor(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left = left != null ? left : LLRBNode.EMPTY;\r\n        this.right = right != null ? right : LLRBNode.EMPTY;\r\n        this.size = this.left.size + 1 + this.right.size;\r\n    }\r\n    // Returns a copy of the current node, optionally replacing pieces of it.\r\n    copy(key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    }\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    // Traverses the tree in key order and calls the specified action function\r\n    // for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    }\r\n    // Traverses the tree in reverse key order and calls the specified action\r\n    // function for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    }\r\n    // Returns the minimum node in the tree.\r\n    min() {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min();\r\n        }\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    minKey() {\r\n        return this.min().key;\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    maxKey() {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    }\r\n    // Returns new tree, with the key/value added.\r\n    insert(key, value, comparator) {\r\n        let n = this;\r\n        const cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    removeMin() {\r\n        if (this.left.isEmpty()) {\r\n            return LLRBNode.EMPTY;\r\n        }\r\n        let n = this;\r\n        if (!n.left.isRed() && !n.left.left.isRed()) {\r\n            n = n.moveRedLeft();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin(), null);\r\n        return n.fixUp();\r\n    }\r\n    // Returns new tree, with the specified item removed.\r\n    remove(key, comparator) {\r\n        let smallest;\r\n        let n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\r\n                n = n.moveRedLeft();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed()) {\r\n                n = n.rotateRight();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\r\n                n = n.moveRedRight();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return LLRBNode.EMPTY;\r\n                }\r\n                else {\r\n                    smallest = n.right.min();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    isRed() {\r\n        return this.color;\r\n    }\r\n    // Returns new tree after performing any needed rotations.\r\n    fixUp() {\r\n        let n = this;\r\n        if (n.right.isRed() && !n.left.isRed()) {\r\n            n = n.rotateLeft();\r\n        }\r\n        if (n.left.isRed() && n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n        }\r\n        if (n.left.isRed() && n.right.isRed()) {\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedLeft() {\r\n        let n = this.colorFlip();\r\n        if (n.right.left.isRed()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight());\r\n            n = n.rotateLeft();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedRight() {\r\n        let n = this.colorFlip();\r\n        if (n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    rotateLeft() {\r\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    }\r\n    rotateRight() {\r\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    }\r\n    colorFlip() {\r\n        const left = this.left.copy(null, null, !this.left.color, null, null);\r\n        const right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        const blackDepth = this.check();\r\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\r\n    // leaves is equal on both sides.  This function verifies that or asserts.\r\n    check() {\r\n        if (this.isRed() && this.left.isRed()) {\r\n            throw fail();\r\n        }\r\n        if (this.right.isRed()) {\r\n            throw fail();\r\n        }\r\n        const blackDepth = this.left.check();\r\n        if (blackDepth !== this.right.check()) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed() ? 0 : 1);\r\n        }\r\n    }\r\n} // end LLRBNode\r\n// Empty node is shared between all LLRB trees.\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nLLRBNode.EMPTY = null;\r\nLLRBNode.RED = true;\r\nLLRBNode.BLACK = false;\r\n// Represents an empty node (a leaf node in the Red-Black Tree).\r\nclass LLRBEmptyNode {\r\n    constructor() {\r\n        this.size = 0;\r\n    }\r\n    get key() {\r\n        throw fail();\r\n    }\r\n    get value() {\r\n        throw fail();\r\n    }\r\n    get color() {\r\n        throw fail();\r\n    }\r\n    get left() {\r\n        throw fail();\r\n    }\r\n    get right() {\r\n        throw fail();\r\n    }\r\n    // Returns a copy of the current node.\r\n    copy(key, value, color, left, right) {\r\n        return this;\r\n    }\r\n    // Returns a copy of the tree, with the specified key/value added.\r\n    insert(key, value, comparator) {\r\n        return new LLRBNode(key, value);\r\n    }\r\n    // Returns a copy of the tree, with the specified key removed.\r\n    remove(key, comparator) {\r\n        return this;\r\n    }\r\n    isEmpty() {\r\n        return true;\r\n    }\r\n    inorderTraversal(action) {\r\n        return false;\r\n    }\r\n    reverseTraversal(action) {\r\n        return false;\r\n    }\r\n    minKey() {\r\n        return null;\r\n    }\r\n    maxKey() {\r\n        return null;\r\n    }\r\n    isRed() {\r\n        return false;\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        return true;\r\n    }\r\n    check() {\r\n        return 0;\r\n    }\r\n} // end LLRBEmptyNode\r\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * SortedSet is an immutable (copy-on-write) collection that holds elements\r\n * in order specified by the provided comparator.\r\n *\r\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\r\n * be equal!\r\n */\r\nclass SortedSet {\r\n    constructor(comparator) {\r\n        this.comparator = comparator;\r\n        this.data = new SortedMap(this.comparator);\r\n    }\r\n    has(elem) {\r\n        return this.data.get(elem) !== null;\r\n    }\r\n    first() {\r\n        return this.data.minKey();\r\n    }\r\n    last() {\r\n        return this.data.maxKey();\r\n    }\r\n    get size() {\r\n        return this.data.size;\r\n    }\r\n    indexOf(elem) {\r\n        return this.data.indexOf(elem);\r\n    }\r\n    /** Iterates elements in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.data.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\r\n    forEachInRange(range, cb) {\r\n        const iter = this.data.getIteratorFrom(range[0]);\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            if (this.comparator(elem.key, range[1]) >= 0) {\r\n                return;\r\n            }\r\n            cb(elem.key);\r\n        }\r\n    }\r\n    /**\r\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\r\n     */\r\n    forEachWhile(cb, start) {\r\n        let iter;\r\n        if (start !== undefined) {\r\n            iter = this.data.getIteratorFrom(start);\r\n        }\r\n        else {\r\n            iter = this.data.getIterator();\r\n        }\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            const result = cb(elem.key);\r\n            if (!result) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /** Finds the least element greater than or equal to `elem`. */\r\n    firstAfterOrEqual(elem) {\r\n        const iter = this.data.getIteratorFrom(elem);\r\n        return iter.hasNext() ? iter.getNext().key : null;\r\n    }\r\n    getIterator() {\r\n        return new SortedSetIterator(this.data.getIterator());\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\r\n    }\r\n    /** Inserts or updates an element */\r\n    add(elem) {\r\n        return this.copy(this.data.remove(elem).insert(elem, true));\r\n    }\r\n    /** Deletes an element */\r\n    delete(elem) {\r\n        if (!this.has(elem)) {\r\n            return this;\r\n        }\r\n        return this.copy(this.data.remove(elem));\r\n    }\r\n    isEmpty() {\r\n        return this.data.isEmpty();\r\n    }\r\n    unionWith(other) {\r\n        let result = this;\r\n        // Make sure `result` always refers to the larger one of the two sets.\r\n        if (result.size < other.size) {\r\n            result = other;\r\n            other = this;\r\n        }\r\n        other.forEach(elem => {\r\n            result = result.add(elem);\r\n        });\r\n        return result;\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof SortedSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.data.getIterator();\r\n        const otherIt = other.data.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisElem = thisIt.getNext().key;\r\n            const otherElem = otherIt.getNext().key;\r\n            if (this.comparator(thisElem, otherElem) !== 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toArray() {\r\n        const res = [];\r\n        this.forEach(targetId => {\r\n            res.push(targetId);\r\n        });\r\n        return res;\r\n    }\r\n    toString() {\r\n        const result = [];\r\n        this.forEach(elem => result.push(elem));\r\n        return 'SortedSet(' + result.toString() + ')';\r\n    }\r\n    copy(data) {\r\n        const result = new SortedSet(this.comparator);\r\n        result.data = data;\r\n        return result;\r\n    }\r\n}\r\nclass SortedSetIterator {\r\n    constructor(iter) {\r\n        this.iter = iter;\r\n    }\r\n    getNext() {\r\n        return this.iter.getNext().key;\r\n    }\r\n    hasNext() {\r\n        return this.iter.hasNext();\r\n    }\r\n}\r\n/**\r\n * Compares two sorted sets for equality using their natural ordering. The\r\n * method computes the intersection and invokes `onAdd` for every element that\r\n * is in `after` but not `before`. `onRemove` is invoked for every element in\r\n * `before` but missing from `after`.\r\n *\r\n * The method creates a copy of both `before` and `after` and runs in O(n log\r\n * n), where n is the size of the two lists.\r\n *\r\n * @param before - The elements that exist in the original set.\r\n * @param after - The elements to diff against the original set.\r\n * @param comparator - The comparator for the elements in before and after.\r\n * @param onAdd - A function to invoke for every element that is part of `\r\n * after` but not `before`.\r\n * @param onRemove - A function to invoke for every element that is part of\r\n * `before` but not `after`.\r\n */\r\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\r\n    const beforeIt = before.getIterator();\r\n    const afterIt = after.getIterator();\r\n    let beforeValue = advanceIterator(beforeIt);\r\n    let afterValue = advanceIterator(afterIt);\r\n    // Walk through the two sets at the same time, using the ordering defined by\r\n    // `comparator`.\r\n    while (beforeValue || afterValue) {\r\n        let added = false;\r\n        let removed = false;\r\n        if (beforeValue && afterValue) {\r\n            const cmp = comparator(beforeValue, afterValue);\r\n            if (cmp < 0) {\r\n                // The element was removed if the next element in our ordered\r\n                // walkthrough is only in `before`.\r\n                removed = true;\r\n            }\r\n            else if (cmp > 0) {\r\n                // The element was added if the next element in our ordered walkthrough\r\n                // is only in `after`.\r\n                added = true;\r\n            }\r\n        }\r\n        else if (beforeValue != null) {\r\n            removed = true;\r\n        }\r\n        else {\r\n            added = true;\r\n        }\r\n        if (added) {\r\n            onAdd(afterValue);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n        else if (removed) {\r\n            onRemove(beforeValue);\r\n            beforeValue = advanceIterator(beforeIt);\r\n        }\r\n        else {\r\n            beforeValue = advanceIterator(beforeIt);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns the next element from the iterator or `undefined` if none available.\r\n */\r\nfunction advanceIterator(it) {\r\n    return it.hasNext() ? it.getNext() : undefined;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a set of fields that can be used to partially patch a document.\r\n * FieldMask is used in conjunction with ObjectValue.\r\n * Examples:\r\n *   foo - Overwrites foo entirely with the provided value. If foo is not\r\n *         present in the companion ObjectValue, the field is deleted.\r\n *   foo.bar - Overwrites only the field bar of the object foo.\r\n *             If foo is not an object, foo is replaced with an object\r\n *             containing foo\r\n */\r\nclass FieldMask {\r\n    constructor(fields) {\r\n        this.fields = fields;\r\n        // TODO(dimond): validation of FieldMask\r\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\r\n        fields.sort(FieldPath$1.comparator);\r\n    }\r\n    static empty() {\r\n        return new FieldMask([]);\r\n    }\r\n    /**\r\n     * Returns a new FieldMask object that is the result of adding all the given\r\n     * fields paths to this field mask.\r\n     */\r\n    unionWith(extraFields) {\r\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\r\n        for (const fieldPath of this.fields) {\r\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\r\n        }\r\n        for (const fieldPath of extraFields) {\r\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\r\n        }\r\n        return new FieldMask(mergedMaskSet.toArray());\r\n    }\r\n    /**\r\n     * Verifies that `fieldPath` is included by at least one field in this field\r\n     * mask.\r\n     *\r\n     * This is an O(n) operation, where `n` is the size of the field mask.\r\n     */\r\n    covers(fieldPath) {\r\n        for (const fieldMaskPath of this.fields) {\r\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isEqual(other) {\r\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Converts a Base64 encoded string to a binary string. */\r\nfunction decodeBase64(encoded) {\r\n    // Note: We used to validate the base64 string here via a regular expression.\r\n    // This was removed to improve the performance of indexing.\r\n    return Buffer.from(encoded, 'base64').toString('binary');\r\n}\r\n/** Converts a binary string to a Base64 encoded string. */\r\nfunction encodeBase64(raw) {\r\n    return Buffer.from(raw, 'binary').toString('base64');\r\n}\r\n/** True if and only if the Base64 conversion functions are available. */\r\nfunction isBase64Available() {\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Immutable class that represents a \"proto\" byte string.\r\n *\r\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\r\n * sent on the wire. This class abstracts away this differentiation by holding\r\n * the proto byte string in a common class that must be converted into a string\r\n * before being sent as a proto.\r\n * @internal\r\n */\r\nclass ByteString {\r\n    constructor(binaryString) {\r\n        this.binaryString = binaryString;\r\n    }\r\n    static fromBase64String(base64) {\r\n        const binaryString = decodeBase64(base64);\r\n        return new ByteString(binaryString);\r\n    }\r\n    static fromUint8Array(array) {\r\n        // TODO(indexing); Remove the copy of the byte string here as this method\r\n        // is frequently called during indexing.\r\n        const binaryString = binaryStringFromUint8Array(array);\r\n        return new ByteString(binaryString);\r\n    }\r\n    [Symbol.iterator]() {\r\n        let i = 0;\r\n        return {\r\n            next: () => {\r\n                if (i < this.binaryString.length) {\r\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n    }\r\n    toBase64() {\r\n        return encodeBase64(this.binaryString);\r\n    }\r\n    toUint8Array() {\r\n        return uint8ArrayFromBinaryString(this.binaryString);\r\n    }\r\n    approximateByteSize() {\r\n        return this.binaryString.length * 2;\r\n    }\r\n    compareTo(other) {\r\n        return primitiveComparator(this.binaryString, other.binaryString);\r\n    }\r\n    isEqual(other) {\r\n        return this.binaryString === other.binaryString;\r\n    }\r\n}\r\nByteString.EMPTY_BYTE_STRING = new ByteString('');\r\n/**\r\n * Helper function to convert an Uint8array to a binary string.\r\n */\r\nfunction binaryStringFromUint8Array(array) {\r\n    let binaryString = '';\r\n    for (let i = 0; i < array.length; ++i) {\r\n        binaryString += String.fromCharCode(array[i]);\r\n    }\r\n    return binaryString;\r\n}\r\n/**\r\n * Helper function to convert a binary string to an Uint8Array.\r\n */\r\nfunction uint8ArrayFromBinaryString(binaryString) {\r\n    const buffer = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n        buffer[i] = binaryString.charCodeAt(i);\r\n    }\r\n    return buffer;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\r\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\r\n/**\r\n * Converts the possible Proto values for a timestamp value into a \"seconds and\r\n * nanos\" representation.\r\n */\r\nfunction normalizeTimestamp(date) {\r\n    hardAssert(!!date);\r\n    // The json interface (for the browser) will return an iso timestamp string,\r\n    // while the proto js library (for node) will return a\r\n    // google.protobuf.Timestamp instance.\r\n    if (typeof date === 'string') {\r\n        // The date string can have higher precision (nanos) than the Date class\r\n        // (millis), so we do some custom parsing here.\r\n        // Parse the nanos right out of the string.\r\n        let nanos = 0;\r\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\r\n        hardAssert(!!fraction);\r\n        if (fraction[1]) {\r\n            // Pad the fraction out to 9 digits (nanos).\r\n            let nanoStr = fraction[1];\r\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\r\n            nanos = Number(nanoStr);\r\n        }\r\n        // Parse the date to get the seconds.\r\n        const parsedDate = new Date(date);\r\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\r\n        return { seconds, nanos };\r\n    }\r\n    else {\r\n        // TODO(b/37282237): Use strings for Proto3 timestamps\r\n        // assert(!this.options.useProto3Json,\r\n        //   'The timestamp instance format requires Proto JS.');\r\n        const seconds = normalizeNumber(date.seconds);\r\n        const nanos = normalizeNumber(date.nanos);\r\n        return { seconds, nanos };\r\n    }\r\n}\r\n/**\r\n * Converts the possible Proto types for numbers into a JavaScript number.\r\n * Returns 0 if the value is not numeric.\r\n */\r\nfunction normalizeNumber(value) {\r\n    // TODO(bjornick): Handle int64 greater than 53 bits.\r\n    if (typeof value === 'number') {\r\n        return value;\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n/** Converts the possible Proto types for Blobs into a ByteString. */\r\nfunction normalizeByteString(blob) {\r\n    if (typeof blob === 'string') {\r\n        return ByteString.fromBase64String(blob);\r\n    }\r\n    else {\r\n        return ByteString.fromUint8Array(blob);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a locally-applied ServerTimestamp.\r\n *\r\n * Server Timestamps are backed by MapValues that contain an internal field\r\n * `__type__` with a value of `server_timestamp`. The previous value and local\r\n * write time are stored in its `__previous_value__` and `__local_write_time__`\r\n * fields respectively.\r\n *\r\n * Notes:\r\n * - ServerTimestampValue instances are created as the result of applying a\r\n *   transform. They can only exist in the local view of a document. Therefore\r\n *   they do not need to be parsed or serialized.\r\n * - When evaluated locally (e.g. for snapshot.data()), they by default\r\n *   evaluate to `null`. This behavior can be configured by passing custom\r\n *   FieldValueOptions to value().\r\n * - With respect to other ServerTimestampValues, they sort by their\r\n *   localWriteTime.\r\n */\r\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\r\nconst TYPE_KEY = '__type__';\r\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\r\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\r\nfunction isServerTimestamp(value) {\r\n    var _a, _b;\r\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\r\n    return type === SERVER_TIMESTAMP_SENTINEL;\r\n}\r\n/**\r\n * Creates a new ServerTimestamp proto value (using the internal format).\r\n */\r\nfunction serverTimestamp$1(localWriteTime, previousValue) {\r\n    const mapValue = {\r\n        fields: {\r\n            [TYPE_KEY]: {\r\n                stringValue: SERVER_TIMESTAMP_SENTINEL\r\n            },\r\n            [LOCAL_WRITE_TIME_KEY]: {\r\n                timestampValue: {\r\n                    seconds: localWriteTime.seconds,\r\n                    nanos: localWriteTime.nanoseconds\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // We should avoid storing deeply nested server timestamp map values\r\n    // because we never use the intermediate \"previous values\".\r\n    // For example:\r\n    // previous: 42L, add: t1, result: t1 -> 42L\r\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\r\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\r\n    // `getPreviousValue` recursively traverses server timestamps to find the\r\n    // least recent Value.\r\n    if (previousValue && isServerTimestamp(previousValue)) {\r\n        previousValue = getPreviousValue(previousValue);\r\n    }\r\n    if (previousValue) {\r\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\r\n    }\r\n    return { mapValue };\r\n}\r\n/**\r\n * Returns the value of the field before this ServerTimestamp was set.\r\n *\r\n * Preserving the previous values allows the user to display the last resoled\r\n * value until the backend responds with the timestamp.\r\n */\r\nfunction getPreviousValue(value) {\r\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\r\n    if (isServerTimestamp(previousValue)) {\r\n        return getPreviousValue(previousValue);\r\n    }\r\n    return previousValue;\r\n}\r\n/**\r\n * Returns the local time at which this timestamp was first set.\r\n */\r\nfunction getLocalWriteTime(value) {\r\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\r\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass DatabaseInfo {\r\n    /**\r\n     * Constructs a DatabaseInfo using the provided host, databaseId and\r\n     * persistenceKey.\r\n     *\r\n     * @param databaseId - The database to use.\r\n     * @param appId - The Firebase App Id.\r\n     * @param persistenceKey - A unique identifier for this Firestore's local\r\n     * storage (used in conjunction with the databaseId).\r\n     * @param host - The Firestore backend host to connect to.\r\n     * @param ssl - Whether to use SSL when connecting.\r\n     * @param forceLongPolling - Whether to use the forceLongPolling option\r\n     * when using WebChannel as the network transport.\r\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\r\n     * option when using WebChannel as the network transport.\r\n     * @param longPollingOptions Options that configure long-polling.\r\n     * @param useFetchStreams Whether to use the Fetch API instead of\r\n     * XMLHTTPRequest\r\n     */\r\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams) {\r\n        this.databaseId = databaseId;\r\n        this.appId = appId;\r\n        this.persistenceKey = persistenceKey;\r\n        this.host = host;\r\n        this.ssl = ssl;\r\n        this.forceLongPolling = forceLongPolling;\r\n        this.autoDetectLongPolling = autoDetectLongPolling;\r\n        this.longPollingOptions = longPollingOptions;\r\n        this.useFetchStreams = useFetchStreams;\r\n    }\r\n}\r\n/** The default database name for a project. */\r\nconst DEFAULT_DATABASE_NAME = '(default)';\r\n/**\r\n * Represents the database ID a Firestore client is associated with.\r\n * @internal\r\n */\r\nclass DatabaseId {\r\n    constructor(projectId, database) {\r\n        this.projectId = projectId;\r\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\r\n    }\r\n    static empty() {\r\n        return new DatabaseId('', '');\r\n    }\r\n    get isDefaultDatabase() {\r\n        return this.database === DEFAULT_DATABASE_NAME;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof DatabaseId &&\r\n            other.projectId === this.projectId &&\r\n            other.database === this.database);\r\n    }\r\n}\r\nfunction databaseIdFromApp(app, database) {\r\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\r\n    }\r\n    return new DatabaseId(app.options.projectId, database);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Sentinel value that sorts before any Mutation Batch ID. */\r\nconst BATCHID_UNKNOWN = -1;\r\n/**\r\n * Returns whether a variable is either undefined or null.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\n/** Returns whether the value represents -0. */\r\nfunction isNegativeZero(value) {\r\n    // Detect if the value is -0.0. Based on polyfill from\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n    return value === 0 && 1 / value === 1 / -0;\r\n}\r\n/**\r\n * Returns whether a value is an integer and in the safe integer range\r\n * @param value - The value to test for being an integer and in the safe range\r\n */\r\nfunction isSafeInteger(value) {\r\n    return (typeof value === 'number' &&\r\n        Number.isInteger(value) &&\r\n        !isNegativeZero(value) &&\r\n        value <= Number.MAX_SAFE_INTEGER &&\r\n        value >= Number.MIN_SAFE_INTEGER);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_VALUE_TYPE = '__max__';\r\nconst MAX_VALUE = {\r\n    mapValue: {\r\n        fields: {\r\n            '__type__': { stringValue: MAX_VALUE_TYPE }\r\n        }\r\n    }\r\n};\r\nconst MIN_VALUE = {\r\n    nullValue: 'NULL_VALUE'\r\n};\r\n/** Extracts the backend's type order for the provided value. */\r\nfunction typeOrder(value) {\r\n    if ('nullValue' in value) {\r\n        return 0 /* TypeOrder.NullValue */;\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return 1 /* TypeOrder.BooleanValue */;\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return 2 /* TypeOrder.NumberValue */;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return 3 /* TypeOrder.TimestampValue */;\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return 5 /* TypeOrder.StringValue */;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return 6 /* TypeOrder.BlobValue */;\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return 7 /* TypeOrder.RefValue */;\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return 8 /* TypeOrder.GeoPointValue */;\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return 9 /* TypeOrder.ArrayValue */;\r\n    }\r\n    else if ('mapValue' in value) {\r\n        if (isServerTimestamp(value)) {\r\n            return 4 /* TypeOrder.ServerTimestampValue */;\r\n        }\r\n        else if (isMaxValue(value)) {\r\n            return 9007199254740991 /* TypeOrder.MaxValue */;\r\n        }\r\n        return 10 /* TypeOrder.ObjectValue */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** Tests `left` and `right` for equality based on the backend semantics. */\r\nfunction valueEquals(left, right) {\r\n    if (left === right) {\r\n        return true;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return false;\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n            return true;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return left.booleanValue === right.booleanValue;\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            return timestampEquals(left, right);\r\n        case 5 /* TypeOrder.StringValue */:\r\n            return left.stringValue === right.stringValue;\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return blobEquals(left, right);\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return left.referenceValue === right.referenceValue;\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            return geoPointEquals(left, right);\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return numberEquals(left, right);\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return objectEquals(left, right);\r\n        case 9007199254740991 /* TypeOrder.MaxValue */:\r\n            return true;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction timestampEquals(left, right) {\r\n    if (typeof left.timestampValue === 'string' &&\r\n        typeof right.timestampValue === 'string' &&\r\n        left.timestampValue.length === right.timestampValue.length) {\r\n        // Use string equality for ISO 8601 timestamps\r\n        return left.timestampValue === right.timestampValue;\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\r\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\r\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\r\n        leftTimestamp.nanos === rightTimestamp.nanos);\r\n}\r\nfunction geoPointEquals(left, right) {\r\n    return (normalizeNumber(left.geoPointValue.latitude) ===\r\n        normalizeNumber(right.geoPointValue.latitude) &&\r\n        normalizeNumber(left.geoPointValue.longitude) ===\r\n            normalizeNumber(right.geoPointValue.longitude));\r\n}\r\nfunction blobEquals(left, right) {\r\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\r\n}\r\nfunction numberEquals(left, right) {\r\n    if ('integerValue' in left && 'integerValue' in right) {\r\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\r\n    }\r\n    else if ('doubleValue' in left && 'doubleValue' in right) {\r\n        const n1 = normalizeNumber(left.doubleValue);\r\n        const n2 = normalizeNumber(right.doubleValue);\r\n        if (n1 === n2) {\r\n            return isNegativeZero(n1) === isNegativeZero(n2);\r\n        }\r\n        else {\r\n            return isNaN(n1) && isNaN(n2);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction objectEquals(left, right) {\r\n    const leftMap = left.mapValue.fields || {};\r\n    const rightMap = right.mapValue.fields || {};\r\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\r\n        return false;\r\n    }\r\n    for (const key in leftMap) {\r\n        if (leftMap.hasOwnProperty(key)) {\r\n            if (rightMap[key] === undefined ||\r\n                !valueEquals(leftMap[key], rightMap[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Returns true if the ArrayValue contains the specified element. */\r\nfunction arrayValueContains(haystack, needle) {\r\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\r\n}\r\nfunction valueCompare(left, right) {\r\n    if (left === right) {\r\n        return 0;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return primitiveComparator(leftType, rightType);\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n        case 9007199254740991 /* TypeOrder.MaxValue */:\r\n            return 0;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return primitiveComparator(left.booleanValue, right.booleanValue);\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return compareNumbers(left, right);\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            return compareTimestamps(left.timestampValue, right.timestampValue);\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\r\n        case 5 /* TypeOrder.StringValue */:\r\n            return primitiveComparator(left.stringValue, right.stringValue);\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return compareBlobs(left.bytesValue, right.bytesValue);\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return compareReferences(left.referenceValue, right.referenceValue);\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return compareArrays(left.arrayValue, right.arrayValue);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return compareMaps(left.mapValue, right.mapValue);\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\nfunction compareNumbers(left, right) {\r\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\r\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\r\n    if (leftNumber < rightNumber) {\r\n        return -1;\r\n    }\r\n    else if (leftNumber > rightNumber) {\r\n        return 1;\r\n    }\r\n    else if (leftNumber === rightNumber) {\r\n        return 0;\r\n    }\r\n    else {\r\n        // one or both are NaN.\r\n        if (isNaN(leftNumber)) {\r\n            return isNaN(rightNumber) ? 0 : -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n}\r\nfunction compareTimestamps(left, right) {\r\n    if (typeof left === 'string' &&\r\n        typeof right === 'string' &&\r\n        left.length === right.length) {\r\n        return primitiveComparator(left, right);\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left);\r\n    const rightTimestamp = normalizeTimestamp(right);\r\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\r\n}\r\nfunction compareReferences(leftPath, rightPath) {\r\n    const leftSegments = leftPath.split('/');\r\n    const rightSegments = rightPath.split('/');\r\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\r\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\r\n        if (comparison !== 0) {\r\n            return comparison;\r\n        }\r\n    }\r\n    return primitiveComparator(leftSegments.length, rightSegments.length);\r\n}\r\nfunction compareGeoPoints(left, right) {\r\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\r\n}\r\nfunction compareBlobs(left, right) {\r\n    const leftBytes = normalizeByteString(left);\r\n    const rightBytes = normalizeByteString(right);\r\n    return leftBytes.compareTo(rightBytes);\r\n}\r\nfunction compareArrays(left, right) {\r\n    const leftArray = left.values || [];\r\n    const rightArray = right.values || [];\r\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\r\n        const compare = valueCompare(leftArray[i], rightArray[i]);\r\n        if (compare) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftArray.length, rightArray.length);\r\n}\r\nfunction compareMaps(left, right) {\r\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\r\n        return 0;\r\n    }\r\n    else if (left === MAX_VALUE.mapValue) {\r\n        return 1;\r\n    }\r\n    else if (right === MAX_VALUE.mapValue) {\r\n        return -1;\r\n    }\r\n    const leftMap = left.fields || {};\r\n    const leftKeys = Object.keys(leftMap);\r\n    const rightMap = right.fields || {};\r\n    const rightKeys = Object.keys(rightMap);\r\n    // Even though MapValues are likely sorted correctly based on their insertion\r\n    // order (e.g. when received from the backend), local modifications can bring\r\n    // elements out of order. We need to re-sort the elements to ensure that\r\n    // canonical IDs are independent of insertion order.\r\n    leftKeys.sort();\r\n    rightKeys.sort();\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\r\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\r\n        if (keyCompare !== 0) {\r\n            return keyCompare;\r\n        }\r\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftKeys.length, rightKeys.length);\r\n}\r\n/**\r\n * Generates the canonical ID for the provided field value (as used in Target\r\n * serialization).\r\n */\r\nfunction canonicalId(value) {\r\n    return canonifyValue(value);\r\n}\r\nfunction canonifyValue(value) {\r\n    if ('nullValue' in value) {\r\n        return 'null';\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return '' + value.booleanValue;\r\n    }\r\n    else if ('integerValue' in value) {\r\n        return '' + value.integerValue;\r\n    }\r\n    else if ('doubleValue' in value) {\r\n        return '' + value.doubleValue;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return canonifyTimestamp(value.timestampValue);\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return value.stringValue;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return canonifyByteString(value.bytesValue);\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return canonifyReference(value.referenceValue);\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return canonifyGeoPoint(value.geoPointValue);\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return canonifyArray(value.arrayValue);\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return canonifyMap(value.mapValue);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction canonifyByteString(byteString) {\r\n    return normalizeByteString(byteString).toBase64();\r\n}\r\nfunction canonifyTimestamp(timestamp) {\r\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\r\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\r\n}\r\nfunction canonifyGeoPoint(geoPoint) {\r\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\r\n}\r\nfunction canonifyReference(referenceValue) {\r\n    return DocumentKey.fromName(referenceValue).toString();\r\n}\r\nfunction canonifyMap(mapValue) {\r\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\r\n    // matching canonical IDs for identical maps, we need to sort the keys.\r\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\r\n    let result = '{';\r\n    let first = true;\r\n    for (const key of sortedKeys) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\r\n    }\r\n    return result + '}';\r\n}\r\nfunction canonifyArray(arrayValue) {\r\n    let result = '[';\r\n    let first = true;\r\n    for (const value of arrayValue.values || []) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += canonifyValue(value);\r\n    }\r\n    return result + ']';\r\n}\r\n/**\r\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\r\n * value.\r\n *\r\n * The memory size takes into account only the actual user data as it resides\r\n * in memory and ignores object overhead.\r\n */\r\nfunction estimateByteSize(value) {\r\n    switch (typeOrder(value)) {\r\n        case 0 /* TypeOrder.NullValue */:\r\n            return 4;\r\n        case 1 /* TypeOrder.BooleanValue */:\r\n            return 4;\r\n        case 2 /* TypeOrder.NumberValue */:\r\n            return 8;\r\n        case 3 /* TypeOrder.TimestampValue */:\r\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\r\n            return 16;\r\n        case 4 /* TypeOrder.ServerTimestampValue */:\r\n            const previousValue = getPreviousValue(value);\r\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\r\n        case 5 /* TypeOrder.StringValue */:\r\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\r\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\r\n            // integer values\"\r\n            return value.stringValue.length * 2;\r\n        case 6 /* TypeOrder.BlobValue */:\r\n            return normalizeByteString(value.bytesValue).approximateByteSize();\r\n        case 7 /* TypeOrder.RefValue */:\r\n            return value.referenceValue.length;\r\n        case 8 /* TypeOrder.GeoPointValue */:\r\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\r\n            return 16;\r\n        case 9 /* TypeOrder.ArrayValue */:\r\n            return estimateArrayByteSize(value.arrayValue);\r\n        case 10 /* TypeOrder.ObjectValue */:\r\n            return estimateMapByteSize(value.mapValue);\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\nfunction estimateMapByteSize(mapValue) {\r\n    let size = 0;\r\n    forEach(mapValue.fields, (key, val) => {\r\n        size += key.length + estimateByteSize(val);\r\n    });\r\n    return size;\r\n}\r\nfunction estimateArrayByteSize(arrayValue) {\r\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\r\n}\r\n/** Returns a reference value for the provided database and key. */\r\nfunction refValue(databaseId, key) {\r\n    return {\r\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\r\n    };\r\n}\r\n/** Returns true if `value` is an IntegerValue . */\r\nfunction isInteger(value) {\r\n    return !!value && 'integerValue' in value;\r\n}\r\n/** Returns true if `value` is a DoubleValue. */\r\nfunction isDouble(value) {\r\n    return !!value && 'doubleValue' in value;\r\n}\r\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\r\nfunction isNumber(value) {\r\n    return isInteger(value) || isDouble(value);\r\n}\r\n/** Returns true if `value` is an ArrayValue. */\r\nfunction isArray(value) {\r\n    return !!value && 'arrayValue' in value;\r\n}\r\n/** Returns true if `value` is a NullValue. */\r\nfunction isNullValue(value) {\r\n    return !!value && 'nullValue' in value;\r\n}\r\n/** Returns true if `value` is NaN. */\r\nfunction isNanValue(value) {\r\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\r\n}\r\n/** Returns true if `value` is a MapValue. */\r\nfunction isMapValue(value) {\r\n    return !!value && 'mapValue' in value;\r\n}\r\n/** Creates a deep copy of `source`. */\r\nfunction deepClone(source) {\r\n    if (source.geoPointValue) {\r\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\r\n    }\r\n    else if (source.timestampValue &&\r\n        typeof source.timestampValue === 'object') {\r\n        return { timestampValue: Object.assign({}, source.timestampValue) };\r\n    }\r\n    else if (source.mapValue) {\r\n        const target = { mapValue: { fields: {} } };\r\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\r\n        return target;\r\n    }\r\n    else if (source.arrayValue) {\r\n        const target = { arrayValue: { values: [] } };\r\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\r\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return Object.assign({}, source);\r\n    }\r\n}\r\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\r\nfunction isMaxValue(value) {\r\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\r\n        MAX_VALUE_TYPE);\r\n}\r\n/** Returns the lowest value for the given value type (inclusive). */\r\nfunction valuesGetLowerBound(value) {\r\n    if ('nullValue' in value) {\r\n        return MIN_VALUE;\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return { booleanValue: false };\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return { doubleValue: NaN };\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return { stringValue: '' };\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return { bytesValue: '' };\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return { arrayValue: {} };\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return { mapValue: {} };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** Returns the largest value for the given value type (exclusive). */\r\nfunction valuesGetUpperBound(value) {\r\n    if ('nullValue' in value) {\r\n        return { booleanValue: false };\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return { doubleValue: NaN };\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return { stringValue: '' };\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return { bytesValue: '' };\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return { arrayValue: {} };\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return { mapValue: {} };\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return MAX_VALUE;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction lowerBoundCompare(left, right) {\r\n    const cmp = valueCompare(left.value, right.value);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    if (left.inclusive && !right.inclusive) {\r\n        return -1;\r\n    }\r\n    else if (!left.inclusive && right.inclusive) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction upperBoundCompare(left, right) {\r\n    const cmp = valueCompare(left.value, right.value);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    if (left.inclusive && !right.inclusive) {\r\n        return 1;\r\n    }\r\n    else if (!left.inclusive && right.inclusive) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\r\n * ability to add and remove fields (via the ObjectValueBuilder).\r\n */\r\nclass ObjectValue {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    static empty() {\r\n        return new ObjectValue({ mapValue: {} });\r\n    }\r\n    /**\r\n     * Returns the value at the given path or null.\r\n     *\r\n     * @param path - the path to search\r\n     * @returns The value at the path or null if the path is not set.\r\n     */\r\n    field(path) {\r\n        if (path.isEmpty()) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            let currentLevel = this.value;\r\n            for (let i = 0; i < path.length - 1; ++i) {\r\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\r\n                if (!isMapValue(currentLevel)) {\r\n                    return null;\r\n                }\r\n            }\r\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\r\n            return currentLevel || null;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the field to the provided value.\r\n     *\r\n     * @param path - The field path to set.\r\n     * @param value - The value to set.\r\n     */\r\n    set(path, value) {\r\n        const fieldsMap = this.getFieldsMap(path.popLast());\r\n        fieldsMap[path.lastSegment()] = deepClone(value);\r\n    }\r\n    /**\r\n     * Sets the provided fields to the provided values.\r\n     *\r\n     * @param data - A map of fields to values (or null for deletes).\r\n     */\r\n    setAll(data) {\r\n        let parent = FieldPath$1.emptyPath();\r\n        let upserts = {};\r\n        let deletes = [];\r\n        data.forEach((value, path) => {\r\n            if (!parent.isImmediateParentOf(path)) {\r\n                // Insert the accumulated changes at this parent location\r\n                const fieldsMap = this.getFieldsMap(parent);\r\n                this.applyChanges(fieldsMap, upserts, deletes);\r\n                upserts = {};\r\n                deletes = [];\r\n                parent = path.popLast();\r\n            }\r\n            if (value) {\r\n                upserts[path.lastSegment()] = deepClone(value);\r\n            }\r\n            else {\r\n                deletes.push(path.lastSegment());\r\n            }\r\n        });\r\n        const fieldsMap = this.getFieldsMap(parent);\r\n        this.applyChanges(fieldsMap, upserts, deletes);\r\n    }\r\n    /**\r\n     * Removes the field at the specified path. If there is no field at the\r\n     * specified path, nothing is changed.\r\n     *\r\n     * @param path - The field path to remove.\r\n     */\r\n    delete(path) {\r\n        const nestedValue = this.field(path.popLast());\r\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\r\n            delete nestedValue.mapValue.fields[path.lastSegment()];\r\n        }\r\n    }\r\n    isEqual(other) {\r\n        return valueEquals(this.value, other.value);\r\n    }\r\n    /**\r\n     * Returns the map that contains the leaf element of `path`. If the parent\r\n     * entry does not yet exist, or if it is not a map, a new map will be created.\r\n     */\r\n    getFieldsMap(path) {\r\n        let current = this.value;\r\n        if (!current.mapValue.fields) {\r\n            current.mapValue = { fields: {} };\r\n        }\r\n        for (let i = 0; i < path.length; ++i) {\r\n            let next = current.mapValue.fields[path.get(i)];\r\n            if (!isMapValue(next) || !next.mapValue.fields) {\r\n                next = { mapValue: { fields: {} } };\r\n                current.mapValue.fields[path.get(i)] = next;\r\n            }\r\n            current = next;\r\n        }\r\n        return current.mapValue.fields;\r\n    }\r\n    /**\r\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\r\n     * entries.\r\n     */\r\n    applyChanges(fieldsMap, inserts, deletes) {\r\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\r\n        for (const field of deletes) {\r\n            delete fieldsMap[field];\r\n        }\r\n    }\r\n    clone() {\r\n        return new ObjectValue(deepClone(this.value));\r\n    }\r\n}\r\n/**\r\n * Returns a FieldMask built from all fields in a MapValue.\r\n */\r\nfunction extractFieldMask(value) {\r\n    const fields = [];\r\n    forEach(value.fields, (key, value) => {\r\n        const currentPath = new FieldPath$1([key]);\r\n        if (isMapValue(value)) {\r\n            const nestedMask = extractFieldMask(value.mapValue);\r\n            const nestedFields = nestedMask.fields;\r\n            if (nestedFields.length === 0) {\r\n                // Preserve the empty map by adding it to the FieldMask.\r\n                fields.push(currentPath);\r\n            }\r\n            else {\r\n                // For nested and non-empty ObjectValues, add the FieldPath of the\r\n                // leaf nodes.\r\n                for (const nestedPath of nestedFields) {\r\n                    fields.push(currentPath.child(nestedPath));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\r\n            // nodes.\r\n            fields.push(currentPath);\r\n        }\r\n    });\r\n    return new FieldMask(fields);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a document in Firestore with a key, version, data and whether it\r\n * has local mutations applied to it.\r\n *\r\n * Documents can transition between states via `convertToFoundDocument()`,\r\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\r\n * not transition to one of these states even after all mutations have been\r\n * applied, `isValidDocument()` returns false and the document should be removed\r\n * from all views.\r\n */\r\nclass MutableDocument {\r\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\r\n        this.key = key;\r\n        this.documentType = documentType;\r\n        this.version = version;\r\n        this.readTime = readTime;\r\n        this.createTime = createTime;\r\n        this.data = data;\r\n        this.documentState = documentState;\r\n    }\r\n    /**\r\n     * Creates a document with no known version or data, but which can serve as\r\n     * base document for mutations.\r\n     */\r\n    static newInvalidDocument(documentKey) {\r\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \r\n        /* version */ SnapshotVersion.min(), \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist with the given data at the\r\n     * given version.\r\n     */\r\n    static newFoundDocument(documentKey, version, createTime, value) {\r\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /** Creates a new document that is known to not exist at the given version. */\r\n    static newNoDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist at the given version but\r\n     * whose data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    static newUnknownDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \r\n        /* version */ version, \r\n        /* readTime */ SnapshotVersion.min(), \r\n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists and that its version\r\n     * and data are known.\r\n     */\r\n    convertToFoundDocument(version, value) {\r\n        // If a document is switching state from being an invalid or deleted\r\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\r\n        // update from Watch or due to applying a local set mutation on top\r\n        // of a deleted document, our best guess about its createTime would be the\r\n        // version at which the document transitioned to a FOUND_DOCUMENT.\r\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\r\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\r\n                this.documentType === 0 /* DocumentType.INVALID */)) {\r\n            this.createTime = version;\r\n        }\r\n        this.version = version;\r\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\r\n        this.data = value;\r\n        this.documentState = 0 /* DocumentState.SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it doesn't exist at the given\r\n     * version.\r\n     */\r\n    convertToNoDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 0 /* DocumentState.SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists at a given version but\r\n     * that its data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    convertToUnknownDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasCommittedMutations() {\r\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasLocalMutations() {\r\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\r\n        this.version = SnapshotVersion.min();\r\n        return this;\r\n    }\r\n    setReadTime(readTime) {\r\n        this.readTime = readTime;\r\n        return this;\r\n    }\r\n    get hasLocalMutations() {\r\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\r\n    }\r\n    get hasCommittedMutations() {\r\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\r\n    }\r\n    get hasPendingWrites() {\r\n        return this.hasLocalMutations || this.hasCommittedMutations;\r\n    }\r\n    isValidDocument() {\r\n        return this.documentType !== 0 /* DocumentType.INVALID */;\r\n    }\r\n    isFoundDocument() {\r\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\r\n    }\r\n    isNoDocument() {\r\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\r\n    }\r\n    isUnknownDocument() {\r\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof MutableDocument &&\r\n            this.key.isEqual(other.key) &&\r\n            this.version.isEqual(other.version) &&\r\n            this.documentType === other.documentType &&\r\n            this.documentState === other.documentState &&\r\n            this.data.isEqual(other.data));\r\n    }\r\n    mutableCopy() {\r\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\r\n    }\r\n    toString() {\r\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\r\n            `{createTime: ${this.createTime}}), ` +\r\n            `{documentType: ${this.documentType}}), ` +\r\n            `{documentState: ${this.documentState}})`);\r\n    }\r\n}\r\n/**\r\n * Compares the value for field `field` in the provided documents. Throws if\r\n * the field does not exist in both documents.\r\n */\r\nfunction compareDocumentsByField(field, d1, d2) {\r\n    const v1 = d1.data.field(field);\r\n    const v2 = d2.data.field(field);\r\n    if (v1 !== null && v2 !== null) {\r\n        return valueCompare(v1, v2);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a bound of a query.\r\n *\r\n * The bound is specified with the given components representing a position and\r\n * whether it's just before or just after the position (relative to whatever the\r\n * query order is).\r\n *\r\n * The position represents a logical index position for a query. It's a prefix\r\n * of values for the (potentially implicit) order by clauses of a query.\r\n *\r\n * Bound provides a function to determine whether a document comes before or\r\n * after a bound. This is influenced by whether the position is just before or\r\n * just after the provided values.\r\n */\r\nclass Bound {\r\n    constructor(position, inclusive) {\r\n        this.position = position;\r\n        this.inclusive = inclusive;\r\n    }\r\n}\r\nfunction boundCompareToDocument(bound, orderBy, doc) {\r\n    let comparison = 0;\r\n    for (let i = 0; i < bound.position.length; i++) {\r\n        const orderByComponent = orderBy[i];\r\n        const component = bound.position[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\r\n        }\r\n        else {\r\n            const docValue = doc.data.field(orderByComponent.field);\r\n            comparison = valueCompare(component, docValue);\r\n        }\r\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\r\n            comparison = comparison * -1;\r\n        }\r\n        if (comparison !== 0) {\r\n            break;\r\n        }\r\n    }\r\n    return comparison;\r\n}\r\n/**\r\n * Returns true if a document sorts after a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\r\n}\r\n/**\r\n * Returns true if a document sorts before a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\r\n}\r\nfunction boundEquals(left, right) {\r\n    if (left === null) {\r\n        return right === null;\r\n    }\r\n    else if (right === null) {\r\n        return false;\r\n    }\r\n    if (left.inclusive !== right.inclusive ||\r\n        left.position.length !== right.position.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.position.length; i++) {\r\n        const leftPosition = left.position[i];\r\n        const rightPosition = right.position[i];\r\n        if (!valueEquals(leftPosition, rightPosition)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\r\n */\r\nclass OrderBy {\r\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\r\n        this.field = field;\r\n        this.dir = dir;\r\n    }\r\n}\r\nfunction canonifyOrderBy(orderBy) {\r\n    // TODO(b/29183165): Make this collision robust.\r\n    return orderBy.field.canonicalString() + orderBy.dir;\r\n}\r\nfunction stringifyOrderBy(orderBy) {\r\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\r\n}\r\nfunction orderByEquals(left, right) {\r\n    return left.dir === right.dir && left.field.isEqual(right.field);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Filter {\r\n}\r\nclass FieldFilter extends Filter {\r\n    constructor(field, op, value) {\r\n        super();\r\n        this.field = field;\r\n        this.op = op;\r\n        this.value = value;\r\n    }\r\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */\r\n    static create(field, op, value) {\r\n        if (field.isKeyField()) {\r\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\r\n                return this.createKeyFieldInFilter(field, op, value);\r\n            }\r\n            else {\r\n                return new KeyFieldFilter(field, op, value);\r\n            }\r\n        }\r\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\r\n            return new ArrayContainsFilter(field, value);\r\n        }\r\n        else if (op === \"in\" /* Operator.IN */) {\r\n            return new InFilter(field, value);\r\n        }\r\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\r\n            return new NotInFilter(field, value);\r\n        }\r\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            return new ArrayContainsAnyFilter(field, value);\r\n        }\r\n        else {\r\n            return new FieldFilter(field, op, value);\r\n        }\r\n    }\r\n    static createKeyFieldInFilter(field, op, value) {\r\n        return op === \"in\" /* Operator.IN */\r\n            ? new KeyFieldInFilter(field, value)\r\n            : new KeyFieldNotInFilter(field, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        // Types do not have to match in NOT_EQUAL filters.\r\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\r\n            return (other !== null &&\r\n                this.matchesComparison(valueCompare(other, this.value)));\r\n        }\r\n        // Only compare types with matching backend order (such as double and int).\r\n        return (other !== null &&\r\n            typeOrder(this.value) === typeOrder(other) &&\r\n            this.matchesComparison(valueCompare(other, this.value)));\r\n    }\r\n    matchesComparison(comparison) {\r\n        switch (this.op) {\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n                return comparison < 0;\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                return comparison <= 0;\r\n            case \"==\" /* Operator.EQUAL */:\r\n                return comparison === 0;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n                return comparison !== 0;\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                return comparison > 0;\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n                return comparison >= 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    }\r\n    isInequality() {\r\n        return ([\r\n            \"<\" /* Operator.LESS_THAN */,\r\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\r\n            \">\" /* Operator.GREATER_THAN */,\r\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\r\n            \"!=\" /* Operator.NOT_EQUAL */,\r\n            \"not-in\" /* Operator.NOT_IN */\r\n        ].indexOf(this.op) >= 0);\r\n    }\r\n    getFlattenedFilters() {\r\n        return [this];\r\n    }\r\n    getFilters() {\r\n        return [this];\r\n    }\r\n}\r\nclass CompositeFilter extends Filter {\r\n    constructor(filters, op) {\r\n        super();\r\n        this.filters = filters;\r\n        this.op = op;\r\n        this.memoizedFlattenedFilters = null;\r\n    }\r\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */\r\n    static create(filters, op) {\r\n        return new CompositeFilter(filters, op);\r\n    }\r\n    matches(doc) {\r\n        if (compositeFilterIsConjunction(this)) {\r\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\r\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\r\n        }\r\n        else {\r\n            // For disjunctions, at least one filter should match.\r\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\r\n        }\r\n    }\r\n    getFlattenedFilters() {\r\n        if (this.memoizedFlattenedFilters !== null) {\r\n            return this.memoizedFlattenedFilters;\r\n        }\r\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\r\n            return result.concat(subfilter.getFlattenedFilters());\r\n        }, []);\r\n        return this.memoizedFlattenedFilters;\r\n    }\r\n    // Returns a mutable copy of `this.filters`\r\n    getFilters() {\r\n        return Object.assign([], this.filters);\r\n    }\r\n}\r\nfunction compositeFilterIsConjunction(compositeFilter) {\r\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\r\n}\r\nfunction compositeFilterIsDisjunction(compositeFilter) {\r\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\r\n}\r\n/**\r\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\r\n */\r\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\r\n    return (compositeFilterIsFlat(compositeFilter) &&\r\n        compositeFilterIsConjunction(compositeFilter));\r\n}\r\n/**\r\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\r\n */\r\nfunction compositeFilterIsFlat(compositeFilter) {\r\n    for (const filter of compositeFilter.filters) {\r\n        if (filter instanceof CompositeFilter) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction canonifyFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        // TODO(b/29183165): Technically, this won't be unique if two values have\r\n        // the same description, such as the int 3 and the string \"3\". So we should\r\n        // add the types in here somehow, too.\r\n        return (filter.field.canonicalString() +\r\n            filter.op.toString() +\r\n            canonicalId(filter.value));\r\n    }\r\n    else if (compositeFilterIsFlatConjunction(filter)) {\r\n        // Older SDK versions use an implicit AND operation between their filters.\r\n        // In the new SDK versions, the developer may use an explicit AND filter.\r\n        // To stay consistent with the old usages, we add a special case to ensure\r\n        // the canonical ID for these two are the same. For example:\r\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\r\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\r\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\r\n    }\r\n    else {\r\n        // filter instanceof CompositeFilter\r\n        const canonicalIdsString = filter.filters\r\n            .map(filter => canonifyFilter(filter))\r\n            .join(',');\r\n        return `${filter.op}(${canonicalIdsString})`;\r\n    }\r\n}\r\nfunction filterEquals(f1, f2) {\r\n    if (f1 instanceof FieldFilter) {\r\n        return fieldFilterEquals(f1, f2);\r\n    }\r\n    else if (f1 instanceof CompositeFilter) {\r\n        return compositeFilterEquals(f1, f2);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n}\r\nfunction fieldFilterEquals(f1, f2) {\r\n    return (f2 instanceof FieldFilter &&\r\n        f1.op === f2.op &&\r\n        f1.field.isEqual(f2.field) &&\r\n        valueEquals(f1.value, f2.value));\r\n}\r\nfunction compositeFilterEquals(f1, f2) {\r\n    if (f2 instanceof CompositeFilter &&\r\n        f1.op === f2.op &&\r\n        f1.filters.length === f2.filters.length) {\r\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\r\n        return subFiltersMatch;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns a new composite filter that contains all filter from\r\n * `compositeFilter` plus all the given filters in `otherFilters`.\r\n */\r\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\r\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\r\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\r\n}\r\n/** Returns a debug description for `filter`. */\r\nfunction stringifyFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        return stringifyFieldFilter(filter);\r\n    }\r\n    else if (filter instanceof CompositeFilter) {\r\n        return stringifyCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return 'Filter';\r\n    }\r\n}\r\nfunction stringifyCompositeFilter(filter) {\r\n    return (filter.op.toString() +\r\n        ` {` +\r\n        filter.getFilters().map(stringifyFilter).join(' ,') +\r\n        '}');\r\n}\r\nfunction stringifyFieldFilter(filter) {\r\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\r\n}\r\n/** Filter that matches on key fields (i.e. '__name__'). */\r\nclass KeyFieldFilter extends FieldFilter {\r\n    constructor(field, op, value) {\r\n        super(field, op, value);\r\n        this.key = DocumentKey.fromName(value.referenceValue);\r\n    }\r\n    matches(doc) {\r\n        const comparison = DocumentKey.comparator(doc.key, this.key);\r\n        return this.matchesComparison(comparison);\r\n    }\r\n}\r\n/** Filter that matches on key fields within an array. */\r\nclass KeyFieldInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* Operator.IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\n/** Filter that matches on key fields not present within an array. */\r\nclass KeyFieldNotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return !this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\nfunction extractDocumentKeysFromArrayValue(op, value) {\r\n    var _a;\r\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\r\n        return DocumentKey.fromName(v.referenceValue);\r\n    });\r\n}\r\n/** A Filter that implements the array-contains operator. */\r\nclass ArrayContainsFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\r\n    }\r\n}\r\n/** A Filter that implements the IN operator. */\r\nclass InFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* Operator.IN */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the not-in operator. */\r\nclass NotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\r\n            return false;\r\n        }\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the array-contains-any operator. */\r\nclass ArrayContainsAnyFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        if (!isArray(other) || !other.arrayValue.values) {\r\n            return false;\r\n        }\r\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Visible for testing\r\nclass TargetImpl {\r\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.orderBy = orderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedCanonicalId = null;\r\n    }\r\n}\r\n/**\r\n * Initializes a Target with a path and optional additional query constraints.\r\n * Path must currently be empty if this is a collection group query.\r\n *\r\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\r\n * using this factory method, because `Query` provides an implicit `orderBy`\r\n * property.\r\n */\r\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\r\n}\r\nfunction canonifyTarget(target) {\r\n    const targetImpl = debugCast(target);\r\n    if (targetImpl.memoizedCanonicalId === null) {\r\n        let str = targetImpl.path.canonicalString();\r\n        if (targetImpl.collectionGroup !== null) {\r\n            str += '|cg:' + targetImpl.collectionGroup;\r\n        }\r\n        str += '|f:';\r\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\r\n        str += '|ob:';\r\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\r\n        if (!isNullOrUndefined(targetImpl.limit)) {\r\n            str += '|l:';\r\n            str += targetImpl.limit;\r\n        }\r\n        if (targetImpl.startAt) {\r\n            str += '|lb:';\r\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\r\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        if (targetImpl.endAt) {\r\n            str += '|ub:';\r\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\r\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        targetImpl.memoizedCanonicalId = str;\r\n    }\r\n    return targetImpl.memoizedCanonicalId;\r\n}\r\nfunction stringifyTarget(target) {\r\n    let str = target.path.canonicalString();\r\n    if (target.collectionGroup !== null) {\r\n        str += ' collectionGroup=' + target.collectionGroup;\r\n    }\r\n    if (target.filters.length > 0) {\r\n        str += `, filters: [${target.filters\r\n            .map(f => stringifyFilter(f))\r\n            .join(', ')}]`;\r\n    }\r\n    if (!isNullOrUndefined(target.limit)) {\r\n        str += ', limit: ' + target.limit;\r\n    }\r\n    if (target.orderBy.length > 0) {\r\n        str += `, orderBy: [${target.orderBy\r\n            .map(o => stringifyOrderBy(o))\r\n            .join(', ')}]`;\r\n    }\r\n    if (target.startAt) {\r\n        str += ', startAt: ';\r\n        str += target.startAt.inclusive ? 'b:' : 'a:';\r\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    if (target.endAt) {\r\n        str += ', endAt: ';\r\n        str += target.endAt.inclusive ? 'a:' : 'b:';\r\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    return `Target(${str})`;\r\n}\r\nfunction targetEquals(left, right) {\r\n    if (left.limit !== right.limit) {\r\n        return false;\r\n    }\r\n    if (left.orderBy.length !== right.orderBy.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.orderBy.length; i++) {\r\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.filters.length !== right.filters.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.filters.length; i++) {\r\n        if (!filterEquals(left.filters[i], right.filters[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.collectionGroup !== right.collectionGroup) {\r\n        return false;\r\n    }\r\n    if (!left.path.isEqual(right.path)) {\r\n        return false;\r\n    }\r\n    if (!boundEquals(left.startAt, right.startAt)) {\r\n        return false;\r\n    }\r\n    return boundEquals(left.endAt, right.endAt);\r\n}\r\nfunction targetIsDocumentTarget(target) {\r\n    return (DocumentKey.isDocumentKey(target.path) &&\r\n        target.collectionGroup === null &&\r\n        target.filters.length === 0);\r\n}\r\n/** Returns the field filters that target the given field path. */\r\nfunction targetGetFieldFiltersForPath(target, path) {\r\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\r\n}\r\n/**\r\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\r\n * filters. Returns `null` if there are no such filters.\r\n */\r\nfunction targetGetArrayValues(target, fieldIndex) {\r\n    const segment = fieldIndexGetArraySegment(fieldIndex);\r\n    if (segment === undefined) {\r\n        return null;\r\n    }\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\r\n        switch (fieldFilter.op) {\r\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\r\n                return fieldFilter.value.arrayValue.values || [];\r\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\r\n                return [fieldFilter.value];\r\n            // Remaining filters are not array filters.\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns the list of values that are used in != or NOT_IN filters. Returns\r\n * `null` if there are no such filters.\r\n */\r\nfunction targetGetNotInValues(target, fieldIndex) {\r\n    const values = new Map();\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\r\n            switch (fieldFilter.op) {\r\n                case \"==\" /* Operator.EQUAL */:\r\n                case \"in\" /* Operator.IN */:\r\n                    // Encode equality prefix, which is encoded in the index value before\r\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\r\n                    // `value != 'ab'`).\r\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\r\n                    break;\r\n                case \"not-in\" /* Operator.NOT_IN */:\r\n                case \"!=\" /* Operator.NOT_EQUAL */:\r\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\r\n                    // segments and hence we can return early here.\r\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\r\n                    return Array.from(values.values());\r\n                // Remaining filters cannot be used as notIn bounds.\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns a lower bound of field values that can be used as a starting point to\r\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\r\n * exists.\r\n */\r\nfunction targetGetLowerBound(target, fieldIndex) {\r\n    const values = [];\r\n    let inclusive = true;\r\n    // For each segment, retrieve a lower bound if there is a suitable filter or\r\n    // startAt.\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\r\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\r\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\r\n        values.push(segmentBound.value);\r\n        inclusive && (inclusive = segmentBound.inclusive);\r\n    }\r\n    return new Bound(values, inclusive);\r\n}\r\n/**\r\n * Returns an upper bound of field values that can be used as an ending point\r\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\r\n * upper bound exists.\r\n */\r\nfunction targetGetUpperBound(target, fieldIndex) {\r\n    const values = [];\r\n    let inclusive = true;\r\n    // For each segment, retrieve an upper bound if there is a suitable filter or\r\n    // endAt.\r\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\r\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\r\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\r\n        values.push(segmentBound.value);\r\n        inclusive && (inclusive = segmentBound.inclusive);\r\n    }\r\n    return new Bound(values, inclusive);\r\n}\r\n/**\r\n * Returns the value to use as the lower bound for ascending index segment at\r\n * the provided `fieldPath` (or the upper bound for an descending segment).\r\n */\r\nfunction targetGetAscendingBound(target, fieldPath, bound) {\r\n    let value = MIN_VALUE;\r\n    let inclusive = true;\r\n    // Process all filters to find a value for the current field segment\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\r\n        let filterValue = MIN_VALUE;\r\n        let filterInclusive = true;\r\n        switch (fieldFilter.op) {\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                filterValue = valuesGetLowerBound(fieldFilter.value);\r\n                break;\r\n            case \"==\" /* Operator.EQUAL */:\r\n            case \"in\" /* Operator.IN */:\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n                filterValue = fieldFilter.value;\r\n                break;\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                filterValue = fieldFilter.value;\r\n                filterInclusive = false;\r\n                break;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n            case \"not-in\" /* Operator.NOT_IN */:\r\n                filterValue = MIN_VALUE;\r\n                break;\r\n            // Remaining filters cannot be used as lower bounds.\r\n        }\r\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\r\n            value = filterValue;\r\n            inclusive = filterInclusive;\r\n        }\r\n    }\r\n    // If there is an additional bound, compare the values against the existing\r\n    // range to see if we can narrow the scope.\r\n    if (bound !== null) {\r\n        for (let i = 0; i < target.orderBy.length; ++i) {\r\n            const orderBy = target.orderBy[i];\r\n            if (orderBy.field.isEqual(fieldPath)) {\r\n                const cursorValue = bound.position[i];\r\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\r\n                    value = cursorValue;\r\n                    inclusive = bound.inclusive;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return { value, inclusive };\r\n}\r\n/**\r\n * Returns the value to use as the upper bound for ascending index segment at\r\n * the provided `fieldPath` (or the lower bound for a descending segment).\r\n */\r\nfunction targetGetDescendingBound(target, fieldPath, bound) {\r\n    let value = MAX_VALUE;\r\n    let inclusive = true;\r\n    // Process all filters to find a value for the current field segment\r\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\r\n        let filterValue = MAX_VALUE;\r\n        let filterInclusive = true;\r\n        switch (fieldFilter.op) {\r\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\r\n            case \">\" /* Operator.GREATER_THAN */:\r\n                filterValue = valuesGetUpperBound(fieldFilter.value);\r\n                filterInclusive = false;\r\n                break;\r\n            case \"==\" /* Operator.EQUAL */:\r\n            case \"in\" /* Operator.IN */:\r\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\r\n                filterValue = fieldFilter.value;\r\n                break;\r\n            case \"<\" /* Operator.LESS_THAN */:\r\n                filterValue = fieldFilter.value;\r\n                filterInclusive = false;\r\n                break;\r\n            case \"!=\" /* Operator.NOT_EQUAL */:\r\n            case \"not-in\" /* Operator.NOT_IN */:\r\n                filterValue = MAX_VALUE;\r\n                break;\r\n            // Remaining filters cannot be used as upper bounds.\r\n        }\r\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\r\n            value = filterValue;\r\n            inclusive = filterInclusive;\r\n        }\r\n    }\r\n    // If there is an additional bound, compare the values against the existing\r\n    // range to see if we can narrow the scope.\r\n    if (bound !== null) {\r\n        for (let i = 0; i < target.orderBy.length; ++i) {\r\n            const orderBy = target.orderBy[i];\r\n            if (orderBy.field.isEqual(fieldPath)) {\r\n                const cursorValue = bound.position[i];\r\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\r\n                    value = cursorValue;\r\n                    inclusive = bound.inclusive;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return { value, inclusive };\r\n}\r\n/** Returns the number of segments of a perfect index for this target. */\r\nfunction targetGetSegmentCount(target) {\r\n    let fields = new SortedSet(FieldPath$1.comparator);\r\n    let hasArraySegment = false;\r\n    for (const filter of target.filters) {\r\n        for (const subFilter of filter.getFlattenedFilters()) {\r\n            // __name__ is not an explicit segment of any index, so we don't need to\r\n            // count it.\r\n            if (subFilter.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\r\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\r\n            // though these are on the same field, they should be counted as two\r\n            // separate segments in an index.\r\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n                hasArraySegment = true;\r\n            }\r\n            else {\r\n                fields = fields.add(subFilter.field);\r\n            }\r\n        }\r\n    }\r\n    for (const orderBy of target.orderBy) {\r\n        // __name__ is not an explicit segment of any index, so we don't need to\r\n        // count it.\r\n        if (!orderBy.field.isKeyField()) {\r\n            fields = fields.add(orderBy.field);\r\n        }\r\n    }\r\n    return fields.size + (hasArraySegment ? 1 : 0);\r\n}\r\nfunction targetHasLimit(target) {\r\n    return target.limit !== null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Query encapsulates all the query attributes we support in the SDK. It can\r\n * be run against the LocalStore, as well as be converted to a `Target` to\r\n * query the RemoteStore results.\r\n *\r\n * Visible for testing.\r\n */\r\nclass QueryImpl {\r\n    /**\r\n     * Initializes a Query with a path and optional additional query constraints.\r\n     * Path must currently be empty if this is a collection group query.\r\n     */\r\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.explicitOrderBy = explicitOrderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.limitType = limitType;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedNormalizedOrderBy = null;\r\n        // The corresponding `Target` of this `Query` instance, for use with\r\n        // non-aggregate queries.\r\n        this.memoizedTarget = null;\r\n        // The corresponding `Target` of this `Query` instance, for use with\r\n        // aggregate queries. Unlike targets for non-aggregate queries,\r\n        // aggregate query targets do not contain normalized order-bys, they only\r\n        // contain explicit order-bys.\r\n        this.memoizedAggregateTarget = null;\r\n        if (this.startAt) ;\r\n        if (this.endAt) ;\r\n    }\r\n}\r\n/** Creates a new Query instance with the options provided. */\r\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\r\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\r\n}\r\n/** Creates a new Query for a query that matches all documents at `path` */\r\nfunction newQueryForPath(path) {\r\n    return new QueryImpl(path);\r\n}\r\n/**\r\n * Helper to convert a collection group query into a collection query at a\r\n * specific path. This is used when executing collection group queries, since\r\n * we have to split the query into a set of collection queries at multiple\r\n * paths.\r\n */\r\nfunction asCollectionQueryAtPath(query, path) {\r\n    return new QueryImpl(path, \r\n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\n/**\r\n * Returns true if this query does not specify any query constraints that\r\n * could remove results.\r\n */\r\nfunction queryMatchesAllDocuments(query) {\r\n    return (query.filters.length === 0 &&\r\n        query.limit === null &&\r\n        query.startAt == null &&\r\n        query.endAt == null &&\r\n        (query.explicitOrderBy.length === 0 ||\r\n            (query.explicitOrderBy.length === 1 &&\r\n                query.explicitOrderBy[0].field.isKeyField())));\r\n}\r\n// Returns the sorted set of inequality filter fields used in this query.\r\nfunction getInequalityFilterFields(query) {\r\n    let result = new SortedSet(FieldPath$1.comparator);\r\n    query.filters.forEach((filter) => {\r\n        const subFilters = filter.getFlattenedFilters();\r\n        subFilters.forEach((filter) => {\r\n            if (filter.isInequality()) {\r\n                result = result.add(filter.field);\r\n            }\r\n        });\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Creates a new Query for a collection group query that matches all documents\r\n * within the provided collection group.\r\n */\r\nfunction newQueryForCollectionGroup(collectionId) {\r\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\r\n}\r\n/**\r\n * Returns whether the query matches a single document by path (rather than a\r\n * collection).\r\n */\r\nfunction isDocumentQuery$1(query) {\r\n    return (DocumentKey.isDocumentKey(query.path) &&\r\n        query.collectionGroup === null &&\r\n        query.filters.length === 0);\r\n}\r\n/**\r\n * Returns whether the query matches a collection group rather than a specific\r\n * collection.\r\n */\r\nfunction isCollectionGroupQuery(query) {\r\n    return query.collectionGroup !== null;\r\n}\r\n/**\r\n * Returns the normalized order-by constraint that is used to execute the Query,\r\n * which can be different from the order-by constraints the user provided (e.g.\r\n * the SDK and backend always orders by `__name__`). The normalized order-by\r\n * includes implicit order-bys in addition to the explicit user provided\r\n * order-bys.\r\n */\r\nfunction queryNormalizedOrderBy(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\r\n        queryImpl.memoizedNormalizedOrderBy = [];\r\n        const fieldsNormalized = new Set();\r\n        // Any explicit order by fields should be added as is.\r\n        for (const orderBy of queryImpl.explicitOrderBy) {\r\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\r\n            fieldsNormalized.add(orderBy.field.canonicalString());\r\n        }\r\n        // The order of the implicit ordering always matches the last explicit order by.\r\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\r\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\r\n            : \"asc\" /* Direction.ASCENDING */;\r\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\r\n        // order. When there are multiple inequality filters on the same field, the field should be added\r\n        // only once.\r\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\r\n        // field to be sorted last.\r\n        const inequalityFields = getInequalityFilterFields(queryImpl);\r\n        inequalityFields.forEach(field => {\r\n            if (!fieldsNormalized.has(field.canonicalString()) &&\r\n                !field.isKeyField()) {\r\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\r\n            }\r\n        });\r\n        // Add the document key field to the last if it is not explicitly ordered.\r\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\r\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\r\n        }\r\n    }\r\n    return queryImpl.memoizedNormalizedOrderBy;\r\n}\r\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation.\r\n */\r\nfunction queryToTarget(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (!queryImpl.memoizedTarget) {\r\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\r\n    }\r\n    return queryImpl.memoizedTarget;\r\n}\r\n/**\r\n * Converts this `Query` instance to its corresponding `Target` representation,\r\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\r\n * aggregate query targets do not contain normalized order-bys, they only\r\n * contain explicit order-bys.\r\n */\r\nfunction queryToAggregateTarget(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (!queryImpl.memoizedAggregateTarget) {\r\n        // Do not include implicit order-bys for aggregate queries.\r\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\r\n    }\r\n    return queryImpl.memoizedAggregateTarget;\r\n}\r\nfunction _queryToTarget(queryImpl, orderBys) {\r\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\r\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\r\n    }\r\n    else {\r\n        // Flip the orderBy directions since we want the last results\r\n        orderBys = orderBys.map(orderBy => {\r\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\r\n                ? \"asc\" /* Direction.ASCENDING */\r\n                : \"desc\" /* Direction.DESCENDING */;\r\n            return new OrderBy(orderBy.field, dir);\r\n        });\r\n        // We need to swap the cursors to match the now-flipped query ordering.\r\n        const startAt = queryImpl.endAt\r\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\r\n            : null;\r\n        const endAt = queryImpl.startAt\r\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\r\n            : null;\r\n        // Now return as a LimitType.First query.\r\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\r\n    }\r\n}\r\nfunction queryWithAddedFilter(query, filter) {\r\n    const newFilters = query.filters.concat([filter]);\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithAddedOrderBy(query, orderBy) {\r\n    // TODO(dimond): validate that orderBy does not list the same key twice.\r\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\r\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithLimit(query, limit, limitType) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithStartAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\r\n}\r\nfunction queryWithEndAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\r\n}\r\nfunction queryEquals(left, right) {\r\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\r\n        left.limitType === right.limitType);\r\n}\r\n// TODO(b/29183165): This is used to get a unique string from a query to, for\r\n// example, use as a dictionary key, but the implementation is subject to\r\n// collisions. Make it collision-free.\r\nfunction canonifyQuery(query) {\r\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\r\n}\r\nfunction stringifyQuery(query) {\r\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\r\n}\r\n/** Returns whether `doc` matches the constraints of `query`. */\r\nfunction queryMatches(query, doc) {\r\n    return (doc.isFoundDocument() &&\r\n        queryMatchesPathAndCollectionGroup(query, doc) &&\r\n        queryMatchesOrderBy(query, doc) &&\r\n        queryMatchesFilters(query, doc) &&\r\n        queryMatchesBounds(query, doc));\r\n}\r\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\r\n    const docPath = doc.key.path;\r\n    if (query.collectionGroup !== null) {\r\n        // NOTE: this.path is currently always empty since we don't expose Collection\r\n        // Group queries rooted at a document path yet.\r\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\r\n            query.path.isPrefixOf(docPath));\r\n    }\r\n    else if (DocumentKey.isDocumentKey(query.path)) {\r\n        // exact match for document queries\r\n        return query.path.isEqual(docPath);\r\n    }\r\n    else {\r\n        // shallow ancestor queries by default\r\n        return query.path.isImmediateParentOf(docPath);\r\n    }\r\n}\r\n/**\r\n * A document must have a value for every ordering clause in order to show up\r\n * in the results.\r\n */\r\nfunction queryMatchesOrderBy(query, doc) {\r\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\r\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\r\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\r\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\r\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\r\n    // it's missing the field 'a'.\r\n    for (const orderBy of queryNormalizedOrderBy(query)) {\r\n        // order-by key always matches\r\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction queryMatchesFilters(query, doc) {\r\n    for (const filter of query.filters) {\r\n        if (!filter.matches(doc)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Makes sure a document is within the bounds, if provided. */\r\nfunction queryMatchesBounds(query, doc) {\r\n    if (query.startAt &&\r\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    if (query.endAt &&\r\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns the collection group that this query targets.\r\n *\r\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\r\n * synchronization for query results.\r\n */\r\nfunction queryCollectionGroup(query) {\r\n    return (query.collectionGroup ||\r\n        (query.path.length % 2 === 1\r\n            ? query.path.lastSegment()\r\n            : query.path.get(query.path.length - 2)));\r\n}\r\n/**\r\n * Returns a new comparator function that can be used to compare two documents\r\n * based on the Query's ordering constraint.\r\n */\r\nfunction newQueryComparator(query) {\r\n    return (d1, d2) => {\r\n        let comparedOnKeyField = false;\r\n        for (const orderBy of queryNormalizedOrderBy(query)) {\r\n            const comp = compareDocs(orderBy, d1, d2);\r\n            if (comp !== 0) {\r\n                return comp;\r\n            }\r\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\r\n        }\r\n        return 0;\r\n    };\r\n}\r\nfunction compareDocs(orderBy, d1, d2) {\r\n    const comparison = orderBy.field.isKeyField()\r\n        ? DocumentKey.comparator(d1.key, d2.key)\r\n        : compareDocumentsByField(orderBy.field, d1, d2);\r\n    switch (orderBy.dir) {\r\n        case \"asc\" /* Direction.ASCENDING */:\r\n            return comparison;\r\n        case \"desc\" /* Direction.DESCENDING */:\r\n            return -1 * comparison;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A map implementation that uses objects as keys. Objects must have an\r\n * associated equals function and must be immutable. Entries in the map are\r\n * stored together with the key being produced from the mapKeyFn. This map\r\n * automatically handles collisions of keys.\r\n */\r\nclass ObjectMap {\r\n    constructor(mapKeyFn, equalsFn) {\r\n        this.mapKeyFn = mapKeyFn;\r\n        this.equalsFn = equalsFn;\r\n        /**\r\n         * The inner map for a key/value pair. Due to the possibility of collisions we\r\n         * keep a list of entries that we do a linear search through to find an actual\r\n         * match. Note that collisions should be rare, so we still expect near\r\n         * constant time lookups in practice.\r\n         */\r\n        this.inner = {};\r\n        /** The number of entries stored in the map */\r\n        this.innerSize = 0;\r\n    }\r\n    /** Get a value for this key, or undefined if it does not exist. */\r\n    get(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return undefined;\r\n        }\r\n        for (const [otherKey, value] of matches) {\r\n            if (this.equalsFn(otherKey, key)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    has(key) {\r\n        return this.get(key) !== undefined;\r\n    }\r\n    /** Put this key and value in the map. */\r\n    set(key, value) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            this.inner[id] = [[key, value]];\r\n            this.innerSize++;\r\n            return;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                // This is updating an existing entry and does not increase `innerSize`.\r\n                matches[i] = [key, value];\r\n                return;\r\n            }\r\n        }\r\n        matches.push([key, value]);\r\n        this.innerSize++;\r\n    }\r\n    /**\r\n     * Remove this key from the map. Returns a boolean if anything was deleted.\r\n     */\r\n    delete(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                if (matches.length === 1) {\r\n                    delete this.inner[id];\r\n                }\r\n                else {\r\n                    matches.splice(i, 1);\r\n                }\r\n                this.innerSize--;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    forEach(fn) {\r\n        forEach(this.inner, (_, entries) => {\r\n            for (const [k, v] of entries) {\r\n                fn(k, v);\r\n            }\r\n        });\r\n    }\r\n    isEmpty() {\r\n        return isEmpty(this.inner);\r\n    }\r\n    size() {\r\n        return this.innerSize;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction mutableDocumentMap() {\r\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentMap(...docs) {\r\n    let map = EMPTY_DOCUMENT_MAP;\r\n    for (const doc of docs) {\r\n        map = map.insert(doc.key, doc);\r\n    }\r\n    return map;\r\n}\r\nfunction newOverlayedDocumentMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\r\n    let documents = EMPTY_DOCUMENT_MAP;\r\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\r\n    return documents;\r\n}\r\nfunction newOverlayMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction newMutationMap() {\r\n    return newDocumentKeyMap();\r\n}\r\nfunction newDocumentKeyMap() {\r\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n}\r\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentVersionMap() {\r\n    return EMPTY_DOCUMENT_VERSION_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\r\nfunction documentKeySet(...keys) {\r\n    let set = EMPTY_DOCUMENT_KEY_SET;\r\n    for (const key of keys) {\r\n        set = set.add(key);\r\n    }\r\n    return set;\r\n}\r\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\r\nfunction targetIdSet() {\r\n    return EMPTY_TARGET_ID_SET;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an DoubleValue for `value` that is encoded based the serializer's\r\n * `useProto3Json` setting.\r\n */\r\nfunction toDouble(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        if (isNaN(value)) {\r\n            return { doubleValue: 'NaN' };\r\n        }\r\n        else if (value === Infinity) {\r\n            return { doubleValue: 'Infinity' };\r\n        }\r\n        else if (value === -Infinity) {\r\n            return { doubleValue: '-Infinity' };\r\n        }\r\n    }\r\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\r\n}\r\n/**\r\n * Returns an IntegerValue for `value`.\r\n */\r\nfunction toInteger(value) {\r\n    return { integerValue: '' + value };\r\n}\r\n/**\r\n * Returns a value for a number that's appropriate to put into a proto.\r\n * The return value is an IntegerValue if it can safely represent the value,\r\n * otherwise a DoubleValue is returned.\r\n */\r\nfunction toNumber(serializer, value) {\r\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used to represent a field transform on a mutation. */\r\nclass TransformOperation {\r\n    constructor() {\r\n        // Make sure that the structural type of `TransformOperation` is unique.\r\n        // See https://github.com/microsoft/TypeScript/issues/5451\r\n        this._ = undefined;\r\n    }\r\n}\r\n/**\r\n * Computes the local transform result against the provided `previousValue`,\r\n * optionally using the provided localWriteTime.\r\n */\r\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return serverTimestamp$1(localWriteTime, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    else {\r\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\r\n    }\r\n}\r\n/**\r\n * Computes a final transform result after the transform has been acknowledged\r\n * by the server, potentially using the server-provided transformResult.\r\n */\r\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\r\n    // The server just sends null as the transform result for array operations,\r\n    // so we have to calculate a result the same as we do for local\r\n    // applications.\r\n    if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    return transformResult;\r\n}\r\n/**\r\n * If this transform operation is not idempotent, returns the base value to\r\n * persist for this transform. If a base value is returned, the transform\r\n * operation is always applied to this base value, even if document has\r\n * already been updated.\r\n *\r\n * Base values provide consistent behavior for non-idempotent transforms and\r\n * allow us to return the same latency-compensated value even if the backend\r\n * has already applied the transform operation. The base value is null for\r\n * idempotent transforms, as they can be re-played even if the backend has\r\n * already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent transforms.\r\n */\r\nfunction computeTransformOperationBaseValue(transform, previousValue) {\r\n    if (transform instanceof NumericIncrementTransformOperation) {\r\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\r\n    }\r\n    return null;\r\n}\r\nfunction transformOperationEquals(left, right) {\r\n    if (left instanceof ArrayUnionTransformOperation &&\r\n        right instanceof ArrayUnionTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof ArrayRemoveTransformOperation &&\r\n        right instanceof ArrayRemoveTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof NumericIncrementTransformOperation &&\r\n        right instanceof NumericIncrementTransformOperation) {\r\n        return valueEquals(left.operand, right.operand);\r\n    }\r\n    return (left instanceof ServerTimestampTransform &&\r\n        right instanceof ServerTimestampTransform);\r\n}\r\n/** Transforms a value into a server-generated timestamp. */\r\nclass ServerTimestampTransform extends TransformOperation {\r\n}\r\n/** Transforms an array value via a union operation. */\r\nclass ArrayUnionTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\r\n    const values = coercedFieldValuesArray(previousValue);\r\n    for (const toUnion of transform.elements) {\r\n        if (!values.some(element => valueEquals(element, toUnion))) {\r\n            values.push(toUnion);\r\n        }\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/** Transforms an array value via a remove operation. */\r\nclass ArrayRemoveTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\r\n    let values = coercedFieldValuesArray(previousValue);\r\n    for (const toRemove of transform.elements) {\r\n        values = values.filter(element => !valueEquals(element, toRemove));\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\r\n * transforms. Converts all field values to integers or doubles, but unlike the\r\n * backend does not cap integer values at 2^63. Instead, JavaScript number\r\n * arithmetic is used and precision loss can occur for values greater than 2^53.\r\n */\r\nclass NumericIncrementTransformOperation extends TransformOperation {\r\n    constructor(serializer, operand) {\r\n        super();\r\n        this.serializer = serializer;\r\n        this.operand = operand;\r\n    }\r\n}\r\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\r\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\r\n    // precision and resolves overflows by reducing precision, we do not\r\n    // manually cap overflows at 2^63.\r\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\r\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\r\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\r\n        return toInteger(sum);\r\n    }\r\n    else {\r\n        return toDouble(transform.serializer, sum);\r\n    }\r\n}\r\nfunction asNumber(value) {\r\n    return normalizeNumber(value.integerValue || value.doubleValue);\r\n}\r\nfunction coercedFieldValuesArray(value) {\r\n    return isArray(value) && value.arrayValue.values\r\n        ? value.arrayValue.values.slice()\r\n        : [];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A field path and the TransformOperation to perform upon it. */\r\nclass FieldTransform {\r\n    constructor(field, transform) {\r\n        this.field = field;\r\n        this.transform = transform;\r\n    }\r\n}\r\nfunction fieldTransformEquals(left, right) {\r\n    return (left.field.isEqual(right.field) &&\r\n        transformOperationEquals(left.transform, right.transform));\r\n}\r\nfunction fieldTransformsAreEqual(left, right) {\r\n    if (left === undefined && right === undefined) {\r\n        return true;\r\n    }\r\n    if (left && right) {\r\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\r\n    }\r\n    return false;\r\n}\r\n/** The result of successfully applying a mutation to the backend. */\r\nclass MutationResult {\r\n    constructor(\r\n    /**\r\n     * The version at which the mutation was committed:\r\n     *\r\n     * - For most operations, this is the updateTime in the WriteResult.\r\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\r\n     *   not stored and have no updateTime).\r\n     *\r\n     * Note that these versions can be different: No-op writes will not change\r\n     * the updateTime even though the commitTime advances.\r\n     */\r\n    version, \r\n    /**\r\n     * The resulting fields returned from the backend after a mutation\r\n     * containing field transforms has been committed. Contains one FieldValue\r\n     * for each FieldTransform that was in the mutation.\r\n     *\r\n     * Will be empty if the mutation did not contain any field transforms.\r\n     */\r\n    transformResults) {\r\n        this.version = version;\r\n        this.transformResults = transformResults;\r\n    }\r\n}\r\n/**\r\n * Encodes a precondition for a mutation. This follows the model that the\r\n * backend accepts with the special case of an explicit \"empty\" precondition\r\n * (meaning no precondition).\r\n */\r\nclass Precondition {\r\n    constructor(updateTime, exists) {\r\n        this.updateTime = updateTime;\r\n        this.exists = exists;\r\n    }\r\n    /** Creates a new empty Precondition. */\r\n    static none() {\r\n        return new Precondition();\r\n    }\r\n    /** Creates a new Precondition with an exists flag. */\r\n    static exists(exists) {\r\n        return new Precondition(undefined, exists);\r\n    }\r\n    /** Creates a new Precondition based on a version a document exists at. */\r\n    static updateTime(version) {\r\n        return new Precondition(version);\r\n    }\r\n    /** Returns whether this Precondition is empty. */\r\n    get isNone() {\r\n        return this.updateTime === undefined && this.exists === undefined;\r\n    }\r\n    isEqual(other) {\r\n        return (this.exists === other.exists &&\r\n            (this.updateTime\r\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\r\n                : !other.updateTime));\r\n    }\r\n}\r\n/** Returns true if the preconditions is valid for the given document. */\r\nfunction preconditionIsValidForDocument(precondition, document) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return (document.isFoundDocument() &&\r\n            document.version.isEqual(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return precondition.exists === document.isFoundDocument();\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n/**\r\n * A mutation describes a self-contained change to a document. Mutations can\r\n * create, replace, delete, and update subsets of documents.\r\n *\r\n * Mutations not only act on the value of the document but also its version.\r\n *\r\n * For local mutations (mutations that haven't been committed yet), we preserve\r\n * the existing version for Set and Patch mutations. For Delete mutations, we\r\n * reset the version to 0.\r\n *\r\n * Here's the expected transition table.\r\n *\r\n * MUTATION           APPLIED TO            RESULTS IN\r\n *\r\n * SetMutation        Document(v3)          Document(v3)\r\n * SetMutation        NoDocument(v3)        Document(v0)\r\n * SetMutation        InvalidDocument(v0)   Document(v0)\r\n * PatchMutation      Document(v3)          Document(v3)\r\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\r\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\r\n * DeleteMutation     Document(v3)          NoDocument(v0)\r\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\r\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\r\n *\r\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\r\n * the resulting version for Set and Patch mutations. As deletes have no\r\n * explicit update time, we use the commitTime of the WriteResponse for\r\n * Delete mutations.\r\n *\r\n * If a mutation is acknowledged by the backend but fails the precondition check\r\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\r\n * the updated version.\r\n *\r\n * Field transforms are used only with Patch and Set Mutations. We use the\r\n * `updateTransforms` message to store transforms, rather than the `transforms`s\r\n * messages.\r\n *\r\n * ## Subclassing Notes\r\n *\r\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\r\n * applyToLocalView() to implement the actual behavior of applying the mutation\r\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\r\n * example).\r\n */\r\nclass Mutation {\r\n}\r\n/**\r\n * A utility method to calculate a `Mutation` representing the overlay from the\r\n * final state of the document, and a `FieldMask` representing the fields that\r\n * are mutated by the local mutations.\r\n */\r\nfunction calculateOverlayMutation(doc, mask) {\r\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\r\n        return null;\r\n    }\r\n    // mask is null when sets or deletes are applied to the current document.\r\n    if (mask === null) {\r\n        if (doc.isNoDocument()) {\r\n            return new DeleteMutation(doc.key, Precondition.none());\r\n        }\r\n        else {\r\n            return new SetMutation(doc.key, doc.data, Precondition.none());\r\n        }\r\n    }\r\n    else {\r\n        const docValue = doc.data;\r\n        const patchValue = ObjectValue.empty();\r\n        let maskSet = new SortedSet(FieldPath$1.comparator);\r\n        for (let path of mask.fields) {\r\n            if (!maskSet.has(path)) {\r\n                let value = docValue.field(path);\r\n                // If we are deleting a nested field, we take the immediate parent as\r\n                // the mask used to construct the resulting mutation.\r\n                // Justification: Nested fields can create parent fields implicitly. If\r\n                // only a leaf entry is deleted in later mutations, the parent field\r\n                // should still remain, but we may have lost this information.\r\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\r\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\r\n                // has the correct result, `foo` is not in `mask`, and the resulting\r\n                // mutation would miss `foo`.\r\n                if (value === null && path.length > 1) {\r\n                    path = path.popLast();\r\n                    value = docValue.field(path);\r\n                }\r\n                if (value === null) {\r\n                    patchValue.delete(path);\r\n                }\r\n                else {\r\n                    patchValue.set(path, value);\r\n                }\r\n                maskSet = maskSet.add(path);\r\n            }\r\n        }\r\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\r\n    }\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing a\r\n * new remote document. If the input document doesn't match the expected state\r\n * (e.g. it is invalid or outdated), the document type may transition to\r\n * unknown.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param mutationResult - The result of applying the mutation from the backend.\r\n */\r\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (mutation instanceof SetMutation) {\r\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else {\r\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing\r\n * the new local view of a document. If the input document doesn't match the\r\n * expected state, the document is not modified.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param previousMask - The fields that have been updated before applying this mutation.\r\n * @param localWriteTime - A timestamp indicating the local write time of the\r\n *     batch this mutation is a part of.\r\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\r\n */\r\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (mutation instanceof SetMutation) {\r\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\r\n    }\r\n    else {\r\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\r\n    }\r\n}\r\n/**\r\n * If this mutation is not idempotent, returns the base value to persist with\r\n * this mutation. If a base value is returned, the mutation is always applied\r\n * to this base value, even if document has already been updated.\r\n *\r\n * The base value is a sparse object that consists of only the document\r\n * fields for which this mutation contains a non-idempotent transformation\r\n * (e.g. a numeric increment). The provided value guarantees consistent\r\n * behavior for non-idempotent transforms and allow us to return the same\r\n * latency-compensated value even if the backend has already applied the\r\n * mutation. The base value is null for idempotent mutations, as they can be\r\n * re-played even if the backend has already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent mutations.\r\n */\r\nfunction mutationExtractBaseValue(mutation, document) {\r\n    let baseObject = null;\r\n    for (const fieldTransform of mutation.fieldTransforms) {\r\n        const existingValue = document.data.field(fieldTransform.field);\r\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\r\n        if (coercedValue != null) {\r\n            if (baseObject === null) {\r\n                baseObject = ObjectValue.empty();\r\n            }\r\n            baseObject.set(fieldTransform.field, coercedValue);\r\n        }\r\n    }\r\n    return baseObject ? baseObject : null;\r\n}\r\nfunction mutationEquals(left, right) {\r\n    if (left.type !== right.type) {\r\n        return false;\r\n    }\r\n    if (!left.key.isEqual(right.key)) {\r\n        return false;\r\n    }\r\n    if (!left.precondition.isEqual(right.precondition)) {\r\n        return false;\r\n    }\r\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\r\n        return false;\r\n    }\r\n    if (left.type === 0 /* MutationType.Set */) {\r\n        return left.value.isEqual(right.value);\r\n    }\r\n    if (left.type === 1 /* MutationType.Patch */) {\r\n        return (left.data.isEqual(right.data) &&\r\n            left.fieldMask.isEqual(right.fieldMask));\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * A mutation that creates or replaces the document at the given key with the\r\n * object value contents.\r\n */\r\nclass SetMutation extends Mutation {\r\n    constructor(key, value, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.value = value;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 0 /* MutationType.Set */;\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\r\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\r\n    // remote document the server has accepted the mutation so the precondition\r\n    // must have held.\r\n    const newData = mutation.value.clone();\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // The mutation failed to apply (e.g. a document ID created with add()\r\n        // caused a name collision).\r\n        return previousMask;\r\n    }\r\n    const newData = mutation.value.clone();\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(document.version, newData)\r\n        .setHasLocalMutations();\r\n    return null; // SetMutation overwrites all fields.\r\n}\r\n/**\r\n * A mutation that modifies fields of the document at the given key with the\r\n * given values. The values are applied through a field mask:\r\n *\r\n *  * When a field is in both the mask and the values, the corresponding field\r\n *    is updated.\r\n *  * When a field is in neither the mask nor the values, the corresponding\r\n *    field is unmodified.\r\n *  * When a field is in the mask but not in the values, the corresponding field\r\n *    is deleted.\r\n *  * When a field is not in the mask but is in the values, the values map is\r\n *    ignored.\r\n */\r\nclass PatchMutation extends Mutation {\r\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 1 /* MutationType.Patch */;\r\n    }\r\n    getFieldMask() {\r\n        return this.fieldMask;\r\n    }\r\n}\r\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // Since the mutation was not rejected, we know that the precondition\r\n        // matched on the backend. We therefore must not have the expected version\r\n        // of the document in our cache and convert to an UnknownDocument with a\r\n        // known updateTime.\r\n        document.convertToUnknownDocument(mutationResult.version);\r\n        return;\r\n    }\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        return previousMask;\r\n    }\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(document.version, newData)\r\n        .setHasLocalMutations();\r\n    if (previousMask === null) {\r\n        return null;\r\n    }\r\n    return previousMask\r\n        .unionWith(mutation.fieldMask.fields)\r\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\r\n}\r\n/**\r\n * Returns a FieldPath/Value map with the content of the PatchMutation.\r\n */\r\nfunction getPatch(mutation) {\r\n    const result = new Map();\r\n    mutation.fieldMask.fields.forEach(fieldPath => {\r\n        if (!fieldPath.isEmpty()) {\r\n            const newValue = mutation.data.field(fieldPath);\r\n            result.set(fieldPath, newValue);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use after a mutation\r\n * containing transforms has been acknowledged by the server.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param mutableDocument - The current state of the document after applying all\r\n * previous mutations.\r\n * @param serverTransformResults - The transform results received by the server.\r\n * @returns The transform results list.\r\n */\r\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\r\n    const transformResults = new Map();\r\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\r\n    for (let i = 0; i < serverTransformResults.length; i++) {\r\n        const fieldTransform = fieldTransforms[i];\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\r\n    }\r\n    return transformResults;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use when applying a\r\n * transform locally.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param localWriteTime - The local time of the mutation (used to\r\n *     generate ServerTimestampValues).\r\n * @param mutableDocument - The document to apply transforms on.\r\n * @returns The transform results list.\r\n */\r\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\r\n    const transformResults = new Map();\r\n    for (const fieldTransform of fieldTransforms) {\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\r\n    }\r\n    return transformResults;\r\n}\r\n/** A mutation that deletes the document at the given key. */\r\nclass DeleteMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 2 /* MutationType.Delete */;\r\n        this.fieldTransforms = [];\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\r\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\r\n    // document the server has accepted the mutation so the precondition must\r\n    // have held.\r\n    document\r\n        .convertToNoDocument(mutationResult.version)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\r\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        document.convertToNoDocument(document.version).setHasLocalMutations();\r\n        return null;\r\n    }\r\n    return previousMask;\r\n}\r\n/**\r\n * A mutation that verifies the existence of the document at the given key with\r\n * the provided precondition.\r\n *\r\n * The `verify` operation is only used in Transactions, and this class serves\r\n * primarily to facilitate serialization into protos.\r\n */\r\nclass VerifyMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 3 /* MutationType.Verify */;\r\n        this.fieldTransforms = [];\r\n    }\r\n    getFieldMask() {\r\n        return null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A batch of mutations that will be sent as one unit to the backend.\r\n */\r\nclass MutationBatch {\r\n    /**\r\n     * @param batchId - The unique ID of this mutation batch.\r\n     * @param localWriteTime - The original write time of this mutation.\r\n     * @param baseMutations - Mutations that are used to populate the base\r\n     * values when this mutation is applied locally. This can be used to locally\r\n     * overwrite values that are persisted in the remote document cache. Base\r\n     * mutations are never sent to the backend.\r\n     * @param mutations - The user-provided mutations in this mutation batch.\r\n     * User-provided mutations are applied both locally and remotely on the\r\n     * backend.\r\n     */\r\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\r\n        this.batchId = batchId;\r\n        this.localWriteTime = localWriteTime;\r\n        this.baseMutations = baseMutations;\r\n        this.mutations = mutations;\r\n    }\r\n    /**\r\n     * Applies all the mutations in this MutationBatch to the specified document\r\n     * to compute the state of the remote document\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     * @param batchResult - The result of applying the MutationBatch to the\r\n     * backend.\r\n     */\r\n    applyToRemoteDocument(document, batchResult) {\r\n        const mutationResults = batchResult.mutationResults;\r\n        for (let i = 0; i < this.mutations.length; i++) {\r\n            const mutation = this.mutations[i];\r\n            if (mutation.key.isEqual(document.key)) {\r\n                const mutationResult = mutationResults[i];\r\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes the local view of a document given all the mutations in this\r\n     * batch.\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\r\n     * @returns A `FieldMask` representing all the fields that are mutated.\r\n     */\r\n    applyToLocalView(document, mutatedFields) {\r\n        // First, apply the base state. This allows us to apply non-idempotent\r\n        // transform against a consistent set of values.\r\n        for (const mutation of this.baseMutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\r\n            }\r\n        }\r\n        // Second, apply all user-provided mutations.\r\n        for (const mutation of this.mutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\r\n            }\r\n        }\r\n        return mutatedFields;\r\n    }\r\n    /**\r\n     * Computes the local view for all provided documents given the mutations in\r\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\r\n     * replace all the mutation applications.\r\n     */\r\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\r\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\r\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\r\n        // to O(n).\r\n        const overlays = newMutationMap();\r\n        this.mutations.forEach(m => {\r\n            const overlayedDocument = documentMap.get(m.key);\r\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\r\n            // and we should remove this cast.\r\n            const mutableDocument = overlayedDocument.overlayedDocument;\r\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\r\n            // Set mutatedFields to null if the document is only from local mutations.\r\n            // This creates a Set or Delete mutation, instead of trying to create a\r\n            // patch mutation as the overlay.\r\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\r\n                ? null\r\n                : mutatedFields;\r\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\r\n            if (overlay !== null) {\r\n                overlays.set(m.key, overlay);\r\n            }\r\n            if (!mutableDocument.isValidDocument()) {\r\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\r\n            }\r\n        });\r\n        return overlays;\r\n    }\r\n    keys() {\r\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    }\r\n    isEqual(other) {\r\n        return (this.batchId === other.batchId &&\r\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\r\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\r\n    }\r\n}\r\n/** The result of applying a mutation batch to the backend. */\r\nclass MutationBatchResult {\r\n    constructor(batch, commitVersion, mutationResults, \r\n    /**\r\n     * A pre-computed mapping from each mutated document to the resulting\r\n     * version.\r\n     */\r\n    docVersions) {\r\n        this.batch = batch;\r\n        this.commitVersion = commitVersion;\r\n        this.mutationResults = mutationResults;\r\n        this.docVersions = docVersions;\r\n    }\r\n    /**\r\n     * Creates a new MutationBatchResult for the given batch and results. There\r\n     * must be one result for each mutation in the batch. This static factory\r\n     * caches a document=&gt;version mapping (docVersions).\r\n     */\r\n    static from(batch, commitVersion, results) {\r\n        hardAssert(batch.mutations.length === results.length);\r\n        let versionMap = documentVersionMap();\r\n        const mutations = batch.mutations;\r\n        for (let i = 0; i < mutations.length; i++) {\r\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\r\n        }\r\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Representation of an overlay computed by Firestore.\r\n *\r\n * Holds information about a mutation and the largest batch id in Firestore when\r\n * the mutation was created.\r\n */\r\nclass Overlay {\r\n    constructor(largestBatchId, mutation) {\r\n        this.largestBatchId = largestBatchId;\r\n        this.mutation = mutation;\r\n    }\r\n    getKey() {\r\n        return this.mutation.key;\r\n    }\r\n    isEqual(other) {\r\n        return other !== null && this.mutation === other.mutation;\r\n    }\r\n    toString() {\r\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ExistenceFilter {\r\n    constructor(count, unchangedNames) {\r\n        this.count = count;\r\n        this.unchangedNames = unchangedNames;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Error Codes describing the different ways GRPC can fail. These are copied\r\n * directly from GRPC's sources here:\r\n *\r\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n *\r\n * Important! The names of these identifiers matter because the string forms\r\n * are used for reverse lookups from the webchannel stream. Do NOT change the\r\n * names of these identifiers or change this into a const enum.\r\n */\r\nvar RpcCode;\r\n(function (RpcCode) {\r\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\r\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\r\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\r\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\r\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\r\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\r\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\r\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\r\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\r\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\r\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\r\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\r\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\r\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\r\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\r\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\r\n})(RpcCode || (RpcCode = {}));\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a non-write operation.\r\n *\r\n * See isPermanentWriteError for classifying write errors.\r\n */\r\nfunction isPermanentError(code) {\r\n    switch (code) {\r\n        case Code.OK:\r\n            return fail();\r\n        case Code.CANCELLED:\r\n        case Code.UNKNOWN:\r\n        case Code.DEADLINE_EXCEEDED:\r\n        case Code.RESOURCE_EXHAUSTED:\r\n        case Code.INTERNAL:\r\n        case Code.UNAVAILABLE:\r\n        // Unauthenticated means something went wrong with our token and we need\r\n        // to retry with new credentials which will happen automatically.\r\n        case Code.UNAUTHENTICATED:\r\n            return false;\r\n        case Code.INVALID_ARGUMENT:\r\n        case Code.NOT_FOUND:\r\n        case Code.ALREADY_EXISTS:\r\n        case Code.PERMISSION_DENIED:\r\n        case Code.FAILED_PRECONDITION:\r\n        // Aborted might be retried in some scenarios, but that is dependant on\r\n        // the context and should handled individually by the calling code.\r\n        // See https://cloud.google.com/apis/design/errors.\r\n        case Code.ABORTED:\r\n        case Code.OUT_OF_RANGE:\r\n        case Code.UNIMPLEMENTED:\r\n        case Code.DATA_LOSS:\r\n            return true;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a write operation.\r\n *\r\n * Write operations must be handled specially because as of b/119437764, ABORTED\r\n * errors on the write stream should be retried too (even though ABORTED errors\r\n * are not generally retryable).\r\n *\r\n * Note that during the initial handshake on the write stream an ABORTED error\r\n * signals that we should discard our stream token (i.e. it is permanent). This\r\n * means a handshake error should be classified with isPermanentError, above.\r\n */\r\nfunction isPermanentWriteError(code) {\r\n    return isPermanentError(code) && code !== Code.ABORTED;\r\n}\r\n/**\r\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\r\n * are not the same as HTTP status codes.\r\n *\r\n * @returns The Code equivalent to the given GRPC status code. Fails if there\r\n *     is no match.\r\n */\r\nfunction mapCodeFromRpcCode(code) {\r\n    if (code === undefined) {\r\n        // This shouldn't normally happen, but in certain error cases (like trying\r\n        // to send invalid proto messages) we may get an error with no GRPC code.\r\n        logError('GRPC error has no .code');\r\n        return Code.UNKNOWN;\r\n    }\r\n    switch (code) {\r\n        case RpcCode.OK:\r\n            return Code.OK;\r\n        case RpcCode.CANCELLED:\r\n            return Code.CANCELLED;\r\n        case RpcCode.UNKNOWN:\r\n            return Code.UNKNOWN;\r\n        case RpcCode.DEADLINE_EXCEEDED:\r\n            return Code.DEADLINE_EXCEEDED;\r\n        case RpcCode.RESOURCE_EXHAUSTED:\r\n            return Code.RESOURCE_EXHAUSTED;\r\n        case RpcCode.INTERNAL:\r\n            return Code.INTERNAL;\r\n        case RpcCode.UNAVAILABLE:\r\n            return Code.UNAVAILABLE;\r\n        case RpcCode.UNAUTHENTICATED:\r\n            return Code.UNAUTHENTICATED;\r\n        case RpcCode.INVALID_ARGUMENT:\r\n            return Code.INVALID_ARGUMENT;\r\n        case RpcCode.NOT_FOUND:\r\n            return Code.NOT_FOUND;\r\n        case RpcCode.ALREADY_EXISTS:\r\n            return Code.ALREADY_EXISTS;\r\n        case RpcCode.PERMISSION_DENIED:\r\n            return Code.PERMISSION_DENIED;\r\n        case RpcCode.FAILED_PRECONDITION:\r\n            return Code.FAILED_PRECONDITION;\r\n        case RpcCode.ABORTED:\r\n            return Code.ABORTED;\r\n        case RpcCode.OUT_OF_RANGE:\r\n            return Code.OUT_OF_RANGE;\r\n        case RpcCode.UNIMPLEMENTED:\r\n            return Code.UNIMPLEMENTED;\r\n        case RpcCode.DATA_LOSS:\r\n            return Code.DATA_LOSS;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass Base64DecodeError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'Base64DecodeError';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The global, singleton instance of TestingHooksSpi.\r\n *\r\n * This variable will be `null` in all cases _except_ when running from\r\n * integration tests that have registered callbacks to be notified of events\r\n * that happen during the test execution.\r\n */\r\nlet testingHooksSpi = null;\r\n/**\r\n * Sets the value of the `testingHooksSpi` object.\r\n * @param instance the instance to set.\r\n */\r\nfunction setTestingHooksSpi(instance) {\r\n    if (testingHooksSpi) {\r\n        throw new Error('a TestingHooksSpi instance is already set');\r\n    }\r\n    testingHooksSpi = instance;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An instance of the Platform's 'TextEncoder' implementation.\r\n */\r\nfunction newTextEncoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\r\n}\r\n/**\r\n * An instance of the Platform's 'TextDecoder' implementation.\r\n */\r\nfunction newTextDecoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer([0xffffffff, 0xffffffff], 0);\r\n// Hash a string using md5 hashing algorithm.\r\nfunction getMd5HashValue(value) {\r\n    const encodedValue = newTextEncoder().encode(value);\r\n    const md5 = new _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Md5();\r\n    md5.update(encodedValue);\r\n    return new Uint8Array(md5.digest());\r\n}\r\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\r\n// 2s complement using little endian.\r\nfunction get64BitUints(Bytes) {\r\n    const dataView = new DataView(Bytes.buffer);\r\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\r\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\r\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\r\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\r\n    const integer1 = new _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk1, chunk2], 0);\r\n    const integer2 = new _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk3, chunk4], 0);\r\n    return [integer1, integer2];\r\n}\r\nclass BloomFilter {\r\n    constructor(bitmap, padding, hashCount) {\r\n        this.bitmap = bitmap;\r\n        this.padding = padding;\r\n        this.hashCount = hashCount;\r\n        if (padding < 0 || padding >= 8) {\r\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\r\n        }\r\n        if (hashCount < 0) {\r\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\r\n        }\r\n        if (bitmap.length > 0 && this.hashCount === 0) {\r\n            // Only empty bloom filter can have 0 hash count.\r\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\r\n        }\r\n        if (bitmap.length === 0 && padding !== 0) {\r\n            // Empty bloom filter should have 0 padding.\r\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\r\n        }\r\n        this.bitCount = bitmap.length * 8 - padding;\r\n        // Set the bit count in Integer to avoid repetition in mightContain().\r\n        this.bitCountInInteger = _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(this.bitCount);\r\n    }\r\n    // Calculate the ith hash value based on the hashed 64bit integers,\r\n    // and calculate its corresponding bit index in the bitmap to be checked.\r\n    getBitIndex(num1, num2, hashIndex) {\r\n        // Calculate hashed value h(i) = h1 + (i * h2).\r\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(hashIndex)));\r\n        // Wrap if hash value overflow 64bit.\r\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\r\n            hashValue = new _firebase_webchannel_wrapper__WEBPACK_IMPORTED_MODULE_6__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\r\n        }\r\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\r\n    }\r\n    // Return whether the bit on the given index in the bitmap is set to 1.\r\n    isBitSet(index) {\r\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\r\n        const byte = this.bitmap[Math.floor(index / 8)];\r\n        const offset = index % 8;\r\n        return (byte & (0x01 << offset)) !== 0;\r\n    }\r\n    mightContain(value) {\r\n        // Empty bitmap should always return false on membership check.\r\n        if (this.bitCount === 0) {\r\n            return false;\r\n        }\r\n        const md5HashedValue = getMd5HashValue(value);\r\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\r\n        for (let i = 0; i < this.hashCount; i++) {\r\n            const index = this.getBitIndex(hash1, hash2, i);\r\n            if (!this.isBitSet(index)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /** Create bloom filter for testing purposes only. */\r\n    static create(bitCount, hashCount, contains) {\r\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\r\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\r\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\r\n        contains.forEach(item => bloomFilter.insert(item));\r\n        return bloomFilter;\r\n    }\r\n    insert(value) {\r\n        if (this.bitCount === 0) {\r\n            return;\r\n        }\r\n        const md5HashedValue = getMd5HashValue(value);\r\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\r\n        for (let i = 0; i < this.hashCount; i++) {\r\n            const index = this.getBitIndex(hash1, hash2, i);\r\n            this.setBit(index);\r\n        }\r\n    }\r\n    setBit(index) {\r\n        const indexOfByte = Math.floor(index / 8);\r\n        const offset = index % 8;\r\n        this.bitmap[indexOfByte] |= 0x01 << offset;\r\n    }\r\n}\r\nclass BloomFilterError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'BloomFilterError';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An event from the RemoteStore. It is split into targetChanges (changes to the\r\n * state or the set of documents in our watched targets) and documentUpdates\r\n * (changes to the actual documents).\r\n */\r\nclass RemoteEvent {\r\n    constructor(\r\n    /**\r\n     * The snapshot version this event brings us up to, or MIN if not set.\r\n     */\r\n    snapshotVersion, \r\n    /**\r\n     * A map from target to changes to the target. See TargetChange.\r\n     */\r\n    targetChanges, \r\n    /**\r\n     * A map of targets that is known to be inconsistent, and the purpose for\r\n     * re-listening. Listens for these targets should be re-established without\r\n     * resume tokens.\r\n     */\r\n    targetMismatches, \r\n    /**\r\n     * A set of which documents have changed or been deleted, along with the\r\n     * doc's new values (if not deleted).\r\n     */\r\n    documentUpdates, \r\n    /**\r\n     * A set of which document updates are due only to limbo resolution targets.\r\n     */\r\n    resolvedLimboDocuments) {\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.targetChanges = targetChanges;\r\n        this.targetMismatches = targetMismatches;\r\n        this.documentUpdates = documentUpdates;\r\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\r\n    }\r\n    /**\r\n     * HACK: Views require RemoteEvents in order to determine whether the view is\r\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\r\n     * used to create a synthesized RemoteEvent that can be used to apply a\r\n     * CURRENT status change to a View, for queries executed in a different tab.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\r\n        const targetChanges = new Map();\r\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\r\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\r\n    }\r\n}\r\n/**\r\n * A TargetChange specifies the set of changes for a specific target as part of\r\n * a RemoteEvent. These changes track which documents are added, modified or\r\n * removed, as well as the target's resume token and whether the target is\r\n * marked CURRENT.\r\n * The actual changes *to* documents are not part of the TargetChange since\r\n * documents may be part of multiple targets.\r\n */\r\nclass TargetChange {\r\n    constructor(\r\n    /**\r\n     * An opaque, server-assigned token that allows watching a query to be resumed\r\n     * after disconnecting without retransmitting all the data that matches the\r\n     * query. The resume token essentially identifies a point in time from which\r\n     * the server should resume sending results.\r\n     */\r\n    resumeToken, \r\n    /**\r\n     * The \"current\" (synced) status of this target. Note that \"current\"\r\n     * has special meaning in the RPC protocol that implies that a target is\r\n     * both up-to-date and consistent with the rest of the watch stream.\r\n     */\r\n    current, \r\n    /**\r\n     * The set of documents that were newly assigned to this target as part of\r\n     * this remote event.\r\n     */\r\n    addedDocuments, \r\n    /**\r\n     * The set of documents that were already assigned to this target but received\r\n     * an update during this remote event.\r\n     */\r\n    modifiedDocuments, \r\n    /**\r\n     * The set of documents that were removed from this target as part of this\r\n     * remote event.\r\n     */\r\n    removedDocuments) {\r\n        this.resumeToken = resumeToken;\r\n        this.current = current;\r\n        this.addedDocuments = addedDocuments;\r\n        this.modifiedDocuments = modifiedDocuments;\r\n        this.removedDocuments = removedDocuments;\r\n    }\r\n    /**\r\n     * This method is used to create a synthesized TargetChanges that can be used to\r\n     * apply a CURRENT status change to a View (for queries executed in a different\r\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\r\n     */\r\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\r\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a changed document and a list of target ids to which this change\r\n * applies.\r\n *\r\n * If document has been deleted NoDocument will be provided.\r\n */\r\nclass DocumentWatchChange {\r\n    constructor(\r\n    /** The new document applies to all of these targets. */\r\n    updatedTargetIds, \r\n    /** The new document is removed from all of these targets. */\r\n    removedTargetIds, \r\n    /** The key of the document for this change. */\r\n    key, \r\n    /**\r\n     * The new document or NoDocument if it was deleted. Is null if the\r\n     * document went out of view without the server sending a new document.\r\n     */\r\n    newDoc) {\r\n        this.updatedTargetIds = updatedTargetIds;\r\n        this.removedTargetIds = removedTargetIds;\r\n        this.key = key;\r\n        this.newDoc = newDoc;\r\n    }\r\n}\r\nclass ExistenceFilterChange {\r\n    constructor(targetId, existenceFilter) {\r\n        this.targetId = targetId;\r\n        this.existenceFilter = existenceFilter;\r\n    }\r\n}\r\nclass WatchTargetChange {\r\n    constructor(\r\n    /** What kind of change occurred to the watch target. */\r\n    state, \r\n    /** The target IDs that were added/removed/set. */\r\n    targetIds, \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \r\n    /** An RPC error indicating why the watch failed. */\r\n    cause = null) {\r\n        this.state = state;\r\n        this.targetIds = targetIds;\r\n        this.resumeToken = resumeToken;\r\n        this.cause = cause;\r\n    }\r\n}\r\n/** Tracks the internal state of a Watch target. */\r\nclass TargetState {\r\n    constructor() {\r\n        /**\r\n         * The number of pending responses (adds or removes) that we are waiting on.\r\n         * We only consider targets active that have no pending responses.\r\n         */\r\n        this.pendingResponses = 0;\r\n        /**\r\n         * Keeps track of the document changes since the last raised snapshot.\r\n         *\r\n         * These changes are continuously updated as we receive document updates and\r\n         * always reflect the current set of changes against the last issued snapshot.\r\n         */\r\n        this.documentChanges = snapshotChangesMap();\r\n        /** See public getters for explanations of these fields. */\r\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\r\n        this._current = false;\r\n        /**\r\n         * Whether this target state should be included in the next snapshot. We\r\n         * initialize to true so that newly-added targets are included in the next\r\n         * RemoteEvent.\r\n         */\r\n        this._hasPendingChanges = true;\r\n    }\r\n    /**\r\n     * Whether this target has been marked 'current'.\r\n     *\r\n     * 'Current' has special meaning in the RPC protocol: It implies that the\r\n     * Watch backend has sent us all changes up to the point at which the target\r\n     * was added and that the target is consistent with the rest of the watch\r\n     * stream.\r\n     */\r\n    get current() {\r\n        return this._current;\r\n    }\r\n    /** The last resume token sent to us for this target. */\r\n    get resumeToken() {\r\n        return this._resumeToken;\r\n    }\r\n    /** Whether this target has pending target adds or target removes. */\r\n    get isPending() {\r\n        return this.pendingResponses !== 0;\r\n    }\r\n    /** Whether we have modified any state that should trigger a snapshot. */\r\n    get hasPendingChanges() {\r\n        return this._hasPendingChanges;\r\n    }\r\n    /**\r\n     * Applies the resume token to the TargetChange, but only when it has a new\r\n     * value. Empty resumeTokens are discarded.\r\n     */\r\n    updateResumeToken(resumeToken) {\r\n        if (resumeToken.approximateByteSize() > 0) {\r\n            this._hasPendingChanges = true;\r\n            this._resumeToken = resumeToken;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a target change from the current set of changes.\r\n     *\r\n     * To reset the document changes after raising this snapshot, call\r\n     * `clearPendingChanges()`.\r\n     */\r\n    toTargetChange() {\r\n        let addedDocuments = documentKeySet();\r\n        let modifiedDocuments = documentKeySet();\r\n        let removedDocuments = documentKeySet();\r\n        this.documentChanges.forEach((key, changeType) => {\r\n            switch (changeType) {\r\n                case 0 /* ChangeType.Added */:\r\n                    addedDocuments = addedDocuments.add(key);\r\n                    break;\r\n                case 2 /* ChangeType.Modified */:\r\n                    modifiedDocuments = modifiedDocuments.add(key);\r\n                    break;\r\n                case 1 /* ChangeType.Removed */:\r\n                    removedDocuments = removedDocuments.add(key);\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\r\n    }\r\n    /**\r\n     * Resets the document changes and sets `hasPendingChanges` to false.\r\n     */\r\n    clearPendingChanges() {\r\n        this._hasPendingChanges = false;\r\n        this.documentChanges = snapshotChangesMap();\r\n    }\r\n    addDocumentChange(key, changeType) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.insert(key, changeType);\r\n    }\r\n    removeDocumentChange(key) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.remove(key);\r\n    }\r\n    recordPendingTargetRequest() {\r\n        this.pendingResponses += 1;\r\n    }\r\n    recordTargetResponse() {\r\n        this.pendingResponses -= 1;\r\n        hardAssert(this.pendingResponses >= 0);\r\n    }\r\n    markCurrent() {\r\n        this._hasPendingChanges = true;\r\n        this._current = true;\r\n    }\r\n}\r\nconst LOG_TAG$g = 'WatchChangeAggregator';\r\n/**\r\n * A helper class to accumulate watch changes into a RemoteEvent.\r\n */\r\nclass WatchChangeAggregator {\r\n    constructor(metadataProvider) {\r\n        this.metadataProvider = metadataProvider;\r\n        /** The internal state of all tracked targets. */\r\n        this.targetStates = new Map();\r\n        /** Keeps track of the documents to update since the last raised snapshot. */\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        /** A mapping of document keys to their set of target IDs. */\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        /**\r\n         * A map of targets with existence filter mismatches. These targets are\r\n         * known to be inconsistent and their listens needs to be re-established by\r\n         * RemoteStore.\r\n         */\r\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\r\n    }\r\n    /**\r\n     * Processes and adds the DocumentWatchChange to the current set of changes.\r\n     */\r\n    handleDocumentChange(docChange) {\r\n        for (const targetId of docChange.updatedTargetIds) {\r\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\r\n                this.addDocumentToTarget(targetId, docChange.newDoc);\r\n            }\r\n            else {\r\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n            }\r\n        }\r\n        for (const targetId of docChange.removedTargetIds) {\r\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n        }\r\n    }\r\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\r\n    handleTargetChange(targetChange) {\r\n        this.forEachTarget(targetChange, targetId => {\r\n            const targetState = this.ensureTargetState(targetId);\r\n            switch (targetChange.state) {\r\n                case 0 /* WatchTargetChangeState.NoChange */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 1 /* WatchTargetChangeState.Added */:\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        // We have a freshly added target, so we need to reset any state\r\n                        // that we had previously. This can happen e.g. when remove and add\r\n                        // back a target for existence filter mismatches.\r\n                        targetState.clearPendingChanges();\r\n                    }\r\n                    targetState.updateResumeToken(targetChange.resumeToken);\r\n                    break;\r\n                case 2 /* WatchTargetChangeState.Removed */:\r\n                    // We need to keep track of removed targets to we can post-filter and\r\n                    // remove any target changes.\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        this.removeTarget(targetId);\r\n                    }\r\n                    break;\r\n                case 3 /* WatchTargetChangeState.Current */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.markCurrent();\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 4 /* WatchTargetChangeState.Reset */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        // Reset the target and synthesizes removes for all existing\r\n                        // documents. The backend will re-add any documents that still\r\n                        // match the target before it sends the next global snapshot.\r\n                        this.resetTarget(targetId);\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Iterates over all targetIds that the watch change applies to: either the\r\n     * targetIds explicitly listed in the change or the targetIds of all currently\r\n     * active targets.\r\n     */\r\n    forEachTarget(targetChange, fn) {\r\n        if (targetChange.targetIds.length > 0) {\r\n            targetChange.targetIds.forEach(fn);\r\n        }\r\n        else {\r\n            this.targetStates.forEach((_, targetId) => {\r\n                if (this.isActiveTarget(targetId)) {\r\n                    fn(targetId);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Handles existence filters and synthesizes deletes for filter mismatches.\r\n     * Targets that are invalidated by filter mismatches are added to\r\n     * `pendingTargetResets`.\r\n     */\r\n    handleExistenceFilter(watchChange) {\r\n        const targetId = watchChange.targetId;\r\n        const expectedCount = watchChange.existenceFilter.count;\r\n        const targetData = this.targetDataForActiveTarget(targetId);\r\n        if (targetData) {\r\n            const target = targetData.target;\r\n            if (targetIsDocumentTarget(target)) {\r\n                if (expectedCount === 0) {\r\n                    // The existence filter told us the document does not exist. We deduce\r\n                    // that this document does not exist and apply a deleted document to\r\n                    // our updates. Without applying this deleted document there might be\r\n                    // another query that will raise this document as part of a snapshot\r\n                    // until it is resolved, essentially exposing inconsistency between\r\n                    // queries.\r\n                    const key = new DocumentKey(target.path);\r\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\r\n                }\r\n                else {\r\n                    hardAssert(expectedCount === 1);\r\n                }\r\n            }\r\n            else {\r\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\r\n                // Existence filter mismatch. Mark the documents as being in limbo, and\r\n                // raise a snapshot with `isFromCache:true`.\r\n                if (currentSize !== expectedCount) {\r\n                    // Apply bloom filter to identify and mark removed documents.\r\n                    const bloomFilter = this.parseBloomFilter(watchChange);\r\n                    const status = bloomFilter\r\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\r\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\r\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\r\n                        // If bloom filter application fails, we reset the mapping and\r\n                        // trigger re-run of the query.\r\n                        this.resetTarget(targetId);\r\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\r\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\r\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\r\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\r\n                    }\r\n                    testingHooksSpi === null || testingHooksSpi === void 0 ? void 0 : testingHooksSpi.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\r\n     * filter.\r\n     */\r\n    parseBloomFilter(watchChange) {\r\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\r\n        if (!unchangedNames || !unchangedNames.bits) {\r\n            return null;\r\n        }\r\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\r\n        let normalizedBitmap;\r\n        try {\r\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof Base64DecodeError) {\r\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\r\n                    err.message +\r\n                    '); ignoring the bloom filter and falling back to full re-query.');\r\n                return null;\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n        let bloomFilter;\r\n        try {\r\n            // BloomFilter throws error if the inputs are invalid.\r\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof BloomFilterError) {\r\n                logWarn('BloomFilter error: ', err);\r\n            }\r\n            else {\r\n                logWarn('Applying bloom filter failed: ', err);\r\n            }\r\n            return null;\r\n        }\r\n        if (bloomFilter.bitCount === 0) {\r\n            return null;\r\n        }\r\n        return bloomFilter;\r\n    }\r\n    /**\r\n     * Apply bloom filter to remove the deleted documents, and return the\r\n     * application status.\r\n     */\r\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\r\n        const expectedCount = watchChange.existenceFilter.count;\r\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\r\n        return expectedCount === currentCount - removedDocumentCount\r\n            ? 0 /* BloomFilterApplicationStatus.Success */\r\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\r\n    }\r\n    /**\r\n     * Filter out removed documents based on bloom filter membership result and\r\n     * return number of documents removed.\r\n     */\r\n    filterRemovedDocuments(bloomFilter, targetId) {\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        let removalCount = 0;\r\n        existingKeys.forEach(key => {\r\n            const databaseId = this.metadataProvider.getDatabaseId();\r\n            const documentPath = `projects/${databaseId.projectId}` +\r\n                `/databases/${databaseId.database}` +\r\n                `/documents/${key.path.canonicalString()}`;\r\n            if (!bloomFilter.mightContain(documentPath)) {\r\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\r\n                removalCount++;\r\n            }\r\n        });\r\n        return removalCount;\r\n    }\r\n    /**\r\n     * Converts the currently accumulated state into a remote event at the\r\n     * provided snapshot version. Resets the accumulated changes before returning.\r\n     */\r\n    createRemoteEvent(snapshotVersion) {\r\n        const targetChanges = new Map();\r\n        this.targetStates.forEach((targetState, targetId) => {\r\n            const targetData = this.targetDataForActiveTarget(targetId);\r\n            if (targetData) {\r\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\r\n                    // Document queries for document that don't exist can produce an empty\r\n                    // result set. To update our local cache, we synthesize a document\r\n                    // delete if we have not previously received the document. This\r\n                    // resolves the limbo state of the document, removing it from\r\n                    // limboDocumentRefs.\r\n                    //\r\n                    // TODO(dimond): Ideally we would have an explicit lookup target\r\n                    // instead resulting in an explicit delete message and we could\r\n                    // remove this special logic.\r\n                    const key = new DocumentKey(targetData.target.path);\r\n                    if (this.pendingDocumentUpdates.get(key) === null &&\r\n                        !this.targetContainsDocument(targetId, key)) {\r\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\r\n                    }\r\n                }\r\n                if (targetState.hasPendingChanges) {\r\n                    targetChanges.set(targetId, targetState.toTargetChange());\r\n                    targetState.clearPendingChanges();\r\n                }\r\n            }\r\n        });\r\n        let resolvedLimboDocuments = documentKeySet();\r\n        // We extract the set of limbo-only document updates as the GC logic\r\n        // special-cases documents that do not appear in the target cache.\r\n        //\r\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\r\n        // client.\r\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\r\n            let isOnlyLimboTarget = true;\r\n            targets.forEachWhile(targetId => {\r\n                const targetData = this.targetDataForActiveTarget(targetId);\r\n                if (targetData &&\r\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\r\n                    isOnlyLimboTarget = false;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            if (isOnlyLimboTarget) {\r\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\r\n            }\r\n        });\r\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\r\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\r\n        return remoteEvent;\r\n    }\r\n    /**\r\n     * Adds the provided document to the internal list of document updates and\r\n     * its document key to the given target's mapping.\r\n     */\r\n    // Visible for testing.\r\n    addDocumentToTarget(targetId, document) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const changeType = this.targetContainsDocument(targetId, document.key)\r\n            ? 2 /* ChangeType.Modified */\r\n            : 0 /* ChangeType.Added */;\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.addDocumentChange(document.key, changeType);\r\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\r\n    }\r\n    /**\r\n     * Removes the provided document from the target mapping. If the\r\n     * document no longer matches the target, but the document's state is still\r\n     * known (e.g. we know that the document was deleted or we received the change\r\n     * that caused the filter mismatch), the new document can be provided\r\n     * to update the remote document cache.\r\n     */\r\n    // Visible for testing.\r\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const targetState = this.ensureTargetState(targetId);\r\n        if (this.targetContainsDocument(targetId, key)) {\r\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\r\n        }\r\n        else {\r\n            // The document may have entered and left the target before we raised a\r\n            // snapshot, so we can just ignore the change.\r\n            targetState.removeDocumentChange(key);\r\n        }\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\r\n        if (updatedDocument) {\r\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\r\n        }\r\n    }\r\n    removeTarget(targetId) {\r\n        this.targetStates.delete(targetId);\r\n    }\r\n    /**\r\n     * Returns the current count of documents in the target. This includes both\r\n     * the number of documents that the LocalStore considers to be part of the\r\n     * target as well as any accumulated changes.\r\n     */\r\n    getCurrentDocumentCountForTarget(targetId) {\r\n        const targetState = this.ensureTargetState(targetId);\r\n        const targetChange = targetState.toTargetChange();\r\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\r\n            targetChange.addedDocuments.size -\r\n            targetChange.removedDocuments.size);\r\n    }\r\n    /**\r\n     * Increment the number of acks needed from watch before we can consider the\r\n     * server to be 'in-sync' with the client's active targets.\r\n     */\r\n    recordPendingTargetRequest(targetId) {\r\n        // For each request we get we need to record we need a response for it.\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.recordPendingTargetRequest();\r\n    }\r\n    ensureTargetState(targetId) {\r\n        let result = this.targetStates.get(targetId);\r\n        if (!result) {\r\n            result = new TargetState();\r\n            this.targetStates.set(targetId, result);\r\n        }\r\n        return result;\r\n    }\r\n    ensureDocumentTargetMapping(key) {\r\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\r\n        if (!targetMapping) {\r\n            targetMapping = new SortedSet(primitiveComparator);\r\n            this.pendingDocumentTargetMapping =\r\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\r\n        }\r\n        return targetMapping;\r\n    }\r\n    /**\r\n     * Verifies that the user is still interested in this target (by calling\r\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\r\n     * from watch.\r\n     */\r\n    isActiveTarget(targetId) {\r\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\r\n        if (!targetActive) {\r\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\r\n        }\r\n        return targetActive;\r\n    }\r\n    /**\r\n     * Returns the TargetData for an active target (i.e. a target that the user\r\n     * is still interested in that has no outstanding target change requests).\r\n     */\r\n    targetDataForActiveTarget(targetId) {\r\n        const targetState = this.targetStates.get(targetId);\r\n        return targetState && targetState.isPending\r\n            ? null\r\n            : this.metadataProvider.getTargetDataForTarget(targetId);\r\n    }\r\n    /**\r\n     * Resets the state of a Watch target to its initial state (e.g. sets\r\n     * 'current' to false, clears the resume token and removes its target mapping\r\n     * from all documents).\r\n     */\r\n    resetTarget(targetId) {\r\n        this.targetStates.set(targetId, new TargetState());\r\n        // Trigger removal for any documents currently mapped to this target.\r\n        // These removals will be part of the initial snapshot if Watch does not\r\n        // resend these documents.\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        existingKeys.forEach(key => {\r\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\r\n        });\r\n    }\r\n    /**\r\n     * Returns whether the LocalStore considers the document to be part of the\r\n     * specified target.\r\n     */\r\n    targetContainsDocument(targetId, key) {\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        return existingKeys.has(key);\r\n    }\r\n}\r\nfunction documentTargetMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\nfunction snapshotChangesMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const result = {\r\n        localCacheCount,\r\n        existenceFilterCount: existenceFilter.count,\r\n        databaseId: databaseId.database,\r\n        projectId: databaseId.projectId\r\n    };\r\n    const unchangedNames = existenceFilter.unchangedNames;\r\n    if (unchangedNames) {\r\n        result.bloomFilter = {\r\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\r\n            hashCount: (_a = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.hashCount) !== null && _a !== void 0 ? _a : 0,\r\n            bitmapLength: (_d = (_c = (_b = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _b === void 0 ? void 0 : _b.bitmap) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\r\n            padding: (_f = (_e = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _e === void 0 ? void 0 : _e.padding) !== null && _f !== void 0 ? _f : 0,\r\n            mightContain: (value) => { var _a; return (_a = bloomFilter === null || bloomFilter === void 0 ? void 0 : bloomFilter.mightContain(value)) !== null && _a !== void 0 ? _a : false; }\r\n        };\r\n    }\r\n    return result;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DIRECTIONS = (() => {\r\n    const dirs = {};\r\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\r\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\r\n    return dirs;\r\n})();\r\nconst OPERATORS = (() => {\r\n    const ops = {};\r\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\r\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\r\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\r\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\r\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\r\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\r\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\r\n    ops[\"in\" /* Operator.IN */] = 'IN';\r\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\r\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\r\n    return ops;\r\n})();\r\nconst COMPOSITE_OPERATORS = (() => {\r\n    const ops = {};\r\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\r\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\r\n    return ops;\r\n})();\r\nfunction assertPresent(value, description) {\r\n}\r\n/**\r\n * This class generates JsonObject values for the Datastore API suitable for\r\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\r\n *\r\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\r\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\r\n * format.\r\n *\r\n * For a description of the Proto3 JSON format check\r\n * https://developers.google.com/protocol-buffers/docs/proto3#json\r\n *\r\n * TODO(klimt): We can remove the databaseId argument if we keep the full\r\n * resource name in documents.\r\n */\r\nclass JsonProtoSerializer {\r\n    constructor(databaseId, useProto3Json) {\r\n        this.databaseId = databaseId;\r\n        this.useProto3Json = useProto3Json;\r\n    }\r\n}\r\nfunction fromRpcStatus(status) {\r\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\r\n    return new FirestoreError(code, status.message || '');\r\n}\r\n/**\r\n * Returns a value for a number (or null) that's appropriate to put into\r\n * a google.protobuf.Int32Value proto.\r\n * DO NOT USE THIS FOR ANYTHING ELSE.\r\n * This method cheats. It's typed as returning \"number\" because that's what\r\n * our generated proto interfaces say Int32Value must be. But GRPC actually\r\n * expects a { value: <number> } struct.\r\n */\r\nfunction toInt32Proto(serializer, val) {\r\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\r\n        return val;\r\n    }\r\n    else {\r\n        return { value: val };\r\n    }\r\n}\r\n/**\r\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\r\n */\r\nfunction fromInt32Proto(val) {\r\n    let result;\r\n    if (typeof val === 'object') {\r\n        result = val.value;\r\n    }\r\n    else {\r\n        result = val;\r\n    }\r\n    return isNullOrUndefined(result) ? null : result;\r\n}\r\n/**\r\n * Returns a value for a Date that's appropriate to put into a proto.\r\n */\r\nfunction toTimestamp(serializer, timestamp) {\r\n    if (serializer.useProto3Json) {\r\n        // Serialize to ISO-8601 date format, but with full nano resolution.\r\n        // Since JS Date has only millis, let's only use it for the seconds and\r\n        // then manually add the fractions to the end.\r\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\r\n        // Remove .xxx frac part and Z in the end.\r\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\r\n        // Pad the fraction out to 9 digits (nanos).\r\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\r\n        return `${strUntilSeconds}.${nanoStr}Z`;\r\n    }\r\n    else {\r\n        return {\r\n            seconds: '' + timestamp.seconds,\r\n            nanos: timestamp.nanoseconds\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        };\r\n    }\r\n}\r\nfunction fromTimestamp(date) {\r\n    const timestamp = normalizeTimestamp(date);\r\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\r\n}\r\n/**\r\n * Returns a value for bytes that's appropriate to put in a proto.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction toBytes(serializer, bytes) {\r\n    if (serializer.useProto3Json) {\r\n        return bytes.toBase64();\r\n    }\r\n    else {\r\n        return bytes.toUint8Array();\r\n    }\r\n}\r\n/**\r\n * Returns a ByteString based on the proto string value.\r\n */\r\nfunction fromBytes(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        hardAssert(value === undefined || typeof value === 'string');\r\n        return ByteString.fromBase64String(value ? value : '');\r\n    }\r\n    else {\r\n        hardAssert(value === undefined ||\r\n            // Check if the value is an instance of both Buffer and Uint8Array,\r\n            // despite the fact that Buffer extends Uint8Array. In some\r\n            // environments, such as jsdom, the prototype chain of Buffer\r\n            // does not indicate that it extends Uint8Array.\r\n            value instanceof Buffer ||\r\n            value instanceof Uint8Array);\r\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\r\n    }\r\n}\r\nfunction toVersion(serializer, version) {\r\n    return toTimestamp(serializer, version.toTimestamp());\r\n}\r\nfunction fromVersion(version) {\r\n    hardAssert(!!version);\r\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\r\n}\r\nfunction toResourceName(databaseId, path) {\r\n    return toResourcePath(databaseId, path).canonicalString();\r\n}\r\nfunction toResourcePath(databaseId, path) {\r\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\r\n    return path === undefined ? resourcePath : resourcePath.child(path);\r\n}\r\nfunction fromResourceName(name) {\r\n    const resource = ResourcePath.fromString(name);\r\n    hardAssert(isValidResourceName(resource));\r\n    return resource;\r\n}\r\nfunction toName(serializer, key) {\r\n    return toResourceName(serializer.databaseId, key.path);\r\n}\r\nfunction fromName(serializer, name) {\r\n    const resource = fromResourceName(name);\r\n    if (resource.get(1) !== serializer.databaseId.projectId) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\r\n            resource.get(1) +\r\n            ' vs ' +\r\n            serializer.databaseId.projectId);\r\n    }\r\n    if (resource.get(3) !== serializer.databaseId.database) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\r\n            resource.get(3) +\r\n            ' vs ' +\r\n            serializer.databaseId.database);\r\n    }\r\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\r\n}\r\nfunction toQueryPath(serializer, path) {\r\n    return toResourceName(serializer.databaseId, path);\r\n}\r\nfunction fromQueryPath(name) {\r\n    const resourceName = fromResourceName(name);\r\n    // In v1beta1 queries for collections at the root did not have a trailing\r\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\r\n    // ability to read the v1beta1 form for compatibility with queries persisted\r\n    // in the local target cache.\r\n    if (resourceName.length === 4) {\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    return extractLocalPathFromResourceName(resourceName);\r\n}\r\nfunction getEncodedDatabaseId(serializer) {\r\n    const path = new ResourcePath([\r\n        'projects',\r\n        serializer.databaseId.projectId,\r\n        'databases',\r\n        serializer.databaseId.database\r\n    ]);\r\n    return path.canonicalString();\r\n}\r\nfunction fullyQualifiedPrefixPath(databaseId) {\r\n    return new ResourcePath([\r\n        'projects',\r\n        databaseId.projectId,\r\n        'databases',\r\n        databaseId.database\r\n    ]);\r\n}\r\nfunction extractLocalPathFromResourceName(resourceName) {\r\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\r\n    return resourceName.popFirst(5);\r\n}\r\n/** Creates a Document proto from key and fields (but no create/update time) */\r\nfunction toMutationDocument(serializer, key, fields) {\r\n    return {\r\n        name: toName(serializer, key),\r\n        fields: fields.value.mapValue.fields\r\n    };\r\n}\r\nfunction toDocument(serializer, document) {\r\n    return {\r\n        name: toName(serializer, document.key),\r\n        fields: document.data.value.mapValue.fields,\r\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\r\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\r\n    };\r\n}\r\nfunction fromDocument(serializer, document, hasCommittedMutations) {\r\n    const key = fromName(serializer, document.name);\r\n    const version = fromVersion(document.updateTime);\r\n    // If we read a document from persistence that is missing createTime, it's due\r\n    // to older SDK versions not storing this information. In such cases, we'll\r\n    // set the createTime to zero. This can be removed in the long term.\r\n    const createTime = document.createTime\r\n        ? fromVersion(document.createTime)\r\n        : SnapshotVersion.min();\r\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\r\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\r\n    if (hasCommittedMutations) {\r\n        result.setHasCommittedMutations();\r\n    }\r\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\r\n}\r\nfunction fromFound(serializer, doc) {\r\n    hardAssert(!!doc.found);\r\n    assertPresent(doc.found.name);\r\n    assertPresent(doc.found.updateTime);\r\n    const key = fromName(serializer, doc.found.name);\r\n    const version = fromVersion(doc.found.updateTime);\r\n    const createTime = doc.found.createTime\r\n        ? fromVersion(doc.found.createTime)\r\n        : SnapshotVersion.min();\r\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\r\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\r\n}\r\nfunction fromMissing(serializer, result) {\r\n    hardAssert(!!result.missing);\r\n    hardAssert(!!result.readTime);\r\n    const key = fromName(serializer, result.missing);\r\n    const version = fromVersion(result.readTime);\r\n    return MutableDocument.newNoDocument(key, version);\r\n}\r\nfunction fromBatchGetDocumentsResponse(serializer, result) {\r\n    if ('found' in result) {\r\n        return fromFound(serializer, result);\r\n    }\r\n    else if ('missing' in result) {\r\n        return fromMissing(serializer, result);\r\n    }\r\n    return fail();\r\n}\r\nfunction fromWatchChange(serializer, change) {\r\n    let watchChange;\r\n    if ('targetChange' in change) {\r\n        assertPresent(change.targetChange);\r\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\r\n        // if unset\r\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\r\n        const targetIds = change.targetChange.targetIds || [];\r\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\r\n        const causeProto = change.targetChange.cause;\r\n        const cause = causeProto && fromRpcStatus(causeProto);\r\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\r\n    }\r\n    else if ('documentChange' in change) {\r\n        assertPresent(change.documentChange);\r\n        const entityChange = change.documentChange;\r\n        assertPresent(entityChange.document);\r\n        assertPresent(entityChange.document.name);\r\n        assertPresent(entityChange.document.updateTime);\r\n        const key = fromName(serializer, entityChange.document.name);\r\n        const version = fromVersion(entityChange.document.updateTime);\r\n        const createTime = entityChange.document.createTime\r\n            ? fromVersion(entityChange.document.createTime)\r\n            : SnapshotVersion.min();\r\n        const data = new ObjectValue({\r\n            mapValue: { fields: entityChange.document.fields }\r\n        });\r\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\r\n        const updatedTargetIds = entityChange.targetIds || [];\r\n        const removedTargetIds = entityChange.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentDelete' in change) {\r\n        assertPresent(change.documentDelete);\r\n        const docDelete = change.documentDelete;\r\n        assertPresent(docDelete.document);\r\n        const key = fromName(serializer, docDelete.document);\r\n        const version = docDelete.readTime\r\n            ? fromVersion(docDelete.readTime)\r\n            : SnapshotVersion.min();\r\n        const doc = MutableDocument.newNoDocument(key, version);\r\n        const removedTargetIds = docDelete.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentRemove' in change) {\r\n        assertPresent(change.documentRemove);\r\n        const docRemove = change.documentRemove;\r\n        assertPresent(docRemove.document);\r\n        const key = fromName(serializer, docRemove.document);\r\n        const removedTargetIds = docRemove.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\r\n    }\r\n    else if ('filter' in change) {\r\n        // TODO(dimond): implement existence filter parsing with strategy.\r\n        assertPresent(change.filter);\r\n        const filter = change.filter;\r\n        assertPresent(filter.targetId);\r\n        const { count = 0, unchangedNames } = filter;\r\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\r\n        const targetId = filter.targetId;\r\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    return watchChange;\r\n}\r\nfunction fromWatchTargetChangeState(state) {\r\n    if (state === 'NO_CHANGE') {\r\n        return 0 /* WatchTargetChangeState.NoChange */;\r\n    }\r\n    else if (state === 'ADD') {\r\n        return 1 /* WatchTargetChangeState.Added */;\r\n    }\r\n    else if (state === 'REMOVE') {\r\n        return 2 /* WatchTargetChangeState.Removed */;\r\n    }\r\n    else if (state === 'CURRENT') {\r\n        return 3 /* WatchTargetChangeState.Current */;\r\n    }\r\n    else if (state === 'RESET') {\r\n        return 4 /* WatchTargetChangeState.Reset */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction versionFromListenResponse(change) {\r\n    // We have only reached a consistent snapshot for the entire stream if there\r\n    // is a read_time set and it applies to all targets (i.e. the list of\r\n    // targets is empty). The backend is guaranteed to send such responses.\r\n    if (!('targetChange' in change)) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    const targetChange = change.targetChange;\r\n    if (targetChange.targetIds && targetChange.targetIds.length) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    if (!targetChange.readTime) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    return fromVersion(targetChange.readTime);\r\n}\r\nfunction toMutation(serializer, mutation) {\r\n    let result;\r\n    if (mutation instanceof SetMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\r\n        };\r\n    }\r\n    else if (mutation instanceof DeleteMutation) {\r\n        result = { delete: toName(serializer, mutation.key) };\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\r\n            updateMask: toDocumentMask(mutation.fieldMask)\r\n        };\r\n    }\r\n    else if (mutation instanceof VerifyMutation) {\r\n        result = {\r\n            verify: toName(serializer, mutation.key)\r\n        };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (mutation.fieldTransforms.length > 0) {\r\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\r\n    }\r\n    if (!mutation.precondition.isNone) {\r\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\r\n    }\r\n    return result;\r\n}\r\nfunction fromMutation(serializer, proto) {\r\n    const precondition = proto.currentDocument\r\n        ? fromPrecondition(proto.currentDocument)\r\n        : Precondition.none();\r\n    const fieldTransforms = proto.updateTransforms\r\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\r\n        : [];\r\n    if (proto.update) {\r\n        assertPresent(proto.update.name);\r\n        const key = fromName(serializer, proto.update.name);\r\n        const value = new ObjectValue({\r\n            mapValue: { fields: proto.update.fields }\r\n        });\r\n        if (proto.updateMask) {\r\n            const fieldMask = fromDocumentMask(proto.updateMask);\r\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, value, precondition, fieldTransforms);\r\n        }\r\n    }\r\n    else if (proto.delete) {\r\n        const key = fromName(serializer, proto.delete);\r\n        return new DeleteMutation(key, precondition);\r\n    }\r\n    else if (proto.verify) {\r\n        const key = fromName(serializer, proto.verify);\r\n        return new VerifyMutation(key, precondition);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toPrecondition(serializer, precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return {\r\n            updateTime: toVersion(serializer, precondition.updateTime)\r\n        };\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return { exists: precondition.exists };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction fromPrecondition(precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return Precondition.exists(precondition.exists);\r\n    }\r\n    else {\r\n        return Precondition.none();\r\n    }\r\n}\r\nfunction fromWriteResult(proto, commitTime) {\r\n    // NOTE: Deletes don't have an updateTime.\r\n    let version = proto.updateTime\r\n        ? fromVersion(proto.updateTime)\r\n        : fromVersion(commitTime);\r\n    if (version.isEqual(SnapshotVersion.min())) {\r\n        // The Firestore Emulator currently returns an update time of 0 for\r\n        // deletes of non-existing documents (rather than null). This breaks the\r\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\r\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\r\n        // TODO(#2149): Remove this when Emulator is fixed\r\n        version = fromVersion(commitTime);\r\n    }\r\n    return new MutationResult(version, proto.transformResults || []);\r\n}\r\nfunction fromWriteResults(protos, commitTime) {\r\n    if (protos && protos.length > 0) {\r\n        hardAssert(commitTime !== undefined);\r\n        return protos.map(proto => fromWriteResult(proto, commitTime));\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction toFieldTransform(serializer, fieldTransform) {\r\n    const transform = fieldTransform.transform;\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            setToServerValue: 'REQUEST_TIME'\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            appendMissingElements: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            removeAllFromArray: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof NumericIncrementTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            increment: transform.operand\r\n        };\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n}\r\nfunction fromFieldTransform(serializer, proto) {\r\n    let transform = null;\r\n    if ('setToServerValue' in proto) {\r\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\r\n        transform = new ServerTimestampTransform();\r\n    }\r\n    else if ('appendMissingElements' in proto) {\r\n        const values = proto.appendMissingElements.values || [];\r\n        transform = new ArrayUnionTransformOperation(values);\r\n    }\r\n    else if ('removeAllFromArray' in proto) {\r\n        const values = proto.removeAllFromArray.values || [];\r\n        transform = new ArrayRemoveTransformOperation(values);\r\n    }\r\n    else if ('increment' in proto) {\r\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\r\n    return new FieldTransform(fieldPath, transform);\r\n}\r\nfunction toDocumentsTarget(serializer, target) {\r\n    return { documents: [toQueryPath(serializer, target.path)] };\r\n}\r\nfunction fromDocumentsTarget(documentsTarget) {\r\n    const count = documentsTarget.documents.length;\r\n    hardAssert(count === 1);\r\n    const name = documentsTarget.documents[0];\r\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\r\n}\r\nfunction toQueryTarget(serializer, target) {\r\n    // Dissect the path into parent, collectionId, and optional key filter.\r\n    const queryTarget = { structuredQuery: {} };\r\n    const path = target.path;\r\n    let parent;\r\n    if (target.collectionGroup !== null) {\r\n        parent = path;\r\n        queryTarget.structuredQuery.from = [\r\n            {\r\n                collectionId: target.collectionGroup,\r\n                allDescendants: true\r\n            }\r\n        ];\r\n    }\r\n    else {\r\n        parent = path.popLast();\r\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\r\n    }\r\n    queryTarget.parent = toQueryPath(serializer, parent);\r\n    const where = toFilters(target.filters);\r\n    if (where) {\r\n        queryTarget.structuredQuery.where = where;\r\n    }\r\n    const orderBy = toOrder(target.orderBy);\r\n    if (orderBy) {\r\n        queryTarget.structuredQuery.orderBy = orderBy;\r\n    }\r\n    const limit = toInt32Proto(serializer, target.limit);\r\n    if (limit !== null) {\r\n        queryTarget.structuredQuery.limit = limit;\r\n    }\r\n    if (target.startAt) {\r\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\r\n    }\r\n    if (target.endAt) {\r\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\r\n    }\r\n    return { queryTarget, parent };\r\n}\r\nfunction toRunAggregationQueryRequest(serializer, target, aggregates) {\r\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\r\n    const aliasMap = {};\r\n    const aggregations = [];\r\n    let aggregationNum = 0;\r\n    aggregates.forEach(aggregate => {\r\n        // Map all client-side aliases to a unique short-form\r\n        // alias. This avoids issues with client-side aliases that\r\n        // exceed the 1500-byte string size limit.\r\n        const serverAlias = `aggregate_${aggregationNum++}`;\r\n        aliasMap[serverAlias] = aggregate.alias;\r\n        if (aggregate.aggregateType === 'count') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                count: {}\r\n            });\r\n        }\r\n        else if (aggregate.aggregateType === 'avg') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                avg: {\r\n                    field: toFieldPathReference(aggregate.fieldPath)\r\n                }\r\n            });\r\n        }\r\n        else if (aggregate.aggregateType === 'sum') {\r\n            aggregations.push({\r\n                alias: serverAlias,\r\n                sum: {\r\n                    field: toFieldPathReference(aggregate.fieldPath)\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return {\r\n        request: {\r\n            structuredAggregationQuery: {\r\n                aggregations,\r\n                structuredQuery: queryTarget.structuredQuery\r\n            },\r\n            parent: queryTarget.parent\r\n        },\r\n        aliasMap,\r\n        parent\r\n    };\r\n}\r\nfunction convertQueryTargetToQuery(target) {\r\n    let path = fromQueryPath(target.parent);\r\n    const query = target.structuredQuery;\r\n    const fromCount = query.from ? query.from.length : 0;\r\n    let collectionGroup = null;\r\n    if (fromCount > 0) {\r\n        hardAssert(fromCount === 1);\r\n        const from = query.from[0];\r\n        if (from.allDescendants) {\r\n            collectionGroup = from.collectionId;\r\n        }\r\n        else {\r\n            path = path.child(from.collectionId);\r\n        }\r\n    }\r\n    let filterBy = [];\r\n    if (query.where) {\r\n        filterBy = fromFilters(query.where);\r\n    }\r\n    let orderBy = [];\r\n    if (query.orderBy) {\r\n        orderBy = fromOrder(query.orderBy);\r\n    }\r\n    let limit = null;\r\n    if (query.limit) {\r\n        limit = fromInt32Proto(query.limit);\r\n    }\r\n    let startAt = null;\r\n    if (query.startAt) {\r\n        startAt = fromStartAtCursor(query.startAt);\r\n    }\r\n    let endAt = null;\r\n    if (query.endAt) {\r\n        endAt = fromEndAtCursor(query.endAt);\r\n    }\r\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\r\n}\r\nfunction fromQueryTarget(target) {\r\n    return queryToTarget(convertQueryTargetToQuery(target));\r\n}\r\nfunction toListenRequestLabels(serializer, targetData) {\r\n    const value = toLabel(targetData.purpose);\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        return {\r\n            'goog-listen-tags': value\r\n        };\r\n    }\r\n}\r\nfunction toLabel(purpose) {\r\n    switch (purpose) {\r\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\r\n            return null;\r\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\r\n            return 'existence-filter-mismatch';\r\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\r\n            return 'existence-filter-mismatch-bloom';\r\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\r\n            return 'limbo-document';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toTarget(serializer, targetData) {\r\n    let result;\r\n    const target = targetData.target;\r\n    if (targetIsDocumentTarget(target)) {\r\n        result = { documents: toDocumentsTarget(serializer, target) };\r\n    }\r\n    else {\r\n        result = { query: toQueryTarget(serializer, target).queryTarget };\r\n    }\r\n    result.targetId = targetData.targetId;\r\n    if (targetData.resumeToken.approximateByteSize() > 0) {\r\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\r\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\r\n        if (expectedCount !== null) {\r\n            result.expectedCount = expectedCount;\r\n        }\r\n    }\r\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\r\n        // TODO(wuandy): Consider removing above check because it is most likely true.\r\n        // Right now, many tests depend on this behaviour though (leaving min() out\r\n        // of serialization).\r\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\r\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\r\n        if (expectedCount !== null) {\r\n            result.expectedCount = expectedCount;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction toFilters(filters) {\r\n    if (filters.length === 0) {\r\n        return;\r\n    }\r\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\r\n}\r\nfunction fromFilters(filter) {\r\n    const result = fromFilter(filter);\r\n    if (result instanceof CompositeFilter &&\r\n        compositeFilterIsFlatConjunction(result)) {\r\n        return result.getFilters();\r\n    }\r\n    return [result];\r\n}\r\nfunction fromFilter(filter) {\r\n    if (filter.unaryFilter !== undefined) {\r\n        return fromUnaryFilter(filter);\r\n    }\r\n    else if (filter.fieldFilter !== undefined) {\r\n        return fromFieldFilter(filter);\r\n    }\r\n    else if (filter.compositeFilter !== undefined) {\r\n        return fromCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toOrder(orderBys) {\r\n    if (orderBys.length === 0) {\r\n        return;\r\n    }\r\n    return orderBys.map(order => toPropertyOrder(order));\r\n}\r\nfunction fromOrder(orderBys) {\r\n    return orderBys.map(order => fromPropertyOrder(order));\r\n}\r\nfunction toStartAtCursor(cursor) {\r\n    return {\r\n        before: cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction toEndAtCursor(cursor) {\r\n    return {\r\n        before: !cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction fromStartAtCursor(cursor) {\r\n    const inclusive = !!cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\nfunction fromEndAtCursor(cursor) {\r\n    const inclusive = !cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\n// visible for testing\r\nfunction toDirection(dir) {\r\n    return DIRECTIONS[dir];\r\n}\r\n// visible for testing\r\nfunction fromDirection(dir) {\r\n    switch (dir) {\r\n        case 'ASCENDING':\r\n            return \"asc\" /* Direction.ASCENDING */;\r\n        case 'DESCENDING':\r\n            return \"desc\" /* Direction.DESCENDING */;\r\n        default:\r\n            return undefined;\r\n    }\r\n}\r\n// visible for testing\r\nfunction toOperatorName(op) {\r\n    return OPERATORS[op];\r\n}\r\nfunction toCompositeOperatorName(op) {\r\n    return COMPOSITE_OPERATORS[op];\r\n}\r\nfunction fromOperatorName(op) {\r\n    switch (op) {\r\n        case 'EQUAL':\r\n            return \"==\" /* Operator.EQUAL */;\r\n        case 'NOT_EQUAL':\r\n            return \"!=\" /* Operator.NOT_EQUAL */;\r\n        case 'GREATER_THAN':\r\n            return \">\" /* Operator.GREATER_THAN */;\r\n        case 'GREATER_THAN_OR_EQUAL':\r\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\r\n        case 'LESS_THAN':\r\n            return \"<\" /* Operator.LESS_THAN */;\r\n        case 'LESS_THAN_OR_EQUAL':\r\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\r\n        case 'ARRAY_CONTAINS':\r\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\r\n        case 'IN':\r\n            return \"in\" /* Operator.IN */;\r\n        case 'NOT_IN':\r\n            return \"not-in\" /* Operator.NOT_IN */;\r\n        case 'ARRAY_CONTAINS_ANY':\r\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction fromCompositeOperatorName(op) {\r\n    switch (op) {\r\n        case 'AND':\r\n            return \"and\" /* CompositeOperator.AND */;\r\n        case 'OR':\r\n            return \"or\" /* CompositeOperator.OR */;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toFieldPathReference(path) {\r\n    return { fieldPath: path.canonicalString() };\r\n}\r\nfunction fromFieldPathReference(fieldReference) {\r\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\r\n}\r\n// visible for testing\r\nfunction toPropertyOrder(orderBy) {\r\n    return {\r\n        field: toFieldPathReference(orderBy.field),\r\n        direction: toDirection(orderBy.dir)\r\n    };\r\n}\r\nfunction fromPropertyOrder(orderBy) {\r\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\r\n}\r\n// visible for testing\r\nfunction toFilter(filter) {\r\n    if (filter instanceof FieldFilter) {\r\n        return toUnaryOrFieldFilter(filter);\r\n    }\r\n    else if (filter instanceof CompositeFilter) {\r\n        return toCompositeFilter(filter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toCompositeFilter(filter) {\r\n    const protos = filter.getFilters().map(filter => toFilter(filter));\r\n    if (protos.length === 1) {\r\n        return protos[0];\r\n    }\r\n    return {\r\n        compositeFilter: {\r\n            op: toCompositeOperatorName(filter.op),\r\n            filters: protos\r\n        }\r\n    };\r\n}\r\nfunction toUnaryOrFieldFilter(filter) {\r\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        fieldFilter: {\r\n            field: toFieldPathReference(filter.field),\r\n            op: toOperatorName(filter.op),\r\n            value: filter.value\r\n        }\r\n    };\r\n}\r\nfunction fromUnaryFilter(filter) {\r\n    switch (filter.unaryFilter.op) {\r\n        case 'IS_NAN':\r\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NULL':\r\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'IS_NOT_NAN':\r\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NOT_NULL':\r\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction fromFieldFilter(filter) {\r\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\r\n}\r\nfunction fromCompositeFilter(filter) {\r\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\r\n}\r\nfunction toDocumentMask(fieldMask) {\r\n    const canonicalFields = [];\r\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\r\n    return {\r\n        fieldPaths: canonicalFields\r\n    };\r\n}\r\nfunction fromDocumentMask(proto) {\r\n    const paths = proto.fieldPaths || [];\r\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\r\n}\r\nfunction isValidResourceName(path) {\r\n    // Resource names have at least 4 components (project ID, database ID)\r\n    return (path.length >= 4 &&\r\n        path.get(0) === 'projects' &&\r\n        path.get(2) === 'databases');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable set of metadata that the local store tracks for each target.\r\n */\r\nclass TargetData {\r\n    constructor(\r\n    /** The target being listened to. */\r\n    target, \r\n    /**\r\n     * The target ID to which the target corresponds; Assigned by the\r\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\r\n     */\r\n    targetId, \r\n    /** The purpose of the target. */\r\n    purpose, \r\n    /**\r\n     * The sequence number of the last transaction during which this target data\r\n     * was modified.\r\n     */\r\n    sequenceNumber, \r\n    /** The latest snapshot version seen for this target. */\r\n    snapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * The maximum snapshot version at which the associated view\r\n     * contained no limbo documents.\r\n     */\r\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \r\n    /**\r\n     * The number of documents that last matched the query at the resume token or\r\n     * read time. Documents are counted only when making a listen request with\r\n     * resume token or read time, otherwise, keep it null.\r\n     */\r\n    expectedCount = null) {\r\n        this.target = target;\r\n        this.targetId = targetId;\r\n        this.purpose = purpose;\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\r\n        this.resumeToken = resumeToken;\r\n        this.expectedCount = expectedCount;\r\n    }\r\n    /** Creates a new target data instance with an updated sequence number. */\r\n    withSequenceNumber(sequenceNumber) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated resume token and\r\n     * snapshot version.\r\n     */\r\n    withResumeToken(resumeToken, snapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \r\n        /* expectedCount= */ null);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated expected count.\r\n     */\r\n    withExpectedCount(expectedCount) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated last limbo free\r\n     * snapshot version number.\r\n     */\r\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Serializer for values stored in the LocalStore. */\r\nclass LocalSerializer {\r\n    constructor(remoteSerializer) {\r\n        this.remoteSerializer = remoteSerializer;\r\n    }\r\n}\r\n/** Decodes a remote document from storage locally to a Document. */\r\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\r\n    let doc;\r\n    if (remoteDoc.document) {\r\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\r\n    }\r\n    else if (remoteDoc.noDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\r\n        doc = MutableDocument.newNoDocument(key, version);\r\n        if (remoteDoc.hasCommittedMutations) {\r\n            doc.setHasCommittedMutations();\r\n        }\r\n    }\r\n    else if (remoteDoc.unknownDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\r\n        doc = MutableDocument.newUnknownDocument(key, version);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (remoteDoc.readTime) {\r\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\r\n    }\r\n    return doc;\r\n}\r\n/** Encodes a document for storage locally. */\r\nfunction toDbRemoteDocument(localSerializer, document) {\r\n    const key = document.key;\r\n    const remoteDoc = {\r\n        prefixPath: key.getCollectionPath().popLast().toArray(),\r\n        collectionGroup: key.collectionGroup,\r\n        documentId: key.path.lastSegment(),\r\n        readTime: toDbTimestampKey(document.readTime),\r\n        hasCommittedMutations: document.hasCommittedMutations\r\n    };\r\n    if (document.isFoundDocument()) {\r\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\r\n    }\r\n    else if (document.isNoDocument()) {\r\n        remoteDoc.noDocument = {\r\n            path: key.path.toArray(),\r\n            readTime: toDbTimestamp(document.version)\r\n        };\r\n    }\r\n    else if (document.isUnknownDocument()) {\r\n        remoteDoc.unknownDocument = {\r\n            path: key.path.toArray(),\r\n            version: toDbTimestamp(document.version)\r\n        };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    return remoteDoc;\r\n}\r\nfunction toDbTimestampKey(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return [timestamp.seconds, timestamp.nanoseconds];\r\n}\r\nfunction fromDbTimestampKey(dbTimestampKey) {\r\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\nfunction toDbTimestamp(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\r\n}\r\nfunction fromDbTimestamp(dbTimestamp) {\r\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\r\nfunction toDbMutationBatch(localSerializer, userId, batch) {\r\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    return {\r\n        userId,\r\n        batchId: batch.batchId,\r\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\r\n        baseMutations: serializedBaseMutations,\r\n        mutations: serializedMutations\r\n    };\r\n}\r\n/** Decodes a DbMutationBatch into a MutationBatch */\r\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\r\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    // Squash old transform mutations into existing patch or set mutations.\r\n    // The replacement of representing `transforms` with `update_transforms`\r\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\r\n    // to be updated to `update_transforms`.\r\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\r\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\r\n        const currentMutation = dbBatch.mutations[i];\r\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\r\n            dbBatch.mutations[i + 1].transform !== undefined;\r\n        if (hasTransform) {\r\n            const transformMutation = dbBatch.mutations[i + 1];\r\n            currentMutation.updateTransforms =\r\n                transformMutation.transform.fieldTransforms;\r\n            dbBatch.mutations.splice(i + 1, 1);\r\n            ++i;\r\n        }\r\n    }\r\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\r\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\r\n}\r\n/** Decodes a DbTarget into TargetData */\r\nfunction fromDbTarget(dbTarget) {\r\n    const version = fromDbTimestamp(dbTarget.readTime);\r\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\r\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\r\n        : SnapshotVersion.min();\r\n    let target;\r\n    if (isDocumentQuery(dbTarget.query)) {\r\n        target = fromDocumentsTarget(dbTarget.query);\r\n    }\r\n    else {\r\n        target = fromQueryTarget(dbTarget.query);\r\n    }\r\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\r\n}\r\n/** Encodes TargetData into a DbTarget for storage locally. */\r\nfunction toDbTarget(localSerializer, targetData) {\r\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\r\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\r\n    let queryProto;\r\n    if (targetIsDocumentTarget(targetData.target)) {\r\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\r\n    }\r\n    else {\r\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\r\n    }\r\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\r\n    // convert it to a base64 string for storage.\r\n    const resumeToken = targetData.resumeToken.toBase64();\r\n    // lastListenSequenceNumber is always 0 until we do real GC.\r\n    return {\r\n        targetId: targetData.targetId,\r\n        canonicalId: canonifyTarget(targetData.target),\r\n        readTime: dbTimestamp,\r\n        resumeToken,\r\n        lastListenSequenceNumber: targetData.sequenceNumber,\r\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\r\n        query: queryProto\r\n    };\r\n}\r\n/**\r\n * A helper function for figuring out what kind of query has been stored.\r\n */\r\nfunction isDocumentQuery(dbQuery) {\r\n    return dbQuery.documents !== undefined;\r\n}\r\n/** Encodes a DbBundle to a BundleMetadata object. */\r\nfunction fromDbBundle(dbBundle) {\r\n    return {\r\n        id: dbBundle.bundleId,\r\n        createTime: fromDbTimestamp(dbBundle.createTime),\r\n        version: dbBundle.version\r\n    };\r\n}\r\n/** Encodes a BundleMetadata to a DbBundle. */\r\nfunction toDbBundle(metadata) {\r\n    return {\r\n        bundleId: metadata.id,\r\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\r\n        version: metadata.version\r\n    };\r\n}\r\n/** Encodes a DbNamedQuery to a NamedQuery. */\r\nfunction fromDbNamedQuery(dbNamedQuery) {\r\n    return {\r\n        name: dbNamedQuery.name,\r\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\r\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\r\n    };\r\n}\r\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\r\nfunction toDbNamedQuery(query) {\r\n    return {\r\n        name: query.name,\r\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\r\n        bundledQuery: query.bundledQuery\r\n    };\r\n}\r\n/**\r\n * Encodes a `BundledQuery` from bundle proto to a Query object.\r\n *\r\n * This reconstructs the original query used to build the bundle being loaded,\r\n * including features exists only in SDKs (for example: limit-to-last).\r\n */\r\nfunction fromBundledQuery(bundledQuery) {\r\n    const query = convertQueryTargetToQuery({\r\n        parent: bundledQuery.parent,\r\n        structuredQuery: bundledQuery.structuredQuery\r\n    });\r\n    if (bundledQuery.limitType === 'LAST') {\r\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\r\n    }\r\n    return query;\r\n}\r\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\r\nfunction fromProtoNamedQuery(namedQuery) {\r\n    return {\r\n        name: namedQuery.name,\r\n        query: fromBundledQuery(namedQuery.bundledQuery),\r\n        readTime: fromVersion(namedQuery.readTime)\r\n    };\r\n}\r\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\r\nfunction fromBundleMetadata(metadata) {\r\n    return {\r\n        id: metadata.id,\r\n        version: metadata.version,\r\n        createTime: fromVersion(metadata.createTime)\r\n    };\r\n}\r\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\r\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\r\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\r\n}\r\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\r\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\r\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\r\n    return {\r\n        userId,\r\n        collectionPath,\r\n        documentId,\r\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\r\n        largestBatchId: overlay.largestBatchId,\r\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\r\n    };\r\n}\r\n/**\r\n * Returns the DbDocumentOverlayKey corresponding to the given user and\r\n * document key.\r\n */\r\nfunction toDbDocumentOverlayKey(userId, docKey) {\r\n    const docId = docKey.path.lastSegment();\r\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\r\n    return [userId, collectionPath, docId];\r\n}\r\nfunction toDbIndexConfiguration(index) {\r\n    return {\r\n        indexId: index.indexId,\r\n        collectionGroup: index.collectionGroup,\r\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\r\n    };\r\n}\r\nfunction fromDbIndexConfiguration(index, state) {\r\n    const decodedState = state\r\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\r\n        : IndexState.empty();\r\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\r\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\r\n}\r\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\r\n    return {\r\n        indexId,\r\n        uid,\r\n        sequenceNumber,\r\n        readTime: toDbTimestamp(offset.readTime),\r\n        documentKey: encodeResourcePath(offset.documentKey.path),\r\n        largestBatchId: offset.largestBatchId\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbBundleCache {\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return bundlesStore(transaction)\r\n            .get(bundleId)\r\n            .next(bundle => {\r\n            if (bundle) {\r\n                return fromDbBundle(bundle);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return namedQueriesStore(transaction)\r\n            .get(queryName)\r\n            .next(query => {\r\n            if (query) {\r\n                return fromDbNamedQuery(query);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the bundles object store.\r\n */\r\nfunction bundlesStore(txn) {\r\n    return getStore(txn, DbBundleStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\r\n */\r\nfunction namedQueriesStore(txn) {\r\n    return getStore(txn, DbNamedQueryStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Implementation of DocumentOverlayCache using IndexedDb.\r\n */\r\nclass IndexedDbDocumentOverlayCache {\r\n    /**\r\n     * @param serializer - The document serializer.\r\n     * @param userId - The userId for which we are accessing overlays.\r\n     */\r\n    constructor(serializer, userId) {\r\n        this.serializer = serializer;\r\n        this.userId = userId;\r\n    }\r\n    static forUser(serializer, user) {\r\n        const userId = user.uid || '';\r\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return documentOverlayStore(transaction)\r\n            .get(toDbDocumentOverlayKey(this.userId, key))\r\n            .next(dbOverlay => {\r\n            if (dbOverlay) {\r\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    getOverlays(transaction, keys) {\r\n        const result = newOverlayMap();\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            return this.getOverlay(transaction, key).next(overlay => {\r\n                if (overlay !== null) {\r\n                    result.set(key, overlay);\r\n                }\r\n            });\r\n        }).next(() => result);\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        const promises = [];\r\n        overlays.forEach((_, mutation) => {\r\n            const overlay = new Overlay(largestBatchId, mutation);\r\n            promises.push(this.saveOverlay(transaction, overlay));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const collectionPaths = new Set();\r\n        // Get the set of unique collection paths.\r\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\r\n        const promises = [];\r\n        collectionPaths.forEach(collectionPath => {\r\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \r\n            /*lowerOpen=*/ false, \r\n            /*upperOpen=*/ true);\r\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = newOverlayMap();\r\n        const collectionPath = encodeResourcePath(collection);\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\r\n            .next(dbOverlays => {\r\n            for (const dbOverlay of dbOverlays) {\r\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        const result = newOverlayMap();\r\n        let currentBatchId = undefined;\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .iterate({\r\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\r\n            range\r\n        }, (_, dbOverlay, control) => {\r\n            // We do not want to return partial batch overlays, even if the size\r\n            // of the result set exceeds the given `count` argument. Therefore, we\r\n            // continue to aggregate results even after the result size exceeds\r\n            // `count` if there are more overlays from the `currentBatchId`.\r\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            if (result.size() < count ||\r\n                overlay.largestBatchId === currentBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n                currentBatchId = overlay.largestBatchId;\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    saveOverlay(transaction, overlay) {\r\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document overlay object store.\r\n */\r\nfunction documentOverlayStore(txn) {\r\n    return getStore(txn, DbDocumentOverlayStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Note: This code is copied from the backend. Code that is not used by\r\n// Firestore was removed.\r\nconst INDEX_TYPE_NULL = 5;\r\nconst INDEX_TYPE_BOOLEAN = 10;\r\nconst INDEX_TYPE_NAN = 13;\r\nconst INDEX_TYPE_NUMBER = 15;\r\nconst INDEX_TYPE_TIMESTAMP = 20;\r\nconst INDEX_TYPE_STRING = 25;\r\nconst INDEX_TYPE_BLOB = 30;\r\nconst INDEX_TYPE_REFERENCE = 37;\r\nconst INDEX_TYPE_GEOPOINT = 45;\r\nconst INDEX_TYPE_ARRAY = 50;\r\nconst INDEX_TYPE_MAP = 55;\r\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\r\n// A terminator that indicates that a truncatable value was not truncated.\r\n// This must be smaller than all other type labels.\r\nconst NOT_TRUNCATED = 2;\r\n/** Firestore index value writer.  */\r\nclass FirestoreIndexValueWriter {\r\n    constructor() { }\r\n    // The write methods below short-circuit writing terminators for values\r\n    // containing a (terminating) truncated value.\r\n    //\r\n    // As an example, consider the resulting encoding for:\r\n    //\r\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\r\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\r\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\r\n    /** Writes an index value.  */\r\n    writeIndexValue(value, encoder) {\r\n        this.writeIndexValueAux(value, encoder);\r\n        // Write separator to split index values\r\n        // (see go/firestore-storage-format#encodings).\r\n        encoder.writeInfinity();\r\n    }\r\n    writeIndexValueAux(indexValue, encoder) {\r\n        if ('nullValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\r\n        }\r\n        else if ('booleanValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\r\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\r\n        }\r\n        else if ('integerValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\r\n        }\r\n        else if ('doubleValue' in indexValue) {\r\n            const n = normalizeNumber(indexValue.doubleValue);\r\n            if (isNaN(n)) {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\r\n            }\r\n            else {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n                if (isNegativeZero(n)) {\r\n                    // -0.0, 0 and 0.0 are all considered the same\r\n                    encoder.writeNumber(0.0);\r\n                }\r\n                else {\r\n                    encoder.writeNumber(n);\r\n                }\r\n            }\r\n        }\r\n        else if ('timestampValue' in indexValue) {\r\n            let timestamp = indexValue.timestampValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\r\n            if (typeof timestamp === 'string') {\r\n                timestamp = normalizeTimestamp(timestamp);\r\n            }\r\n            encoder.writeString(`${timestamp.seconds || ''}`);\r\n            encoder.writeNumber(timestamp.nanos || 0);\r\n        }\r\n        else if ('stringValue' in indexValue) {\r\n            this.writeIndexString(indexValue.stringValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('bytesValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\r\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('referenceValue' in indexValue) {\r\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\r\n        }\r\n        else if ('geoPointValue' in indexValue) {\r\n            const geoPoint = indexValue.geoPointValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\r\n            encoder.writeNumber(geoPoint.latitude || 0);\r\n            encoder.writeNumber(geoPoint.longitude || 0);\r\n        }\r\n        else if ('mapValue' in indexValue) {\r\n            if (isMaxValue(indexValue)) {\r\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\r\n            }\r\n            else {\r\n                this.writeIndexMap(indexValue.mapValue, encoder);\r\n                this.writeTruncationMarker(encoder);\r\n            }\r\n        }\r\n        else if ('arrayValue' in indexValue) {\r\n            this.writeIndexArray(indexValue.arrayValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n    writeIndexString(stringIndexValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\r\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\r\n    }\r\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\r\n        encoder.writeString(stringIndexValue);\r\n    }\r\n    writeIndexMap(mapIndexValue, encoder) {\r\n        const map = mapIndexValue.fields || {};\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\r\n        for (const key of Object.keys(map)) {\r\n            this.writeIndexString(key, encoder);\r\n            this.writeIndexValueAux(map[key], encoder);\r\n        }\r\n    }\r\n    writeIndexArray(arrayIndexValue, encoder) {\r\n        const values = arrayIndexValue.values || [];\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\r\n        for (const element of values) {\r\n            this.writeIndexValueAux(element, encoder);\r\n        }\r\n    }\r\n    writeIndexEntityRef(referenceValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\r\n        const path = DocumentKey.fromName(referenceValue).path;\r\n        path.forEach(segment => {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\r\n            this.writeUnlabeledIndexString(segment, encoder);\r\n        });\r\n    }\r\n    writeValueTypeLabel(encoder, typeOrder) {\r\n        encoder.writeNumber(typeOrder);\r\n    }\r\n    writeTruncationMarker(encoder) {\r\n        // While the SDK does not implement truncation, the truncation marker is\r\n        // used to terminate all variable length values (which are strings, bytes,\r\n        // references, arrays and maps).\r\n        encoder.writeNumber(NOT_TRUNCATED);\r\n    }\r\n}\r\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law | agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** These constants are taken from the backend. */\r\nconst MIN_SURROGATE = '\\uD800';\r\nconst MAX_SURROGATE = '\\uDBFF';\r\nconst ESCAPE1 = 0x00;\r\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\r\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\r\nconst ESCAPE2 = 0xff;\r\nconst INFINITY = 0xff; // Combined with ESCAPE2\r\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\r\nconst LONG_SIZE = 64;\r\nconst BYTE_SIZE = 8;\r\n/**\r\n * The default size of the buffer. This is arbitrary, but likely larger than\r\n * most index values so that less copies of the underlying buffer will be made.\r\n * For large values, a single copy will made to double the buffer length.\r\n */\r\nconst DEFAULT_BUFFER_SIZE = 1024;\r\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\r\nfunction doubleToLongBits(value) {\r\n    const dv = new DataView(new ArrayBuffer(8));\r\n    dv.setFloat64(0, value, /* littleEndian= */ false);\r\n    return new Uint8Array(dv.buffer);\r\n}\r\n/**\r\n * Counts the number of zeros in a byte.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction numberOfLeadingZerosInByte(x) {\r\n    if (x === 0) {\r\n        return 8;\r\n    }\r\n    let zeros = 0;\r\n    if (x >> 4 === 0) {\r\n        // Test if the first four bits are zero.\r\n        zeros += 4;\r\n        x = x << 4;\r\n    }\r\n    if (x >> 6 === 0) {\r\n        // Test if the first two (or next two) bits are zero.\r\n        zeros += 2;\r\n        x = x << 2;\r\n    }\r\n    if (x >> 7 === 0) {\r\n        // Test if the remaining bit is zero.\r\n        zeros += 1;\r\n    }\r\n    return zeros;\r\n}\r\n/** Counts the number of leading zeros in the given byte array. */\r\nfunction numberOfLeadingZeros(bytes) {\r\n    let leadingZeros = 0;\r\n    for (let i = 0; i < 8; ++i) {\r\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\r\n        leadingZeros += zeros;\r\n        if (zeros !== 8) {\r\n            break;\r\n        }\r\n    }\r\n    return leadingZeros;\r\n}\r\n/**\r\n * Returns the number of bytes required to store \"value\". Leading zero bytes\r\n * are skipped.\r\n */\r\nfunction unsignedNumLength(value) {\r\n    // This is just the number of bytes for the unsigned representation of the number.\r\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\r\n    return Math.ceil(numBits / BYTE_SIZE);\r\n}\r\n/**\r\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\r\n * behavior defined by the backend.\r\n *\r\n * The code is ported from its Java counterpart.\r\n */\r\nclass OrderedCodeWriter {\r\n    constructor() {\r\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\r\n        this.position = 0;\r\n    }\r\n    writeBytesAscending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteAscending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    writeBytesDescending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteDescending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, ascending. */\r\n    writeUtf8Ascending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteAscending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, descending */\r\n    writeUtf8Descending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteDescending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    writeNumberAscending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // actual value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = len & 0xff; // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = value[i] & 0xff;\r\n        }\r\n    }\r\n    writeNumberDescending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // inverted value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = ~(value[i] & 0xff);\r\n        }\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\r\n     * sequences written in ascending order.\r\n     */\r\n    writeInfinityAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE2);\r\n        this.writeEscapedByteAscending(INFINITY);\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\r\n     * sequences written in descending order.\r\n     */\r\n    writeInfinityDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE2);\r\n        this.writeEscapedByteDescending(INFINITY);\r\n    }\r\n    /**\r\n     * Resets the buffer such that it is the same as when it was newly\r\n     * constructed.\r\n     */\r\n    reset() {\r\n        this.position = 0;\r\n    }\r\n    seed(encodedBytes) {\r\n        this.ensureAvailable(encodedBytes.length);\r\n        this.buffer.set(encodedBytes, this.position);\r\n        this.position += encodedBytes.length;\r\n    }\r\n    /** Makes a copy of the encoded bytes in this buffer.  */\r\n    encodedBytes() {\r\n        return this.buffer.slice(0, this.position);\r\n    }\r\n    /**\r\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\r\n     * floating-point comparison results with the following exceptions:\r\n     *   -0.0 < 0.0\r\n     *   all non-NaN < NaN\r\n     *   NaN = NaN\r\n     */\r\n    toOrderedBits(val) {\r\n        const value = doubleToLongBits(val);\r\n        // Check if the first bit is set. We use a bit mask since value[0] is\r\n        // encoded as a number from 0 to 255.\r\n        const isNegative = (value[0] & 0x80) !== 0;\r\n        // Revert the two complement to get natural ordering\r\n        value[0] ^= isNegative ? 0xff : 0x80;\r\n        for (let i = 1; i < value.length; ++i) {\r\n            value[i] ^= isNegative ? 0xff : 0x00;\r\n        }\r\n        return value;\r\n    }\r\n    /** Writes a single byte ascending to the buffer. */\r\n    writeByteAscending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteAscending(ESCAPE1);\r\n            this.writeEscapedByteAscending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteAscending(ESCAPE2);\r\n            this.writeEscapedByteAscending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteAscending(masked);\r\n        }\r\n    }\r\n    /** Writes a single byte descending to the buffer.  */\r\n    writeByteDescending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteDescending(ESCAPE1);\r\n            this.writeEscapedByteDescending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteDescending(ESCAPE2);\r\n            this.writeEscapedByteDescending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteDescending(b);\r\n        }\r\n    }\r\n    writeSeparatorAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE1);\r\n        this.writeEscapedByteAscending(SEPARATOR);\r\n    }\r\n    writeSeparatorDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE1);\r\n        this.writeEscapedByteDescending(SEPARATOR);\r\n    }\r\n    writeEscapedByteAscending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = b;\r\n    }\r\n    writeEscapedByteDescending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = ~b;\r\n    }\r\n    ensureAvailable(bytes) {\r\n        const minCapacity = bytes + this.position;\r\n        if (minCapacity <= this.buffer.length) {\r\n            return;\r\n        }\r\n        // Try doubling.\r\n        let newLength = this.buffer.length * 2;\r\n        // Still not big enough? Just allocate the right size.\r\n        if (newLength < minCapacity) {\r\n            newLength = minCapacity;\r\n        }\r\n        // Create the new buffer.\r\n        const newBuffer = new Uint8Array(newLength);\r\n        newBuffer.set(this.buffer); // copy old data\r\n        this.buffer = newBuffer;\r\n    }\r\n}\n\nclass AscendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesAscending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Ascending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberAscending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityAscending();\r\n    }\r\n}\r\nclass DescendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesDescending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Descending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberDescending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityDescending();\r\n    }\r\n}\r\n/**\r\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\r\n * actual encoding.\r\n */\r\nclass IndexByteEncoder {\r\n    constructor() {\r\n        this.orderedCode = new OrderedCodeWriter();\r\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\r\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\r\n    }\r\n    seed(encodedBytes) {\r\n        this.orderedCode.seed(encodedBytes);\r\n    }\r\n    forKind(kind) {\r\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\r\n    }\r\n    encodedBytes() {\r\n        return this.orderedCode.encodedBytes();\r\n    }\r\n    reset() {\r\n        this.orderedCode.reset();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Represents an index entry saved by the SDK in persisted storage. */\r\nclass IndexEntry {\r\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\r\n        this.indexId = indexId;\r\n        this.documentKey = documentKey;\r\n        this.arrayValue = arrayValue;\r\n        this.directionalValue = directionalValue;\r\n    }\r\n    /**\r\n     * Returns an IndexEntry entry that sorts immediately after the current\r\n     * directional value.\r\n     */\r\n    successor() {\r\n        const currentLength = this.directionalValue.length;\r\n        const newLength = currentLength === 0 || this.directionalValue[currentLength - 1] === 255\r\n            ? currentLength + 1\r\n            : currentLength;\r\n        const successor = new Uint8Array(newLength);\r\n        successor.set(this.directionalValue, 0);\r\n        if (newLength !== currentLength) {\r\n            successor.set([0], this.directionalValue.length);\r\n        }\r\n        else {\r\n            ++successor[successor.length - 1];\r\n        }\r\n        return new IndexEntry(this.indexId, this.documentKey, this.arrayValue, successor);\r\n    }\r\n}\r\nfunction indexEntryComparator(left, right) {\r\n    let cmp = left.indexId - right.indexId;\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = compareByteArrays(left.directionalValue, right.directionalValue);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return DocumentKey.comparator(left.documentKey, right.documentKey);\r\n}\r\nfunction compareByteArrays(left, right) {\r\n    for (let i = 0; i < left.length && i < right.length; ++i) {\r\n        const compare = left[i] - right[i];\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return left.length - right.length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A light query planner for Firestore.\r\n *\r\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\r\n * determines whether a given index can be used to serve the specified target.\r\n *\r\n * The following table showcases some possible index configurations:\r\n *\r\n * Query                                               | Index\r\n * -----------------------------------------------------------------------------\r\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\r\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\r\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\r\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\r\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\r\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\r\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\r\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\r\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\r\n */\r\nclass TargetIndexMatcher {\r\n    constructor(target) {\r\n        // The inequality filters of the target (if it exists).\r\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\r\n        // comparator.\r\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\r\n        this.collectionId =\r\n            target.collectionGroup != null\r\n                ? target.collectionGroup\r\n                : target.path.lastSegment();\r\n        this.orderBys = target.orderBy;\r\n        this.equalityFilters = [];\r\n        for (const filter of target.filters) {\r\n            const fieldFilter = filter;\r\n            if (fieldFilter.isInequality()) {\r\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\r\n            }\r\n            else {\r\n                this.equalityFilters.push(fieldFilter);\r\n            }\r\n        }\r\n    }\r\n    get hasMultipleInequality() {\r\n        return this.inequalityFilters.size > 1;\r\n    }\r\n    /**\r\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\r\n     * target.\r\n     *\r\n     * An index is considered capable of serving the target when:\r\n     * - The target uses all index segments for its filters and orderBy clauses.\r\n     *   The target can have additional filter and orderBy clauses, but not\r\n     *   fewer.\r\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\r\n     *   have a corresponding `CONTAINS` segment.\r\n     * - All directional index segments can be mapped to the target as a series of\r\n     *   equality filters, a single inequality filter and a series of orderBy\r\n     *   clauses.\r\n     * - The segments that represent the equality filters may appear out of order.\r\n     * - The optional segment for the inequality filter must appear after all\r\n     *   equality segments.\r\n     * - The segments that represent that orderBy clause of the target must appear\r\n     *   in order after all equality and inequality segments. Single orderBy\r\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\r\n     *   omitted.\r\n     */\r\n    servedByIndex(index) {\r\n        hardAssert(index.collectionGroup === this.collectionId);\r\n        if (this.hasMultipleInequality) {\r\n            // Only single inequality is supported for now.\r\n            // TODO(Add support for multiple inequality query): b/298441043\r\n            return false;\r\n        }\r\n        // If there is an array element, find a matching filter.\r\n        const arraySegment = fieldIndexGetArraySegment(index);\r\n        if (arraySegment !== undefined &&\r\n            !this.hasMatchingEqualityFilter(arraySegment)) {\r\n            return false;\r\n        }\r\n        const segments = fieldIndexGetDirectionalSegments(index);\r\n        let equalitySegments = new Set();\r\n        let segmentIndex = 0;\r\n        let orderBysIndex = 0;\r\n        // Process all equalities first. Equalities can appear out of order.\r\n        for (; segmentIndex < segments.length; ++segmentIndex) {\r\n            // We attempt to greedily match all segments to equality filters. If a\r\n            // filter matches an index segment, we can mark the segment as used.\r\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\r\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\r\n            }\r\n            else {\r\n                // If we cannot find a matching filter, we need to verify whether the\r\n                // remaining segments map to the target's inequality and its orderBy\r\n                // clauses.\r\n                break;\r\n            }\r\n        }\r\n        // If we already have processed all segments, all segments are used to serve\r\n        // the equality filters and we do not need to map any segments to the\r\n        // target's inequality and orderBy clauses.\r\n        if (segmentIndex === segments.length) {\r\n            return true;\r\n        }\r\n        if (this.inequalityFilters.size > 0) {\r\n            // Only a single inequality is currently supported. Get the only entry in the set.\r\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\r\n            // If there is an inequality filter and the field was not in one of the\r\n            // equality filters above, the next segment must match both the filter\r\n            // and the first orderBy clause.\r\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\r\n                const segment = segments[segmentIndex];\r\n                if (!this.matchesFilter(inequalityFilter, segment) ||\r\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\r\n                    return false;\r\n                }\r\n            }\r\n            ++segmentIndex;\r\n        }\r\n        // All remaining segments need to represent the prefix of the target's\r\n        // orderBy.\r\n        for (; segmentIndex < segments.length; ++segmentIndex) {\r\n            const segment = segments[segmentIndex];\r\n            if (orderBysIndex >= this.orderBys.length ||\r\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns a full matched field index for this target. Currently multiple\r\n     * inequality query is not supported so function returns null.\r\n     */\r\n    buildTargetIndex() {\r\n        if (this.hasMultipleInequality) {\r\n            return null;\r\n        }\r\n        // We want to make sure only one segment created for one field. For example,\r\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\r\n        // once.\r\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\r\n        const segments = [];\r\n        for (const filter of this.equalityFilters) {\r\n            if (filter.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n            if (isArrayOperator) {\r\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\r\n            }\r\n            else {\r\n                if (uniqueFields.has(filter.field)) {\r\n                    continue;\r\n                }\r\n                uniqueFields = uniqueFields.add(filter.field);\r\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\r\n            }\r\n        }\r\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\r\n        // on the target defining an appropriate \"order by\" to ensure that the\r\n        // required index segment is added. The query engine would reject a query\r\n        // with an inequality filter that lacks the required order-by clause.\r\n        for (const orderBy of this.orderBys) {\r\n            // Stop adding more segments if we see a order-by on key. Typically this\r\n            // is the default implicit order-by which is covered in the index_entry\r\n            // table as a separate column. If it is not the default order-by, the\r\n            // generated index will be missing some segments optimized for order-bys,\r\n            // which is probably fine.\r\n            if (orderBy.field.isKeyField()) {\r\n                continue;\r\n            }\r\n            if (uniqueFields.has(orderBy.field)) {\r\n                continue;\r\n            }\r\n            uniqueFields = uniqueFields.add(orderBy.field);\r\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\r\n                ? 0 /* IndexKind.ASCENDING */\r\n                : 1 /* IndexKind.DESCENDING */));\r\n        }\r\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\r\n    }\r\n    hasMatchingEqualityFilter(segment) {\r\n        for (const filter of this.equalityFilters) {\r\n            if (this.matchesFilter(filter, segment)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    matchesFilter(filter, segment) {\r\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\r\n            return false;\r\n        }\r\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\r\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\r\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\r\n    }\r\n    matchesOrderBy(orderBy, segment) {\r\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\r\n            return false;\r\n        }\r\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\r\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\r\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\r\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides utility functions that help with boolean logic transformations needed for handling\r\n * complex filters used in queries.\r\n */\r\n/**\r\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\r\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\r\n * input into a disjunction of equality filters and returns the expanded filter.\r\n */\r\nfunction computeInExpansion(filter) {\r\n    var _a, _b;\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        if (filter instanceof InFilter) {\r\n            const expandedFilters = ((_b = (_a = filter.value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value))) || [];\r\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\r\n        }\r\n        else {\r\n            // We have reached other kinds of field filters.\r\n            return filter;\r\n        }\r\n    }\r\n    // We have a composite filter.\r\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\r\n    return CompositeFilter.create(expandedFilters, filter.op);\r\n}\r\n/**\r\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\r\n *\r\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\r\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\r\n * with two elements: a composite filter that performs (A && C), and a composite filter that\r\n * performs (B && C).\r\n *\r\n * @param filter the composite filter to calculate DNF transform for.\r\n * @return the terms in the DNF transform.\r\n */\r\nfunction getDnfTerms(filter) {\r\n    if (filter.getFilters().length === 0) {\r\n        return [];\r\n    }\r\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\r\n    hardAssert(isDisjunctiveNormalForm(result));\r\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\r\n        return [result];\r\n    }\r\n    return result.getFilters();\r\n}\r\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\r\nfunction isSingleFieldFilter(filter) {\r\n    return filter instanceof FieldFilter;\r\n}\r\n/**\r\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\r\n * && b == 20)\r\n */\r\nfunction isFlatConjunction(filter) {\r\n    return (filter instanceof CompositeFilter &&\r\n        compositeFilterIsFlatConjunction(filter));\r\n}\r\n/**\r\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\r\n *\r\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\r\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\r\n *\r\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\r\n */\r\nfunction isDisjunctiveNormalForm(filter) {\r\n    return (isSingleFieldFilter(filter) ||\r\n        isFlatConjunction(filter) ||\r\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\r\n}\r\n/**\r\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\r\n * field filters. e.g. (a == 10) || (b==20 && c==30)\r\n */\r\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\r\n    if (filter instanceof CompositeFilter) {\r\n        if (compositeFilterIsDisjunction(filter)) {\r\n            for (const subFilter of filter.getFilters()) {\r\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction computeDistributedNormalForm(filter) {\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        return filter;\r\n    }\r\n    if (filter.filters.length === 1) {\r\n        return computeDistributedNormalForm(filter.filters[0]);\r\n    }\r\n    // Compute DNF for each of the subfilters first\r\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\r\n    let newFilter = CompositeFilter.create(result, filter.op);\r\n    newFilter = applyAssociation(newFilter);\r\n    if (isDisjunctiveNormalForm(newFilter)) {\r\n        return newFilter;\r\n    }\r\n    hardAssert(newFilter instanceof CompositeFilter);\r\n    hardAssert(compositeFilterIsConjunction(newFilter));\r\n    hardAssert(newFilter.filters.length > 1);\r\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\r\n}\r\nfunction applyDistribution(lhs, rhs) {\r\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter);\r\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter);\r\n    let result;\r\n    if (lhs instanceof FieldFilter) {\r\n        if (rhs instanceof FieldFilter) {\r\n            // FieldFilter FieldFilter\r\n            result = applyDistributionFieldFilters(lhs, rhs);\r\n        }\r\n        else {\r\n            // FieldFilter CompositeFilter\r\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\r\n        }\r\n    }\r\n    else {\r\n        if (rhs instanceof FieldFilter) {\r\n            // CompositeFilter FieldFilter\r\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\r\n        }\r\n        else {\r\n            // CompositeFilter CompositeFilter\r\n            result = applyDistributionCompositeFilters(lhs, rhs);\r\n        }\r\n    }\r\n    return applyAssociation(result);\r\n}\r\nfunction applyDistributionFieldFilters(lhs, rhs) {\r\n    // Conjunction distribution for two field filters is the conjunction of them.\r\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\r\n}\r\nfunction applyDistributionCompositeFilters(lhs, rhs) {\r\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0);\r\n    // There are four cases:\r\n    // (A & B) & (C & D) --> (A & B & C & D)\r\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\r\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\r\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\r\n    // Case 1 is a merge.\r\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\r\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\r\n    }\r\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\r\n    // we should take each element of the disjunction and distribute it over the other side, and\r\n    // return the disjunction of the distribution results.\r\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\r\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\r\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\r\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\r\n}\r\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\r\n    // There are two cases:\r\n    // A & (B & C) --> (A & B & C)\r\n    // A & (B | C) --> (A & B) | (A & C)\r\n    if (compositeFilterIsConjunction(compositeFilter)) {\r\n        // Case 1\r\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\r\n    }\r\n    else {\r\n        // Case 2\r\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\r\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\r\n    }\r\n}\r\n/**\r\n * Applies the associativity property to the given filter and returns the resulting filter.\r\n *\r\n * <ul>\r\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\r\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\r\n * </ul>\r\n *\r\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\r\n */\r\nfunction applyAssociation(filter) {\r\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\r\n    if (filter instanceof FieldFilter) {\r\n        return filter;\r\n    }\r\n    const filters = filter.getFilters();\r\n    // If the composite filter only contains 1 filter, apply associativity to it.\r\n    if (filters.length === 1) {\r\n        return applyAssociation(filters[0]);\r\n    }\r\n    // Associativity applied to a flat composite filter results is itself.\r\n    if (compositeFilterIsFlat(filter)) {\r\n        return filter;\r\n    }\r\n    // First apply associativity to all subfilters. This will in turn recursively apply\r\n    // associativity to all nested composite filters and field filters.\r\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\r\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\r\n    // take out their filters and add them to `compositeFilter`. For example:\r\n    // compositeFilter = (A | (B | C | D))\r\n    // compositeSubfilter = (B | C | D)\r\n    // Result: (A | B | C | D)\r\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\r\n    // added to the top-level \"compositeFilter\".\r\n    const newSubfilters = [];\r\n    updatedFilters.forEach(subfilter => {\r\n        if (subfilter instanceof FieldFilter) {\r\n            newSubfilters.push(subfilter);\r\n        }\r\n        else if (subfilter instanceof CompositeFilter) {\r\n            if (subfilter.op === filter.op) {\r\n                // compositeFilter: (A | (B | C))\r\n                // compositeSubfilter: (B | C)\r\n                // Result: (A | B | C)\r\n                newSubfilters.push(...subfilter.filters);\r\n            }\r\n            else {\r\n                // compositeFilter: (A | (B & C))\r\n                // compositeSubfilter: (B & C)\r\n                // Result: (A | (B & C))\r\n                newSubfilters.push(subfilter);\r\n            }\r\n        }\r\n    });\r\n    if (newSubfilters.length === 1) {\r\n        return newSubfilters[0];\r\n    }\r\n    return CompositeFilter.create(newSubfilters, filter.op);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of IndexManager.\r\n */\r\nclass MemoryIndexManager {\r\n    constructor() {\r\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\r\n    }\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        this.collectionParentIndex.add(collectionPath);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    deleteAllFieldIndexes(transaction) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    createTargetIndexes(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getDocumentsMatchingTarget(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    getIndexType(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve([]);\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    getMinOffset(transaction, target) {\r\n        return PersistencePromise.resolve(IndexOffset.min());\r\n    }\r\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\r\n        return PersistencePromise.resolve(IndexOffset.min());\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\r\n/**\r\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\r\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\r\n * in indexeddb_schema.ts\r\n */\r\nclass MemoryCollectionParentIndex {\r\n    constructor() {\r\n        this.index = {};\r\n    }\r\n    // Returns false if the entry already existed.\r\n    add(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        const added = !existingParents.has(parentPath);\r\n        this.index[collectionId] = existingParents.add(parentPath);\r\n        return added;\r\n    }\r\n    has(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId];\r\n        return existingParents && existingParents.has(parentPath);\r\n    }\r\n    getEntries(collectionId) {\r\n        const parentPaths = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        return parentPaths.toArray();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$f = 'IndexedDbIndexManager';\r\nconst EMPTY_VALUE = new Uint8Array(0);\r\n/**\r\n * A persisted implementation of IndexManager.\r\n *\r\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\r\n * data as it supports multi-tab access.\r\n */\r\nclass IndexedDbIndexManager {\r\n    constructor(user, databaseId) {\r\n        this.databaseId = databaseId;\r\n        /**\r\n         * An in-memory copy of the index entries we've already written since the SDK\r\n         * launched. Used to avoid re-writing the same entry repeatedly.\r\n         *\r\n         * This is *NOT* a complete cache of what's in persistence and so can never be\r\n         * used to satisfy reads.\r\n         */\r\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\r\n        /**\r\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\r\n         * contains only one term from the target's disjunctive normal form (DNF).\r\n         */\r\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\r\n        this.uid = user.uid || '';\r\n    }\r\n    /**\r\n     * Adds a new entry to the collection parent index.\r\n     *\r\n     * Repeated calls for the same collectionPath should be avoided within a\r\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\r\n     * has been committed.\r\n     */\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        if (!this.collectionParentsCache.has(collectionPath)) {\r\n            const collectionId = collectionPath.lastSegment();\r\n            const parentPath = collectionPath.popLast();\r\n            transaction.addOnCommittedListener(() => {\r\n                // Add the collection to the in memory cache only if the transaction was\r\n                // successfully committed.\r\n                this.collectionParentsCache.add(collectionPath);\r\n            });\r\n            const collectionParent = {\r\n                collectionId,\r\n                parent: encodeResourcePath(parentPath)\r\n            };\r\n            return collectionParentsStore(transaction).put(collectionParent);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        const parentPaths = [];\r\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return collectionParentsStore(transaction)\r\n            .loadAll(range)\r\n            .next(entries => {\r\n            for (const entry of entries) {\r\n                // This collectionId guard shouldn't be necessary (and isn't as long\r\n                // as we're running in a real browser), but there's a bug in\r\n                // indexeddbshim that breaks our range in our tests running in node:\r\n                // https://github.com/axemclion/IndexedDBShim/issues/334\r\n                if (entry.collectionId !== collectionId) {\r\n                    break;\r\n                }\r\n                parentPaths.push(decodeResourcePath(entry.parent));\r\n            }\r\n            return parentPaths;\r\n        });\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\r\n        // Safari & Firefox.\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const dbIndex = toDbIndexConfiguration(index);\r\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\r\n        const result = indexes.add(dbIndex);\r\n        if (index.indexState) {\r\n            const states = indexStateStore(transaction);\r\n            return result.next(indexId => {\r\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\r\n            });\r\n        }\r\n        else {\r\n            return result.next();\r\n        }\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        const entries = indexEntriesStore(transaction);\r\n        return indexes\r\n            .delete(index.indexId)\r\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)))\r\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)));\r\n    }\r\n    deleteAllFieldIndexes(transaction) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const entries = indexEntriesStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return indexes\r\n            .deleteAll()\r\n            .next(() => entries.deleteAll())\r\n            .next(() => states.deleteAll());\r\n    }\r\n    createTargetIndexes(transaction, target) {\r\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\r\n            return this.getIndexType(transaction, subTarget).next(type => {\r\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\r\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\r\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\r\n                    if (fieldIndex != null) {\r\n                        return this.addFieldIndex(transaction, fieldIndex);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getDocumentsMatchingTarget(transaction, target) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        let canServeTarget = true;\r\n        const indexes = new Map();\r\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\r\n            return this.getFieldIndex(transaction, subTarget).next(index => {\r\n                canServeTarget && (canServeTarget = !!index);\r\n                indexes.set(subTarget, index);\r\n            });\r\n        }).next(() => {\r\n            if (!canServeTarget) {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n            else {\r\n                let existingKeys = documentKeySet();\r\n                const result = [];\r\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\r\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\r\n                    const arrayValues = targetGetArrayValues(subTarget, index);\r\n                    const notInValues = targetGetNotInValues(subTarget, index);\r\n                    const lowerBound = targetGetLowerBound(subTarget, index);\r\n                    const upperBound = targetGetUpperBound(subTarget, index);\r\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\r\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\r\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\r\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\r\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\r\n                        return indexEntries\r\n                            .loadFirst(indexRange, target.limit)\r\n                            .next(entries => {\r\n                            entries.forEach(entry => {\r\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\r\n                                if (!existingKeys.has(documentKey)) {\r\n                                    existingKeys = existingKeys.add(documentKey);\r\n                                    result.push(documentKey);\r\n                                }\r\n                            });\r\n                        });\r\n                    });\r\n                }).next(() => result);\r\n            }\r\n        });\r\n    }\r\n    getSubTargets(target) {\r\n        let subTargets = this.targetToDnfSubTargets.get(target);\r\n        if (subTargets) {\r\n            return subTargets;\r\n        }\r\n        if (target.filters.length === 0) {\r\n            subTargets = [target];\r\n        }\r\n        else {\r\n            // There is an implicit AND operation between all the filters stored in the target\r\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\r\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\r\n        }\r\n        this.targetToDnfSubTargets.set(target, subTargets);\r\n        return subTargets;\r\n    }\r\n    /**\r\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\r\n     * bounds.\r\n     */\r\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\r\n        // The number of total index scans we union together. This is similar to a\r\n        // distributed normal form, but adapted for array values. We create a single\r\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\r\n        // combined with the values from the query bounds.\r\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\r\n            Math.max(lowerBounds.length, upperBounds.length);\r\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\r\n        const indexRanges = [];\r\n        for (let i = 0; i < totalScans; ++i) {\r\n            const arrayValue = arrayValues\r\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\r\n                : EMPTY_VALUE;\r\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\r\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\r\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \r\n            /* inclusive= */ true));\r\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\r\n        }\r\n        return indexRanges;\r\n    }\r\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\r\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\r\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\r\n        return inclusive ? entry : entry.successor();\r\n    }\r\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\r\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\r\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\r\n        return inclusive ? entry.successor() : entry;\r\n    }\r\n    getFieldIndex(transaction, target) {\r\n        const targetIndexMatcher = new TargetIndexMatcher(target);\r\n        const collectionGroup = target.collectionGroup != null\r\n            ? target.collectionGroup\r\n            : target.path.lastSegment();\r\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\r\n            // Return the index with the most number of segments.\r\n            let index = null;\r\n            for (const candidate of indexes) {\r\n                const matches = targetIndexMatcher.servedByIndex(candidate);\r\n                if (matches &&\r\n                    (!index || candidate.fields.length > index.fields.length)) {\r\n                    index = candidate;\r\n                }\r\n            }\r\n            return index;\r\n        });\r\n    }\r\n    getIndexType(transaction, target) {\r\n        let indexType = 2 /* IndexType.FULL */;\r\n        const subTargets = this.getSubTargets(target);\r\n        return PersistencePromise.forEach(subTargets, (target) => {\r\n            return this.getFieldIndex(transaction, target).next(index => {\r\n                if (!index) {\r\n                    indexType = 0 /* IndexType.NONE */;\r\n                }\r\n                else if (indexType !== 0 /* IndexType.NONE */ &&\r\n                    index.fields.length < targetGetSegmentCount(target)) {\r\n                    indexType = 1 /* IndexType.PARTIAL */;\r\n                }\r\n            });\r\n        }).next(() => {\r\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\r\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\r\n            // and apply the limit in memory as a post-processing step.\r\n            if (targetHasLimit(target) &&\r\n                subTargets.length > 1 &&\r\n                indexType === 2 /* IndexType.FULL */) {\r\n                return 1 /* IndexType.PARTIAL */;\r\n            }\r\n            return indexType;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the byte encoded form of the directional values in the field index.\r\n     * Returns `null` if the document does not have all fields specified in the\r\n     * index.\r\n     */\r\n    encodeDirectionalElements(fieldIndex, document) {\r\n        const encoder = new IndexByteEncoder();\r\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n            const field = document.data.field(segment.fieldPath);\r\n            if (field == null) {\r\n                return null;\r\n            }\r\n            const directionalEncoder = encoder.forKind(segment.kind);\r\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\r\n        }\r\n        return encoder.encodedBytes();\r\n    }\r\n    /** Encodes a single value to the ascending index format. */\r\n    encodeSingleElement(value) {\r\n        const encoder = new IndexByteEncoder();\r\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\r\n        return encoder.encodedBytes();\r\n    }\r\n    /**\r\n     * Returns an encoded form of the document key that sorts based on the key\r\n     * ordering of the field index.\r\n     */\r\n    encodeDirectionalKey(fieldIndex, documentKey) {\r\n        const encoder = new IndexByteEncoder();\r\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\r\n        return encoder.encodedBytes();\r\n    }\r\n    /**\r\n     * Encodes the given field values according to the specification in `target`.\r\n     * For IN queries, a list of possible values is returned.\r\n     */\r\n    encodeValues(fieldIndex, target, values) {\r\n        if (values === null) {\r\n            return [];\r\n        }\r\n        let encoders = [];\r\n        encoders.push(new IndexByteEncoder());\r\n        let valueIdx = 0;\r\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n            const value = values[valueIdx++];\r\n            for (const encoder of encoders) {\r\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\r\n                    encoders = this.expandIndexValues(encoders, segment, value);\r\n                }\r\n                else {\r\n                    const directionalEncoder = encoder.forKind(segment.kind);\r\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\r\n                }\r\n            }\r\n        }\r\n        return this.getEncodedBytes(encoders);\r\n    }\r\n    /**\r\n     * Encodes the given bounds according to the specification in `target`. For IN\r\n     * queries, a list of possible values is returned.\r\n     */\r\n    encodeBound(fieldIndex, target, bound) {\r\n        return this.encodeValues(fieldIndex, target, bound.position);\r\n    }\r\n    /** Returns the byte representation for the provided encoders. */\r\n    getEncodedBytes(encoders) {\r\n        const result = [];\r\n        for (let i = 0; i < encoders.length; ++i) {\r\n            result[i] = encoders[i].encodedBytes();\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a separate encoder for each element of an array.\r\n     *\r\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\r\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\r\n     * list of new encoders is returned.\r\n     */\r\n    expandIndexValues(encoders, segment, value) {\r\n        const prefixes = [...encoders];\r\n        const results = [];\r\n        for (const arrayElement of value.arrayValue.values || []) {\r\n            for (const prefix of prefixes) {\r\n                const clonedEncoder = new IndexByteEncoder();\r\n                clonedEncoder.seed(prefix.encodedBytes());\r\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\r\n                results.push(clonedEncoder);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    isInFilter(target, fieldPath) {\r\n        return !!target.filters.find(f => f instanceof FieldFilter &&\r\n            f.field.isEqual(fieldPath) &&\r\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return (collectionGroup\r\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            : indexes.loadAll()).next(indexConfigs => {\r\n            const result = [];\r\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\r\n                return states\r\n                    .get([indexConfig.indexId, this.uid])\r\n                    .next(indexState => {\r\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\r\n                });\r\n            }).next(() => result);\r\n        });\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        return this.getFieldIndexes(transaction).next(indexes => {\r\n            if (indexes.length === 0) {\r\n                return null;\r\n            }\r\n            indexes.sort((l, r) => {\r\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\r\n                return cmp !== 0\r\n                    ? cmp\r\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\r\n            });\r\n            return indexes[0].collectionGroup;\r\n        });\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\r\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\r\n        // it could be used across different IndexedDB transactions. As any cached\r\n        // data might be invalidated by other multi-tab clients, we can only trust\r\n        // data within a single IndexedDB transaction. We therefore add a cache\r\n        // here.\r\n        const memoizedIndexes = new Map();\r\n        return PersistencePromise.forEach(documents, (key, doc) => {\r\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\r\n            const fieldIndexes = memoizedCollectionIndexes\r\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\r\n                : this.getFieldIndexes(transaction, key.collectionGroup);\r\n            return fieldIndexes.next(fieldIndexes => {\r\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\r\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\r\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\r\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\r\n                        if (!existingEntries.isEqual(newEntries)) {\r\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\r\n                        }\r\n                        return PersistencePromise.resolve();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.put({\r\n            indexId: indexEntry.indexId,\r\n            uid: this.uid,\r\n            arrayValue: indexEntry.arrayValue,\r\n            directionalValue: indexEntry.directionalValue,\r\n            orderedDocumentKey: this.encodeDirectionalKey(fieldIndex, document.key),\r\n            documentKey: document.key.path.toArray()\r\n        });\r\n    }\r\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.delete([\r\n            indexEntry.indexId,\r\n            this.uid,\r\n            indexEntry.arrayValue,\r\n            indexEntry.directionalValue,\r\n            this.encodeDirectionalKey(fieldIndex, document.key),\r\n            document.key.path.toArray()\r\n        ]);\r\n    }\r\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        let results = new SortedSet(indexEntryComparator);\r\n        return indexEntries\r\n            .iterate({\r\n            index: DbIndexEntryDocumentKeyIndex,\r\n            range: IDBKeyRange.only([\r\n                fieldIndex.indexId,\r\n                this.uid,\r\n                this.encodeDirectionalKey(fieldIndex, documentKey)\r\n            ])\r\n        }, (_, entry) => {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\r\n        })\r\n            .next(() => results);\r\n    }\r\n    /** Creates the index entries for the given document. */\r\n    computeIndexEntries(document, fieldIndex) {\r\n        let results = new SortedSet(indexEntryComparator);\r\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\r\n        if (directionalValue == null) {\r\n            return results;\r\n        }\r\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\r\n        if (arraySegment != null) {\r\n            const value = document.data.field(arraySegment.fieldPath);\r\n            if (isArray(value)) {\r\n                for (const arrayValue of value.arrayValue.values || []) {\r\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\r\n        }\r\n        return results;\r\n    }\r\n    /**\r\n     * Updates the index entries for the provided document by deleting entries\r\n     * that are no longer referenced in `newEntries` and adding all newly added\r\n     * entries.\r\n     */\r\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\r\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\r\n        const promises = [];\r\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \r\n        /* onAdd= */ entry => {\r\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\r\n        }, \r\n        /* onRemove= */ entry => {\r\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getNextSequenceNumber(transaction) {\r\n        let nextSequenceNumber = 1;\r\n        const states = indexStateStore(transaction);\r\n        return states\r\n            .iterate({\r\n            index: DbIndexStateSequenceNumberIndex,\r\n            reverse: true,\r\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\r\n        }, (_, state, controller) => {\r\n            controller.done();\r\n            nextSequenceNumber = state.sequenceNumber + 1;\r\n        })\r\n            .next(() => nextSequenceNumber);\r\n    }\r\n    /**\r\n     * Returns a new set of IDB ranges that splits the existing range and excludes\r\n     * any values that match the `notInValue` from these ranges. As an example,\r\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\r\n     */\r\n    createRange(lower, upper, notInValues) {\r\n        // The notIn values need to be sorted and unique so that we can return a\r\n        // sorted set of non-overlapping ranges.\r\n        notInValues = notInValues\r\n            .sort((l, r) => indexEntryComparator(l, r))\r\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\r\n        const bounds = [];\r\n        bounds.push(lower);\r\n        for (const notInValue of notInValues) {\r\n            const cmpToLower = indexEntryComparator(notInValue, lower);\r\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\r\n            if (cmpToLower === 0) {\r\n                // `notInValue` is the lower bound. We therefore need to raise the bound\r\n                // to the next value.\r\n                bounds[0] = lower.successor();\r\n            }\r\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\r\n                // `notInValue` is in the middle of the range\r\n                bounds.push(notInValue);\r\n                bounds.push(notInValue.successor());\r\n            }\r\n            else if (cmpToUpper > 0) {\r\n                // `notInValue` (and all following values) are out of the range\r\n                break;\r\n            }\r\n        }\r\n        bounds.push(upper);\r\n        const ranges = [];\r\n        for (let i = 0; i < bounds.length; i += 2) {\r\n            // If we encounter two bounds that will create an unmatchable key range,\r\n            // then we return an empty set of key ranges.\r\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\r\n                return [];\r\n            }\r\n            const lowerBound = [\r\n                bounds[i].indexId,\r\n                this.uid,\r\n                bounds[i].arrayValue,\r\n                bounds[i].directionalValue,\r\n                EMPTY_VALUE,\r\n                []\r\n            ];\r\n            const upperBound = [\r\n                bounds[i + 1].indexId,\r\n                this.uid,\r\n                bounds[i + 1].arrayValue,\r\n                bounds[i + 1].directionalValue,\r\n                EMPTY_VALUE,\r\n                []\r\n            ];\r\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\r\n        }\r\n        return ranges;\r\n    }\r\n    isRangeMatchable(lowerBound, upperBound) {\r\n        // If lower bound is greater than the upper bound, then the key\r\n        // range can never be matched.\r\n        return indexEntryComparator(lowerBound, upperBound) > 0;\r\n    }\r\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\r\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\r\n    }\r\n    getMinOffset(transaction, target) {\r\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail())).next(getMinOffsetFromFieldIndexes);\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the collectionParents\r\n * document store.\r\n */\r\nfunction collectionParentsStore(txn) {\r\n    return getStore(txn, DbCollectionParentStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index entry object store.\r\n */\r\nfunction indexEntriesStore(txn) {\r\n    return getStore(txn, DbIndexEntryStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index configuration object store.\r\n */\r\nfunction indexConfigurationStore(txn) {\r\n    return getStore(txn, DbIndexConfigurationStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index state object store.\r\n */\r\nfunction indexStateStore(txn) {\r\n    return getStore(txn, DbIndexStateStore);\r\n}\r\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\r\n    hardAssert(fieldIndexes.length !== 0);\r\n    let minOffset = fieldIndexes[0].indexState.offset;\r\n    let maxBatchId = minOffset.largestBatchId;\r\n    for (let i = 1; i < fieldIndexes.length; i++) {\r\n        const newOffset = fieldIndexes[i].indexState.offset;\r\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\r\n            minOffset = newOffset;\r\n        }\r\n        if (maxBatchId < newOffset.largestBatchId) {\r\n            maxBatchId = newOffset.largestBatchId;\r\n        }\r\n    }\r\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Delete a mutation batch and the associated document mutations.\r\n * @returns A PersistencePromise of the document mutations that were removed.\r\n */\r\nfunction removeMutationBatch(txn, userId, batch) {\r\n    const mutationStore = txn.store(DbMutationBatchStore);\r\n    const indexTxn = txn.store(DbDocumentMutationStore);\r\n    const promises = [];\r\n    const range = IDBKeyRange.only(batch.batchId);\r\n    let numDeleted = 0;\r\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\r\n        numDeleted++;\r\n        return control.delete();\r\n    });\r\n    promises.push(removePromise.next(() => {\r\n        hardAssert(numDeleted === 1);\r\n    }));\r\n    const removedDocuments = [];\r\n    for (const mutation of batch.mutations) {\r\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\r\n        promises.push(indexTxn.delete(indexKey));\r\n        removedDocuments.push(mutation.key);\r\n    }\r\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\r\n}\r\n/**\r\n * Returns an approximate size for the given document.\r\n */\r\nfunction dbDocumentSize(doc) {\r\n    if (!doc) {\r\n        return 0;\r\n    }\r\n    let value;\r\n    if (doc.document) {\r\n        value = doc.document;\r\n    }\r\n    else if (doc.unknownDocument) {\r\n        value = doc.unknownDocument;\r\n    }\r\n    else if (doc.noDocument) {\r\n        value = doc.noDocument;\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n    return JSON.stringify(value).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A mutation queue for a specific user, backed by IndexedDB. */\r\nclass IndexedDbMutationQueue {\r\n    constructor(\r\n    /**\r\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\r\n     * retrieve mutations.\r\n     */\r\n    userId, serializer, indexManager, referenceDelegate) {\r\n        this.userId = userId;\r\n        this.serializer = serializer;\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * Caches the document keys for pending mutation batches. If the mutation\r\n         * has been removed from IndexedDb, the cached value may continue to\r\n         * be used to retrieve the batch's document keys. To remove a cached value\r\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\r\n         * or through `removeMutationBatches()`.\r\n         *\r\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\r\n         * this cache is used by secondary clients to invalidate the local\r\n         * view of the documents that were previously affected by the mutation.\r\n         */\r\n        // PORTING NOTE: Multi-tab only.\r\n        this.documentKeysByBatchId = {};\r\n    }\r\n    /**\r\n     * Creates a new mutation queue for the given user.\r\n     * @param user - The user for which to create a mutation queue.\r\n     * @param serializer - The serializer to use when persisting to IndexedDb.\r\n     */\r\n    static forUser(user, serializer, indexManager, referenceDelegate) {\r\n        // TODO(mcg): Figure out what constraints there are on userIDs\r\n        // In particular, are there any reserved characters? are empty ids allowed?\r\n        // For the moment store these together in the same mutations table assuming\r\n        // that empty userIDs aren't allowed.\r\n        hardAssert(user.uid !== '');\r\n        const userId = user.isAuthenticated() ? user.uid : '';\r\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\r\n    }\r\n    checkEmpty(transaction) {\r\n        let empty = true;\r\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\r\n            empty = false;\r\n            control.done();\r\n        })\r\n            .next(() => empty);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const documentStore = documentMutationsStore(transaction);\r\n        const mutationStore = mutationsStore(transaction);\r\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\r\n        // compound indices that include auto-generated keys correctly. To ensure\r\n        // that the index entry is added correctly in all browsers, we perform two\r\n        // writes: The first write is used to retrieve the next auto-generated Batch\r\n        // ID, and the second write populates the index and stores the actual\r\n        // mutation batch.\r\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\r\n        // We write an empty object to obtain key\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return mutationStore.add({}).next(batchId => {\r\n            hardAssert(typeof batchId === 'number');\r\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\r\n            const promises = [];\r\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n            for (const mutation of mutations) {\r\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\r\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\r\n                promises.push(mutationStore.put(dbBatch));\r\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\r\n            }\r\n            collectionParents.forEach(parent => {\r\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\r\n            });\r\n            transaction.addOnCommittedListener(() => {\r\n                this.documentKeysByBatchId[batchId] = batch.keys();\r\n            });\r\n            return PersistencePromise.waitFor(promises).next(() => batch);\r\n        });\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return mutationsStore(transaction)\r\n            .get(batchId)\r\n            .next(dbBatch => {\r\n            if (dbBatch) {\r\n                hardAssert(dbBatch.userId === this.userId);\r\n                return fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the document keys for the mutation batch with the given batchId.\r\n     * For primary clients, this method returns `null` after\r\n     * `removeMutationBatches()` has been called. Secondary clients return a\r\n     * cached result until `removeCachedMutationKeys()` is invoked.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    lookupMutationKeys(transaction, batchId) {\r\n        if (this.documentKeysByBatchId[batchId]) {\r\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\r\n        }\r\n        else {\r\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\r\n                if (batch) {\r\n                    const keys = batch.keys();\r\n                    this.documentKeysByBatchId[batchId] = keys;\r\n                    return keys;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\r\n        let foundBatch = null;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\r\n            if (dbBatch.userId === this.userId) {\r\n                hardAssert(dbBatch.batchId >= nextBatchId);\r\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            control.done();\r\n        })\r\n            .next(() => foundBatch);\r\n    }\r\n    getHighestUnacknowledgedBatchId(transaction) {\r\n        const range = IDBKeyRange.upperBound([\r\n            this.userId,\r\n            Number.POSITIVE_INFINITY\r\n        ]);\r\n        let batchId = BATCHID_UNKNOWN;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\r\n            batchId = dbBatch.batchId;\r\n            control.done();\r\n        })\r\n            .next(() => batchId);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\r\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        // Scan the document-mutation index starting with a prefix starting with\r\n        // the given documentKey.\r\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        const results = [];\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchId] = indexKey;\r\n            // Only consider rows matching exactly the specific key of\r\n            // interest. Note that because we order by path first, and we\r\n            // order terminators before path separators, we'll encounter all\r\n            // the index rows for documentKey contiguously. In particular, all\r\n            // the rows for documentKey will occur before any rows for\r\n            // documents nested in a subcollection beneath documentKey so we\r\n            // can stop as soon as we hit any such row.\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Look up the mutation batch in the store.\r\n            return mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (!mutation) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            });\r\n        })\r\n            .next(() => results);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        const promises = [];\r\n        documentKeys.forEach(documentKey => {\r\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\r\n            const range = IDBKeyRange.lowerBound(indexStart);\r\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\r\n                const [userID, encodedPath, batchID] = indexKey;\r\n                // Only consider rows matching exactly the specific key of\r\n                // interest. Note that because we order by path first, and we\r\n                // order terminators before path separators, we'll encounter all\r\n                // the index rows for documentKey contiguously. In particular, all\r\n                // the rows for documentKey will occur before any rows for\r\n                // documents nested in a subcollection beneath documentKey so we\r\n                // can stop as soon as we hit any such row.\r\n                const path = decodeResourcePath(encodedPath);\r\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n            });\r\n            promises.push(promise);\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        const queryPath = query.path;\r\n        const immediateChildrenLength = queryPath.length + 1;\r\n        // TODO(mcg): Actually implement a single-collection query\r\n        //\r\n        // This is actually executing an ancestor query, traversing the whole\r\n        // subtree below the collection which can be horrifically inefficient for\r\n        // some structures. The right way to solve this is to implement the full\r\n        // value index, but that's not in the cards in the near future so this is\r\n        // the best we can do for the moment.\r\n        //\r\n        // Since we don't yet index the actual properties in the mutations, our\r\n        // current approach is to just return all mutation batches that affect\r\n        // documents in the collection being queried.\r\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\r\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\r\n        // scan of the main table.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchID] = indexKey;\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Rows with document keys more than one segment longer than the\r\n            // query path can't be matches. For example, a query on 'rooms'\r\n            // can't match the document /rooms/abc/messages/xyx.\r\n            // TODO(mcg): we'll need a different scanner when we implement\r\n            // ancestor queries.\r\n            if (path.length !== immediateChildrenLength) {\r\n                return;\r\n            }\r\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n        })\r\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    lookupMutationBatches(transaction, batchIDs) {\r\n        const results = [];\r\n        const promises = [];\r\n        // TODO(rockwood): Implement this using iterate.\r\n        batchIDs.forEach(batchId => {\r\n            promises.push(mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (mutation === null) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            }));\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => results);\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\r\n            transaction.addOnCommittedListener(() => {\r\n                this.removeCachedMutationKeys(batch.batchId);\r\n            });\r\n            return PersistencePromise.forEach(removedDocuments, (key) => {\r\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Clears the cached keys for a mutation batch. This method should be\r\n     * called by secondary clients after they process mutation updates.\r\n     *\r\n     * Note that this method does not have to be called from primary clients as\r\n     * the corresponding cache entries are cleared when an acknowledged or\r\n     * rejected batch is removed from the mutation queue.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    removeCachedMutationKeys(batchId) {\r\n        delete this.documentKeysByBatchId[batchId];\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        return this.checkEmpty(txn).next(empty => {\r\n            if (!empty) {\r\n                return PersistencePromise.resolve();\r\n            }\r\n            // Verify that there are no entries in the documentMutations index if\r\n            // the queue is empty.\r\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\r\n            const danglingMutationReferences = [];\r\n            return documentMutationsStore(txn)\r\n                .iterate({ range: startRange }, (key, _, control) => {\r\n                const userID = key[0];\r\n                if (userID !== this.userId) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                else {\r\n                    const path = decodeResourcePath(key[1]);\r\n                    danglingMutationReferences.push(path);\r\n                }\r\n            })\r\n                .next(() => {\r\n                hardAssert(danglingMutationReferences.length === 0);\r\n            });\r\n        });\r\n    }\r\n    containsKey(txn, key) {\r\n        return mutationQueueContainsKey(txn, this.userId, key);\r\n    }\r\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\r\n    /** Returns the mutation queue's metadata from IndexedDb. */\r\n    getMutationQueueMetadata(transaction) {\r\n        return mutationQueuesStore(transaction)\r\n            .get(this.userId)\r\n            .next((metadata) => {\r\n            return (metadata || {\r\n                userId: this.userId,\r\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\r\n                lastStreamToken: ''\r\n            });\r\n        });\r\n    }\r\n}\r\n/**\r\n * @returns true if the mutation queue for the given user contains a pending\r\n *         mutation for the given key.\r\n */\r\nfunction mutationQueueContainsKey(txn, userId, key) {\r\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\r\n    const encodedPath = indexKey[1];\r\n    const startRange = IDBKeyRange.lowerBound(indexKey);\r\n    let containsKey = false;\r\n    return documentMutationsStore(txn)\r\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\r\n        const [userID, keyPath, /*batchID*/ _] = key;\r\n        if (userID === userId && keyPath === encodedPath) {\r\n            containsKey = true;\r\n        }\r\n        control.done();\r\n    })\r\n        .next(() => containsKey);\r\n}\r\n/** Returns true if any mutation queue contains the given document. */\r\nfunction mutationQueuesContainKey(txn, docKey) {\r\n    let found = false;\r\n    return mutationQueuesStore(txn)\r\n        .iterateSerial(userId => {\r\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\r\n            if (containsKey) {\r\n                found = true;\r\n            }\r\n            return PersistencePromise.resolve(!containsKey);\r\n        });\r\n    })\r\n        .next(() => found);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutations object store.\r\n */\r\nfunction mutationsStore(txn) {\r\n    return getStore(txn, DbMutationBatchStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction documentMutationsStore(txn) {\r\n    return getStore(txn, DbDocumentMutationStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction mutationQueuesStore(txn) {\r\n    return getStore(txn, DbMutationQueueStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Offset to ensure non-overlapping target ids. */\r\nconst OFFSET = 2;\r\n/**\r\n * Generates monotonically increasing target IDs for sending targets to the\r\n * watch stream.\r\n *\r\n * The client constructs two generators, one for the target cache, and one for\r\n * for the sync engine (to generate limbo documents targets). These\r\n * generators produce non-overlapping IDs (by using even and odd IDs\r\n * respectively).\r\n *\r\n * By separating the target ID space, the query cache can generate target IDs\r\n * that persist across client restarts, while sync engine can independently\r\n * generate in-memory target IDs that are transient and can be reused after a\r\n * restart.\r\n */\r\nclass TargetIdGenerator {\r\n    constructor(lastId) {\r\n        this.lastId = lastId;\r\n    }\r\n    next() {\r\n        this.lastId += OFFSET;\r\n        return this.lastId;\r\n    }\r\n    static forTargetCache() {\r\n        // The target cache generator must return '2' in its first call to `next()`\r\n        // as there is no differentiation in the protocol layer between an unset\r\n        // number and the number '0'. If we were to sent a target with target ID\r\n        // '0', the backend would consider it unset and replace it with its own ID.\r\n        return new TargetIdGenerator(2 - OFFSET);\r\n    }\r\n    static forSyncEngine() {\r\n        // Sync engine assigns target IDs for limbo document detection.\r\n        return new TargetIdGenerator(1 - OFFSET);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTargetCache {\r\n    constructor(referenceDelegate, serializer) {\r\n        this.referenceDelegate = referenceDelegate;\r\n        this.serializer = serializer;\r\n    }\r\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\r\n    // some of it (in particular `highestTargetId`) can be modified by secondary\r\n    // tabs. We could perhaps be more granular (and e.g. still cache\r\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\r\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\r\n    // out to have a meaningful performance impact.\r\n    allocateTargetId(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\r\n            metadata.highestTargetId = targetIdGenerator.next();\r\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\r\n        });\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\r\n        });\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            if (lastRemoteSnapshotVersion) {\r\n                metadata.lastRemoteSnapshotVersion =\r\n                    lastRemoteSnapshotVersion.toTimestamp();\r\n            }\r\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\r\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            }\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData).next(() => {\r\n            return this.retrieveMetadata(transaction).next(metadata => {\r\n                metadata.targetCount += 1;\r\n                this.updateMetadataFromTargetData(targetData, metadata);\r\n                return this.saveMetadata(transaction, metadata);\r\n            });\r\n        });\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData);\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\r\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\r\n            .next(() => this.retrieveMetadata(transaction))\r\n            .next(metadata => {\r\n            hardAssert(metadata.targetCount > 0);\r\n            metadata.targetCount -= 1;\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    /**\r\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\r\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\r\n     * Returns the number of targets removed.\r\n     */\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const promises = [];\r\n        return targetsStore(txn)\r\n            .iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                count++;\r\n                promises.push(this.removeTargetData(txn, targetData));\r\n            }\r\n        })\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => count);\r\n    }\r\n    /**\r\n     * Call provided function with each `TargetData` that we have cached.\r\n     */\r\n    forEachTarget(txn, f) {\r\n        return targetsStore(txn).iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            f(targetData);\r\n        });\r\n    }\r\n    retrieveMetadata(transaction) {\r\n        return globalTargetStore(transaction)\r\n            .get(DbTargetGlobalKey)\r\n            .next(metadata => {\r\n            hardAssert(metadata !== null);\r\n            return metadata;\r\n        });\r\n    }\r\n    saveMetadata(transaction, metadata) {\r\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\r\n    }\r\n    saveTargetData(transaction, targetData) {\r\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\r\n    }\r\n    /**\r\n     * In-place updates the provided metadata to account for values in the given\r\n     * TargetData. Saving is done separately. Returns true if there were any\r\n     * changes to the metadata.\r\n     */\r\n    updateMetadataFromTargetData(targetData, metadata) {\r\n        let updated = false;\r\n        if (targetData.targetId > metadata.highestTargetId) {\r\n            metadata.highestTargetId = targetData.targetId;\r\n            updated = true;\r\n        }\r\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\r\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\r\n            updated = true;\r\n        }\r\n        return updated;\r\n    }\r\n    getTargetCount(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        // Iterating by the canonicalId may yield more than one result because\r\n        // canonicalId values are not required to be unique per target. This query\r\n        // depends on the queryTargets index to be efficient.\r\n        const canonicalId = canonifyTarget(target);\r\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\r\n        let result = null;\r\n        return targetsStore(transaction)\r\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\r\n            const found = fromDbTarget(value);\r\n            // After finding a potential match, check that the target is\r\n            // actually equal to the requested target.\r\n            if (targetEquals(target, found.target)) {\r\n                result = found;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const promises = [];\r\n        const store = documentTargetStore(txn);\r\n        keys.forEach(key => {\r\n            const path = encodeResourcePath(key.path);\r\n            promises.push(store.put({ targetId, path }));\r\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const store = documentTargetStore(txn);\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            const path = encodeResourcePath(key.path);\r\n            return PersistencePromise.waitFor([\r\n                store.delete([targetId, path]),\r\n                this.referenceDelegate.removeReference(txn, targetId, key)\r\n            ]);\r\n        });\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        const store = documentTargetStore(txn);\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return store.delete(range);\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        const store = documentTargetStore(txn);\r\n        let result = documentKeySet();\r\n        return store\r\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\r\n            const path = decodeResourcePath(key[1]);\r\n            const docKey = new DocumentKey(path);\r\n            result = result.add(docKey);\r\n        })\r\n            .next(() => result);\r\n    }\r\n    containsKey(txn, key) {\r\n        const path = encodeResourcePath(key.path);\r\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        let count = 0;\r\n        return documentTargetStore(txn)\r\n            .iterate({\r\n            index: DbTargetDocumentDocumentTargetsIndex,\r\n            keysOnly: true,\r\n            range\r\n        }, ([targetId, path], _, control) => {\r\n            // Having a sentinel row for a document does not count as containing that document;\r\n            // For the target cache, containing the document means the document is part of some\r\n            // target.\r\n            if (targetId !== 0) {\r\n                count++;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => count > 0);\r\n    }\r\n    /**\r\n     * Looks up a TargetData entry by target ID.\r\n     *\r\n     * @param targetId - The target ID of the TargetData entry to look up.\r\n     * @returns The cached TargetData entry, or null if the cache has no entry for\r\n     * the target.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    getTargetDataForTarget(transaction, targetId) {\r\n        return targetsStore(transaction)\r\n            .get(targetId)\r\n            .next(found => {\r\n            if (found) {\r\n                return fromDbTarget(found);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the queries object store.\r\n */\r\nfunction targetsStore(txn) {\r\n    return getStore(txn, DbTargetStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the target globals object store.\r\n */\r\nfunction globalTargetStore(txn) {\r\n    return getStore(txn, DbTargetGlobalStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document target object store.\r\n */\r\nfunction documentTargetStore(txn) {\r\n    return getStore(txn, DbTargetDocumentStore);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst GC_DID_NOT_RUN = {\r\n    didRun: false,\r\n    sequenceNumbersCollected: 0,\r\n    targetsRemoved: 0,\r\n    documentsRemoved: 0\r\n};\r\nconst LRU_COLLECTION_DISABLED = -1;\r\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\r\nclass LruParams {\r\n    constructor(\r\n    // When we attempt to collect, we will only do so if the cache size is greater than this\r\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\r\n    cacheSizeCollectionThreshold, \r\n    // The percentage of sequence numbers that we will attempt to collect\r\n    percentileToCollect, \r\n    // A cap on the total number of sequence numbers that will be collected. This prevents\r\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\r\n    maximumSequenceNumbersToCollect) {\r\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\r\n        this.percentileToCollect = percentileToCollect;\r\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\r\n    }\r\n    static withCacheSize(cacheSize) {\r\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\n    }\r\n}\r\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\r\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\r\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$e = 'LruGarbageCollector';\r\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\r\n/** How long we wait to try running LRU GC after SDK initialization. */\r\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\r\n/** Minimum amount of time between GC checks, after the first one. */\r\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\r\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\r\n    const seqCmp = primitiveComparator(aSequence, bSequence);\r\n    if (seqCmp === 0) {\r\n        // This order doesn't matter, but we can bias against churn by sorting\r\n        // entries created earlier as less than newer entries.\r\n        return primitiveComparator(aIndex, bIndex);\r\n    }\r\n    else {\r\n        return seqCmp;\r\n    }\r\n}\r\n/**\r\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\r\n * lowest n values passed to `addElement`, and finally reports the largest of\r\n * them in `maxValue`.\r\n */\r\nclass RollingSequenceNumberBuffer {\r\n    constructor(maxElements) {\r\n        this.maxElements = maxElements;\r\n        this.buffer = new SortedSet(bufferEntryComparator);\r\n        this.previousIndex = 0;\r\n    }\r\n    nextIndex() {\r\n        return ++this.previousIndex;\r\n    }\r\n    addElement(sequenceNumber) {\r\n        const entry = [sequenceNumber, this.nextIndex()];\r\n        if (this.buffer.size < this.maxElements) {\r\n            this.buffer = this.buffer.add(entry);\r\n        }\r\n        else {\r\n            const highestValue = this.buffer.last();\r\n            if (bufferEntryComparator(entry, highestValue) < 0) {\r\n                this.buffer = this.buffer.delete(highestValue).add(entry);\r\n            }\r\n        }\r\n    }\r\n    get maxValue() {\r\n        // Guaranteed to be non-empty. If we decide we are not collecting any\r\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\r\n        // decided that we are collecting n sequence numbers, it's because n is some\r\n        // percentage of the existing sequence numbers. That means we should never\r\n        // be in a situation where we are collecting sequence numbers but don't\r\n        // actually have any.\r\n        return this.buffer.last()[0];\r\n    }\r\n}\r\n/**\r\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\r\n * whether or not GC is enabled, as well as which delay to use before the next run.\r\n */\r\nclass LruScheduler {\r\n    constructor(garbageCollector, asyncQueue, localStore) {\r\n        this.garbageCollector = garbageCollector;\r\n        this.asyncQueue = asyncQueue;\r\n        this.localStore = localStore;\r\n        this.gcTask = null;\r\n    }\r\n    start() {\r\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\r\n            LRU_COLLECTION_DISABLED) {\r\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.gcTask) {\r\n            this.gcTask.cancel();\r\n            this.gcTask = null;\r\n        }\r\n    }\r\n    get started() {\r\n        return this.gcTask !== null;\r\n    }\r\n    scheduleGC(delay) {\r\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\r\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\r\n            this.gcTask = null;\r\n            try {\r\n                await this.localStore.collectGarbage(this.garbageCollector);\r\n            }\r\n            catch (e) {\r\n                if (isIndexedDbTransactionError(e)) {\r\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\r\n                }\r\n                else {\r\n                    await ignoreIfPrimaryLeaseLoss(e);\r\n                }\r\n            }\r\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Implements the steps for LRU garbage collection.\r\n */\r\nclass LruGarbageCollectorImpl {\r\n    constructor(delegate, params) {\r\n        this.delegate = delegate;\r\n        this.params = params;\r\n    }\r\n    calculateTargetCount(txn, percentile) {\r\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\r\n            return Math.floor((percentile / 100.0) * targetCount);\r\n        });\r\n    }\r\n    nthSequenceNumber(txn, n) {\r\n        if (n === 0) {\r\n            return PersistencePromise.resolve(ListenSequence.INVALID);\r\n        }\r\n        const buffer = new RollingSequenceNumberBuffer(n);\r\n        return this.delegate\r\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\r\n            .next(() => {\r\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\r\n        })\r\n            .next(() => buffer.maxValue);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\r\n    }\r\n    collect(txn, activeTargetIds) {\r\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\r\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\r\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\r\n        }\r\n        return this.getCacheSize(txn).next(cacheSize => {\r\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\r\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\r\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\r\n                return GC_DID_NOT_RUN;\r\n            }\r\n            else {\r\n                return this.runGarbageCollection(txn, activeTargetIds);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.delegate.getCacheSize(txn);\r\n    }\r\n    runGarbageCollection(txn, activeTargetIds) {\r\n        let upperBoundSequenceNumber;\r\n        let sequenceNumbersToCollect, targetsRemoved;\r\n        // Timestamps for various pieces of the process\r\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\r\n        const startTs = Date.now();\r\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\r\n            .next(sequenceNumbers => {\r\n            // Cap at the configured max\r\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\r\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\r\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\r\n                    `from ${sequenceNumbers}`);\r\n                sequenceNumbersToCollect =\r\n                    this.params.maximumSequenceNumbersToCollect;\r\n            }\r\n            else {\r\n                sequenceNumbersToCollect = sequenceNumbers;\r\n            }\r\n            countedTargetsTs = Date.now();\r\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\r\n        })\r\n            .next(upperBound => {\r\n            upperBoundSequenceNumber = upperBound;\r\n            foundUpperBoundTs = Date.now();\r\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\r\n        })\r\n            .next(numTargetsRemoved => {\r\n            targetsRemoved = numTargetsRemoved;\r\n            removedTargetsTs = Date.now();\r\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\r\n        })\r\n            .next(documentsRemoved => {\r\n            removedDocumentsTs = Date.now();\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                const desc = 'LRU Garbage Collection\\n' +\r\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\r\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\r\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\r\n                    `\\tRemoved ${targetsRemoved} targets in ` +\r\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\r\n                    `\\tRemoved ${documentsRemoved} documents in ` +\r\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\r\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\r\n                logDebug('LruGarbageCollector', desc);\r\n            }\r\n            return PersistencePromise.resolve({\r\n                didRun: true,\r\n                sequenceNumbersCollected: sequenceNumbersToCollect,\r\n                targetsRemoved,\r\n                documentsRemoved\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction newLruGarbageCollector(delegate, params) {\r\n    return new LruGarbageCollectorImpl(delegate, params);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Provides LRU functionality for IndexedDB persistence. */\r\nclass IndexedDbLruDelegateImpl {\r\n    constructor(db, params) {\r\n        this.db = db;\r\n        this.garbageCollector = newLruGarbageCollector(this, params);\r\n    }\r\n    getSequenceNumberCount(txn) {\r\n        const docCountPromise = this.orphanedDocumentCount(txn);\r\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\r\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\r\n    }\r\n    orphanedDocumentCount(txn) {\r\n        let orphanedCount = 0;\r\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\r\n            orphanedCount++;\r\n        }).next(() => orphanedCount);\r\n    }\r\n    forEachTarget(txn, f) {\r\n        return this.db.getTargetCache().forEachTarget(txn, f);\r\n    }\r\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\r\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Returns true if anything would prevent this document from being garbage\r\n     * collected, given that the document in question is not present in any\r\n     * targets and has a sequence number less than or equal to the upper bound for\r\n     * the collection run.\r\n     */\r\n    isPinned(txn, docKey) {\r\n        return mutationQueuesContainKey(txn, docKey);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        const documentCache = this.db.getRemoteDocumentCache();\r\n        const changeBuffer = documentCache.newChangeBuffer();\r\n        const promises = [];\r\n        let documentCount = 0;\r\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\r\n            if (sequenceNumber <= upperBound) {\r\n                const p = this.isPinned(txn, docKey).next(isPinned => {\r\n                    if (!isPinned) {\r\n                        documentCount++;\r\n                        // Our size accounting requires us to read all documents before\r\n                        // removing them.\r\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\r\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\r\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\r\n                        });\r\n                    }\r\n                });\r\n                promises.push(p);\r\n            }\r\n        });\r\n        return iteration\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => changeBuffer.apply(txn))\r\n            .next(() => documentCount);\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\r\n        return this.db.getTargetCache().updateTargetData(txn, updated);\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\r\n     * means not a part of any target, so the only entry in the target-document index for\r\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\r\n     * number for the last time the document was accessed.\r\n     */\r\n    forEachOrphanedDocument(txn, f) {\r\n        const store = documentTargetStore(txn);\r\n        let nextToReport = ListenSequence.INVALID;\r\n        let nextPath;\r\n        return store\r\n            .iterate({\r\n            index: DbTargetDocumentDocumentTargetsIndex\r\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\r\n            if (targetId === 0) {\r\n                // if nextToReport is valid, report it, this is a new key so the\r\n                // last one must not be a member of any targets.\r\n                if (nextToReport !== ListenSequence.INVALID) {\r\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n                }\r\n                // set nextToReport to be this sequence number. It's the next one we\r\n                // might report, if we don't find any targets for this document.\r\n                // Note that the sequence number must be defined when the targetId\r\n                // is 0.\r\n                nextToReport = sequenceNumber;\r\n                nextPath = path;\r\n            }\r\n            else {\r\n                // set nextToReport to be invalid, we know we don't need to report\r\n                // this one since we found a target for it.\r\n                nextToReport = ListenSequence.INVALID;\r\n            }\r\n        })\r\n            .next(() => {\r\n            // Since we report sequence numbers after getting to the next key, we\r\n            // need to check if the last key we iterated over was an orphaned\r\n            // document and report it.\r\n            if (nextToReport !== ListenSequence.INVALID) {\r\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.db.getRemoteDocumentCache().getSize(txn);\r\n    }\r\n}\r\nfunction sentinelKey$1(key) {\r\n    return [0, encodeResourcePath(key.path)];\r\n}\r\n/**\r\n * @returns A value suitable for writing a sentinel row in the target-document\r\n * store.\r\n */\r\nfunction sentinelRow(key, sequenceNumber) {\r\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\r\n}\r\nfunction writeSentinelKey(txn, key) {\r\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\r\n * It can be used to batch up a set of changes to be written to the cache, but\r\n * additionally supports reading entries back with the `getEntry()` method,\r\n * falling back to the underlying RemoteDocumentCache if no entry is\r\n * buffered.\r\n *\r\n * Entries added to the cache *must* be read first. This is to facilitate\r\n * calculating the size delta of the pending changes.\r\n *\r\n * PORTING NOTE: This class was implemented then removed from other platforms.\r\n * If byte-counting ends up being needed on the other platforms, consider\r\n * porting this class as part of that implementation work.\r\n */\r\nclass RemoteDocumentChangeBuffer {\r\n    constructor() {\r\n        // A mapping of document key to the new cache entry that should be written.\r\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n        this.changesApplied = false;\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\r\n     *\r\n     * You can only modify documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    addEntry(document) {\r\n        this.assertNotApplied();\r\n        this.changes.set(document.key, document);\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\r\n     *\r\n     * You can only remove documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    removeEntry(key, readTime) {\r\n        this.assertNotApplied();\r\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache. The buffered changes will first be checked,\r\n     * and if no buffered change applies, this will forward to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document or an invalid document if we have nothing\r\n     * cached.\r\n     */\r\n    getEntry(transaction, documentKey) {\r\n        this.assertNotApplied();\r\n        const bufferedEntry = this.changes.get(documentKey);\r\n        if (bufferedEntry !== undefined) {\r\n            return PersistencePromise.resolve(bufferedEntry);\r\n        }\r\n        else {\r\n            return this.getFromCache(transaction, documentKey);\r\n        }\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache, forwarding to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKeys - The keys of the entries to look up.\r\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\r\n     *     found, the corresponding key will be mapped to an invalid document.\r\n     */\r\n    getEntries(transaction, documentKeys) {\r\n        return this.getAllFromCache(transaction, documentKeys);\r\n    }\r\n    /**\r\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\r\n     * the provided transaction.\r\n     */\r\n    apply(transaction) {\r\n        this.assertNotApplied();\r\n        this.changesApplied = true;\r\n        return this.applyChanges(transaction);\r\n    }\r\n    /** Helper to assert this.changes is not null  */\r\n    assertNotApplied() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newIndexedDbRemoteDocumentCache()`.\r\n */\r\nclass IndexedDbRemoteDocumentCacheImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entries to the cache.\r\n     *\r\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    addEntry(transaction, key, doc) {\r\n        const documentStore = remoteDocumentsStore(transaction);\r\n        return documentStore.put(doc);\r\n    }\r\n    /**\r\n     * Removes a document from the cache.\r\n     *\r\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    removeEntry(transaction, documentKey, readTime) {\r\n        const store = remoteDocumentsStore(transaction);\r\n        return store.delete(dbReadTimeKey(documentKey, readTime));\r\n    }\r\n    /**\r\n     * Updates the current cache size.\r\n     *\r\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\r\n     * cache's metadata.\r\n     */\r\n    updateMetadata(transaction, sizeDelta) {\r\n        return this.getMetadata(transaction).next(metadata => {\r\n            metadata.byteSize += sizeDelta;\r\n            return this.setMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        let doc = MutableDocument.newInvalidDocument(documentKey);\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentDocumentKeyIndex,\r\n            range: IDBKeyRange.only(dbKey(documentKey))\r\n        }, (_, dbRemoteDoc) => {\r\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\r\n        })\r\n            .next(() => doc);\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache.\r\n     *\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document entry and its size.\r\n     */\r\n    getSizedEntry(transaction, documentKey) {\r\n        let result = {\r\n            size: 0,\r\n            document: MutableDocument.newInvalidDocument(documentKey)\r\n        };\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentDocumentKeyIndex,\r\n            range: IDBKeyRange.only(dbKey(documentKey))\r\n        }, (_, dbRemoteDoc) => {\r\n            result = {\r\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\r\n                size: dbDocumentSize(dbRemoteDoc)\r\n            };\r\n        })\r\n            .next(() => result);\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n        }).next(() => results);\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache.\r\n     *\r\n     * @param documentKeys - The set of keys entries to look up.\r\n     * @returns A map of documents indexed by key and a map of sizes indexed by\r\n     *     key (zero if the document does not exist).\r\n     */\r\n    getSizedEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        let sizeMap = new SortedMap(DocumentKey.comparator);\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\r\n        }).next(() => {\r\n            return { documents: results, sizeMap };\r\n        });\r\n    }\r\n    forEachDbEntry(transaction, documentKeys, callback) {\r\n        if (documentKeys.isEmpty()) {\r\n            return PersistencePromise.resolve();\r\n        }\r\n        let sortedKeys = new SortedSet(dbKeyComparator);\r\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\r\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\r\n        const keyIter = sortedKeys.getIterator();\r\n        let nextKey = keyIter.getNext();\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\r\n            const potentialKey = DocumentKey.fromSegments([\r\n                ...dbRemoteDoc.prefixPath,\r\n                dbRemoteDoc.collectionGroup,\r\n                dbRemoteDoc.documentId\r\n            ]);\r\n            // Go through keys not found in cache.\r\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.getNext();\r\n            }\r\n            if (nextKey && nextKey.isEqual(potentialKey)) {\r\n                // Key found in cache.\r\n                callback(nextKey, dbRemoteDoc);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n            // Skip to the next key (if there is one).\r\n            if (nextKey) {\r\n                control.skip(dbKey(nextKey));\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => {\r\n            // The rest of the keys are not in the cache. One case where `iterate`\r\n            // above won't go through them is when the cache is empty.\r\n            while (nextKey) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n        });\r\n    }\r\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\r\n        const collection = query.path;\r\n        const startKey = [\r\n            collection.popLast().toArray(),\r\n            collection.lastSegment(),\r\n            toDbTimestampKey(offset.readTime),\r\n            offset.documentKey.path.isEmpty()\r\n                ? ''\r\n                : offset.documentKey.path.lastSegment()\r\n        ];\r\n        const endKey = [\r\n            collection.popLast().toArray(),\r\n            collection.lastSegment(),\r\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\r\n            ''\r\n        ];\r\n        return remoteDocumentsStore(transaction)\r\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\r\n            .next(dbRemoteDocs => {\r\n            context === null || context === void 0 ? void 0 : context.incrementDocumentReadCount(dbRemoteDocs.length);\r\n            let results = mutableDocumentMap();\r\n            for (const dbRemoteDoc of dbRemoteDocs) {\r\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\r\n                if (document.isFoundDocument() &&\r\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\r\n                    // Either the document matches the given query, or it is mutated.\r\n                    results = results.insert(document.key, document);\r\n                }\r\n            }\r\n            return results;\r\n        });\r\n    }\r\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\r\n        let results = mutableDocumentMap();\r\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\r\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({\r\n            index: DbRemoteDocumentCollectionGroupIndex,\r\n            range: IDBKeyRange.bound(startKey, endKey, true)\r\n        }, (_, dbRemoteDoc, control) => {\r\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\r\n            results = results.insert(document.key, document);\r\n            if (results.size === limit) {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => results);\r\n    }\r\n    newChangeBuffer(options) {\r\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\r\n    }\r\n    getSize(txn) {\r\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\r\n    }\r\n    getMetadata(txn) {\r\n        return documentGlobalStore(txn)\r\n            .get(DbRemoteDocumentGlobalKey)\r\n            .next(metadata => {\r\n            hardAssert(!!metadata);\r\n            return metadata;\r\n        });\r\n    }\r\n    setMetadata(txn, metadata) {\r\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\r\n    }\r\n    /**\r\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\r\n     * the document corresponds to the format used for sentinel deletes).\r\n     */\r\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\r\n        if (dbRemoteDoc) {\r\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\r\n            // Whether the document is a sentinel removal and should only be used in the\r\n            // `getNewDocumentChanges()`\r\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\r\n            if (!isSentinelRemoval) {\r\n                return doc;\r\n            }\r\n        }\r\n        return MutableDocument.newInvalidDocument(documentKey);\r\n    }\r\n}\r\n/** Creates a new IndexedDbRemoteDocumentCache. */\r\nfunction newIndexedDbRemoteDocumentCache(serializer) {\r\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\r\n *\r\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\r\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\r\n * when we apply the changes.\r\n */\r\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    /**\r\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\r\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\r\n     * `getNewDocumentChanges()`.\r\n     */\r\n    constructor(documentCache, trackRemovals) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n        this.trackRemovals = trackRemovals;\r\n        // A map of document sizes and read times prior to applying the changes in\r\n        // this buffer.\r\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        let sizeDelta = 0;\r\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n        this.changes.forEach((key, documentChange) => {\r\n            const previousDoc = this.documentStates.get(key);\r\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\r\n            if (documentChange.isValidDocument()) {\r\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\r\n                collectionParents = collectionParents.add(key.path.popLast());\r\n                const size = dbDocumentSize(doc);\r\n                sizeDelta += size - previousDoc.size;\r\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\r\n            }\r\n            else {\r\n                sizeDelta -= previousDoc.size;\r\n                if (this.trackRemovals) {\r\n                    // In order to track removals, we store a \"sentinel delete\" in the\r\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\r\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\r\n                    // preserved in `getNewDocumentChanges()`.\r\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\r\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\r\n                }\r\n            }\r\n        });\r\n        collectionParents.forEach(parent => {\r\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\r\n        });\r\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        // Record the size of everything we load from the cache so we can compute a delta later.\r\n        return this.documentCache\r\n            .getSizedEntry(transaction, documentKey)\r\n            .next(getResult => {\r\n            this.documentStates.set(documentKey, {\r\n                size: getResult.size,\r\n                readTime: getResult.document.readTime\r\n            });\r\n            return getResult.document;\r\n        });\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        // Record the size of everything we load from the cache so we can compute\r\n        // a delta later.\r\n        return this.documentCache\r\n            .getSizedEntries(transaction, documentKeys)\r\n            .next(({ documents, sizeMap }) => {\r\n            // Note: `getAllFromCache` returns two maps instead of a single map from\r\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\r\n            // `MutableDocumentMap` directly, without a conversion.\r\n            sizeMap.forEach((documentKey, size) => {\r\n                this.documentStates.set(documentKey, {\r\n                    size,\r\n                    readTime: documents.get(documentKey).readTime\r\n                });\r\n            });\r\n            return documents;\r\n        });\r\n    }\r\n}\r\nfunction documentGlobalStore(txn) {\r\n    return getStore(txn, DbRemoteDocumentGlobalStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\r\n */\r\nfunction remoteDocumentsStore(txn) {\r\n    return getStore(txn, DbRemoteDocumentStore);\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups on the\r\n * `DbRemoteDocumentDocumentKeyIndex` index.\r\n */\r\nfunction dbKey(documentKey) {\r\n    const path = documentKey.path.toArray();\r\n    return [\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* collection id */ path[path.length - 2],\r\n        /* document id */ path[path.length - 1]\r\n    ];\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups via the primary key of\r\n * the DbRemoteDocument object store.\r\n */\r\nfunction dbReadTimeKey(documentKey, readTime) {\r\n    const path = documentKey.path.toArray();\r\n    return [\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* collection id */ path[path.length - 2],\r\n        toDbTimestampKey(readTime),\r\n        /* document id */ path[path.length - 1]\r\n    ];\r\n}\r\n/**\r\n * Returns a key that can be used for document lookups on the\r\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\r\n */\r\nfunction dbCollectionGroupKey(collectionGroup, offset) {\r\n    const path = offset.documentKey.path.toArray();\r\n    return [\r\n        /* collection id */ collectionGroup,\r\n        toDbTimestampKey(offset.readTime),\r\n        /* prefix path */ path.slice(0, path.length - 2),\r\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\r\n    ];\r\n}\r\n/**\r\n * Comparator that compares document keys according to the primary key sorting\r\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\r\n * and then document ID).\r\n *\r\n * Visible for testing.\r\n */\r\nfunction dbKeyComparator(l, r) {\r\n    const left = l.path.toArray();\r\n    const right = r.path.toArray();\r\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\r\n    let cmp = 0;\r\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\r\n        cmp = primitiveComparator(left[i], right[i]);\r\n        if (cmp) {\r\n            return cmp;\r\n        }\r\n    }\r\n    cmp = primitiveComparator(left.length, right.length);\r\n    if (cmp) {\r\n        return cmp;\r\n    }\r\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\r\n    if (cmp) {\r\n        return cmp;\r\n    }\r\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Schema Version for the Web client:\r\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\r\n *     Document Cache\r\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\r\n *     longer required because migration 3 unconditionally clears it.\r\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\r\n *     to limbo resolution. Addresses\r\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\r\n * 4.  Multi-Tab Support.\r\n * 5.  Removal of held write acks.\r\n * 6.  Create document global for tracking document cache size.\r\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\r\n * 8.  Add collection-parent index for Collection Group queries.\r\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\r\n *     an auto-incrementing ID. This is required for Index-Free queries.\r\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\r\n * 11. Add bundles and named_queries for bundle support.\r\n * 12. Add document overlays.\r\n * 13. Rewrite the keys of the remote document cache to allow for efficient\r\n *     document lookup via `getAll()`.\r\n * 14. Add overlays.\r\n * 15. Add indexing support.\r\n * 16. Parse timestamp strings before creating index entries.\r\n */\r\nconst SCHEMA_VERSION = 16;\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a local view (overlay) of a document, and the fields that are\r\n * locally mutated.\r\n */\r\nclass OverlayedDocument {\r\n    constructor(overlayedDocument, \r\n    /**\r\n     * The fields that are locally mutated by patch mutations.\r\n     *\r\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\r\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\r\n     */\r\n    mutatedFields) {\r\n        this.overlayedDocument = overlayedDocument;\r\n        this.mutatedFields = mutatedFields;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A readonly view of the local state of all documents we're tracking (i.e. we\r\n * have a cached version in remoteDocumentCache or local mutations for the\r\n * document). The view is computed by applying the mutations in the\r\n * MutationQueue to the RemoteDocumentCache.\r\n */\r\nclass LocalDocumentsView {\r\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\r\n        this.remoteDocumentCache = remoteDocumentCache;\r\n        this.mutationQueue = mutationQueue;\r\n        this.documentOverlayCache = documentOverlayCache;\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Get the local view of the document identified by `key`.\r\n     *\r\n     * @returns Local view of the document or null if we don't have any cached\r\n     * state for it.\r\n     */\r\n    getDocument(transaction, key) {\r\n        let overlay = null;\r\n        return this.documentOverlayCache\r\n            .getOverlay(transaction, key)\r\n            .next(value => {\r\n            overlay = value;\r\n            return this.remoteDocumentCache.getEntry(transaction, key);\r\n        })\r\n            .next(document => {\r\n            if (overlay !== null) {\r\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\r\n            }\r\n            return document;\r\n        });\r\n    }\r\n    /**\r\n     * Gets the local view of the documents identified by `keys`.\r\n     *\r\n     * If we don't have cached state for a document in `keys`, a NoDocument will\r\n     * be stored for that key in the resulting set.\r\n     */\r\n    getDocuments(transaction, keys) {\r\n        return this.remoteDocumentCache\r\n            .getEntries(transaction, keys)\r\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\r\n    }\r\n    /**\r\n     * Similar to `getDocuments`, but creates the local view from the given\r\n     * `baseDocs` without retrieving documents from the local store.\r\n     *\r\n     * @param transaction - The transaction this operation is scoped to.\r\n     * @param docs - The documents to apply local mutations to get the local views.\r\n     * @param existenceStateChanged - The set of document keys whose existence state\r\n     *   is changed. This is useful to determine if some documents overlay needs\r\n     *   to be recalculated.\r\n     */\r\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\r\n        const overlays = newOverlayMap();\r\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\r\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\r\n                let result = documentMap();\r\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\r\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\r\n                });\r\n                return result;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Gets the overlayed documents for the given document map, which will include\r\n     * the local view of those documents and a `FieldMask` indicating which fields\r\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\r\n     */\r\n    getOverlayedDocuments(transaction, docs) {\r\n        const overlays = newOverlayMap();\r\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\r\n    }\r\n    /**\r\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\r\n     * if the map does not already contain an entry for the given document key.\r\n     */\r\n    populateOverlays(transaction, overlays, docs) {\r\n        const missingOverlays = [];\r\n        docs.forEach(key => {\r\n            if (!overlays.has(key)) {\r\n                missingOverlays.push(key);\r\n            }\r\n        });\r\n        return this.documentOverlayCache\r\n            .getOverlays(transaction, missingOverlays)\r\n            .next(result => {\r\n            result.forEach((key, val) => {\r\n                overlays.set(key, val);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Computes the local view for the given documents.\r\n     *\r\n     * @param docs - The documents to compute views for. It also has the base\r\n     *   version of the documents.\r\n     * @param overlays - The overlays that need to be applied to the given base\r\n     *   version of the documents.\r\n     * @param existenceStateChanged - A set of documents whose existence states\r\n     *   might have changed. This is used to determine if we need to re-calculate\r\n     *   overlays from mutation queues.\r\n     * @return A map represents the local documents view.\r\n     */\r\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\r\n        let recalculateDocuments = mutableDocumentMap();\r\n        const mutatedFields = newDocumentKeyMap();\r\n        const results = newOverlayedDocumentMap();\r\n        docs.forEach((_, doc) => {\r\n            const overlay = overlays.get(doc.key);\r\n            // Recalculate an overlay if the document's existence state changed due to\r\n            // a remote event *and* the overlay is a PatchMutation. This is because\r\n            // document existence state can change if some patch mutation's\r\n            // preconditions are met.\r\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\r\n            // might be a patch mutation whose precondition does not match before the\r\n            // change (hence overlay is undefined), but would now match.\r\n            if (existenceStateChanged.has(doc.key) &&\r\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\r\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\r\n            }\r\n            else if (overlay !== undefined) {\r\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\r\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\r\n            }\r\n            else {\r\n                // no overlay exists\r\n                // Using EMPTY to indicate there is no overlay for the document.\r\n                mutatedFields.set(doc.key, FieldMask.empty());\r\n            }\r\n        });\r\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\r\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\r\n            docs.forEach((documentKey, document) => {\r\n                var _a;\r\n                return results.set(documentKey, new OverlayedDocument(document, (_a = mutatedFields.get(documentKey)) !== null && _a !== void 0 ? _a : null));\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n    recalculateAndSaveOverlays(transaction, docs) {\r\n        const masks = newDocumentKeyMap();\r\n        // A reverse lookup map from batch id to the documents within that batch.\r\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\r\n        let processed = documentKeySet();\r\n        return this.mutationQueue\r\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\r\n            .next(batches => {\r\n            for (const batch of batches) {\r\n                batch.keys().forEach(key => {\r\n                    const baseDoc = docs.get(key);\r\n                    if (baseDoc === null) {\r\n                        return;\r\n                    }\r\n                    let mask = masks.get(key) || FieldMask.empty();\r\n                    mask = batch.applyToLocalView(baseDoc, mask);\r\n                    masks.set(key, mask);\r\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\r\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\r\n                });\r\n            }\r\n        })\r\n            .next(() => {\r\n            const promises = [];\r\n            // Iterate in descending order of batch IDs, and skip documents that are\r\n            // already saved.\r\n            const iter = documentsByBatchId.getReverseIterator();\r\n            while (iter.hasNext()) {\r\n                const entry = iter.getNext();\r\n                const batchId = entry.key;\r\n                const keys = entry.value;\r\n                const overlays = newMutationMap();\r\n                keys.forEach(key => {\r\n                    if (!processed.has(key)) {\r\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\r\n                        if (overlayMutation !== null) {\r\n                            overlays.set(key, overlayMutation);\r\n                        }\r\n                        processed = processed.add(key);\r\n                    }\r\n                });\r\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\r\n            }\r\n            return PersistencePromise.waitFor(promises);\r\n        })\r\n            .next(() => masks);\r\n    }\r\n    /**\r\n     * Recalculates overlays by reading the documents from remote document cache\r\n     * first, and saves them after they are calculated.\r\n     */\r\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\r\n        return this.remoteDocumentCache\r\n            .getEntries(transaction, documentKeys)\r\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\r\n    }\r\n    /**\r\n     * Performs a query against the local view of all documents.\r\n     *\r\n     * @param transaction - The persistence transaction.\r\n     * @param query - The query to match documents against.\r\n     * @param offset - Read time and key to start scanning by (exclusive).\r\n     * @param context - A optional tracker to keep a record of important details\r\n     *   during database local query execution.\r\n     */\r\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\r\n        if (isDocumentQuery$1(query)) {\r\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\r\n        }\r\n        else if (isCollectionGroupQuery(query)) {\r\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\r\n        }\r\n        else {\r\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\r\n        }\r\n    }\r\n    /**\r\n     * Given a collection group, returns the next documents that follow the provided offset, along\r\n     * with an updated batch ID.\r\n     *\r\n     * <p>The documents returned by this method are ordered by remote version from the provided\r\n     * offset. If there are no more remote documents after the provided offset, documents with\r\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\r\n     * returned together, the total number of documents returned can exceed {@code count}.\r\n     *\r\n     * @param transaction\r\n     * @param collectionGroup The collection group for the documents.\r\n     * @param offset The offset to index into.\r\n     * @param count The number of documents to return\r\n     * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\r\n     */\r\n    getNextDocuments(transaction, collectionGroup, offset, count) {\r\n        return this.remoteDocumentCache\r\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\r\n            .next((originalDocs) => {\r\n            const overlaysPromise = count - originalDocs.size > 0\r\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\r\n                : PersistencePromise.resolve(newOverlayMap());\r\n            // The callsite will use the largest batch ID together with the latest read time to create\r\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\r\n            // no overlay will increase the overall read time. This is why we only need to special case\r\n            // the batch id.\r\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\r\n            let modifiedDocs = originalDocs;\r\n            return overlaysPromise.next(overlays => {\r\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\r\n                    if (largestBatchId < overlay.largestBatchId) {\r\n                        largestBatchId = overlay.largestBatchId;\r\n                    }\r\n                    if (originalDocs.get(key)) {\r\n                        return PersistencePromise.resolve();\r\n                    }\r\n                    return this.remoteDocumentCache\r\n                        .getEntry(transaction, key)\r\n                        .next(doc => {\r\n                        modifiedDocs = modifiedDocs.insert(key, doc);\r\n                    });\r\n                })\r\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\r\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\r\n                    .next(localDocs => ({\r\n                    batchId: largestBatchId,\r\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\r\n                }));\r\n            });\r\n        });\r\n    }\r\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\r\n        // Just do a simple document lookup.\r\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\r\n            let result = documentMap();\r\n            if (document.isFoundDocument()) {\r\n                result = result.insert(document.key, document);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\r\n        const collectionId = query.collectionGroup;\r\n        let results = documentMap();\r\n        return this.indexManager\r\n            .getCollectionParents(transaction, collectionId)\r\n            .next(parents => {\r\n            // Perform a collection query against each parent that contains the\r\n            // collectionId and aggregate the results.\r\n            return PersistencePromise.forEach(parents, (parent) => {\r\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\r\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\r\n                    r.forEach((key, doc) => {\r\n                        results = results.insert(key, doc);\r\n                    });\r\n                });\r\n            }).next(() => results);\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\r\n        // Query the remote documents and overlay mutations.\r\n        let overlays;\r\n        return this.documentOverlayCache\r\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\r\n            .next(result => {\r\n            overlays = result;\r\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\r\n        })\r\n            .next(remoteDocuments => {\r\n            // As documents might match the query because of their overlay we need to\r\n            // include documents for all overlays in the initial document set.\r\n            overlays.forEach((_, overlay) => {\r\n                const key = overlay.getKey();\r\n                if (remoteDocuments.get(key) === null) {\r\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\r\n                }\r\n            });\r\n            // Apply the overlays and match against the query.\r\n            let results = documentMap();\r\n            remoteDocuments.forEach((key, document) => {\r\n                const overlay = overlays.get(key);\r\n                if (overlay !== undefined) {\r\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\r\n                }\r\n                // Finally, insert the documents that still match the query\r\n                if (queryMatches(query, document)) {\r\n                    results = results.insert(key, document);\r\n                }\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryBundleCache {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n        this.bundles = new Map();\r\n        this.namedQueries = new Map();\r\n    }\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of DocumentOverlayCache.\r\n */\r\nclass MemoryDocumentOverlayCache {\r\n    constructor() {\r\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\r\n        // for the overlay and the overlay itself.\r\n        this.overlays = new SortedMap(DocumentKey.comparator);\r\n        this.overlayByBatchId = new Map();\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return PersistencePromise.resolve(this.overlays.get(key));\r\n    }\r\n    getOverlays(transaction, keys) {\r\n        const result = newOverlayMap();\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            return this.getOverlay(transaction, key).next(overlay => {\r\n                if (overlay !== null) {\r\n                    result.set(key, overlay);\r\n                }\r\n            });\r\n        }).next(() => result);\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        overlays.forEach((_, mutation) => {\r\n            this.saveOverlay(transaction, largestBatchId, mutation);\r\n        });\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const keys = this.overlayByBatchId.get(batchId);\r\n        if (keys !== undefined) {\r\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\r\n            this.overlayByBatchId.delete(batchId);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = newOverlayMap();\r\n        const immediateChildrenPathLength = collection.length + 1;\r\n        const prefix = new DocumentKey(collection.child(''));\r\n        const iter = this.overlays.getIteratorFrom(prefix);\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (!collection.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            // Documents from sub-collections\r\n            if (key.path.length !== immediateChildrenPathLength) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\r\n        const iter = this.overlays.getIterator();\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (key.getCollectionGroup() !== collectionGroup) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\r\n                if (overlaysForBatchId === null) {\r\n                    overlaysForBatchId = newOverlayMap();\r\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\r\n                }\r\n                overlaysForBatchId.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        const result = newOverlayMap();\r\n        const batchIter = batchIdToOverlays.getIterator();\r\n        while (batchIter.hasNext()) {\r\n            const entry = batchIter.getNext();\r\n            const overlays = entry.value;\r\n            overlays.forEach((key, overlay) => result.set(key, overlay));\r\n            if (result.size() >= count) {\r\n                break;\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    saveOverlay(transaction, largestBatchId, mutation) {\r\n        // Remove the association of the overlay to its batch id.\r\n        const existing = this.overlays.get(mutation.key);\r\n        if (existing !== null) {\r\n            const newSet = this.overlayByBatchId\r\n                .get(existing.largestBatchId)\r\n                .delete(mutation.key);\r\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\r\n        }\r\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\r\n        // Create the association of this overlay to the given largestBatchId.\r\n        let batch = this.overlayByBatchId.get(largestBatchId);\r\n        if (batch === undefined) {\r\n            batch = documentKeySet();\r\n            this.overlayByBatchId.set(largestBatchId, batch);\r\n        }\r\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A collection of references to a document from some kind of numbered entity\r\n * (either a target ID or batch ID). As references are added to or removed from\r\n * the set corresponding events are emitted to a registered garbage collector.\r\n *\r\n * Each reference is represented by a DocumentReference object. Each of them\r\n * contains enough information to uniquely identify the reference. They are all\r\n * stored primarily in a set sorted by key. A document is considered garbage if\r\n * there's no references in that set (this can be efficiently checked thanks to\r\n * sorting by key).\r\n *\r\n * ReferenceSet also keeps a secondary set that contains references sorted by\r\n * IDs. This one is used to efficiently implement removal of all references by\r\n * some target ID.\r\n */\r\nclass ReferenceSet {\r\n    constructor() {\r\n        // A set of outstanding references to a document sorted by key.\r\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\r\n        // A set of outstanding references to a document sorted by target id.\r\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\r\n    }\r\n    /** Returns true if the reference set contains no references. */\r\n    isEmpty() {\r\n        return this.refsByKey.isEmpty();\r\n    }\r\n    /** Adds a reference to the given document key for the given ID. */\r\n    addReference(key, id) {\r\n        const ref = new DocReference(key, id);\r\n        this.refsByKey = this.refsByKey.add(ref);\r\n        this.refsByTarget = this.refsByTarget.add(ref);\r\n    }\r\n    /** Add references to the given document keys for the given ID. */\r\n    addReferences(keys, id) {\r\n        keys.forEach(key => this.addReference(key, id));\r\n    }\r\n    /**\r\n     * Removes a reference to the given document key for the given\r\n     * ID.\r\n     */\r\n    removeReference(key, id) {\r\n        this.removeRef(new DocReference(key, id));\r\n    }\r\n    removeReferences(keys, id) {\r\n        keys.forEach(key => this.removeReference(key, id));\r\n    }\r\n    /**\r\n     * Clears all references with a given ID. Calls removeRef() for each key\r\n     * removed.\r\n     */\r\n    removeReferencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        const keys = [];\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            this.removeRef(ref);\r\n            keys.push(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    removeAllReferences() {\r\n        this.refsByKey.forEach(ref => this.removeRef(ref));\r\n    }\r\n    removeRef(ref) {\r\n        this.refsByKey = this.refsByKey.delete(ref);\r\n        this.refsByTarget = this.refsByTarget.delete(ref);\r\n    }\r\n    referencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        let keys = documentKeySet();\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            keys = keys.add(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    containsKey(key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\r\n        return firstRef !== null && key.isEqual(firstRef.key);\r\n    }\r\n}\r\nclass DocReference {\r\n    constructor(key, targetOrBatchId) {\r\n        this.key = key;\r\n        this.targetOrBatchId = targetOrBatchId;\r\n    }\r\n    /** Compare by key then by ID */\r\n    static compareByKey(left, right) {\r\n        return (DocumentKey.comparator(left.key, right.key) ||\r\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\r\n    }\r\n    /** Compare by ID then by key */\r\n    static compareByTargetId(left, right) {\r\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\r\n            DocumentKey.comparator(left.key, right.key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryMutationQueue {\r\n    constructor(indexManager, referenceDelegate) {\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * The set of all mutations that have been sent but not yet been applied to\r\n         * the backend.\r\n         */\r\n        this.mutationQueue = [];\r\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\r\n        this.nextBatchId = 1;\r\n        /** An ordered mapping between documents and the mutations batch IDs. */\r\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\r\n    }\r\n    checkEmpty(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const batchId = this.nextBatchId;\r\n        this.nextBatchId++;\r\n        if (this.mutationQueue.length > 0) {\r\n            this.mutationQueue[this.mutationQueue.length - 1];\r\n        }\r\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n        this.mutationQueue.push(batch);\r\n        // Track references by document key and index collection parents.\r\n        for (const mutation of mutations) {\r\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\r\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\r\n        }\r\n        return PersistencePromise.resolve(batch);\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        // The requested batchId may still be out of range so normalize it to the\r\n        // start of the queue.\r\n        const rawIndex = this.indexOfBatchId(nextBatchId);\r\n        const index = rawIndex < 0 ? 0 : rawIndex;\r\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\r\n    }\r\n    getHighestUnacknowledgedBatchId() {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.slice());\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        const start = new DocReference(documentKey, 0);\r\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n        const result = [];\r\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\r\n            result.push(batch);\r\n        });\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        documentKeys.forEach(documentKey => {\r\n            const start = new DocReference(documentKey, 0);\r\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n            });\r\n        });\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        // Use the query path as a prefix for testing if a document matches the\r\n        // query.\r\n        const prefix = query.path;\r\n        const immediateChildrenPathLength = prefix.length + 1;\r\n        // Construct a document reference for actually scanning the index. Unlike\r\n        // the prefix the document key in this reference must have an even number of\r\n        // segments. The empty segment can be used a suffix of the query path\r\n        // because it precedes all other segments in an ordered traversal.\r\n        let startPath = prefix;\r\n        if (!DocumentKey.isDocumentKey(startPath)) {\r\n            startPath = startPath.child('');\r\n        }\r\n        const start = new DocReference(new DocumentKey(startPath), 0);\r\n        // Find unique batchIDs referenced by all documents potentially matching the\r\n        // query.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        this.batchesByDocumentKey.forEachWhile(ref => {\r\n            const rowKeyPath = ref.key.path;\r\n            if (!prefix.isPrefixOf(rowKeyPath)) {\r\n                return false;\r\n            }\r\n            else {\r\n                // Rows with document keys more than one segment longer than the query\r\n                // path can't be matches. For example, a query on 'rooms' can't match\r\n                // the document /rooms/abc/messages/xyx.\r\n                // TODO(mcg): we'll need a different scanner when we implement\r\n                // ancestor queries.\r\n                if (rowKeyPath.length === immediateChildrenPathLength) {\r\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n                }\r\n                return true;\r\n            }\r\n        }, start);\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    findMutationBatches(batchIDs) {\r\n        // Construct an array of matching batches, sorted by batchID to ensure that\r\n        // multiple mutations affecting the same document key are applied in order.\r\n        const result = [];\r\n        batchIDs.forEach(batchId => {\r\n            const batch = this.findMutationBatch(batchId);\r\n            if (batch !== null) {\r\n                result.push(batch);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        // Find the position of the first batch for removal.\r\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\r\n        hardAssert(batchIndex === 0);\r\n        this.mutationQueue.shift();\r\n        let references = this.batchesByDocumentKey;\r\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\r\n            const ref = new DocReference(mutation.key, batch.batchId);\r\n            references = references.delete(ref);\r\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\r\n        }).next(() => {\r\n            this.batchesByDocumentKey = references;\r\n        });\r\n    }\r\n    removeCachedMutationKeys(batchId) {\r\n        // No-op since the memory mutation queue does not maintain a separate cache.\r\n    }\r\n    containsKey(txn, key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\r\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        if (this.mutationQueue.length === 0) ;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue and asserts that\r\n     * the resulting index is within the bounds of the queue.\r\n     *\r\n     * @param batchId - The batchId to search for\r\n     * @param action - A description of what the caller is doing, phrased in passive\r\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\r\n     */\r\n    indexOfExistingBatchId(batchId, action) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        return index;\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue. This operation\r\n     * is O(1).\r\n     *\r\n     * @returns The computed index of the batch with the given batchId, based on\r\n     * the state of the queue. Note this index can be negative if the requested\r\n     * batchId has already been remvoed from the queue or past the end of the\r\n     * queue if the batchId is larger than the last added batch.\r\n     */\r\n    indexOfBatchId(batchId) {\r\n        if (this.mutationQueue.length === 0) {\r\n            // As an index this is past the end of the queue\r\n            return 0;\r\n        }\r\n        // Examine the front of the queue to figure out the difference between the\r\n        // batchId and indexes in the array. Note that since the queue is ordered\r\n        // by batchId, if the first batch has a larger batchId then the requested\r\n        // batchId doesn't exist in the queue.\r\n        const firstBatchId = this.mutationQueue[0].batchId;\r\n        return batchId - firstBatchId;\r\n    }\r\n    /**\r\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\r\n     * other functions that uses this code easier to read and more efficent.\r\n     */\r\n    findMutationBatch(batchId) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        if (index < 0 || index >= this.mutationQueue.length) {\r\n            return null;\r\n        }\r\n        const batch = this.mutationQueue[index];\r\n        return batch;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction documentEntryMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newMemoryRemoteDocumentCache()`.\r\n */\r\nclass MemoryRemoteDocumentCacheImpl {\r\n    /**\r\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n     * expected to just return 0 to avoid unnecessarily doing the work of\r\n     * calculating the size.\r\n     */\r\n    constructor(sizer) {\r\n        this.sizer = sizer;\r\n        /** Underlying cache of documents and their read times. */\r\n        this.docs = documentEntryMap();\r\n        /** Size of all cached documents. */\r\n        this.size = 0;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    addEntry(transaction, doc) {\r\n        const key = doc.key;\r\n        const entry = this.docs.get(key);\r\n        const previousSize = entry ? entry.size : 0;\r\n        const currentSize = this.sizer(doc);\r\n        this.docs = this.docs.insert(key, {\r\n            document: doc.mutableCopy(),\r\n            size: currentSize\r\n        });\r\n        this.size += currentSize - previousSize;\r\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\r\n    }\r\n    /**\r\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    removeEntry(documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        if (entry) {\r\n            this.docs = this.docs.remove(documentKey);\r\n            this.size -= entry.size;\r\n        }\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        return PersistencePromise.resolve(entry\r\n            ? entry.document.mutableCopy()\r\n            : MutableDocument.newInvalidDocument(documentKey));\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        documentKeys.forEach(documentKey => {\r\n            const entry = this.docs.get(documentKey);\r\n            results = results.insert(documentKey, entry\r\n                ? entry.document.mutableCopy()\r\n                : MutableDocument.newInvalidDocument(documentKey));\r\n        });\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\r\n        let results = mutableDocumentMap();\r\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\r\n        // the documents we need to match the query against.\r\n        const collectionPath = query.path;\r\n        const prefix = new DocumentKey(collectionPath.child(''));\r\n        const iterator = this.docs.getIteratorFrom(prefix);\r\n        while (iterator.hasNext()) {\r\n            const { key, value: { document } } = iterator.getNext();\r\n            if (!collectionPath.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            if (key.path.length > collectionPath.length + 1) {\r\n                // Exclude entries from subcollections.\r\n                continue;\r\n            }\r\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\r\n                // The document sorts before the offset.\r\n                continue;\r\n            }\r\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\r\n                // The document cannot possibly match the query.\r\n                continue;\r\n            }\r\n            results = results.insert(document.key, document.mutableCopy());\r\n        }\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limti) {\r\n        // This method should only be called from the IndexBackfiller if persistence\r\n        // is enabled.\r\n        fail();\r\n    }\r\n    forEachDocumentKey(transaction, f) {\r\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\r\n    }\r\n    newChangeBuffer(options) {\r\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\r\n        // a separate changelog and does not need special handling for removals.\r\n        return new MemoryRemoteDocumentChangeBuffer(this);\r\n    }\r\n    getSize(txn) {\r\n        return PersistencePromise.resolve(this.size);\r\n    }\r\n}\r\n/**\r\n * Creates a new memory-only RemoteDocumentCache.\r\n *\r\n * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n * expected to just return 0 to avoid unnecessarily doing the work of\r\n * calculating the size.\r\n */\r\nfunction newMemoryRemoteDocumentCache(sizer) {\r\n    return new MemoryRemoteDocumentCacheImpl(sizer);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\r\n */\r\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    constructor(documentCache) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        this.changes.forEach((key, doc) => {\r\n            if (doc.isValidDocument()) {\r\n                promises.push(this.documentCache.addEntry(transaction, doc));\r\n            }\r\n            else {\r\n                this.documentCache.removeEntry(key);\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        return this.documentCache.getEntry(transaction, documentKey);\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        return this.documentCache.getEntries(transaction, documentKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryTargetCache {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /**\r\n         * Maps a target to the data about that target\r\n         */\r\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /** The last received snapshot version. */\r\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\r\n        /** The highest numbered target ID encountered. */\r\n        this.highestTargetId = 0;\r\n        /** The highest sequence number encountered. */\r\n        this.highestSequenceNumber = 0;\r\n        /**\r\n         * A ordered bidirectional mapping between documents and the remote target\r\n         * IDs.\r\n         */\r\n        this.references = new ReferenceSet();\r\n        this.targetCount = 0;\r\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\r\n    }\r\n    forEachTarget(txn, f) {\r\n        this.targets.forEach((_, targetData) => f(targetData));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return PersistencePromise.resolve(this.highestSequenceNumber);\r\n    }\r\n    allocateTargetId(transaction) {\r\n        this.highestTargetId = this.targetIdGenerator.next();\r\n        return PersistencePromise.resolve(this.highestTargetId);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        if (lastRemoteSnapshotVersion) {\r\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\r\n        }\r\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = highestListenSequenceNumber;\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    saveTargetData(targetData) {\r\n        this.targets.set(targetData.target, targetData);\r\n        const targetId = targetData.targetId;\r\n        if (targetId > this.highestTargetId) {\r\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\r\n            this.highestTargetId = targetId;\r\n        }\r\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = targetData.sequenceNumber;\r\n        }\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        this.targetCount += 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        this.targets.delete(targetData.target);\r\n        this.references.removeReferencesForId(targetData.targetId);\r\n        this.targetCount -= 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargets(transaction, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const removals = [];\r\n        this.targets.forEach((key, targetData) => {\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                this.targets.delete(key);\r\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\r\n                count++;\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(removals).next(() => count);\r\n    }\r\n    getTargetCount(transaction) {\r\n        return PersistencePromise.resolve(this.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        const targetData = this.targets.get(target) || null;\r\n        return PersistencePromise.resolve(targetData);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        this.references.addReferences(keys, targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        this.references.removeReferences(keys, targetId);\r\n        const referenceDelegate = this.persistence.referenceDelegate;\r\n        const promises = [];\r\n        if (referenceDelegate) {\r\n            keys.forEach(key => {\r\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\r\n            });\r\n        }\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        this.references.removeReferencesForId(targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const matchingKeys = this.references.referencesForId(targetId);\r\n        return PersistencePromise.resolve(matchingKeys);\r\n    }\r\n    containsKey(txn, key) {\r\n        return PersistencePromise.resolve(this.references.containsKey(key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$d = 'MemoryPersistence';\r\n/**\r\n * A memory-backed instance of Persistence. Data is stored only in RAM and\r\n * not persisted across sessions.\r\n */\r\nclass MemoryPersistence {\r\n    /**\r\n     * The constructor accepts a factory for creating a reference delegate. This\r\n     * allows both the delegate and this instance to have strong references to\r\n     * each other without having nullable fields that would then need to be\r\n     * checked or asserted on every access.\r\n     */\r\n    constructor(referenceDelegateFactory, serializer) {\r\n        this.mutationQueues = {};\r\n        this.overlays = {};\r\n        this.listenSequence = new ListenSequence(0);\r\n        this._started = false;\r\n        this._started = true;\r\n        this.referenceDelegate = referenceDelegateFactory(this);\r\n        this.targetCache = new MemoryTargetCache(this);\r\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\r\n        this.indexManager = new MemoryIndexManager();\r\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.bundleCache = new MemoryBundleCache(this.serializer);\r\n    }\r\n    start() {\r\n        return Promise.resolve();\r\n    }\r\n    shutdown() {\r\n        // No durable state to ensure is closed on shutdown.\r\n        this._started = false;\r\n        return Promise.resolve();\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    setDatabaseDeletedListener() {\r\n        // No op.\r\n    }\r\n    setNetworkEnabled() {\r\n        // No op.\r\n    }\r\n    getIndexManager(user) {\r\n        // We do not currently support indices for memory persistence, so we can\r\n        // return the same shared instance of the memory index manager.\r\n        return this.indexManager;\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        let overlay = this.overlays[user.toKey()];\r\n        if (!overlay) {\r\n            overlay = new MemoryDocumentOverlayCache();\r\n            this.overlays[user.toKey()] = overlay;\r\n        }\r\n        return overlay;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        let queue = this.mutationQueues[user.toKey()];\r\n        if (!queue) {\r\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\r\n            this.mutationQueues[user.toKey()] = queue;\r\n        }\r\n        return queue;\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\r\n        const txn = new MemoryTransaction(this.listenSequence.next());\r\n        this.referenceDelegate.onTransactionStarted();\r\n        return transactionOperation(txn)\r\n            .next(result => {\r\n            return this.referenceDelegate\r\n                .onTransactionCommitted(txn)\r\n                .next(() => result);\r\n        })\r\n            .toPromise()\r\n            .then(result => {\r\n            txn.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    mutationQueuesContainKey(transaction, key) {\r\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\r\n    }\r\n}\r\n/**\r\n * Memory persistence is not actually transactional, but future implementations\r\n * may have transaction-scoped state.\r\n */\r\nclass MemoryTransaction extends PersistenceTransaction {\r\n    constructor(currentSequenceNumber) {\r\n        super();\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nclass MemoryEagerDelegate {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /** Tracks all documents that are active in Query views. */\r\n        this.localViewReferences = new ReferenceSet();\r\n        /** The list of documents that are potentially GCed after each transaction. */\r\n        this._orphanedDocuments = null;\r\n    }\r\n    static factory(persistence) {\r\n        return new MemoryEagerDelegate(persistence);\r\n    }\r\n    get orphanedDocuments() {\r\n        if (!this._orphanedDocuments) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return this._orphanedDocuments;\r\n        }\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        this.localViewReferences.addReference(key, targetId);\r\n        this.orphanedDocuments.delete(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        this.localViewReferences.removeReference(key, targetId);\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\r\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        const cache = this.persistence.getTargetCache();\r\n        return cache\r\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n            .next(keys => {\r\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        })\r\n            .next(() => cache.removeTargetData(txn, targetData));\r\n    }\r\n    onTransactionStarted() {\r\n        this._orphanedDocuments = new Set();\r\n    }\r\n    onTransactionCommitted(txn) {\r\n        // Remove newly orphaned documents.\r\n        const cache = this.persistence.getRemoteDocumentCache();\r\n        const changeBuffer = cache.newChangeBuffer();\r\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            return this.isReferenced(txn, key).next(isReferenced => {\r\n                if (!isReferenced) {\r\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\r\n                }\r\n            });\r\n        }).next(() => {\r\n            this._orphanedDocuments = null;\r\n            return changeBuffer.apply(txn);\r\n        });\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return this.isReferenced(txn, key).next(isReferenced => {\r\n            if (isReferenced) {\r\n                this.orphanedDocuments.delete(key.toString());\r\n            }\r\n            else {\r\n                this.orphanedDocuments.add(key.toString());\r\n            }\r\n        });\r\n    }\r\n    documentSize(doc) {\r\n        // For eager GC, we don't care about the document size, there are no size thresholds.\r\n        return 0;\r\n    }\r\n    isReferenced(txn, key) {\r\n        return PersistencePromise.or([\r\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\r\n            () => this.persistence.getTargetCache().containsKey(txn, key),\r\n            () => this.persistence.mutationQueuesContainKey(txn, key)\r\n        ]);\r\n    }\r\n}\r\nclass MemoryLruDelegate {\r\n    constructor(persistence, lruParams) {\r\n        this.persistence = persistence;\r\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\r\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\r\n    }\r\n    static factory(persistence, lruParams) {\r\n        return new MemoryLruDelegate(persistence, lruParams);\r\n    }\r\n    // No-ops, present so memory persistence doesn't have to care which delegate\r\n    // it has.\r\n    onTransactionStarted() { }\r\n    onTransactionCommitted(txn) {\r\n        return PersistencePromise.resolve();\r\n    }\r\n    forEachTarget(txn, f) {\r\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\r\n    }\r\n    getSequenceNumberCount(txn) {\r\n        const docCountPromise = this.orphanedDocumentCount(txn);\r\n        const targetCountPromise = this.persistence\r\n            .getTargetCache()\r\n            .getTargetCount(txn);\r\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\r\n    }\r\n    orphanedDocumentCount(txn) {\r\n        let orphanedCount = 0;\r\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\r\n            orphanedCount++;\r\n        }).next(() => orphanedCount);\r\n    }\r\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\r\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\r\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\r\n            // being too recent.\r\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\r\n                if (!isPinned) {\r\n                    return f(sequenceNumber);\r\n                }\r\n                else {\r\n                    return PersistencePromise.resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.persistence\r\n            .getTargetCache()\r\n            .removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        let count = 0;\r\n        const cache = this.persistence.getRemoteDocumentCache();\r\n        const changeBuffer = cache.newChangeBuffer();\r\n        const p = cache.forEachDocumentKey(txn, key => {\r\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\r\n                if (!isPinned) {\r\n                    count++;\r\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\r\n                }\r\n            });\r\n        });\r\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\r\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    documentSize(document) {\r\n        let documentSize = document.key.toString().length;\r\n        if (document.isFoundDocument()) {\r\n            documentSize += estimateByteSize(document.data.value);\r\n        }\r\n        return documentSize;\r\n    }\r\n    isPinned(txn, key, upperBound) {\r\n        return PersistencePromise.or([\r\n            () => this.persistence.mutationQueuesContainKey(txn, key),\r\n            () => this.persistence.getTargetCache().containsKey(txn, key),\r\n            () => {\r\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\r\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\r\n            }\r\n        ]);\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Performs database creation and schema upgrades. */\r\nclass SchemaConverter {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    /**\r\n     * Performs database creation and schema upgrades.\r\n     *\r\n     * Note that in production, this method is only ever used to upgrade the schema\r\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\r\n     * and local feature development.\r\n     */\r\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\r\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\r\n        if (fromVersion < 1 && toVersion >= 1) {\r\n            createPrimaryClientStore(db);\r\n            createMutationQueue(db);\r\n            createQueryCache(db);\r\n            createLegacyRemoteDocumentCache(db);\r\n        }\r\n        // Migration 2 to populate the targetGlobal object no longer needed since\r\n        // migration 3 unconditionally clears it.\r\n        let p = PersistencePromise.resolve();\r\n        if (fromVersion < 3 && toVersion >= 3) {\r\n            // Brand new clients don't need to drop and recreate--only clients that\r\n            // potentially have corrupt data.\r\n            if (fromVersion !== 0) {\r\n                dropQueryCache(db);\r\n                createQueryCache(db);\r\n            }\r\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 4 && toVersion >= 4) {\r\n            if (fromVersion !== 0) {\r\n                // Schema version 3 uses auto-generated keys to generate globally unique\r\n                // mutation batch IDs (this was previously ensured internally by the\r\n                // client). To migrate to the new schema, we have to read all mutations\r\n                // and write them back out. We preserve the existing batch IDs to guarantee\r\n                // consistency with other object stores. Any further mutation batch IDs will\r\n                // be auto-generated.\r\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\r\n            }\r\n            p = p.next(() => {\r\n                createClientMetadataStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 5 && toVersion >= 5) {\r\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 6 && toVersion >= 6) {\r\n            p = p.next(() => {\r\n                createDocumentGlobalStore(db);\r\n                return this.addDocumentGlobal(simpleDbTransaction);\r\n            });\r\n        }\r\n        if (fromVersion < 7 && toVersion >= 7) {\r\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 8 && toVersion >= 8) {\r\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 9 && toVersion >= 9) {\r\n            p = p.next(() => {\r\n                // Multi-Tab used to manage its own changelog, but this has been moved\r\n                // to the DbRemoteDocument object store itself. Since the previous change\r\n                // log only contained transient data, we can drop its object store.\r\n                dropRemoteDocumentChangesStore(db);\r\n                // Note: Schema version 9 used to create a read time index for the\r\n                // RemoteDocumentCache. This is now done with schema version 13.\r\n            });\r\n        }\r\n        if (fromVersion < 10 && toVersion >= 10) {\r\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 11 && toVersion >= 11) {\r\n            p = p.next(() => {\r\n                createBundlesStore(db);\r\n                createNamedQueriesStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 12 && toVersion >= 12) {\r\n            p = p.next(() => {\r\n                createDocumentOverlayStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 13 && toVersion >= 13) {\r\n            p = p\r\n                .next(() => createRemoteDocumentCache(db))\r\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\r\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\r\n        }\r\n        if (fromVersion < 14 && toVersion >= 14) {\r\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 15 && toVersion >= 15) {\r\n            p = p.next(() => createFieldIndex(db));\r\n        }\r\n        if (fromVersion < 16 && toVersion >= 16) {\r\n            // Clear the object stores to remove possibly corrupted index entries\r\n            p = p\r\n                .next(() => {\r\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\r\n                indexStateStore.clear();\r\n            })\r\n                .next(() => {\r\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\r\n                indexEntryStore.clear();\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    addDocumentGlobal(txn) {\r\n        let byteSize = 0;\r\n        return txn\r\n            .store(DbRemoteDocumentStore$1)\r\n            .iterate((_, doc) => {\r\n            byteSize += dbDocumentSize(doc);\r\n        })\r\n            .next(() => {\r\n            const metadata = { byteSize };\r\n            return txn\r\n                .store(DbRemoteDocumentGlobalStore)\r\n                .put(DbRemoteDocumentGlobalKey, metadata);\r\n        });\r\n    }\r\n    removeAcknowledgedMutations(txn) {\r\n        const queuesStore = txn.store(DbMutationQueueStore);\r\n        const mutationsStore = txn.store(DbMutationBatchStore);\r\n        return queuesStore.loadAll().next(queues => {\r\n            return PersistencePromise.forEach(queues, (queue) => {\r\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\r\n                return mutationsStore\r\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\r\n                    .next(dbBatches => {\r\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\r\n                        hardAssert(dbBatch.userId === queue.userId);\r\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\r\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\r\n     * with a sequence number. Missing rows are given the most recently used sequence number.\r\n     */\r\n    ensureSequenceNumbers(txn) {\r\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\r\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\r\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\r\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\r\n            const writeSentinelKey = (path) => {\r\n                return documentTargetStore.put({\r\n                    targetId: 0,\r\n                    path: encodeResourcePath(path),\r\n                    sequenceNumber: metadata.highestListenSequenceNumber\r\n                });\r\n            };\r\n            const promises = [];\r\n            return documentsStore\r\n                .iterate((key, doc) => {\r\n                const path = new ResourcePath(key);\r\n                const docSentinelKey = sentinelKey(path);\r\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\r\n                    if (!maybeSentinel) {\r\n                        return writeSentinelKey(path);\r\n                    }\r\n                    else {\r\n                        return PersistencePromise.resolve();\r\n                    }\r\n                }));\r\n            })\r\n                .next(() => PersistencePromise.waitFor(promises));\r\n        });\r\n    }\r\n    createCollectionParentIndex(db, txn) {\r\n        // Create the index.\r\n        db.createObjectStore(DbCollectionParentStore, {\r\n            keyPath: DbCollectionParentKeyPath\r\n        });\r\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\r\n        // Helper to add an index entry iff we haven't already written it.\r\n        const cache = new MemoryCollectionParentIndex();\r\n        const addEntry = (collectionPath) => {\r\n            if (cache.add(collectionPath)) {\r\n                const collectionId = collectionPath.lastSegment();\r\n                const parentPath = collectionPath.popLast();\r\n                return collectionParentsStore.put({\r\n                    collectionId,\r\n                    parent: encodeResourcePath(parentPath)\r\n                });\r\n            }\r\n        };\r\n        // Index existing remote documents.\r\n        return txn\r\n            .store(DbRemoteDocumentStore$1)\r\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\r\n            const path = new ResourcePath(pathSegments);\r\n            return addEntry(path.popLast());\r\n        })\r\n            .next(() => {\r\n            // Index existing mutations.\r\n            return txn\r\n                .store(DbDocumentMutationStore)\r\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\r\n                const path = decodeResourcePath(encodedPath);\r\n                return addEntry(path.popLast());\r\n            });\r\n        });\r\n    }\r\n    rewriteCanonicalIds(txn) {\r\n        const targetStore = txn.store(DbTargetStore);\r\n        return targetStore.iterate((key, originalDbTarget) => {\r\n            const originalTargetData = fromDbTarget(originalDbTarget);\r\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\r\n            return targetStore.put(updatedDbTarget);\r\n        });\r\n    }\r\n    rewriteRemoteDocumentCache(db, transaction) {\r\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\r\n        const writes = [];\r\n        return legacyRemoteDocumentStore\r\n            .iterate((_, legacyDocument) => {\r\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\r\n            const path = extractKey(legacyDocument).path.toArray();\r\n            const dbRemoteDocument = {\r\n                prefixPath: path.slice(0, path.length - 2),\r\n                collectionGroup: path[path.length - 2],\r\n                documentId: path[path.length - 1],\r\n                readTime: legacyDocument.readTime || [0, 0],\r\n                unknownDocument: legacyDocument.unknownDocument,\r\n                noDocument: legacyDocument.noDocument,\r\n                document: legacyDocument.document,\r\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\r\n            };\r\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\r\n        })\r\n            .next(() => PersistencePromise.waitFor(writes));\r\n    }\r\n    runOverlayMigration(db, transaction) {\r\n        const mutationsStore = transaction.store(DbMutationBatchStore);\r\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\r\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\r\n        return mutationsStore.loadAll().next(dbBatches => {\r\n            const userToDocumentSet = new Map();\r\n            dbBatches.forEach(dbBatch => {\r\n                var _a;\r\n                let documentSet = (_a = userToDocumentSet.get(dbBatch.userId)) !== null && _a !== void 0 ? _a : documentKeySet();\r\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\r\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\r\n                userToDocumentSet.set(dbBatch.userId, documentSet);\r\n            });\r\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\r\n                const user = new User(userId);\r\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\r\n                // NOTE: The index manager and the reference delegate are\r\n                // irrelevant for the purpose of recalculating and saving\r\n                // overlays. We can therefore simply use the memory\r\n                // implementation.\r\n                const indexManager = memoryPersistence.getIndexManager(user);\r\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\r\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\r\n                return localDocumentsView\r\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\r\n                    .next();\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction sentinelKey(path) {\r\n    return [0, encodeResourcePath(path)];\r\n}\r\nfunction createPrimaryClientStore(db) {\r\n    db.createObjectStore(DbPrimaryClientStore);\r\n}\r\nfunction createMutationQueue(db) {\r\n    db.createObjectStore(DbMutationQueueStore, {\r\n        keyPath: DbMutationQueueKeyPath\r\n    });\r\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\r\n        keyPath: DbMutationBatchKeyPath,\r\n        autoIncrement: true\r\n    });\r\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\r\n    db.createObjectStore(DbDocumentMutationStore);\r\n}\r\n/**\r\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\r\n * and rewrites all data.\r\n */\r\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\r\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\r\n    return v1MutationsStore.loadAll().next(existingMutations => {\r\n        db.deleteObjectStore(DbMutationBatchStore);\r\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\r\n            keyPath: DbMutationBatchKeyPath,\r\n            autoIncrement: true\r\n        });\r\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\r\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\r\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\r\n        return PersistencePromise.waitFor(writeAll);\r\n    });\r\n}\r\nfunction createLegacyRemoteDocumentCache(db) {\r\n    db.createObjectStore(DbRemoteDocumentStore$1);\r\n}\r\nfunction createRemoteDocumentCache(db) {\r\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\r\n        keyPath: DbRemoteDocumentKeyPath\r\n    });\r\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\r\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\r\n}\r\nfunction createDocumentGlobalStore(db) {\r\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\r\n}\r\nfunction createQueryCache(db) {\r\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\r\n        keyPath: DbTargetDocumentKeyPath\r\n    });\r\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\r\n    const targetStore = db.createObjectStore(DbTargetStore, {\r\n        keyPath: DbTargetKeyPath\r\n    });\r\n    // NOTE: This is unique only because the TargetId is the suffix.\r\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\r\n    db.createObjectStore(DbTargetGlobalStore);\r\n}\r\nfunction dropQueryCache(db) {\r\n    db.deleteObjectStore(DbTargetDocumentStore);\r\n    db.deleteObjectStore(DbTargetStore);\r\n    db.deleteObjectStore(DbTargetGlobalStore);\r\n}\r\nfunction dropRemoteDocumentChangesStore(db) {\r\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\r\n        db.deleteObjectStore('remoteDocumentChanges');\r\n    }\r\n}\r\n/**\r\n * Creates the target global singleton row.\r\n *\r\n * @param txn - The version upgrade transaction for indexeddb\r\n */\r\nfunction writeEmptyTargetGlobalEntry(txn) {\r\n    const globalStore = txn.store(DbTargetGlobalStore);\r\n    const metadata = {\r\n        highestTargetId: 0,\r\n        highestListenSequenceNumber: 0,\r\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\r\n        targetCount: 0\r\n    };\r\n    return globalStore.put(DbTargetGlobalKey, metadata);\r\n}\r\nfunction createClientMetadataStore(db) {\r\n    db.createObjectStore(DbClientMetadataStore, {\r\n        keyPath: DbClientMetadataKeyPath\r\n    });\r\n}\r\nfunction createBundlesStore(db) {\r\n    db.createObjectStore(DbBundleStore, {\r\n        keyPath: DbBundleKeyPath\r\n    });\r\n}\r\nfunction createNamedQueriesStore(db) {\r\n    db.createObjectStore(DbNamedQueryStore, {\r\n        keyPath: DbNamedQueryKeyPath\r\n    });\r\n}\r\nfunction createFieldIndex(db) {\r\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\r\n        keyPath: DbIndexConfigurationKeyPath,\r\n        autoIncrement: true\r\n    });\r\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\r\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\r\n        keyPath: DbIndexStateKeyPath\r\n    });\r\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\r\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\r\n        keyPath: DbIndexEntryKeyPath\r\n    });\r\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\r\n}\r\nfunction createDocumentOverlayStore(db) {\r\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\r\n        keyPath: DbDocumentOverlayKeyPath\r\n    });\r\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\r\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\r\n}\r\nfunction extractKey(remoteDoc) {\r\n    if (remoteDoc.document) {\r\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\r\n    }\r\n    else if (remoteDoc.noDocument) {\r\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\r\n    }\r\n    else if (remoteDoc.unknownDocument) {\r\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$c = 'IndexedDbPersistence';\r\n/**\r\n * Oldest acceptable age in milliseconds for client metadata before the client\r\n * is considered inactive and its associated data is garbage collected.\r\n */\r\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\r\n/**\r\n * Oldest acceptable metadata age for clients that may participate in the\r\n * primary lease election. Clients that have not updated their client metadata\r\n * within 5 seconds are not eligible to receive a primary lease.\r\n */\r\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\r\n/**\r\n * The interval at which clients will update their metadata, including\r\n * refreshing their primary lease if held or potentially trying to acquire it if\r\n * not held.\r\n *\r\n * Primary clients may opportunistically refresh their metadata earlier\r\n * if they're already performing an IndexedDB operation.\r\n */\r\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\r\n/** User-facing error when the primary lease is required but not available. */\r\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\r\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\r\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\r\n    'one tab has persistence enabled at any given time.';\r\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\r\n    'an incomplete implementation. Offline persistence has been disabled.';\r\n// The format of the LocalStorage key that stores zombied client is:\r\n//     firestore_zombie_<persistence_prefix>_<instance_key>\r\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\r\n/**\r\n * The name of the main (and currently only) IndexedDB database. This name is\r\n * appended to the prefix provided to the IndexedDbPersistence constructor.\r\n */\r\nconst MAIN_DATABASE = 'main';\r\n/**\r\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\r\n * across sessions.\r\n *\r\n * On Web only, the Firestore SDKs support shared access to its persistence\r\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\r\n * to synchronize state even without network connectivity. Shared access is\r\n * currently optional and not enabled unless all clients invoke\r\n * `enablePersistence()` with `{synchronizeTabs:true}`.\r\n *\r\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\r\n * will designate one client as the primary client. An effort is made to pick\r\n * a visible, network-connected and active client, and this client is\r\n * responsible for letting other clients know about its presence. The primary\r\n * client writes a unique client-generated identifier (the client ID) to\r\n * IndexedDbs owner store every 4 seconds. If the primary client fails to\r\n * update this entry, another client can acquire the lease and take over as\r\n * primary.\r\n *\r\n * Some persistence operations in the SDK are designated as primary-client only\r\n * operations. This includes the acknowledgment of mutations and all updates of\r\n * remote documents. The effects of these operations are written to persistence\r\n * and then broadcast to other tabs via LocalStorage (see\r\n * `WebStorageSharedClientState`), which then refresh their state from\r\n * persistence.\r\n *\r\n * Similarly, the primary client listens to notifications sent by secondary\r\n * clients to discover persistence changes written by secondary clients, such as\r\n * the addition of new mutations and query targets.\r\n *\r\n * If multi-tab is not enabled and another tab already obtained the primary\r\n * lease, IndexedDbPersistence enters a failed state and all subsequent\r\n * operations will automatically fail.\r\n *\r\n * Additionally, there is an optimization so that when a tab is closed, the\r\n * primary lease is released immediately (this is especially important to make\r\n * sure that a refreshed tab is able to immediately re-acquire the primary\r\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\r\n * since it is an asynchronous API. So in addition to attempting to give up the\r\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\r\n * LocalStorage which acts as an indicator that another tab should go ahead and\r\n * take the primary lease immediately regardless of the current lease timestamp.\r\n *\r\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\r\n * longer optional.\r\n */\r\nclass IndexedDbPersistence {\r\n    constructor(\r\n    /**\r\n     * Whether to synchronize the in-memory state of multiple tabs and share\r\n     * access to local persistence.\r\n     */\r\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \r\n    /**\r\n     * If set to true, forcefully obtains database access. Existing tabs will\r\n     * no longer be able to access IndexedDB.\r\n     */\r\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\r\n        this.allowTabSynchronization = allowTabSynchronization;\r\n        this.persistenceKey = persistenceKey;\r\n        this.clientId = clientId;\r\n        this.queue = queue;\r\n        this.window = window;\r\n        this.document = document;\r\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\r\n        this.forceOwningTab = forceOwningTab;\r\n        this.schemaVersion = schemaVersion;\r\n        this.listenSequence = null;\r\n        this._started = false;\r\n        this.isPrimary = false;\r\n        this.networkEnabled = true;\r\n        /** Our window.unload handler, if registered. */\r\n        this.windowUnloadHandler = null;\r\n        this.inForeground = false;\r\n        /** Our 'visibilitychange' listener if registered. */\r\n        this.documentVisibilityHandler = null;\r\n        /** The client metadata refresh task. */\r\n        this.clientMetadataRefresher = null;\r\n        /** The last time we garbage collected the client metadata object store. */\r\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\r\n        /** A listener to notify on primary state changes. */\r\n        this.primaryStateListener = _ => Promise.resolve();\r\n        if (!IndexedDbPersistence.isAvailable()) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\r\n        }\r\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\r\n        this.dbName = persistenceKey + MAIN_DATABASE;\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\r\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\r\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\r\n        this.bundleCache = new IndexedDbBundleCache();\r\n        if (this.window && this.window.localStorage) {\r\n            this.webStorage = this.window.localStorage;\r\n        }\r\n        else {\r\n            this.webStorage = null;\r\n            if (forceOwningTab === false) {\r\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\r\n                    'reliably. In particular enablePersistence() could fail immediately ' +\r\n                    'after refreshing the page.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempt to start IndexedDb persistence.\r\n     *\r\n     * @returns Whether persistence was enabled.\r\n     */\r\n    start() {\r\n        // NOTE: This is expected to fail sometimes (in the case of another tab\r\n        // already having the persistence lock), so it's the first thing we should\r\n        // do.\r\n        return this.updateClientMetadataAndTryBecomePrimary()\r\n            .then(() => {\r\n            if (!this.isPrimary && !this.allowTabSynchronization) {\r\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\r\n                // obtain the primary lease.\r\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n            }\r\n            this.attachVisibilityHandler();\r\n            this.attachWindowUnloadHook();\r\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\r\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\r\n        })\r\n            .then(highestListenSequenceNumber => {\r\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\r\n        })\r\n            .then(() => {\r\n            this._started = true;\r\n        })\r\n            .catch(reason => {\r\n            this.simpleDb && this.simpleDb.close();\r\n            return Promise.reject(reason);\r\n        });\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the primary state of the\r\n     * instance changes. Upon registering, this listener is invoked immediately\r\n     * with the current primary state.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setPrimaryStateListener(primaryStateListener) {\r\n        this.primaryStateListener = async (primaryState) => {\r\n            if (this.started) {\r\n                return primaryStateListener(primaryState);\r\n            }\r\n        };\r\n        return primaryStateListener(this.isPrimary);\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the database receives a\r\n     * version change event indicating that it has deleted.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setDatabaseDeletedListener(databaseDeletedListener) {\r\n        this.simpleDb.setVersionChangeListener(async (event) => {\r\n            // Check if an attempt is made to delete IndexedDB.\r\n            if (event.newVersion === null) {\r\n                await databaseDeletedListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Adjusts the current network state in the client's metadata, potentially\r\n     * affecting the primary lease.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setNetworkEnabled(networkEnabled) {\r\n        if (this.networkEnabled !== networkEnabled) {\r\n            this.networkEnabled = networkEnabled;\r\n            // Schedule a primary lease refresh for immediate execution. The eventual\r\n            // lease update will be propagated via `primaryStateListener`.\r\n            this.queue.enqueueAndForget(async () => {\r\n                if (this.started) {\r\n                    await this.updateClientMetadataAndTryBecomePrimary();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\r\n     * extend the primary lease for the local client. Asynchronously notifies the\r\n     * primary state listener if the client either newly obtained or released its\r\n     * primary lease.\r\n     */\r\n    updateClientMetadataAndTryBecomePrimary() {\r\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\r\n            const metadataStore = clientMetadataStore(txn);\r\n            return metadataStore\r\n                .put({\r\n                clientId: this.clientId,\r\n                updateTimeMs: Date.now(),\r\n                networkEnabled: this.networkEnabled,\r\n                inForeground: this.inForeground\r\n            })\r\n                .next(() => {\r\n                if (this.isPrimary) {\r\n                    return this.verifyPrimaryLease(txn).next(success => {\r\n                        if (!success) {\r\n                            this.isPrimary = false;\r\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n                .next(() => this.canActAsPrimary(txn))\r\n                .next(canActAsPrimary => {\r\n                if (this.isPrimary && !canActAsPrimary) {\r\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\r\n                }\r\n                else if (canActAsPrimary) {\r\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\r\n                }\r\n                else {\r\n                    return /* canActAsPrimary= */ false;\r\n                }\r\n            });\r\n        })\r\n            .catch(e => {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\r\n                // Proceed with the existing state. Any subsequent access to\r\n                // IndexedDB will verify the lease.\r\n                return this.isPrimary;\r\n            }\r\n            if (!this.allowTabSynchronization) {\r\n                throw e;\r\n            }\r\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\r\n            return /* isPrimary= */ false;\r\n        })\r\n            .then(isPrimary => {\r\n            if (this.isPrimary !== isPrimary) {\r\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\r\n            }\r\n            this.isPrimary = isPrimary;\r\n        });\r\n    }\r\n    verifyPrimaryLease(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\r\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\r\n        });\r\n    }\r\n    removeClientMetadata(txn) {\r\n        const metadataStore = clientMetadataStore(txn);\r\n        return metadataStore.delete(this.clientId);\r\n    }\r\n    /**\r\n     * If the garbage collection threshold has passed, prunes the\r\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\r\n     * time of all clients.\r\n     */\r\n    async maybeGarbageCollectMultiClientState() {\r\n        if (this.isPrimary &&\r\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\r\n            this.lastGarbageCollectionTime = Date.now();\r\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\r\n                const metadataStore = getStore(txn, DbClientMetadataStore);\r\n                return metadataStore.loadAll().next(existingClients => {\r\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\r\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\r\n                    // Delete metadata for clients that are no longer considered active.\r\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\r\n                });\r\n            }).catch(() => {\r\n                // Ignore primary lease violations or any other type of error. The next\r\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\r\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\r\n                // on LocalStore.\r\n                return [];\r\n            });\r\n            // Delete potential leftover entries that may continue to mark the\r\n            // inactive clients as zombied in LocalStorage.\r\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\r\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\r\n            // entries first to avoid potentially reviving a zombied client.\r\n            if (this.webStorage) {\r\n                for (const inactiveClient of inactiveClients) {\r\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Schedules a recurring timer to update the client metadata and to either\r\n     * extend or acquire the primary lease if the client is eligible.\r\n     */\r\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\r\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\r\n            return this.updateClientMetadataAndTryBecomePrimary()\r\n                .then(() => this.maybeGarbageCollectMultiClientState())\r\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\r\n        });\r\n    }\r\n    /** Checks whether `client` is the local client. */\r\n    isLocalClient(client) {\r\n        return client ? client.ownerId === this.clientId : false;\r\n    }\r\n    /**\r\n     * Evaluate the state of all active clients and determine whether the local\r\n     * client is or can act as the holder of the primary lease. Returns whether\r\n     * the client is eligible for the lease, but does not actually acquire it.\r\n     * May return 'false' even if there is no active leaseholder and another\r\n     * (foreground) client should become leaseholder instead.\r\n     */\r\n    canActAsPrimary(txn) {\r\n        if (this.forceOwningTab) {\r\n            return PersistencePromise.resolve(true);\r\n        }\r\n        const store = primaryClientStore(txn);\r\n        return store\r\n            .get(DbPrimaryClientKey)\r\n            .next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            // A client is eligible for the primary lease if:\r\n            // - its network is enabled and the client's tab is in the foreground.\r\n            // - its network is enabled and no other client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and the client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and no other client's tab is in\r\n            //   the foreground.\r\n            // - the `forceOwningTab` setting was passed in.\r\n            if (currentLeaseIsValid) {\r\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\r\n                    return true;\r\n                }\r\n                if (!this.isLocalClient(currentPrimary)) {\r\n                    if (!currentPrimary.allowTabSynchronization) {\r\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\r\n                        // not opted into multi-tab synchronization. If this happens at\r\n                        // client startup, we reject the Promise returned by\r\n                        // `enablePersistence()` and the user can continue to use Firestore\r\n                        // with in-memory persistence.\r\n                        // If this fails during a lease refresh, we will instead block the\r\n                        // AsyncQueue from executing further operations. Note that this is\r\n                        // acceptable since mixing & matching different `synchronizeTabs`\r\n                        // settings is not supported.\r\n                        //\r\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\r\n                        // no longer be turned off.\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            if (this.networkEnabled && this.inForeground) {\r\n                return true;\r\n            }\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(existingClients => {\r\n                // Process all existing clients and determine whether at least one of\r\n                // them is better suited to obtain the primary lease.\r\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\r\n                    if (this.clientId !== otherClient.clientId) {\r\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\r\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\r\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\r\n                        if (otherClientHasBetterNetworkState ||\r\n                            (otherClientHasBetterVisibility &&\r\n                                otherClientHasSameNetworkState)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                });\r\n                return preferredCandidate === undefined;\r\n            });\r\n        })\r\n            .next(canActAsPrimary => {\r\n            if (this.isPrimary !== canActAsPrimary) {\r\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\r\n            }\r\n            return canActAsPrimary;\r\n        });\r\n    }\r\n    async shutdown() {\r\n        // The shutdown() operations are idempotent and can be called even when\r\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\r\n        this._started = false;\r\n        this.markClientZombied();\r\n        if (this.clientMetadataRefresher) {\r\n            this.clientMetadataRefresher.cancel();\r\n            this.clientMetadataRefresher = null;\r\n        }\r\n        this.detachVisibilityHandler();\r\n        this.detachWindowUnloadHook();\r\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\r\n        // has obtained the primary lease.\r\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\r\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\r\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\r\n        });\r\n        this.simpleDb.close();\r\n        // Remove the entry marking the client as zombied from LocalStorage since\r\n        // we successfully deleted its metadata from IndexedDb.\r\n        this.removeClientZombiedEntry();\r\n    }\r\n    /**\r\n     * Returns clients that are not zombied and have an updateTime within the\r\n     * provided threshold.\r\n     */\r\n    filterActiveClients(clients, activityThresholdMs) {\r\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\r\n            !this.isClientZombied(client.clientId));\r\n    }\r\n    /**\r\n     * Returns the IDs of the clients that are currently active. If multi-tab\r\n     * is not supported, returns an array that only contains the local client's\r\n     * ID.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    getActiveClients() {\r\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\r\n        });\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getIndexManager(user) {\r\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\r\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\r\n        const objectStores = getObjectStores(this.schemaVersion);\r\n        let persistenceTransaction;\r\n        // Do all transactions as readwrite against all object stores, since we\r\n        // are the only reader/writer.\r\n        return this.simpleDb\r\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\r\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\r\n                ? this.listenSequence.next()\r\n                : ListenSequence.INVALID);\r\n            if (mode === 'readwrite-primary') {\r\n                // While we merely verify that we have (or can acquire) the lease\r\n                // immediately, we wait to extend the primary lease until after\r\n                // executing transactionOperation(). This ensures that even if the\r\n                // transactionOperation takes a long time, we'll use a recent\r\n                // leaseTimestampMs in the extended (or newly acquired) lease.\r\n                return this.verifyPrimaryLease(persistenceTransaction)\r\n                    .next(holdsPrimaryLease => {\r\n                    if (holdsPrimaryLease) {\r\n                        return /* holdsPrimaryLease= */ true;\r\n                    }\r\n                    return this.canActAsPrimary(persistenceTransaction);\r\n                })\r\n                    .next(holdsPrimaryLease => {\r\n                    if (!holdsPrimaryLease) {\r\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\r\n                        this.isPrimary = false;\r\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\r\n                    }\r\n                    return transactionOperation(persistenceTransaction);\r\n                })\r\n                    .next(result => {\r\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\r\n                });\r\n            }\r\n            else {\r\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\r\n            }\r\n        })\r\n            .then(result => {\r\n            persistenceTransaction.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies that the current tab is the primary leaseholder or alternatively\r\n     * that the leaseholder has opted into multi-tab synchronization.\r\n     */\r\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\r\n    // be turned off.\r\n    verifyAllowTabSynchronization(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\r\n                if (!this.forceOwningTab &&\r\n                    (!this.allowTabSynchronization ||\r\n                        !currentPrimary.allowTabSynchronization)) {\r\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Obtains or extends the new primary lease for the local client. This\r\n     * method does not verify that the client is eligible for this lease.\r\n     */\r\n    acquireOrExtendPrimaryLease(txn) {\r\n        const newPrimary = {\r\n            ownerId: this.clientId,\r\n            allowTabSynchronization: this.allowTabSynchronization,\r\n            leaseTimestampMs: Date.now()\r\n        };\r\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\r\n    }\r\n    static isAvailable() {\r\n        return SimpleDb.isAvailable();\r\n    }\r\n    /** Checks the primary lease and removes it if we are the current primary. */\r\n    releasePrimaryLeaseIfHeld(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\r\n            if (this.isLocalClient(primaryClient)) {\r\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\r\n                return store.delete(DbPrimaryClientKey);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve();\r\n            }\r\n        });\r\n    }\r\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\r\n    isWithinAge(updateTimeMs, maxAgeMs) {\r\n        const now = Date.now();\r\n        const minAcceptable = now - maxAgeMs;\r\n        const maxAcceptable = now;\r\n        if (updateTimeMs < minAcceptable) {\r\n            return false;\r\n        }\r\n        else if (updateTimeMs > maxAcceptable) {\r\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    attachVisibilityHandler() {\r\n        if (this.document !== null &&\r\n            typeof this.document.addEventListener === 'function') {\r\n            this.documentVisibilityHandler = () => {\r\n                this.queue.enqueueAndForget(() => {\r\n                    this.inForeground = this.document.visibilityState === 'visible';\r\n                    return this.updateClientMetadataAndTryBecomePrimary();\r\n                });\r\n            };\r\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.inForeground = this.document.visibilityState === 'visible';\r\n        }\r\n    }\r\n    detachVisibilityHandler() {\r\n        if (this.documentVisibilityHandler) {\r\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.documentVisibilityHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a window.unload handler that will synchronously write our\r\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\r\n     * by tabs trying to acquire the primary lease to determine that the lease\r\n     * is no longer valid even if the timestamp is recent. This is particularly\r\n     * important for the refresh case (so the tab correctly re-acquires the\r\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\r\n     * it is a synchronous API and so can be used reliably from  an unload\r\n     * handler.\r\n     */\r\n    attachWindowUnloadHook() {\r\n        var _a;\r\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\r\n            this.windowUnloadHandler = () => {\r\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\r\n                // accesses internal state. We execute this code directly during shutdown\r\n                // to make sure it gets a chance to run.\r\n                this.markClientZombied();\r\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\r\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() &&\r\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\r\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\r\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\r\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\r\n                    // the next page load.\r\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\r\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\r\n                }\r\n                this.queue.enqueueAndForget(() => {\r\n                    // Attempt graceful shutdown (including releasing our primary lease),\r\n                    // but there's no guarantee it will complete.\r\n                    return this.shutdown();\r\n                });\r\n            };\r\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\r\n        }\r\n    }\r\n    detachWindowUnloadHook() {\r\n        if (this.windowUnloadHandler) {\r\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\r\n            this.windowUnloadHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\r\n     * Clients become zombied when their tab closes without running all of the\r\n     * cleanup logic in `shutdown()`.\r\n     */\r\n    isClientZombied(clientId) {\r\n        var _a;\r\n        try {\r\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\r\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\r\n            return isZombied;\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't working.\r\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Record client as zombied (a client that had its tab closed). Zombied\r\n     * clients are ignored during primary tab selection.\r\n     */\r\n    markClientZombied() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't available / working.\r\n            logError('Failed to set zombie client id.', e);\r\n        }\r\n    }\r\n    /** Removes the zombied client entry if it exists. */\r\n    removeClientZombiedEntry() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\r\n        }\r\n        catch (e) {\r\n            // Ignore\r\n        }\r\n    }\r\n    zombiedClientLocalStorageKey(clientId) {\r\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the primary client object store.\r\n */\r\nfunction primaryClientStore(txn) {\r\n    return getStore(txn, DbPrimaryClientStore);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the client metadata object store.\r\n */\r\nfunction clientMetadataStore(txn) {\r\n    return getStore(txn, DbClientMetadataStore);\r\n}\r\n/**\r\n * Generates a string used as a prefix when storing data in IndexedDB and\r\n * LocalStorage.\r\n */\r\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\r\n    // Use two different prefix formats:\r\n    //\r\n    //   * firestore / persistenceKey / projectID . databaseID / ...\r\n    //   * firestore / persistenceKey / projectID / ...\r\n    //\r\n    // projectIDs are DNS-compatible names and cannot contain dots\r\n    // so there's no danger of collisions.\r\n    let database = databaseId.projectId;\r\n    if (!databaseId.isDefaultDatabase) {\r\n        database += '.' + databaseId.database;\r\n    }\r\n    return 'firestore/' + persistenceKey + '/' + database + '/';\r\n}\r\nasync function indexedDbClearPersistence(persistenceKey) {\r\n    if (!SimpleDb.isAvailable()) {\r\n        return Promise.resolve();\r\n    }\r\n    const dbName = persistenceKey + MAIN_DATABASE;\r\n    await SimpleDb.delete(dbName);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Compares two array for equality using comparator. The method computes the\r\n * intersection and invokes `onAdd` for every element that is in `after` but not\r\n * `before`. `onRemove` is invoked for every element in `before` but missing\r\n * from `after`.\r\n *\r\n * The method creates a copy of both `before` and `after` and runs in O(n log\r\n * n), where n is the size of the two lists.\r\n *\r\n * @param before - The elements that exist in the original array.\r\n * @param after - The elements to diff against the original array.\r\n * @param comparator - The comparator for the elements in before and after.\r\n * @param onAdd - A function to invoke for every element that is part of `\r\n * after` but not `before`.\r\n * @param onRemove - A function to invoke for every element that is part of\r\n * `before` but not `after`.\r\n */\r\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\r\n    before = [...before];\r\n    after = [...after];\r\n    before.sort(comparator);\r\n    after.sort(comparator);\r\n    const bLen = before.length;\r\n    const aLen = after.length;\r\n    let a = 0;\r\n    let b = 0;\r\n    while (a < aLen && b < bLen) {\r\n        const cmp = comparator(before[b], after[a]);\r\n        if (cmp < 0) {\r\n            // The element was removed if the next element in our ordered\r\n            // walkthrough is only in `before`.\r\n            onRemove(before[b++]);\r\n        }\r\n        else if (cmp > 0) {\r\n            // The element was added if the next element in our ordered walkthrough\r\n            // is only in `after`.\r\n            onAdd(after[a++]);\r\n        }\r\n        else {\r\n            a++;\r\n            b++;\r\n        }\r\n    }\r\n    while (a < aLen) {\r\n        onAdd(after[a++]);\r\n    }\r\n    while (b < bLen) {\r\n        onRemove(before[b++]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$b = 'LocalStore';\r\n/**\r\n * The maximum time to leave a resume token buffered without writing it out.\r\n * This value is arbitrary: it's long enough to avoid several writes\r\n * (possibly indefinitely if updates come more frequently than this) but\r\n * short enough that restarting after crashing will still have a pretty\r\n * recent resume token.\r\n */\r\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\r\n/**\r\n * Implements `LocalStore` interface.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass LocalStoreImpl {\r\n    constructor(\r\n    /** Manages our in-memory or durable persistence. */\r\n    persistence, queryEngine, initialUser, serializer) {\r\n        this.persistence = persistence;\r\n        this.queryEngine = queryEngine;\r\n        this.serializer = serializer;\r\n        /**\r\n         * Maps a targetID to data about its target.\r\n         *\r\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\r\n         * of `applyRemoteEvent()` idempotent.\r\n         */\r\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\r\n        /** Maps a target to its targetID. */\r\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\r\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /**\r\n         * A per collection group index of the last read time processed by\r\n         * `getNewDocumentChanges()`.\r\n         *\r\n         * PORTING NOTE: This is only used for multi-tab synchronization.\r\n         */\r\n        this.collectionGroupReadTime = new Map();\r\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\r\n        this.targetCache = persistence.getTargetCache();\r\n        this.bundleCache = persistence.getBundleCache();\r\n        this.initializeUserComponents(initialUser);\r\n    }\r\n    initializeUserComponents(user) {\r\n        // TODO(indexing): Add spec tests that test these components change after a\r\n        // user change\r\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\r\n        this.indexManager = this.persistence.getIndexManager(user);\r\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\r\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\r\n        this.remoteDocuments.setIndexManager(this.indexManager);\r\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\r\n    }\r\n    collectGarbage(garbageCollector) {\r\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\r\n    }\r\n}\r\nfunction newLocalStore(\r\n/** Manages our in-memory or durable persistence. */\r\npersistence, queryEngine, initialUser, serializer) {\r\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\r\n}\r\n/**\r\n * Tells the LocalStore that the currently authenticated user has changed.\r\n *\r\n * In response the local store switches the mutation queue to the new user and\r\n * returns any resulting document changes.\r\n */\r\n// PORTING NOTE: Android and iOS only return the documents affected by the\r\n// change.\r\nasync function localStoreHandleUserChange(localStore, user) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\r\n        // Swap out the mutation queue, grabbing the pending mutation batches\r\n        // before and after.\r\n        let oldBatches;\r\n        return localStoreImpl.mutationQueue\r\n            .getAllMutationBatches(txn)\r\n            .next(promisedOldBatches => {\r\n            oldBatches = promisedOldBatches;\r\n            localStoreImpl.initializeUserComponents(user);\r\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\r\n        })\r\n            .next(newBatches => {\r\n            const removedBatchIds = [];\r\n            const addedBatchIds = [];\r\n            // Union the old/new changed keys.\r\n            let changedKeys = documentKeySet();\r\n            for (const batch of oldBatches) {\r\n                removedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            for (const batch of newBatches) {\r\n                addedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            // Return the set of all (potentially) changed documents and the list\r\n            // of mutation batch IDs that were affected by change.\r\n            return localStoreImpl.localDocuments\r\n                .getDocuments(txn, changedKeys)\r\n                .next(affectedDocuments => {\r\n                return {\r\n                    affectedDocuments,\r\n                    removedBatchIds,\r\n                    addedBatchIds\r\n                };\r\n            });\r\n        });\r\n    });\r\n    return result;\r\n}\r\n/* Accepts locally generated Mutations and commit them to storage. */\r\nfunction localStoreWriteLocally(localStore, mutations) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const localWriteTime = Timestamp.now();\r\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    let overlayedDocuments;\r\n    let mutationBatch;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\r\n        // Figure out which keys do not have a remote version in the cache, this\r\n        // is needed to create the right overlay mutation: if no remote version\r\n        // presents, we do not need to create overlays as patch mutations.\r\n        // TODO(Overlay): Is there a better way to determine this? Using the\r\n        //  document version does not work because local mutations set them back\r\n        //  to 0.\r\n        let remoteDocs = mutableDocumentMap();\r\n        let docsWithoutRemoteVersion = documentKeySet();\r\n        return localStoreImpl.remoteDocuments\r\n            .getEntries(txn, keys)\r\n            .next(docs => {\r\n            remoteDocs = docs;\r\n            remoteDocs.forEach((key, doc) => {\r\n                if (!doc.isValidDocument()) {\r\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\r\n                }\r\n            });\r\n        })\r\n            .next(() => {\r\n            // Load and apply all existing mutations. This lets us compute the\r\n            // current base state for all non-idempotent transforms before applying\r\n            // any additional user-provided writes.\r\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\r\n        })\r\n            .next((docs) => {\r\n            overlayedDocuments = docs;\r\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\r\n            // we record the base state in a separate patch mutation. This is\r\n            // later used to guarantee consistent values and prevents flicker\r\n            // even if the backend sends us an update that already includes our\r\n            // transform.\r\n            const baseMutations = [];\r\n            for (const mutation of mutations) {\r\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\r\n                if (baseValue != null) {\r\n                    // NOTE: The base state should only be applied if there's some\r\n                    // existing document to override, so use a Precondition of\r\n                    // exists=true\r\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\r\n                }\r\n            }\r\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\r\n        })\r\n            .next(batch => {\r\n            mutationBatch = batch;\r\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\r\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\r\n        });\r\n    })\r\n        .then(() => ({\r\n        batchId: mutationBatch.batchId,\r\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\r\n    }));\r\n}\r\n/**\r\n * Acknowledges the given batch.\r\n *\r\n * On the happy path when a batch is acknowledged, the local store will\r\n *\r\n *  + remove the batch from the mutation queue;\r\n *  + apply the changes to the remote document cache;\r\n *  + recalculate the latency compensated view implied by those changes (there\r\n *    may be mutations in the queue that affect the documents but haven't been\r\n *    acknowledged yet); and\r\n *  + give the changed documents back the sync engine\r\n *\r\n * @returns The resulting (modified) documents.\r\n */\r\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\r\n        const affected = batchResult.batch.keys();\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\r\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\r\n    });\r\n}\r\nfunction getKeysWithTransformResults(batchResult) {\r\n    let result = documentKeySet();\r\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\r\n        const mutationResult = batchResult.mutationResults[i];\r\n        if (mutationResult.transformResults.length > 0) {\r\n            result = result.add(batchResult.batch.mutations[i].key);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Removes mutations from the MutationQueue for the specified batch;\r\n * LocalDocuments will be recalculated.\r\n *\r\n * @returns The resulting modified documents.\r\n */\r\nfunction localStoreRejectBatch(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\r\n        let affectedKeys;\r\n        return localStoreImpl.mutationQueue\r\n            .lookupMutationBatch(txn, batchId)\r\n            .next((batch) => {\r\n            hardAssert(batch !== null);\r\n            affectedKeys = batch.keys();\r\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\r\n        })\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\r\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\r\n    });\r\n}\r\n/**\r\n * Returns the largest (latest) batch id in mutation queue that is pending\r\n * server response.\r\n *\r\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\r\n */\r\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\r\n}\r\n/**\r\n * Returns the last consistent snapshot processed (used by the RemoteStore to\r\n * determine whether to buffer incoming snapshots from the backend).\r\n */\r\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\r\n}\r\n/**\r\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\r\n * event reflects any write batches that have been acknowledged or rejected\r\n * (i.e. we do not re-apply local mutations to updates from this event).\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const remoteVersion = remoteEvent.snapshotVersion;\r\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\r\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n        const promises = [];\r\n        remoteEvent.targetChanges.forEach((change, targetId) => {\r\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\r\n            if (!oldTargetData) {\r\n                return;\r\n            }\r\n            // Only update the remote keys if the target is still active. This\r\n            // ensures that we can persist the updated target data along with\r\n            // the updated assignment.\r\n            promises.push(localStoreImpl.targetCache\r\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\r\n                .next(() => {\r\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\r\n            }));\r\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\r\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\r\n                newTargetData = newTargetData\r\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\r\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\r\n            }\r\n            else if (change.resumeToken.approximateByteSize() > 0) {\r\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\r\n            }\r\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\r\n            // Update the target data if there are target changes (or if\r\n            // sufficient time has passed since the last update).\r\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\r\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\r\n            }\r\n        });\r\n        let changedDocs = mutableDocumentMap();\r\n        let existenceChangedKeys = documentKeySet();\r\n        remoteEvent.documentUpdates.forEach(key => {\r\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\r\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\r\n            }\r\n        });\r\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\r\n        // the remote documents in advance in a single call.\r\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\r\n            changedDocs = result.changedDocuments;\r\n            existenceChangedKeys = result.existenceChangedKeys;\r\n        }));\r\n        // HACK: The only reason we allow a null snapshot version is so that we\r\n        // can synthesize remote events when we get permission denied errors while\r\n        // trying to resolve the state of a locally cached document that is in\r\n        // limbo.\r\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\r\n            const updateRemoteVersion = localStoreImpl.targetCache\r\n                .getLastRemoteSnapshotVersion(txn)\r\n                .next(lastRemoteSnapshotVersion => {\r\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\r\n            });\r\n            promises.push(updateRemoteVersion);\r\n        }\r\n        return PersistencePromise.waitFor(promises)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\r\n            .next(() => changedDocs);\r\n    })\r\n        .then(changedDocs => {\r\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\r\n        return changedDocs;\r\n    });\r\n}\r\n/**\r\n * Populates document change buffer with documents from backend or a bundle.\r\n * Returns the document changes resulting from applying those documents, and\r\n * also a set of documents whose existence state are changed as a result.\r\n *\r\n * @param txn - Transaction to use to read existing documents from storage.\r\n * @param documentBuffer - Document buffer to collect the resulted changes to be\r\n *        applied to storage.\r\n * @param documents - Documents to be applied.\r\n */\r\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\r\n    let updatedKeys = documentKeySet();\r\n    let existenceChangedKeys = documentKeySet();\r\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\r\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\r\n        let changedDocuments = mutableDocumentMap();\r\n        documents.forEach((key, doc) => {\r\n            const existingDoc = existingDocs.get(key);\r\n            // Check if see if there is a existence state change for this document.\r\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\r\n                existenceChangedKeys = existenceChangedKeys.add(key);\r\n            }\r\n            // Note: The order of the steps below is important, since we want\r\n            // to ensure that rejected limbo resolutions (which fabricate\r\n            // NoDocuments with SnapshotVersion.min()) never add documents to\r\n            // cache.\r\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\r\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\r\n                // events. We remove these documents from cache since we lost\r\n                // access.\r\n                documentBuffer.removeEntry(key, doc.readTime);\r\n                changedDocuments = changedDocuments.insert(key, doc);\r\n            }\r\n            else if (!existingDoc.isValidDocument() ||\r\n                doc.version.compareTo(existingDoc.version) > 0 ||\r\n                (doc.version.compareTo(existingDoc.version) === 0 &&\r\n                    existingDoc.hasPendingWrites)) {\r\n                documentBuffer.addEntry(doc);\r\n                changedDocuments = changedDocuments.insert(key, doc);\r\n            }\r\n            else {\r\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\r\n            }\r\n        });\r\n        return { changedDocuments, existenceChangedKeys };\r\n    });\r\n}\r\n/**\r\n * Returns true if the newTargetData should be persisted during an update of\r\n * an active target. TargetData should always be persisted when a target is\r\n * being released and should not call this function.\r\n *\r\n * While the target is active, TargetData updates can be omitted when nothing\r\n * about the target has changed except metadata like the resume token or\r\n * snapshot version. Occasionally it's worth the extra write to prevent these\r\n * values from getting too stale after a crash, but this doesn't have to be\r\n * too frequent.\r\n */\r\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\r\n    // Always persist target data if we don't already have a resume token.\r\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\r\n        return true;\r\n    }\r\n    // Don't allow resume token changes to be buffered indefinitely. This\r\n    // allows us to be reasonably up-to-date after a crash and avoids needing\r\n    // to loop over all active queries on shutdown. Especially in the browser\r\n    // we may not get time to do anything interesting while the current tab is\r\n    // closing.\r\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\r\n        oldTargetData.snapshotVersion.toMicroseconds();\r\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\r\n        return true;\r\n    }\r\n    // Otherwise if the only thing that has changed about a target is its resume\r\n    // token it's not worth persisting. Note that the RemoteStore keeps an\r\n    // in-memory view of the currently active targets which includes the current\r\n    // resume token, so stream failure or user changes will still use an\r\n    // up-to-date resume token regardless of what we do here.\r\n    const changes = change.addedDocuments.size +\r\n        change.modifiedDocuments.size +\r\n        change.removedDocuments.size;\r\n    return changes > 0;\r\n}\r\n/**\r\n * Notifies local store of the changed views to locally pin documents.\r\n */\r\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    try {\r\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\r\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\r\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\r\n            });\r\n        });\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\r\n            // number for the documents that were included in this transaction.\r\n            // This might trigger them to be deleted earlier than they otherwise\r\n            // would have, but it should not invalidate the integrity of the data.\r\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    for (const viewChange of viewChanges) {\r\n        const targetId = viewChange.targetId;\r\n        if (!viewChange.fromCache) {\r\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n            // Advance the last limbo free snapshot version\r\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\r\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\r\n            // TODO(b/272564316): Apply the optimization done on other platforms.\r\n            // This is a problem for web because saving the updated targetData from\r\n            // non-primary client conflicts with what primary client saved.\r\n        }\r\n    }\r\n}\r\n/**\r\n * Gets the mutation batch after the passed in batchId in the mutation queue\r\n * or null if empty.\r\n * @param afterBatchId - If provided, the batch to search after.\r\n * @returns The next mutation or null if there wasn't one.\r\n */\r\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\r\n        if (afterBatchId === undefined) {\r\n            afterBatchId = BATCHID_UNKNOWN;\r\n        }\r\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\r\n    });\r\n}\r\n/**\r\n * Reads the current value of a Document with a given key or null if not\r\n * found - used for testing.\r\n */\r\nfunction localStoreReadDocument(localStore, key) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\r\n}\r\n/**\r\n * Assigns the given target an internal ID so that its results can be pinned so\r\n * they don't get GC'd. A target must be allocated in the local store before\r\n * the store can be used to manage its view.\r\n *\r\n * Allocating an already allocated `Target` will return the existing `TargetData`\r\n * for that `Target`.\r\n */\r\nfunction localStoreAllocateTarget(localStore, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Allocate target', 'readwrite', txn => {\r\n        let targetData;\r\n        return localStoreImpl.targetCache\r\n            .getTargetData(txn, target)\r\n            .next((cached) => {\r\n            if (cached) {\r\n                // This target has been listened to previously, so reuse the\r\n                // previous targetID.\r\n                // TODO(mcg): freshen last accessed date?\r\n                targetData = cached;\r\n                return PersistencePromise.resolve(targetData);\r\n            }\r\n            else {\r\n                return localStoreImpl.targetCache\r\n                    .allocateTargetId(txn)\r\n                    .next(targetId => {\r\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\r\n                    return localStoreImpl.targetCache\r\n                        .addTargetData(txn, targetData)\r\n                        .next(() => targetData);\r\n                });\r\n            }\r\n        });\r\n    })\r\n        .then(targetData => {\r\n        // If Multi-Tab is enabled, the existing target data may be newer than\r\n        // the in-memory data\r\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\r\n        if (cachedTargetData === null ||\r\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\r\n                0) {\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\r\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\r\n        }\r\n        return targetData;\r\n    });\r\n}\r\n/**\r\n * Returns the TargetData as seen by the LocalStore, including updates that may\r\n * have not yet been persisted to the TargetCache.\r\n */\r\n// Visible for testing.\r\nfunction localStoreGetTargetData(localStore, transaction, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\r\n    if (targetId !== undefined) {\r\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\r\n    }\r\n    else {\r\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\r\n    }\r\n}\r\n/**\r\n * Unpins all the documents associated with the given target. If\r\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\r\n * directly removes the associated target data from the target cache.\r\n *\r\n * Releasing a non-existing `Target` is a no-op.\r\n */\r\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\r\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\r\n    try {\r\n        if (!keepPersistedTargetData) {\r\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\r\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\r\n            });\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // All `releaseTarget` does is record the final metadata state for the\r\n            // target, but we've been recording this periodically during target\r\n            // activity. If we lose this write this could cause a very slight\r\n            // difference in the order of target deletion during GC, but we\r\n            // don't define exact LRU semantics so this is acceptable.\r\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    localStoreImpl.targetDataByTarget =\r\n        localStoreImpl.targetDataByTarget.remove(targetId);\r\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\r\n}\r\n/**\r\n * Runs the specified query against the local store and returns the results,\r\n * potentially taking advantage of query data from previous executions (such\r\n * as the set of remote keys).\r\n *\r\n * @param usePreviousResults - Whether results from previous executions can\r\n * be used to optimize this query execution.\r\n */\r\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\r\n    let remoteKeys = documentKeySet();\r\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\r\n    // Use readwrite instead of readonly so indexes can be created\r\n    txn => {\r\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\r\n            .next(targetData => {\r\n            if (targetData) {\r\n                lastLimboFreeSnapshotVersion =\r\n                    targetData.lastLimboFreeSnapshotVersion;\r\n                return localStoreImpl.targetCache\r\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n                    .next(result => {\r\n                    remoteKeys = result;\r\n                });\r\n            }\r\n        })\r\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\r\n            ? lastLimboFreeSnapshotVersion\r\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\r\n            .next(documents => {\r\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\r\n            return { documents, remoteKeys };\r\n        });\r\n    });\r\n}\r\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\r\n    const batch = batchResult.batch;\r\n    const docKeys = batch.keys();\r\n    let promiseChain = PersistencePromise.resolve();\r\n    docKeys.forEach(docKey => {\r\n        promiseChain = promiseChain\r\n            .next(() => documentBuffer.getEntry(txn, docKey))\r\n            .next(doc => {\r\n            const ackVersion = batchResult.docVersions.get(docKey);\r\n            hardAssert(ackVersion !== null);\r\n            if (doc.version.compareTo(ackVersion) < 0) {\r\n                batch.applyToRemoteDocument(doc, batchResult);\r\n                if (doc.isValidDocument()) {\r\n                    // We use the commitVersion as the readTime rather than the\r\n                    // document's updateTime since the updateTime is not advanced\r\n                    // for updates that do not modify the underlying document.\r\n                    doc.setReadTime(batchResult.commitVersion);\r\n                    documentBuffer.addEntry(doc);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\r\n}\r\n/** Returns the local view of the documents affected by a mutation batch. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\r\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\r\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\r\n            if (keys) {\r\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n        });\r\n    });\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\r\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\r\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetActiveClients(localStore) {\r\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\r\n    return persistenceImpl.getActiveClients();\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetCachedTarget(localStore, targetId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\r\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    if (cachedTargetData) {\r\n        return Promise.resolve(cachedTargetData.target);\r\n    }\r\n    else {\r\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\r\n            return targetCacheImpl\r\n                .getTargetDataForTarget(txn, targetId)\r\n                .next(targetData => (targetData ? targetData.target : null));\r\n        });\r\n    }\r\n}\r\n/**\r\n * Returns the set of documents that have been updated since the last call.\r\n * If this is the first call, returns the set of changes since client\r\n * initialization. Further invocations will return document that have changed\r\n * since the prior call.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    // Get the current maximum read time for the collection. This should always\r\n    // exist, but to reduce the chance for regressions we default to\r\n    // SnapshotVersion.Min()\r\n    // TODO(indexing): Consider removing the default value.\r\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\r\n        SnapshotVersion.min();\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \r\n    /* limit= */ Number.MAX_SAFE_INTEGER))\r\n        .then(changedDocs => {\r\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\r\n        return changedDocs;\r\n    });\r\n}\r\n/** Sets the collection group's maximum read time from the given documents. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\r\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\r\n        SnapshotVersion.min();\r\n    changedDocs.forEach((_, doc) => {\r\n        if (doc.readTime.compareTo(readTime) > 0) {\r\n            readTime = doc.readTime;\r\n        }\r\n    });\r\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\r\n}\r\n/**\r\n * Creates a new target using the given bundle name, which will be used to\r\n * hold the keys of all documents from the bundle in query-document mappings.\r\n * This ensures that the loaded documents do not get garbage collected\r\n * right away.\r\n */\r\nfunction umbrellaTarget(bundleName) {\r\n    // It is OK that the path used for the query is not valid, because this will\r\n    // not be read and queried.\r\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\r\n}\r\n/**\r\n * Applies the documents from a bundle to the \"ground-state\" (remote)\r\n * documents.\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let documentKeys = documentKeySet();\r\n    let documentMap = mutableDocumentMap();\r\n    for (const bundleDoc of documents) {\r\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n        if (bundleDoc.document) {\r\n            documentKeys = documentKeys.add(documentKey);\r\n        }\r\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\r\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\r\n        documentMap = documentMap.insert(documentKey, doc);\r\n    }\r\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n    });\r\n    // Allocates a target to hold all document keys from the bundle, such that\r\n    // they will not get garbage collected right away.\r\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\r\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\r\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\r\n            .next(documentChangeResult => {\r\n            documentBuffer.apply(txn);\r\n            return documentChangeResult;\r\n        })\r\n            .next(documentChangeResult => {\r\n            return localStoreImpl.targetCache\r\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\r\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\r\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\r\n                .next(() => documentChangeResult.changedDocuments);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a boolean to indicate if the given bundle has already\r\n * been loaded and the create time is newer than the current loading bundle.\r\n */\r\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\r\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\r\n    })\r\n        .then(cached => {\r\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\r\n    });\r\n}\r\n/**\r\n * Saves the given `BundleMetadata` to local persistence.\r\n */\r\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\r\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\r\n * resolves to undefined if no persisted data can be found.\r\n */\r\nfunction localStoreGetNamedQuery(localStore, queryName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\r\n}\r\n/**\r\n * Saves the given `NamedQuery` to local persistence.\r\n */\r\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\r\n    // Allocate a target for the named query such that it can be resumed\r\n    // from associated read time if users use it to listen.\r\n    // NOTE: this also means if no corresponding target exists, the new target\r\n    // will remain active and will not get collected, unless users happen to\r\n    // unlisten the query somehow.\r\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\r\n        const readTime = fromVersion(query.readTime);\r\n        // Simply save the query itself if it is older than what the SDK already\r\n        // has.\r\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\r\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\r\n        }\r\n        // Update existing target data because the query from the bundle is newer.\r\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\r\n        localStoreImpl.targetDataByTarget =\r\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\r\n        return localStoreImpl.targetCache\r\n            .updateTargetData(transaction, newTargetData)\r\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\r\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\r\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\r\n    });\r\n}\r\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const indexManager = localStoreImpl.indexManager;\r\n    const promises = [];\r\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\r\n        .getFieldIndexes(transaction)\r\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\r\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\r\n    }, fieldIndex => {\r\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\r\n    }))\r\n        .next(() => PersistencePromise.waitFor(promises)));\r\n}\r\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\r\n}\r\nfunction localStoreDeleteAllFieldIndexes(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const indexManager = localStoreImpl.indexManager;\r\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A tracker to keep a record of important details during database local query\r\n * execution.\r\n */\r\nclass QueryContext {\r\n    constructor() {\r\n        /**\r\n         * Counts the number of documents passed through during local query execution.\r\n         */\r\n        this._documentReadCount = 0;\r\n    }\r\n    get documentReadCount() {\r\n        return this._documentReadCount;\r\n    }\r\n    incrementDocumentReadCount(amount) {\r\n        this._documentReadCount += amount;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\r\n/**\r\n * This cost represents the evaluation result of\r\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\r\n * / ([docKey, docContent] per documents in full collection scan) coming from\r\n * experiment [enter PR experiment URL here].\r\n */\r\nfunction getDefaultRelativeIndexReadCostPerDocument() {\r\n    // These values were derived from an experiment where several members of the\r\n    // Firestore SDK team ran a performance test in various environments.\r\n    // Googlers can see b/299284287 for details.\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)()) {\r\n        return 8;\r\n    }\r\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) > 0) {\r\n        return 6;\r\n    }\r\n    else {\r\n        return 4;\r\n    }\r\n}\r\n/**\r\n * The Firestore query engine.\r\n *\r\n * Firestore queries can be executed in three modes. The Query Engine determines\r\n * what mode to use based on what data is persisted. The mode only determines\r\n * the runtime complexity of the query - the result set is equivalent across all\r\n * implementations.\r\n *\r\n * The Query engine will use indexed-based execution if a user has configured\r\n * any index that can be used to execute query (via `setIndexConfiguration()`).\r\n * Otherwise, the engine will try to optimize the query by re-using a previously\r\n * persisted query result. If that is not possible, the query will be executed\r\n * via a full collection scan.\r\n *\r\n * Index-based execution is the default when available. The query engine\r\n * supports partial indexed execution and merges the result from the index\r\n * lookup with documents that have not yet been indexed. The index evaluation\r\n * matches the backend's format and as such, the SDK can use indexing for all\r\n * queries that the backend supports.\r\n *\r\n * If no index exists, the query engine tries to take advantage of the target\r\n * document mapping in the TargetCache. These mappings exists for all queries\r\n * that have been synced with the backend at least once and allow the query\r\n * engine to only read documents that previously matched a query plus any\r\n * documents that were edited after the query was last listened to.\r\n *\r\n * There are some cases when this optimization is not guaranteed to produce\r\n * the same results as full collection scans. In these cases, query\r\n * processing falls back to full scans. These cases are:\r\n *\r\n * - Limit queries where a document that matched the query previously no longer\r\n *   matches the query.\r\n *\r\n * - Limit queries where a document edit may cause the document to sort below\r\n *   another document that is in the local cache.\r\n *\r\n * - Queries that have never been CURRENT or free of limbo documents.\r\n */\r\nclass QueryEngine {\r\n    constructor() {\r\n        this.initialized = false;\r\n        this.indexAutoCreationEnabled = false;\r\n        /**\r\n         * SDK only decides whether it should create index when collection size is\r\n         * larger than this.\r\n         */\r\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\r\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\r\n    }\r\n    /** Sets the document view to query against. */\r\n    initialize(localDocuments, indexManager) {\r\n        this.localDocumentsView = localDocuments;\r\n        this.indexManager = indexManager;\r\n        this.initialized = true;\r\n    }\r\n    /** Returns all local documents matching the specified query. */\r\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\r\n        // Stores the result from executing the query; using this object is more\r\n        // convenient than passing the result between steps of the persistence\r\n        // transaction and improves readability comparatively.\r\n        const queryResult = { result: null };\r\n        return this.performQueryUsingIndex(transaction, query)\r\n            .next(result => {\r\n            queryResult.result = result;\r\n        })\r\n            .next(() => {\r\n            if (queryResult.result) {\r\n                return;\r\n            }\r\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\r\n                queryResult.result = result;\r\n            });\r\n        })\r\n            .next(() => {\r\n            if (queryResult.result) {\r\n                return;\r\n            }\r\n            const context = new QueryContext();\r\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\r\n                queryResult.result = result;\r\n                if (this.indexAutoCreationEnabled) {\r\n                    return this.createCacheIndexes(transaction, query, context, result.size);\r\n                }\r\n            });\r\n        })\r\n            .next(() => queryResult.result);\r\n    }\r\n    createCacheIndexes(transaction, query, context, resultSize) {\r\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\r\n            }\r\n            return PersistencePromise.resolve();\r\n        }\r\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\r\n        }\r\n        if (context.documentReadCount >\r\n            this.relativeIndexReadCostPerDocument * resultSize) {\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\r\n            }\r\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    /**\r\n     * Performs an indexed query that evaluates the query based on a collection's\r\n     * persisted index values. Returns `null` if an index is not available.\r\n     */\r\n    performQueryUsingIndex(transaction, query) {\r\n        if (queryMatchesAllDocuments(query)) {\r\n            // Queries that match all documents don't benefit from using\r\n            // key-based lookups. It is more efficient to scan all documents in a\r\n            // collection, rather than to perform individual lookups.\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        let target = queryToTarget(query);\r\n        return this.indexManager\r\n            .getIndexType(transaction, target)\r\n            .next(indexType => {\r\n            if (indexType === 0 /* IndexType.NONE */) {\r\n                // The target cannot be served from any index.\r\n                return null;\r\n            }\r\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\r\n                // We cannot apply a limit for targets that are served using a partial\r\n                // index. If a partial index will be used to serve the target, the\r\n                // query may return a superset of documents that match the target\r\n                // (e.g. if the index doesn't include all the target's filters), or\r\n                // may return the correct set of documents in the wrong order (e.g. if\r\n                // the index doesn't include a segment for one of the orderBys).\r\n                // Therefore, a limit should not be applied in such cases.\r\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\r\n                target = queryToTarget(query);\r\n            }\r\n            return this.indexManager\r\n                .getDocumentsMatchingTarget(transaction, target)\r\n                .next(keys => {\r\n                const sortedKeys = documentKeySet(...keys);\r\n                return this.localDocumentsView\r\n                    .getDocuments(transaction, sortedKeys)\r\n                    .next(indexedDocuments => {\r\n                    return this.indexManager\r\n                        .getMinOffset(transaction, target)\r\n                        .next(offset => {\r\n                        const previousResults = this.applyQuery(query, indexedDocuments);\r\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\r\n                            // A limit query whose boundaries change due to local\r\n                            // edits can be re-run against the cache by excluding the\r\n                            // limit. This ensures that all documents that match the\r\n                            // query's filters are included in the result set. The SDK\r\n                            // can then apply the limit once all local edits are\r\n                            // incorporated.\r\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\r\n                        }\r\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Performs a query based on the target's persisted query mapping. Returns\r\n     * `null` if the mapping is not available or cannot be used.\r\n     */\r\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\r\n        if (queryMatchesAllDocuments(query)) {\r\n            // Queries that match all documents don't benefit from using\r\n            // key-based lookups. It is more efficient to scan all documents in a\r\n            // collection, rather than to perform individual lookups.\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        // Queries that have never seen a snapshot without limbo free documents\r\n        // should also be run as a full collection scan.\r\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\r\n            return PersistencePromise.resolve(null);\r\n        }\r\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\r\n            const previousResults = this.applyQuery(query, documents);\r\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\r\n            }\r\n            // Retrieve all results for documents that were updated since the last\r\n            // limbo-document free remote snapshot.\r\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\r\n        });\r\n    }\r\n    /** Applies the query filter and sorting to the provided documents.  */\r\n    applyQuery(query, documents) {\r\n        // Sort the documents and re-apply the query filter since previously\r\n        // matching documents do not necessarily still match the query.\r\n        let queryResults = new SortedSet(newQueryComparator(query));\r\n        documents.forEach((_, maybeDoc) => {\r\n            if (queryMatches(query, maybeDoc)) {\r\n                queryResults = queryResults.add(maybeDoc);\r\n            }\r\n        });\r\n        return queryResults;\r\n    }\r\n    /**\r\n     * Determines if a limit query needs to be refilled from cache, making it\r\n     * ineligible for index-free execution.\r\n     *\r\n     * @param query - The query.\r\n     * @param sortedPreviousResults - The documents that matched the query when it\r\n     * was last synchronized, sorted by the query's comparator.\r\n     * @param remoteKeys - The document keys that matched the query at the last\r\n     * snapshot.\r\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\r\n     * query was last synchronized.\r\n     */\r\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\r\n        if (query.limit === null) {\r\n            // Queries without limits do not need to be refilled.\r\n            return false;\r\n        }\r\n        if (remoteKeys.size !== sortedPreviousResults.size) {\r\n            // The query needs to be refilled if a previously matching document no\r\n            // longer matches.\r\n            return true;\r\n        }\r\n        // Limit queries are not eligible for index-free query execution if there is\r\n        // a potential that an older document from cache now sorts before a document\r\n        // that was previously part of the limit. This, however, can only happen if\r\n        // the document at the edge of the limit goes out of limit.\r\n        // If a document that is not the limit boundary sorts differently,\r\n        // the boundary of the limit itself did not change and documents from cache\r\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\r\n        // any modifications that don't affect the last document.\r\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\r\n            ? sortedPreviousResults.last()\r\n            : sortedPreviousResults.first();\r\n        if (!docAtLimitEdge) {\r\n            // We don't need to refill the query if there were already no documents.\r\n            return false;\r\n        }\r\n        return (docAtLimitEdge.hasPendingWrites ||\r\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\r\n    }\r\n    executeFullCollectionScan(transaction, query, context) {\r\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\r\n        }\r\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\r\n    }\r\n    /**\r\n     * Combines the results from an indexed execution with the remaining documents\r\n     * that have not yet been indexed.\r\n     */\r\n    appendRemainingResults(transaction, indexedResults, query, offset) {\r\n        // Retrieve all results for documents that were updated since the offset.\r\n        return this.localDocumentsView\r\n            .getDocumentsMatchingQuery(transaction, query, offset)\r\n            .next(remainingResults => {\r\n            // Merge with existing results\r\n            indexedResults.forEach(d => {\r\n                remainingResults = remainingResults.insert(d.key, d);\r\n            });\r\n            return remainingResults;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The format of the LocalStorage key that stores the client state is:\r\n//     firestore_clients_<persistence_prefix>_<instance_key>\r\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\r\n/** Assembles the key for a client state in WebStorage */\r\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\r\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\r\n}\r\n// The format of the WebStorage key that stores the mutation state is:\r\n//     firestore_mutations_<persistence_prefix>_<batch_id>\r\n//     (for unauthenticated users)\r\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\r\n//\r\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\r\n// contain.\r\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\r\n/** Assembles the key for a mutation batch in WebStorage */\r\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\r\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\r\n    if (user.isAuthenticated()) {\r\n        mutationKey += `_${user.uid}`;\r\n    }\r\n    return mutationKey;\r\n}\r\n// The format of the WebStorage key that stores a query target's metadata is:\r\n//     firestore_targets_<persistence_prefix>_<target_id>\r\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\r\n/** Assembles the key for a query state in WebStorage */\r\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\r\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\r\n}\r\n// The WebStorage prefix that stores the primary tab's online state. The\r\n// format of the key is:\r\n//     firestore_online_state_<persistence_prefix>\r\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\r\n/** Assembles the key for the online state of the primary tab. */\r\nfunction createWebStorageOnlineStateKey(persistenceKey) {\r\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage prefix that plays as a event to indicate the remote documents\r\n// might have changed due to some secondary tabs loading a bundle.\r\n// format of the key is:\r\n//     firestore_bundle_loaded_v2_<persistenceKey>\r\n// The version ending with \"v2\" stores the list of modified collection groups.\r\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\r\nfunction createBundleLoadedKey(persistenceKey) {\r\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\r\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\r\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\r\n/** Assembles the key for the current sequence number. */\r\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\r\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$a = 'SharedClientState';\r\n/**\r\n * Holds the state of a mutation batch, including its user ID, batch ID and\r\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass MutationMetadata {\r\n    constructor(user, batchId, state, error) {\r\n        this.user = user;\r\n        this.batchId = batchId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(user, batchId, value) {\r\n        const mutationBatch = JSON.parse(value);\r\n        let validData = typeof mutationBatch === 'object' &&\r\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\r\n                -1 &&\r\n            (mutationBatch.error === undefined ||\r\n                typeof mutationBatch.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && mutationBatch.error) {\r\n            validData =\r\n                typeof mutationBatch.error.message === 'string' &&\r\n                    typeof mutationBatch.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const batchMetadata = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            batchMetadata.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(batchMetadata);\r\n    }\r\n}\r\n/**\r\n * Holds the state of a query target, including its target ID and whether the\r\n * target is 'not-current', 'current' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass QueryTargetMetadata {\r\n    constructor(targetId, state, error) {\r\n        this.targetId = targetId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(targetId, value) {\r\n        const targetState = JSON.parse(value);\r\n        let validData = typeof targetState === 'object' &&\r\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\r\n                -1 &&\r\n            (targetState.error === undefined ||\r\n                typeof targetState.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && targetState.error) {\r\n            validData =\r\n                typeof targetState.error.message === 'string' &&\r\n                    typeof targetState.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const targetState = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            targetState.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(targetState);\r\n    }\r\n}\r\n/**\r\n * This class represents the immutable ClientState for a client read from\r\n * WebStorage, containing the list of active query targets.\r\n */\r\nclass RemoteClientState {\r\n    constructor(clientId, activeTargetIds) {\r\n        this.clientId = clientId;\r\n        this.activeTargetIds = activeTargetIds;\r\n    }\r\n    /**\r\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(clientId, value) {\r\n        const clientState = JSON.parse(value);\r\n        let validData = typeof clientState === 'object' &&\r\n            clientState.activeTargetIds instanceof Array;\r\n        let activeTargetIdsSet = targetIdSet();\r\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\r\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\r\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\r\n        }\r\n        if (validData) {\r\n            return new RemoteClientState(clientId, activeTargetIdsSet);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * This class represents the online state for all clients participating in\r\n * multi-tab. The online state is only written to by the primary client, and\r\n * used in secondary clients to update their query views.\r\n */\r\nclass SharedOnlineState {\r\n    constructor(clientId, onlineState) {\r\n        this.clientId = clientId;\r\n        this.onlineState = onlineState;\r\n    }\r\n    /**\r\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(value) {\r\n        const onlineState = JSON.parse(value);\r\n        const validData = typeof onlineState === 'object' &&\r\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\r\n                -1 &&\r\n            typeof onlineState.clientId === 'string';\r\n        if (validData) {\r\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\r\n * mutable and keeps track of all pending mutations, which allows us to\r\n * update the range of pending mutation batch IDs as new mutations are added or\r\n * removed.\r\n *\r\n * The data in `LocalClientState` is not read from WebStorage and instead\r\n * updated via its instance methods. The updated state can be serialized via\r\n * `toWebStorageJSON()`.\r\n */\r\n// Visible for testing.\r\nclass LocalClientState {\r\n    constructor() {\r\n        this.activeTargetIds = targetIdSet();\r\n    }\r\n    addQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\r\n    }\r\n    removeQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\r\n    }\r\n    /**\r\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\r\n     * Does not encode `clientId` as it is part of the key in WebStorage.\r\n     */\r\n    toWebStorageJSON() {\r\n        const data = {\r\n            activeTargetIds: this.activeTargetIds.toArray(),\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        return JSON.stringify(data);\r\n    }\r\n}\r\n/**\r\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\r\n * backing store for the SharedClientState. It keeps track of all active\r\n * clients and supports modifications of the local client's data.\r\n */\r\nclass WebStorageSharedClientState {\r\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\r\n        this.window = window;\r\n        this.queue = queue;\r\n        this.persistenceKey = persistenceKey;\r\n        this.localClientId = localClientId;\r\n        this.syncEngine = null;\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n        this.storageListener = this.handleWebStorageEvent.bind(this);\r\n        this.activeClients = new SortedMap(primitiveComparator);\r\n        this.started = false;\r\n        /**\r\n         * Captures WebStorage events that occur before `start()` is called. These\r\n         * events are replayed once `WebStorageSharedClientState` is started.\r\n         */\r\n        this.earlyEvents = [];\r\n        // Escape the special characters mentioned here:\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n        this.storage = this.window.localStorage;\r\n        this.currentUser = initialUser;\r\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\r\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\r\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\r\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\r\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\r\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\r\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\r\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\r\n        // Rather than adding the storage observer during start(), we add the\r\n        // storage observer during initialization. This ensures that we collect\r\n        // events before other components populate their initial state (during their\r\n        // respective start() calls). Otherwise, we might for example miss a\r\n        // mutation that is added after LocalStore's start() processed the existing\r\n        // mutations but before we observe WebStorage events.\r\n        this.window.addEventListener('storage', this.storageListener);\r\n    }\r\n    /** Returns 'true' if WebStorage is available in the current environment. */\r\n    static isAvailable(window) {\r\n        return !!(window && window.localStorage);\r\n    }\r\n    async start() {\r\n        // Retrieve the list of existing clients to backfill the data in\r\n        // SharedClientState.\r\n        const existingClients = await this.syncEngine.getActiveClients();\r\n        for (const clientId of existingClients) {\r\n            if (clientId === this.localClientId) {\r\n                continue;\r\n            }\r\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\r\n            if (storageItem) {\r\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\r\n                if (clientState) {\r\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\r\n                }\r\n            }\r\n        }\r\n        this.persistClientState();\r\n        // Check if there is an existing online state and call the callback handler\r\n        // if applicable.\r\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\r\n        if (onlineStateJSON) {\r\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\r\n            if (onlineState) {\r\n                this.handleOnlineStateEvent(onlineState);\r\n            }\r\n        }\r\n        for (const event of this.earlyEvents) {\r\n            this.handleWebStorageEvent(event);\r\n        }\r\n        this.earlyEvents = [];\r\n        // Register a window unload hook to remove the client metadata entry from\r\n        // WebStorage even if `shutdown()` was not called.\r\n        this.window.addEventListener('pagehide', () => this.shutdown());\r\n        this.started = true;\r\n    }\r\n    writeSequenceNumber(sequenceNumber) {\r\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.extractActiveQueryTargets(this.activeClients);\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        let found = false;\r\n        this.activeClients.forEach((key, value) => {\r\n            if (value.activeTargetIds.has(targetId)) {\r\n                found = true;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        this.persistMutationState(batchId, 'pending');\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        this.persistMutationState(batchId, state, error);\r\n        // Once a final mutation result is observed by other clients, they no longer\r\n        // access the mutation's metadata entry. Since WebStorage replays events\r\n        // in order, it is safe to delete the entry right after updating it.\r\n        this.removeMutationState(batchId);\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        let queryState = 'not-current';\r\n        // Lookup an existing query state if the target ID was already registered\r\n        // by another tab\r\n        if (this.isActiveQueryTarget(targetId)) {\r\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n            if (storageItem) {\r\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\r\n                if (metadata) {\r\n                    queryState = metadata.state;\r\n                }\r\n            }\r\n        }\r\n        this.localClientState.addQueryTarget(targetId);\r\n        this.persistClientState();\r\n        return queryState;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localClientState.removeQueryTarget(targetId);\r\n        this.persistClientState();\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localClientState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.persistQueryTargetState(targetId, state, error);\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        removedBatchIds.forEach(batchId => {\r\n            this.removeMutationState(batchId);\r\n        });\r\n        this.currentUser = user;\r\n        addedBatchIds.forEach(batchId => {\r\n            this.addPendingMutation(batchId);\r\n        });\r\n    }\r\n    setOnlineState(onlineState) {\r\n        this.persistOnlineState(onlineState);\r\n    }\r\n    notifyBundleLoaded(collectionGroups) {\r\n        this.persistBundleLoadedState(collectionGroups);\r\n    }\r\n    shutdown() {\r\n        if (this.started) {\r\n            this.window.removeEventListener('storage', this.storageListener);\r\n            this.removeItem(this.localClientStorageKey);\r\n            this.started = false;\r\n        }\r\n    }\r\n    getItem(key) {\r\n        const value = this.storage.getItem(key);\r\n        logDebug(LOG_TAG$a, 'READ', key, value);\r\n        return value;\r\n    }\r\n    setItem(key, value) {\r\n        logDebug(LOG_TAG$a, 'SET', key, value);\r\n        this.storage.setItem(key, value);\r\n    }\r\n    removeItem(key) {\r\n        logDebug(LOG_TAG$a, 'REMOVE', key);\r\n        this.storage.removeItem(key);\r\n    }\r\n    handleWebStorageEvent(event) {\r\n        // Note: The function is typed to take Event to be interface-compatible with\r\n        // `Window.addEventListener`.\r\n        const storageEvent = event;\r\n        if (storageEvent.storageArea === this.storage) {\r\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\r\n            if (storageEvent.key === this.localClientStorageKey) {\r\n                logError('Received WebStorage notification for local change. Another client might have ' +\r\n                    'garbage-collected our state');\r\n                return;\r\n            }\r\n            this.queue.enqueueRetryable(async () => {\r\n                if (!this.started) {\r\n                    this.earlyEvents.push(storageEvent);\r\n                    return;\r\n                }\r\n                if (storageEvent.key === null) {\r\n                    return;\r\n                }\r\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue != null) {\r\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\r\n                        if (clientState) {\r\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\r\n                        return this.handleClientStateEvent(clientId, null);\r\n                    }\r\n                }\r\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (mutationMetadata) {\r\n                            return this.handleMutationBatchEvent(mutationMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (queryTargetMetadata) {\r\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.onlineStateKey) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\r\n                        if (onlineState) {\r\n                            return this.handleOnlineStateEvent(onlineState);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.sequenceNumberKey) {\r\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\r\n                    if (sequenceNumber !== ListenSequence.INVALID) {\r\n                        this.sequenceNumberHandler(sequenceNumber);\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.bundleLoadedKey) {\r\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\r\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\r\n                }\r\n            });\r\n        }\r\n    }\r\n    get localClientState() {\r\n        return this.activeClients.get(this.localClientId);\r\n    }\r\n    persistClientState() {\r\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\r\n    }\r\n    persistMutationState(batchId, state, error) {\r\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\r\n    }\r\n    removeMutationState(batchId) {\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.removeItem(mutationKey);\r\n    }\r\n    persistOnlineState(onlineState) {\r\n        const entry = {\r\n            clientId: this.localClientId,\r\n            onlineState\r\n        };\r\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\r\n    }\r\n    persistQueryTargetState(targetId, state, error) {\r\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\r\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\r\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\r\n    }\r\n    persistBundleLoadedState(collectionGroups) {\r\n        const json = JSON.stringify(Array.from(collectionGroups));\r\n        this.setItem(this.bundleLoadedKey, json);\r\n    }\r\n    /**\r\n     * Parses a client state key in WebStorage. Returns null if the key does not\r\n     * match the expected key format.\r\n     */\r\n    fromWebStorageClientStateKey(key) {\r\n        const match = this.clientStateKeyRe.exec(key);\r\n        return match ? match[1] : null;\r\n    }\r\n    /**\r\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\r\n     * be parsed.\r\n     */\r\n    fromWebStorageClientState(key, value) {\r\n        const clientId = this.fromWebStorageClientStateKey(key);\r\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\r\n    }\r\n    /**\r\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageMutationMetadata(key, value) {\r\n        const match = this.mutationBatchKeyRe.exec(key);\r\n        const batchId = Number(match[1]);\r\n        const userId = match[2] !== undefined ? match[2] : null;\r\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\r\n    }\r\n    /**\r\n     * Parses a query target state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageQueryTargetMetadata(key, value) {\r\n        const match = this.queryTargetKeyRe.exec(key);\r\n        const targetId = Number(match[1]);\r\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\r\n    }\r\n    /**\r\n     * Parses an online state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageOnlineState(value) {\r\n        return SharedOnlineState.fromWebStorageEntry(value);\r\n    }\r\n    fromWebStoreBundleLoadedState(value) {\r\n        return JSON.parse(value);\r\n    }\r\n    async handleMutationBatchEvent(mutationBatch) {\r\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\r\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\r\n            return;\r\n        }\r\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\r\n    }\r\n    handleQueryTargetEvent(targetMetadata) {\r\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\r\n    }\r\n    handleClientStateEvent(clientId, clientState) {\r\n        const updatedClients = clientState\r\n            ? this.activeClients.insert(clientId, clientState)\r\n            : this.activeClients.remove(clientId);\r\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\r\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\r\n        const addedTargets = [];\r\n        const removedTargets = [];\r\n        newTargets.forEach(targetId => {\r\n            if (!existingTargets.has(targetId)) {\r\n                addedTargets.push(targetId);\r\n            }\r\n        });\r\n        existingTargets.forEach(targetId => {\r\n            if (!newTargets.has(targetId)) {\r\n                removedTargets.push(targetId);\r\n            }\r\n        });\r\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\r\n            this.activeClients = updatedClients;\r\n        });\r\n    }\r\n    handleOnlineStateEvent(onlineState) {\r\n        // We check whether the client that wrote this online state is still active\r\n        // by comparing its client ID to the list of clients kept active in\r\n        // IndexedDb. If a client does not update their IndexedDb client state\r\n        // within 5 seconds, it is considered inactive and we don't emit an online\r\n        // state event.\r\n        if (this.activeClients.get(onlineState.clientId)) {\r\n            this.onlineStateHandler(onlineState.onlineState);\r\n        }\r\n    }\r\n    extractActiveQueryTargets(clients) {\r\n        let activeTargets = targetIdSet();\r\n        clients.forEach((kev, value) => {\r\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\r\n        });\r\n        return activeTargets;\r\n    }\r\n}\r\nfunction fromWebStorageSequenceNumber(seqString) {\r\n    let sequenceNumber = ListenSequence.INVALID;\r\n    if (seqString != null) {\r\n        try {\r\n            const parsed = JSON.parse(seqString);\r\n            hardAssert(typeof parsed === 'number');\r\n            sequenceNumber = parsed;\r\n        }\r\n        catch (e) {\r\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\r\n        }\r\n    }\r\n    return sequenceNumber;\r\n}\r\n/**\r\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\r\n * clients using memory persistence. The state in this class remains fully\r\n * isolated and no synchronization is performed.\r\n */\r\nclass MemorySharedClientState {\r\n    constructor() {\r\n        this.localState = new LocalClientState();\r\n        this.queryState = {};\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        // No op.\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        // No op.\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        this.localState.addQueryTarget(targetId);\r\n        return this.queryState[targetId] || 'not-current';\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.queryState[targetId] = state;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localState.removeQueryTarget(targetId);\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        delete this.queryState[targetId];\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.localState.activeTargetIds;\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    start() {\r\n        this.localState = new LocalClientState();\r\n        return Promise.resolve();\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        // No op.\r\n    }\r\n    setOnlineState(onlineState) {\r\n        // No op.\r\n    }\r\n    shutdown() { }\r\n    writeSequenceNumber(sequenceNumber) { }\r\n    notifyBundleLoaded(collectionGroups) {\r\n        // No op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass NoopConnectivityMonitor {\r\n    addCallback(callback) {\r\n        // No-op.\r\n    }\r\n    shutdown() {\r\n        // No-op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a simple helper class that implements the Stream interface to\r\n * bridge to other implementations that are streams but do not implement the\r\n * interface. The stream callbacks are invoked with the callOn... methods.\r\n */\r\nclass StreamBridge {\r\n    constructor(args) {\r\n        this.sendFn = args.sendFn;\r\n        this.closeFn = args.closeFn;\r\n    }\r\n    onConnected(callback) {\r\n        this.wrappedOnConnected = callback;\r\n    }\r\n    onOpen(callback) {\r\n        this.wrappedOnOpen = callback;\r\n    }\r\n    onClose(callback) {\r\n        this.wrappedOnClose = callback;\r\n    }\r\n    onMessage(callback) {\r\n        this.wrappedOnMessage = callback;\r\n    }\r\n    close() {\r\n        this.closeFn();\r\n    }\r\n    send(msg) {\r\n        this.sendFn(msg);\r\n    }\r\n    callOnConnected() {\r\n        this.wrappedOnConnected();\r\n    }\r\n    callOnOpen() {\r\n        this.wrappedOnOpen();\r\n    }\r\n    callOnClose(err) {\r\n        this.wrappedOnClose(err);\r\n    }\r\n    callOnMessage(msg) {\r\n        this.wrappedOnMessage(msg);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The value returned from the most recent invocation of\r\n * `generateUniqueDebugId()`, or null if it has never been invoked.\r\n */\r\nlet lastUniqueDebugId = null;\r\n/**\r\n * Generates and returns an initial value for `lastUniqueDebugId`.\r\n *\r\n * The returned value is randomly selected from a range of integers that are\r\n * represented as 8 hexadecimal digits. This means that (within reason) any\r\n * numbers generated by incrementing the returned number by 1 will also be\r\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\r\n * length when converted to a hexadecimal string, making reading logs containing\r\n * these IDs easier to follow. And since the return value is randomly selected\r\n * it will help to differentiate between logs from different executions.\r\n */\r\nfunction generateInitialUniqueDebugId() {\r\n    const minResult = 0x10000000;\r\n    const maxResult = 0x90000000;\r\n    const resultRange = maxResult - minResult;\r\n    const resultOffset = Math.round(resultRange * Math.random());\r\n    return minResult + resultOffset;\r\n}\r\n/**\r\n * Generates and returns a unique ID as a hexadecimal string.\r\n *\r\n * The returned ID is intended to be used in debug logging messages to help\r\n * correlate log messages that may be spatially separated in the logs, but\r\n * logically related. For example, a network connection could include the same\r\n * \"debug ID\" string in all of its log messages to help trace a specific\r\n * connection over time.\r\n *\r\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\r\n */\r\nfunction generateUniqueDebugId() {\r\n    if (lastUniqueDebugId === null) {\r\n        lastUniqueDebugId = generateInitialUniqueDebugId();\r\n    }\r\n    else {\r\n        lastUniqueDebugId++;\r\n    }\r\n    return '0x' + lastUniqueDebugId.toString(16);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\r\n * details.\r\n */\r\n/**\r\n * Creates a node-style callback that resolves or rejects a new Promise. The\r\n * callback is passed to the given action which can then use the callback as\r\n * a parameter to a node-style function.\r\n *\r\n * The intent is to directly bridge a node-style function (which takes a\r\n * callback) into a Promise without manually converting between the node-style\r\n * callback and the promise at each call.\r\n *\r\n * In effect it allows you to convert:\r\n *\r\n * @example\r\n * new Promise((resolve: (value?: fs.Stats) => void,\r\n *              reject: (error?: any) => void) => {\r\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\r\n *     if (error) {\r\n *       reject(error);\r\n *     } else {\r\n *       resolve(stat);\r\n *     }\r\n *   });\r\n * });\r\n *\r\n * Into\r\n * @example\r\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\r\n *   fs.stat(path, callback);\r\n * });\r\n *\r\n * @param action - a function that takes a node-style callback as an argument\r\n *     and then uses that callback to invoke some node-style API.\r\n * @returns a new Promise which will be rejected if the callback is given the\r\n *     first Error parameter or will resolve to the value given otherwise.\r\n */\r\nfunction nodePromise(action) {\r\n    return new Promise((resolve, reject) => {\r\n        action((error, value) => {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(value);\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: Fetch runtime version from grpc-js/package.json instead\r\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\r\nconst grpcVersion = '1.9.1';\r\nconst LOG_TAG$9 = 'GrpcConnection';\r\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\r\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\r\n    hardAssert(authToken === null || authToken.type === 'OAuth');\r\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.Metadata();\r\n    if (authToken) {\r\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appCheckToken) {\r\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appId) {\r\n        metadata.set('X-Firebase-GMPID', appId);\r\n    }\r\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\r\n    // These headers are used to improve routing and project isolation by the\r\n    // backend.\r\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\r\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\r\n    // 11 from Google3.\r\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\r\n    metadata.set('x-goog-request-params', databasePath);\r\n    return metadata;\r\n}\r\n/**\r\n * A Connection implemented by GRPC-Node.\r\n */\r\nclass GrpcConnection {\r\n    constructor(protos, databaseInfo) {\r\n        this.databaseInfo = databaseInfo;\r\n        // We cache stubs for the most-recently-used token.\r\n        this.cachedStub = null;\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.firestore = protos['google']['firestore']['v1'];\r\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\r\n    }\r\n    get shouldResourcePathBeIncludedInRequest() {\r\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\r\n        // the \"path\" to be part of the given `request`.\r\n        return true;\r\n    }\r\n    ensureActiveStub() {\r\n        if (!this.cachedStub) {\r\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\r\n            const credentials = this.databaseInfo.ssl\r\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createSsl()\r\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createInsecure();\r\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\r\n        }\r\n        return this.cachedStub;\r\n    }\r\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\r\n        const streamId = generateUniqueDebugId();\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\r\n        return nodePromise((callback) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\r\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\r\n                if (grpcError) {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\r\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\r\n                    callback(undefined, value);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\r\n        const streamId = generateUniqueDebugId();\r\n        const results = [];\r\n        const responseDeferred = new Deferred();\r\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\r\n        const stream = stub[rpcName](jsonRequest, metadata);\r\n        let callbackFired = false;\r\n        stream.on('data', (response) => {\r\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\r\n            results.push(response);\r\n            if (expectedResponseCount !== undefined &&\r\n                results.length === expectedResponseCount) {\r\n                callbackFired = true;\r\n                responseDeferred.resolve(results);\r\n            }\r\n        });\r\n        stream.on('end', () => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\r\n            if (!callbackFired) {\r\n                callbackFired = true;\r\n                responseDeferred.resolve(results);\r\n            }\r\n        });\r\n        stream.on('error', (grpcError) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\r\n            const code = mapCodeFromRpcCode(grpcError.code);\r\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\r\n        });\r\n        return responseDeferred.promise;\r\n    }\r\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\r\n    openStream(rpcName, authToken, appCheckToken) {\r\n        const streamId = generateUniqueDebugId();\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const grpcStream = stub[rpcName](metadata);\r\n        let closed = false;\r\n        const close = (err) => {\r\n            if (!closed) {\r\n                closed = true;\r\n                stream.callOnClose(err);\r\n                grpcStream.end();\r\n            }\r\n        };\r\n        const stream = new StreamBridge({\r\n            sendFn: (msg) => {\r\n                if (!closed) {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\r\n                    try {\r\n                        grpcStream.write(msg);\r\n                    }\r\n                    catch (e) {\r\n                        // This probably means we didn't conform to the proto.  Make sure to\r\n                        // log the message we sent.\r\n                        logError('Failure sending:', msg);\r\n                        logError('Error:', e);\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\r\n                        'not sending because gRPC stream is closed:', msg);\r\n                }\r\n            },\r\n            closeFn: () => {\r\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\r\n                close();\r\n            }\r\n        });\r\n        let onConnectedSent = false;\r\n        grpcStream.on('data', (msg) => {\r\n            if (!closed) {\r\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\r\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\r\n                if (!onConnectedSent) {\r\n                    stream.callOnConnected();\r\n                    onConnectedSent = true;\r\n                }\r\n                stream.callOnMessage(msg);\r\n            }\r\n        });\r\n        grpcStream.on('end', () => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\r\n            close();\r\n        });\r\n        grpcStream.on('error', (grpcError) => {\r\n            if (!closed) {\r\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\r\n                const code = mapCodeFromRpcCode(grpcError.code);\r\n                close(new FirestoreError(code, grpcError.message));\r\n            }\r\n        });\r\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\r\n            `to ${this.databaseInfo.host}`);\r\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\r\n        // simulate an onOpen in the next loop after the stream had it's listeners\r\n        // registered\r\n        setTimeout(() => {\r\n            stream.callOnOpen();\r\n        }, 0);\r\n        return stream;\r\n    }\r\n    /**\r\n     * Closes and cleans up any resources associated with the GrpcConnection.\r\n     * If a gRPC client has been generated for this connection, the gRPC client\r\n     * is closed. Failure to call terminate on a GrpcConnection can result\r\n     * in leaked resources of the gRPC client.\r\n     */\r\n    terminate() {\r\n        if (this.cachedStub) {\r\n            this.cachedStub.close();\r\n            this.cachedStub = undefined;\r\n        }\r\n    }\r\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used by tests so we can match @grpc/proto-loader behavior. */\r\nconst protoLoaderOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    defaults: true,\r\n    oneofs: false\r\n};\r\n/**\r\n * Loads the protocol buffer definitions for Firestore.\r\n *\r\n * @returns The GrpcObject representing our protos.\r\n */\r\nfunction loadProtos() {\r\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__.fromJSON(protos$1, protoLoaderOptions);\r\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.loadPackageDefinition(packageDefinition);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Loads the GRPC stack */\r\nfunction newConnection(databaseInfo) {\r\n    const protos = loadProtos();\r\n    return new GrpcConnection(protos, databaseInfo);\r\n}\r\n/** Return the Platform-specific connectivity monitor. */\r\nfunction newConnectivityMonitor() {\r\n    return new NoopConnectivityMonitor();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The Platform's 'window' implementation or null if not available. */\r\nfunction getWindow() {\r\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\r\n        // eslint-disable-next-line no-restricted-globals\r\n        return window;\r\n    }\r\n    return null;\r\n}\r\n/** The Platform's 'document' implementation or null if not available. */\r\nfunction getDocument() {\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newSerializer(databaseId) {\r\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$8 = 'ExponentialBackoff';\r\n/**\r\n * Initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */\r\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\r\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\r\n/** Maximum backoff time in milliseconds */\r\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\r\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\r\n * base delay. This prevents clients from accidentally synchronizing their\r\n * delays causing spikes of load to the backend.\r\n */\r\nclass ExponentialBackoff {\r\n    constructor(\r\n    /**\r\n     * The AsyncQueue to run backoff operations on.\r\n     */\r\n    queue, \r\n    /**\r\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\r\n     */\r\n    timerId, \r\n    /**\r\n     * The initial delay (used as the base delay on the first retry attempt).\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * little as 0.5*initialDelayMs.\r\n     */\r\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \r\n    /**\r\n     * The multiplier to use to determine the extended base delay after each\r\n     * attempt.\r\n     */\r\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \r\n    /**\r\n     * The maximum base delay after which no further backoff is performed.\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * much as 1.5*maxDelayMs.\r\n     */\r\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\r\n        this.queue = queue;\r\n        this.timerId = timerId;\r\n        this.initialDelayMs = initialDelayMs;\r\n        this.backoffFactor = backoffFactor;\r\n        this.maxDelayMs = maxDelayMs;\r\n        this.currentBaseMs = 0;\r\n        this.timerPromise = null;\r\n        /** The last backoff attempt, as epoch milliseconds. */\r\n        this.lastAttemptTime = Date.now();\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets the backoff delay.\r\n     *\r\n     * The very next backoffAndWait() will have no delay. If it is called again\r\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n     * subsequent ones will increase according to the backoffFactor.\r\n     */\r\n    reset() {\r\n        this.currentBaseMs = 0;\r\n    }\r\n    /**\r\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n     * RESOURCE_EXHAUSTED error).\r\n     */\r\n    resetToMax() {\r\n        this.currentBaseMs = this.maxDelayMs;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves after currentDelayMs, and increases the\r\n     * delay for any subsequent attempts. If there was a pending backoff operation\r\n     * already, it will be canceled.\r\n     */\r\n    backoffAndRun(op) {\r\n        // Cancel any pending backoff operation.\r\n        this.cancel();\r\n        // First schedule using the current base (which may be 0 and should be\r\n        // honored as such).\r\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\r\n        // Guard against lastAttemptTime being in the future due to a clock change.\r\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\r\n        // Guard against the backoff delay already being past.\r\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\r\n        if (remainingDelayMs > 0) {\r\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\r\n                `(base delay: ${this.currentBaseMs} ms, ` +\r\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\r\n                `last attempt: ${delaySoFarMs} ms ago)`);\r\n        }\r\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\r\n            this.lastAttemptTime = Date.now();\r\n            return op();\r\n        });\r\n        // Apply backoff factor to determine next delay and ensure it is within\r\n        // bounds.\r\n        this.currentBaseMs *= this.backoffFactor;\r\n        if (this.currentBaseMs < this.initialDelayMs) {\r\n            this.currentBaseMs = this.initialDelayMs;\r\n        }\r\n        if (this.currentBaseMs > this.maxDelayMs) {\r\n            this.currentBaseMs = this.maxDelayMs;\r\n        }\r\n    }\r\n    skipBackoff() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.skipDelay();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.cancel();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\r\n    jitterDelayMs() {\r\n        return (Math.random() - 0.5) * this.currentBaseMs;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$7 = 'PersistentStream';\r\n/** The time a stream stays open after it is marked idle. */\r\nconst IDLE_TIMEOUT_MS = 60 * 1000;\r\n/** The time a stream stays open until we consider it healthy. */\r\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A PersistentStream is an abstract base class that represents a streaming RPC\r\n * to the Firestore backend. It's built on top of the connections own support\r\n * for streaming RPCs, and adds several critical features for our clients:\r\n *\r\n *   - Exponential backoff on failure\r\n *   - Authentication via CredentialsProvider\r\n *   - Dispatching all callbacks into the shared worker queue\r\n *   - Closing idle streams after 60 seconds of inactivity\r\n *\r\n * Subclasses of PersistentStream implement serialization of models to and\r\n * from the JSON representation of the protocol buffers for a specific\r\n * streaming RPC.\r\n *\r\n * ## Starting and Stopping\r\n *\r\n * Streaming RPCs are stateful and need to be start()ed before messages can\r\n * be sent and received. The PersistentStream will call the onOpen() function\r\n * of the listener once the stream is ready to accept requests.\r\n *\r\n * Should a start() fail, PersistentStream will call the registered onClose()\r\n * listener with a FirestoreError indicating what went wrong.\r\n *\r\n * A PersistentStream can be started and stopped repeatedly.\r\n *\r\n * Generic types:\r\n *  SendType: The type of the outgoing message of the underlying\r\n *    connection stream\r\n *  ReceiveType: The type of the incoming message of the underlying\r\n *    connection stream\r\n *  ListenerType: The type of the listener that will be used for callbacks\r\n */\r\nclass PersistentStream {\r\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\r\n        this.queue = queue;\r\n        this.idleTimerId = idleTimerId;\r\n        this.healthTimerId = healthTimerId;\r\n        this.connection = connection;\r\n        this.authCredentialsProvider = authCredentialsProvider;\r\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\r\n        this.listener = listener;\r\n        this.state = 0 /* PersistentStreamState.Initial */;\r\n        /**\r\n         * A close count that's incremented every time the stream is closed; used by\r\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\r\n         * close.\r\n         */\r\n        this.closeCount = 0;\r\n        this.idleTimer = null;\r\n        this.healthCheck = null;\r\n        this.stream = null;\r\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\r\n    }\r\n    /**\r\n     * Returns true if start() has been called and no error has occurred. True\r\n     * indicates the stream is open or in the process of opening (which\r\n     * encompasses respecting backoff, getting auth tokens, and starting the\r\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\r\n     * outbound requests.\r\n     */\r\n    isStarted() {\r\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\r\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\r\n            this.isOpen());\r\n    }\r\n    /**\r\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\r\n     * called) and the stream is ready for outbound requests.\r\n     */\r\n    isOpen() {\r\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\r\n            this.state === 3 /* PersistentStreamState.Healthy */);\r\n    }\r\n    /**\r\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\r\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\r\n     * ready for outbound requests, at which point isOpen() will return true.\r\n     *\r\n     * When start returns, isStarted() will return true.\r\n     */\r\n    start() {\r\n        if (this.state === 4 /* PersistentStreamState.Error */) {\r\n            this.performBackoff();\r\n            return;\r\n        }\r\n        this.auth();\r\n    }\r\n    /**\r\n     * Stops the RPC. This call is idempotent and allowed regardless of the\r\n     * current isStarted() state.\r\n     *\r\n     * When stop returns, isStarted() and isOpen() will both return false.\r\n     */\r\n    async stop() {\r\n        if (this.isStarted()) {\r\n            await this.close(0 /* PersistentStreamState.Initial */);\r\n        }\r\n    }\r\n    /**\r\n     * After an error the stream will usually back off on the next attempt to\r\n     * start it. If the error warrants an immediate restart of the stream, the\r\n     * sender can use this to indicate that the receiver should not back off.\r\n     *\r\n     * Each error will call the onClose() listener. That function can decide to\r\n     * inhibit backoff if required.\r\n     */\r\n    inhibitBackoff() {\r\n        this.state = 0 /* PersistentStreamState.Initial */;\r\n        this.backoff.reset();\r\n    }\r\n    /**\r\n     * Marks this stream as idle. If no further actions are performed on the\r\n     * stream for one minute, the stream will automatically close itself and\r\n     * notify the stream's onClose() handler with Status.OK. The stream will then\r\n     * be in a !isStarted() state, requiring the caller to start the stream again\r\n     * before further use.\r\n     *\r\n     * Only streams that are in state 'Open' can be marked idle, as all other\r\n     * states imply pending network operations.\r\n     */\r\n    markIdle() {\r\n        // Starts the idle time if we are in state 'Open' and are not yet already\r\n        // running a timer (in which case the previous idle timeout still applies).\r\n        if (this.isOpen() && this.idleTimer === null) {\r\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\r\n        }\r\n    }\r\n    /** Sends a message to the underlying stream. */\r\n    sendRequest(msg) {\r\n        this.cancelIdleCheck();\r\n        this.stream.send(msg);\r\n    }\r\n    /** Called by the idle timer when the stream should close due to inactivity. */\r\n    async handleIdleCloseTimer() {\r\n        if (this.isOpen()) {\r\n            // When timing out an idle stream there's no reason to force the stream into backoff when\r\n            // it restarts so set the stream state to Initial instead of Error.\r\n            return this.close(0 /* PersistentStreamState.Initial */);\r\n        }\r\n    }\r\n    /** Marks the stream as active again. */\r\n    cancelIdleCheck() {\r\n        if (this.idleTimer) {\r\n            this.idleTimer.cancel();\r\n            this.idleTimer = null;\r\n        }\r\n    }\r\n    /** Cancels the health check delayed operation. */\r\n    cancelHealthCheck() {\r\n        if (this.healthCheck) {\r\n            this.healthCheck.cancel();\r\n            this.healthCheck = null;\r\n        }\r\n    }\r\n    /**\r\n     * Closes the stream and cleans up as necessary:\r\n     *\r\n     * * closes the underlying GRPC stream;\r\n     * * calls the onClose handler with the given 'error';\r\n     * * sets internal stream state to 'finalState';\r\n     * * adjusts the backoff timer based on the error\r\n     *\r\n     * A new stream can be opened by calling start().\r\n     *\r\n     * @param finalState - the intended state of the stream after closing.\r\n     * @param error - the error the connection was closed with.\r\n     */\r\n    async close(finalState, error) {\r\n        // Cancel any outstanding timers (they're guaranteed not to execute).\r\n        this.cancelIdleCheck();\r\n        this.cancelHealthCheck();\r\n        this.backoff.cancel();\r\n        // Invalidates any stream-related callbacks (e.g. from auth or the\r\n        // underlying stream), guaranteeing they won't execute.\r\n        this.closeCount++;\r\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\r\n            // If this is an intentional close ensure we don't delay our next connection attempt.\r\n            this.backoff.reset();\r\n        }\r\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\r\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\r\n            logError(error.toString());\r\n            logError('Using maximum backoff delay to prevent overloading the backend.');\r\n            this.backoff.resetToMax();\r\n        }\r\n        else if (error &&\r\n            error.code === Code.UNAUTHENTICATED &&\r\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\r\n            // \"unauthenticated\" error means the token was rejected. This should rarely\r\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\r\n            // request a token. If a user manually resets their system clock this can\r\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\r\n            // before we received the first message and we need to invalidate the token\r\n            // to ensure that we fetch a new token.\r\n            this.authCredentialsProvider.invalidateToken();\r\n            this.appCheckCredentialsProvider.invalidateToken();\r\n        }\r\n        // Clean up the underlying stream because we are no longer interested in events.\r\n        if (this.stream !== null) {\r\n            this.tearDown();\r\n            this.stream.close();\r\n            this.stream = null;\r\n        }\r\n        // This state must be assigned before calling onClose() to allow the callback to\r\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\r\n        this.state = finalState;\r\n        // Notify the listener that the stream closed.\r\n        await this.listener.onClose(error);\r\n    }\r\n    /**\r\n     * Can be overridden to perform additional cleanup before the stream is closed.\r\n     * Calling super.tearDown() is not required.\r\n     */\r\n    tearDown() { }\r\n    auth() {\r\n        this.state = 1 /* PersistentStreamState.Starting */;\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\r\n        const closeCount = this.closeCount;\r\n        Promise.all([\r\n            this.authCredentialsProvider.getToken(),\r\n            this.appCheckCredentialsProvider.getToken()\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            // Stream can be stopped while waiting for authentication.\r\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\r\n            // and let this dispatch onto the queue, but that opened a spec test can\r\n            // of worms that I don't want to deal with in this PR.\r\n            if (this.closeCount === closeCount) {\r\n                // Normally we'd have to schedule the callback on the AsyncQueue.\r\n                // However, the following calls are safe to be called outside the\r\n                // AsyncQueue since they don't chain asynchronous calls\r\n                this.startStream(authToken, appCheckToken);\r\n            }\r\n        }, (error) => {\r\n            dispatchIfNotClosed(() => {\r\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\r\n                return this.handleStreamClose(rpcError);\r\n            });\r\n        });\r\n    }\r\n    startStream(authToken, appCheckToken) {\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        this.stream = this.startRpc(authToken, appCheckToken);\r\n        this.stream.onConnected(() => {\r\n            dispatchIfNotClosed(() => this.listener.onConnected());\r\n        });\r\n        this.stream.onOpen(() => {\r\n            dispatchIfNotClosed(() => {\r\n                this.state = 2 /* PersistentStreamState.Open */;\r\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\r\n                    if (this.isOpen()) {\r\n                        this.state = 3 /* PersistentStreamState.Healthy */;\r\n                    }\r\n                    return Promise.resolve();\r\n                });\r\n                return this.listener.onOpen();\r\n            });\r\n        });\r\n        this.stream.onClose((error) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.handleStreamClose(error);\r\n            });\r\n        });\r\n        this.stream.onMessage((msg) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.onMessage(msg);\r\n            });\r\n        });\r\n    }\r\n    performBackoff() {\r\n        this.state = 5 /* PersistentStreamState.Backoff */;\r\n        this.backoff.backoffAndRun(async () => {\r\n            this.state = 0 /* PersistentStreamState.Initial */;\r\n            this.start();\r\n        });\r\n    }\r\n    // Visible for tests\r\n    handleStreamClose(error) {\r\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\r\n        this.stream = null;\r\n        // In theory the stream could close cleanly, however, in our current model\r\n        // we never expect this to happen because if we stop a stream ourselves,\r\n        // this callback will never be called. To prevent cases where we retry\r\n        // without a backoff accidentally, we set the stream to error in all cases.\r\n        return this.close(4 /* PersistentStreamState.Error */, error);\r\n    }\r\n    /**\r\n     * Returns a \"dispatcher\" function that dispatches operations onto the\r\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\r\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\r\n     * re-opened, etc.\r\n     */\r\n    getCloseGuardedDispatcher(startCloseCount) {\r\n        return (fn) => {\r\n            this.queue.enqueueAndForget(() => {\r\n                if (this.closeCount === startCloseCount) {\r\n                    return fn();\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\r\n                    return Promise.resolve();\r\n                }\r\n            });\r\n        };\r\n    }\r\n}\r\n/**\r\n * A PersistentStream that implements the Listen RPC.\r\n *\r\n * Once the Listen stream has called the onOpen() listener, any number of\r\n * listen() and unlisten() calls can be made to control what changes will be\r\n * sent from the server for ListenResponses.\r\n */\r\nclass PersistentListenStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Listen', authToken, appCheckToken);\r\n    }\r\n    onMessage(watchChangeProto) {\r\n        // A successful response means the stream is healthy\r\n        this.backoff.reset();\r\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\r\n        const snapshot = versionFromListenResponse(watchChangeProto);\r\n        return this.listener.onWatchChange(watchChange, snapshot);\r\n    }\r\n    /**\r\n     * Registers interest in the results of the given target. If the target\r\n     * includes a resumeToken it will be included in the request. Results that\r\n     * affect the target will be streamed back as WatchChange messages that\r\n     * reference the targetId.\r\n     */\r\n    watch(targetData) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.addTarget = toTarget(this.serializer, targetData);\r\n        const labels = toListenRequestLabels(this.serializer, targetData);\r\n        if (labels) {\r\n            request.labels = labels;\r\n        }\r\n        this.sendRequest(request);\r\n    }\r\n    /**\r\n     * Unregisters interest in the results of the target associated with the\r\n     * given targetId.\r\n     */\r\n    unwatch(targetId) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.removeTarget = targetId;\r\n        this.sendRequest(request);\r\n    }\r\n}\r\n/**\r\n * A Stream that implements the Write RPC.\r\n *\r\n * The Write RPC requires the caller to maintain special streamToken\r\n * state in between calls, to help the server understand which responses the\r\n * client has processed by the time the next request is made. Every response\r\n * will contain a streamToken; this value must be passed to the next\r\n * request.\r\n *\r\n * After calling start() on this stream, the next request must be a handshake,\r\n * containing whatever streamToken is on hand. Once a response to this\r\n * request is received, all pending mutations may be submitted. When\r\n * submitting multiple batches of mutations at the same time, it's\r\n * okay to use the same streamToken for the calls to writeMutations.\r\n *\r\n * TODO(b/33271235): Use proto types\r\n */\r\nclass PersistentWriteStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n        this.handshakeComplete_ = false;\r\n    }\r\n    /**\r\n     * Tracks whether or not a handshake has been successfully exchanged and\r\n     * the stream is ready to accept mutations.\r\n     */\r\n    get handshakeComplete() {\r\n        return this.handshakeComplete_;\r\n    }\r\n    // Override of PersistentStream.start\r\n    start() {\r\n        this.handshakeComplete_ = false;\r\n        this.lastStreamToken = undefined;\r\n        super.start();\r\n    }\r\n    tearDown() {\r\n        if (this.handshakeComplete_) {\r\n            this.writeMutations([]);\r\n        }\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Write', authToken, appCheckToken);\r\n    }\r\n    onMessage(responseProto) {\r\n        // Always capture the last stream token.\r\n        hardAssert(!!responseProto.streamToken);\r\n        this.lastStreamToken = responseProto.streamToken;\r\n        if (!this.handshakeComplete_) {\r\n            // The first response is always the handshake response\r\n            hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\r\n            this.handshakeComplete_ = true;\r\n            return this.listener.onHandshakeComplete();\r\n        }\r\n        else {\r\n            // A successful first write response means the stream is healthy,\r\n            // Note, that we could consider a successful handshake healthy, however,\r\n            // the write itself might be causing an error we want to back off from.\r\n            this.backoff.reset();\r\n            const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\r\n            const commitVersion = fromVersion(responseProto.commitTime);\r\n            return this.listener.onMutationResult(commitVersion, results);\r\n        }\r\n    }\r\n    /**\r\n     * Sends an initial streamToken to the server, performing the handshake\r\n     * required to make the StreamingWrite RPC work. Subsequent\r\n     * calls should wait until onHandshakeComplete was called.\r\n     */\r\n    writeHandshake() {\r\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\r\n        // stream token on the handshake, ignoring any stream token we might have.\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        this.sendRequest(request);\r\n    }\r\n    /** Sends a group of mutations to the Firestore backend to apply. */\r\n    writeMutations(mutations) {\r\n        const request = {\r\n            streamToken: this.lastStreamToken,\r\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\r\n        };\r\n        this.sendRequest(request);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Datastore and its related methods are a wrapper around the external Google\r\n * Cloud Datastore grpc API, which provides an interface that is more convenient\r\n * for the rest of the client SDK architecture to consume.\r\n */\r\nclass Datastore {\r\n}\r\n/**\r\n * An implementation of Datastore that exposes additional state for internal\r\n * consumption.\r\n */\r\nclass DatastoreImpl extends Datastore {\r\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\r\n        super();\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.connection = connection;\r\n        this.serializer = serializer;\r\n        this.terminated = false;\r\n    }\r\n    verifyInitialized() {\r\n        if (this.terminated) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\r\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\r\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    terminate() {\r\n        this.terminated = true;\r\n        this.connection.terminate();\r\n    }\r\n}\r\n// TODO(firestorexp): Make sure there is only one Datastore instance per\r\n// firestore-exp client.\r\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\r\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\r\n}\r\nasync function invokeCommitRpc(datastore, mutations) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const request = {\r\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\r\n    };\r\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\r\n}\r\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const request = {\r\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\r\n    };\r\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\r\n    const docs = new Map();\r\n    response.forEach(proto => {\r\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\r\n        docs.set(doc.key.toString(), doc);\r\n    });\r\n    const result = [];\r\n    keys.forEach(key => {\r\n        const doc = docs.get(key.toString());\r\n        hardAssert(!!doc);\r\n        result.push(doc);\r\n    });\r\n    return result;\r\n}\r\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\r\n    var _a;\r\n    const datastoreImpl = debugCast(datastore);\r\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\r\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\r\n        delete request.parent;\r\n    }\r\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \r\n    /*expectedResponseCount=*/ 1);\r\n    // Omit RunAggregationQueryResponse that only contain readTimes.\r\n    const filteredResult = response.filter(proto => !!proto.result);\r\n    hardAssert(filteredResult.length === 1);\r\n    // Remap the short-form aliases that were sent to the server\r\n    // to the client-side aliases. Users will access the results\r\n    // using the client-side alias.\r\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\r\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\r\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\r\n        return accumulator;\r\n    }, {});\r\n    return remappedFields;\r\n}\r\nfunction newPersistentWriteStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\r\nfunction newPersistentWatchStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$6 = 'OnlineStateTracker';\r\n// To deal with transient failures, we allow multiple stream attempts before\r\n// giving up and transitioning from OnlineState.Unknown to Offline.\r\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\r\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\r\n// to 1. If that works okay, we could potentially remove this logic entirely.\r\nconst MAX_WATCH_STREAM_FAILURES = 1;\r\n// To deal with stream attempts that don't succeed or fail in a timely manner,\r\n// we have a timeout for OnlineState to reach Online or Offline.\r\n// If the timeout is reached, we transition to Offline rather than waiting\r\n// indefinitely.\r\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A component used by the RemoteStore to track the OnlineState (that is,\r\n * whether or not the client as a whole should be considered to be online or\r\n * offline), implementing the appropriate heuristics.\r\n *\r\n * In particular, when the client is trying to connect to the backend, we\r\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\r\n * a connection to succeed. If we have too many failures or the timeout elapses,\r\n * then we set the OnlineState to Offline, and the client will behave as if\r\n * it is offline (get()s will return cached data, etc.).\r\n */\r\nclass OnlineStateTracker {\r\n    constructor(asyncQueue, onlineStateHandler) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.onlineStateHandler = onlineStateHandler;\r\n        /** The current OnlineState. */\r\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\r\n        /**\r\n         * A count of consecutive failures to open the stream. If it reaches the\r\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\r\n         * Offline.\r\n         */\r\n        this.watchStreamFailures = 0;\r\n        /**\r\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\r\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\r\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\r\n         */\r\n        this.onlineStateTimer = null;\r\n        /**\r\n         * Whether the client should log a warning message if it fails to connect to\r\n         * the backend (initially true, cleared after a successful stream, or if we've\r\n         * logged the message already).\r\n         */\r\n        this.shouldWarnClientIsOffline = true;\r\n    }\r\n    /**\r\n     * Called by RemoteStore when a watch stream is started (including on each\r\n     * backoff attempt).\r\n     *\r\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\r\n     * the onlineStateTimer.\r\n     */\r\n    handleWatchStreamStart() {\r\n        if (this.watchStreamFailures === 0) {\r\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\r\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\r\n                this.onlineStateTimer = null;\r\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\r\n                    `seconds.`);\r\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\r\n                // NOTE: handleWatchStreamFailure() will continue to increment\r\n                // watchStreamFailures even though we are already marked Offline,\r\n                // but this is non-harmful.\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates our OnlineState as appropriate after the watch stream reports a\r\n     * failure. The first failure moves us to the 'Unknown' state. We then may\r\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\r\n     * actually transition to the 'Offline' state.\r\n     */\r\n    handleWatchStreamFailure(error) {\r\n        if (this.state === \"Online\" /* OnlineState.Online */) {\r\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\r\n        }\r\n        else {\r\n            this.watchStreamFailures++;\r\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\r\n                this.clearOnlineStateTimer();\r\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\r\n                    `times. Most recent error: ${error.toString()}`);\r\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Explicitly sets the OnlineState to the specified state.\r\n     *\r\n     * Note that this resets our timers / failure counters, etc. used by our\r\n     * Offline heuristics, so must not be used in place of\r\n     * handleWatchStreamStart() and handleWatchStreamFailure().\r\n     */\r\n    set(newState) {\r\n        this.clearOnlineStateTimer();\r\n        this.watchStreamFailures = 0;\r\n        if (newState === \"Online\" /* OnlineState.Online */) {\r\n            // We've connected to watch at least once. Don't warn the developer\r\n            // about being offline going forward.\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        this.setAndBroadcast(newState);\r\n    }\r\n    setAndBroadcast(newState) {\r\n        if (newState !== this.state) {\r\n            this.state = newState;\r\n            this.onlineStateHandler(newState);\r\n        }\r\n    }\r\n    logClientOfflineWarningIfNecessary(details) {\r\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\r\n            `This typically indicates that your device does not have a healthy ` +\r\n            `Internet connection at the moment. The client will operate in offline ` +\r\n            `mode until it is able to successfully connect to the backend.`;\r\n        if (this.shouldWarnClientIsOffline) {\r\n            logError(message);\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$6, message);\r\n        }\r\n    }\r\n    clearOnlineStateTimer() {\r\n        if (this.onlineStateTimer !== null) {\r\n            this.onlineStateTimer.cancel();\r\n            this.onlineStateTimer = null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$5 = 'RemoteStore';\r\n// TODO(b/35853402): Negotiate this with the stream.\r\nconst MAX_PENDING_WRITES = 10;\r\nclass RemoteStoreImpl {\r\n    constructor(\r\n    /**\r\n     * The local store, used to fill the write pipeline with outbound mutations.\r\n     */\r\n    localStore, \r\n    /** The client-side proxy for interacting with the backend. */\r\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n        this.localStore = localStore;\r\n        this.datastore = datastore;\r\n        this.asyncQueue = asyncQueue;\r\n        this.remoteSyncer = {};\r\n        /**\r\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\r\n         * LocalStore via fillWritePipeline() and have or will send to the write\r\n         * stream.\r\n         *\r\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\r\n         * restart the write stream. When the stream is established the writes in the\r\n         * pipeline will be sent in order.\r\n         *\r\n         * Writes remain in writePipeline until they are acknowledged by the backend\r\n         * and thus will automatically be re-sent if the stream is interrupted /\r\n         * restarted before they're acknowledged.\r\n         *\r\n         * Write responses from the backend are linked to their originating request\r\n         * purely based on order, and so we can just shift() writes from the front of\r\n         * the writePipeline as we receive responses.\r\n         */\r\n        this.writePipeline = [];\r\n        /**\r\n         * A mapping of watched targets that the client cares about tracking and the\r\n         * user has explicitly called a 'listen' for this target.\r\n         *\r\n         * These targets may or may not have been sent to or acknowledged by the\r\n         * server. On re-establishing the listen stream, these targets should be sent\r\n         * to the server. The targets removed with unlistens are removed eagerly\r\n         * without waiting for confirmation from the listen stream.\r\n         */\r\n        this.listenTargets = new Map();\r\n        /**\r\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\r\n         * RemoteStore may start its network connections.\r\n         */\r\n        this.offlineCauses = new Set();\r\n        /**\r\n         * Event handlers that get called when the network is disabled or enabled.\r\n         *\r\n         * PORTING NOTE: These functions are used on the Web client to create the\r\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\r\n         * the streams are created during construction of RemoteStore.\r\n         */\r\n        this.onNetworkStatusChange = [];\r\n        this.connectivityMonitor = connectivityMonitor;\r\n        this.connectivityMonitor.addCallback((_) => {\r\n            asyncQueue.enqueueAndForget(async () => {\r\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\r\n                // network becomes unreachable as we don't have any other way to tear\r\n                // down our streams.\r\n                if (canUseNetwork(this)) {\r\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\r\n                    await restartNetwork(this);\r\n                }\r\n            });\r\n        });\r\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\r\n    }\r\n}\r\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\r\n}\r\n/** Re-enables the network. Idempotent. */\r\nfunction remoteStoreEnableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\r\n    return enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function enableNetworkInternal(remoteStoreImpl) {\r\n    if (canUseNetwork(remoteStoreImpl)) {\r\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n            await networkStatusHandler(/* enabled= */ true);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Temporarily disables the network. The network can be re-enabled using\r\n * enableNetwork().\r\n */\r\nasync function remoteStoreDisableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    // Set the OnlineState to Offline so get()s return from cache, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\r\n}\r\nasync function disableNetworkInternal(remoteStoreImpl) {\r\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n        await networkStatusHandler(/* enabled= */ false);\r\n    }\r\n}\r\nasync function remoteStoreShutdown(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\r\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.connectivityMonitor.shutdown();\r\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\r\n    // triggering spurious listener events with cached data, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n}\r\n/**\r\n * Starts new listen for the given target. Uses resume token if provided. It\r\n * is a no-op if the target of given `TargetData` is already being listened to.\r\n */\r\nfunction remoteStoreListen(remoteStore, targetData) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\r\n        return;\r\n    }\r\n    // Mark this as something the client is currently listening for.\r\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        // The listen will be sent in onWatchStreamOpen\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    }\r\n}\r\n/**\r\n * Removes the listen from server. It is a no-op if the given target id is\r\n * not being listened to.\r\n */\r\nfunction remoteStoreUnlisten(remoteStore, targetId) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const watchStream = ensureWatchStream(remoteStoreImpl);\r\n    remoteStoreImpl.listenTargets.delete(targetId);\r\n    if (watchStream.isOpen()) {\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n    }\r\n    if (remoteStoreImpl.listenTargets.size === 0) {\r\n        if (watchStream.isOpen()) {\r\n            watchStream.markIdle();\r\n        }\r\n        else if (canUseNetwork(remoteStoreImpl)) {\r\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\r\n            // have no listeners, since without any listens to send we cannot\r\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\r\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n        }\r\n    }\r\n}\r\n/**\r\n * We need to increment the the expected number of pending responses we're due\r\n * from watch so we wait for the ack to process any messages from this target.\r\n */\r\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\r\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\r\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\r\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\r\n        targetData = targetData.withExpectedCount(expectedCount);\r\n    }\r\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\r\n}\r\n/**\r\n * We need to increment the expected number of pending responses we're due\r\n * from watch so we wait for the removal on the server before we process any\r\n * messages from this target.\r\n */\r\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\r\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\r\n}\r\nfunction startWatchStream(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\r\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\r\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\r\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\r\n    });\r\n    ensureWatchStream(remoteStoreImpl).start();\r\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\r\n}\r\n/**\r\n * Returns whether the watch stream should be started because it's necessary\r\n * and has not yet been started.\r\n */\r\nfunction shouldStartWatchStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.listenTargets.size > 0);\r\n}\r\nfunction canUseNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    return remoteStoreImpl.offlineCauses.size === 0;\r\n}\r\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = undefined;\r\n}\r\nasync function onWatchStreamConnected(remoteStoreImpl) {\r\n    // Mark the client as online since we got a \"connected\" notification.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\r\n}\r\nasync function onWatchStreamOpen(remoteStoreImpl) {\r\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    });\r\n}\r\nasync function onWatchStreamClose(remoteStoreImpl, error) {\r\n    cleanUpWatchStreamState(remoteStoreImpl);\r\n    // If we still need the watch stream, retry the connection.\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else {\r\n        // No need to restart watch stream because there are no active targets.\r\n        // The online state is set to unknown because there is no active attempt\r\n        // at establishing a connection\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n}\r\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\r\n    // Mark the client as online since we got a message from the server\r\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\r\n    if (watchChange instanceof WatchTargetChange &&\r\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\r\n        watchChange.cause) {\r\n        // There was an error on a target, don't wait for a consistent snapshot\r\n        // to raise events\r\n        try {\r\n            await handleTargetError(remoteStoreImpl, watchChange);\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n        return;\r\n    }\r\n    if (watchChange instanceof DocumentWatchChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\r\n    }\r\n    else if (watchChange instanceof ExistenceFilterChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\r\n    }\r\n    else {\r\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\r\n    }\r\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\r\n        try {\r\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\r\n                // We have received a target change with a global snapshot if the snapshot\r\n                // version is not equal to SnapshotVersion.min().\r\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recovery logic for IndexedDB errors that takes the network offline until\r\n * `op` succeeds. Retries are scheduled with backoff using\r\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\r\n * validated via a generic operation.\r\n *\r\n * The returned Promise is resolved once the network is disabled and before\r\n * any retry attempt.\r\n */\r\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\r\n    if (isIndexedDbTransactionError(e)) {\r\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\r\n        // Disable network and raise offline snapshots\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\r\n        if (!op) {\r\n            // Use a simple read operation to determine if IndexedDB recovered.\r\n            // Ideally, we would expose a health check directly on SimpleDb, but\r\n            // RemoteStore only has access to persistence through LocalStore.\r\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n        }\r\n        // Probe IndexedDB periodically and re-enable network\r\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\r\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\r\n            await op();\r\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\r\n            await enableNetworkInternal(remoteStoreImpl);\r\n        });\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\r\n/**\r\n * Executes `op`. If `op` fails, takes the network offline until `op`\r\n * succeeds. Returns after the first attempt.\r\n */\r\nfunction executeWithRecovery(remoteStoreImpl, op) {\r\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\r\n}\r\n/**\r\n * Takes a batch of changes from the Datastore, repackages them as a\r\n * RemoteEvent, and passes that on to the listener, which is typically the\r\n * SyncEngine.\r\n */\r\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\r\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\r\n    // Update in-memory resume tokens. LocalStore will update the\r\n    // persistent view of these when applying the completed RemoteEvent.\r\n    remoteEvent.targetChanges.forEach((change, targetId) => {\r\n        if (change.resumeToken.approximateByteSize() > 0) {\r\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n            // A watched target might have been removed already.\r\n            if (targetData) {\r\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\r\n            }\r\n        }\r\n    });\r\n    // Re-establish listens for the targets that have been invalidated by\r\n    // existence filter mismatches.\r\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\r\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n        if (!targetData) {\r\n            // A watched target might have been removed already.\r\n            return;\r\n        }\r\n        // Clear the resume token for the target, since we're in a known mismatch\r\n        // state.\r\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\r\n        // Cause a hard reset by unwatching and rewatching immediately, but\r\n        // deliberately don't send a resume token so that we get a full update.\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n        // Mark the target we send as being on behalf of an existence filter\r\n        // mismatch, but don't actually retain that in listenTargets. This ensures\r\n        // that we flag the first re-listen this way without impacting future\r\n        // listens of this target (that might happen e.g. on reconnect).\r\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\r\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\r\n    });\r\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\r\n}\r\n/** Handles an error on a target */\r\nasync function handleTargetError(remoteStoreImpl, watchChange) {\r\n    const error = watchChange.cause;\r\n    for (const targetId of watchChange.targetIds) {\r\n        // A watched target might have been removed already.\r\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\r\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\r\n            remoteStoreImpl.listenTargets.delete(targetId);\r\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Attempts to fill our write pipeline with writes from the LocalStore.\r\n *\r\n * Called internally to bootstrap or refill the write pipeline and by\r\n * SyncEngine whenever there are new mutations to process.\r\n *\r\n * Starts the write stream if necessary.\r\n */\r\nasync function fillWritePipeline(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\r\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\r\n            .batchId\r\n        : BATCHID_UNKNOWN;\r\n    while (canAddToWritePipeline(remoteStoreImpl)) {\r\n        try {\r\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\r\n            if (batch === null) {\r\n                if (remoteStoreImpl.writePipeline.length === 0) {\r\n                    writeStream.markIdle();\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                lastBatchIdRetrieved = batch.batchId;\r\n                addToWritePipeline(remoteStoreImpl, batch);\r\n            }\r\n        }\r\n        catch (e) {\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\n/**\r\n * Returns true if we can add to the write pipeline (i.e. the network is\r\n * enabled and the write pipeline is not full).\r\n */\r\nfunction canAddToWritePipeline(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\r\n}\r\n/**\r\n * Queues additional writes to be sent to the write stream, sending them\r\n * immediately if the write stream is established.\r\n */\r\nfunction addToWritePipeline(remoteStoreImpl, batch) {\r\n    remoteStoreImpl.writePipeline.push(batch);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nfunction shouldStartWriteStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.writePipeline.length > 0);\r\n}\r\nfunction startWriteStream(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).start();\r\n}\r\nasync function onWriteStreamOpen(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\r\n}\r\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    // Send the write pipeline now that the stream is established.\r\n    for (const batch of remoteStoreImpl.writePipeline) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\r\n    const batch = remoteStoreImpl.writePipeline.shift();\r\n    const success = MutationBatchResult.from(batch, commitVersion, results);\r\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\r\n    // It's possible that with the completion of this mutation another\r\n    // slot has freed up.\r\n    await fillWritePipeline(remoteStoreImpl);\r\n}\r\nasync function onWriteStreamClose(remoteStoreImpl, error) {\r\n    // If the write stream closed after the write handshake completes, a write\r\n    // operation failed and we fail the pending operation.\r\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\r\n        // This error affects the actual write.\r\n        await handleWriteError(remoteStoreImpl, error);\r\n    }\r\n    // The write stream might have been started by refilling the write\r\n    // pipeline for failed writes\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\nasync function handleWriteError(remoteStoreImpl, error) {\r\n    // Only handle permanent errors here. If it's transient, just let the retry\r\n    // logic kick in.\r\n    if (isPermanentWriteError(error.code)) {\r\n        // This was a permanent error, the request itself was the problem\r\n        // so it's not going to succeed if we resend it.\r\n        const batch = remoteStoreImpl.writePipeline.shift();\r\n        // In this case it's also unlikely that the server itself is melting\r\n        // down -- this was just a bad request so inhibit backoff on the next\r\n        // restart.\r\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\r\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\r\n        // It's possible that with the completion of this mutation\r\n        // another slot has freed up.\r\n        await fillWritePipeline(remoteStoreImpl);\r\n    }\r\n}\r\nasync function restartNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\r\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\r\n    // Tear down and re-create our network streams. This will ensure we get a\r\n    // fresh auth token for the new user and re-fill the write pipeline with\r\n    // new mutations from the LocalStore (since mutations are per-user).\r\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    if (usesNetwork) {\r\n        // Don't set the network status to Unknown if we are offline.\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\r\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\n/**\r\n * Toggles the network state when the client gains or loses its primary lease.\r\n */\r\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (isPrimary) {\r\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\r\n        await enableNetworkInternal(remoteStoreImpl);\r\n    }\r\n    else if (!isPrimary) {\r\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n    }\r\n}\r\n/**\r\n * If not yet initialized, registers the WatchStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWatchStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.watchStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\r\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\r\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.watchStream.inhibitBackoff();\r\n                if (shouldStartWatchStream(remoteStoreImpl)) {\r\n                    startWatchStream(remoteStoreImpl);\r\n                }\r\n                else {\r\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\r\n                }\r\n            }\r\n            else {\r\n                await remoteStoreImpl.watchStream.stop();\r\n                cleanUpWatchStreamState(remoteStoreImpl);\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.watchStream;\r\n}\r\n/**\r\n * If not yet initialized, registers the WriteStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWriteStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.writeStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onConnected: () => Promise.resolve(),\r\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\r\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\r\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.writeStream.inhibitBackoff();\r\n                // This will start the write stream if necessary.\r\n                await fillWritePipeline(remoteStoreImpl);\r\n            }\r\n            else {\r\n                await remoteStoreImpl.writeStream.stop();\r\n                if (remoteStoreImpl.writePipeline.length > 0) {\r\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\r\n                    remoteStoreImpl.writePipeline = [];\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.writeStream;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$4 = 'AsyncQueue';\r\n/**\r\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\r\n *\r\n * It is created via DelayedOperation.createAndSchedule().\r\n *\r\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\r\n *\r\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\r\n * in newer versions of TypeScript defines `finally`, which is not available in\r\n * IE.\r\n */\r\nclass DelayedOperation {\r\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.timerId = timerId;\r\n        this.targetTimeMs = targetTimeMs;\r\n        this.op = op;\r\n        this.removalCallback = removalCallback;\r\n        this.deferred = new Deferred();\r\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\r\n        // It's normal for the deferred promise to be canceled (due to cancellation)\r\n        // and so we attach a dummy catch callback to avoid\r\n        // 'UnhandledPromiseRejectionWarning' log spam.\r\n        this.deferred.promise.catch(err => { });\r\n    }\r\n    get promise() {\r\n        return this.deferred.promise;\r\n    }\r\n    /**\r\n     * Creates and returns a DelayedOperation that has been scheduled to be\r\n     * executed on the provided asyncQueue after the provided delayMs.\r\n     *\r\n     * @param asyncQueue - The queue to schedule the operation on.\r\n     * @param id - A Timer ID identifying the type of operation this is.\r\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\r\n     * @param op - The operation to run.\r\n     * @param removalCallback - A callback to be called synchronously once the\r\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\r\n     *   from its delayedOperations list.\r\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\r\n     *   the DelayedOperation class public.\r\n     */\r\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\r\n        const targetTime = Date.now() + delayMs;\r\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\r\n        delayedOp.start(delayMs);\r\n        return delayedOp;\r\n    }\r\n    /**\r\n     * Starts the timer. This is called immediately after construction by\r\n     * createAndSchedule().\r\n     */\r\n    start(delayMs) {\r\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\r\n    }\r\n    /**\r\n     * Queues the operation to run immediately (if it hasn't already been run or\r\n     * canceled).\r\n     */\r\n    skipDelay() {\r\n        return this.handleDelayElapsed();\r\n    }\r\n    /**\r\n     * Cancels the operation if it hasn't already been executed or canceled. The\r\n     * promise will be rejected.\r\n     *\r\n     * As long as the operation has not yet been run, calling cancel() provides a\r\n     * guarantee that the operation will not be run.\r\n     */\r\n    cancel(reason) {\r\n        if (this.timerHandle !== null) {\r\n            this.clearTimeout();\r\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\r\n        }\r\n    }\r\n    handleDelayElapsed() {\r\n        this.asyncQueue.enqueueAndForget(() => {\r\n            if (this.timerHandle !== null) {\r\n                this.clearTimeout();\r\n                return this.op().then(result => {\r\n                    return this.deferred.resolve(result);\r\n                });\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    clearTimeout() {\r\n        if (this.timerHandle !== null) {\r\n            this.removalCallback(this);\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a FirestoreError that can be surfaced to the user if the provided\r\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\r\n */\r\nfunction wrapInUserErrorIfRecoverable(e, msg) {\r\n    logError(LOG_TAG$4, `${msg}: ${e}`);\r\n    if (isIndexedDbTransactionError(e)) {\r\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\r\n * in order specified by the provided comparator. We always add a document key\r\n * comparator on top of what is provided to guarantee document equality based on\r\n * the key.\r\n */\r\nclass DocumentSet {\r\n    /** The default ordering is by key if the comparator is omitted */\r\n    constructor(comp) {\r\n        // We are adding document key comparator to the end as it's the only\r\n        // guaranteed unique property of a document.\r\n        if (comp) {\r\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        else {\r\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        this.keyedMap = documentMap();\r\n        this.sortedSet = new SortedMap(this.comparator);\r\n    }\r\n    /**\r\n     * Returns an empty copy of the existing DocumentSet, using the same\r\n     * comparator.\r\n     */\r\n    static emptySet(oldSet) {\r\n        return new DocumentSet(oldSet.comparator);\r\n    }\r\n    has(key) {\r\n        return this.keyedMap.get(key) != null;\r\n    }\r\n    get(key) {\r\n        return this.keyedMap.get(key);\r\n    }\r\n    first() {\r\n        return this.sortedSet.minKey();\r\n    }\r\n    last() {\r\n        return this.sortedSet.maxKey();\r\n    }\r\n    isEmpty() {\r\n        return this.sortedSet.isEmpty();\r\n    }\r\n    /**\r\n     * Returns the index of the provided key in the document set, or -1 if the\r\n     * document key is not present in the set;\r\n     */\r\n    indexOf(key) {\r\n        const doc = this.keyedMap.get(key);\r\n        return doc ? this.sortedSet.indexOf(doc) : -1;\r\n    }\r\n    get size() {\r\n        return this.sortedSet.size;\r\n    }\r\n    /** Iterates documents in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.sortedSet.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Inserts or updates a document with the same key */\r\n    add(doc) {\r\n        // First remove the element if we have it.\r\n        const set = this.delete(doc.key);\r\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\r\n    }\r\n    /** Deletes a document with a given key */\r\n    delete(key) {\r\n        const doc = this.get(key);\r\n        if (!doc) {\r\n            return this;\r\n        }\r\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof DocumentSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.sortedSet.getIterator();\r\n        const otherIt = other.sortedSet.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisDoc = thisIt.getNext().key;\r\n            const otherDoc = otherIt.getNext().key;\r\n            if (!thisDoc.isEqual(otherDoc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toString() {\r\n        const docStrings = [];\r\n        this.forEach(doc => {\r\n            docStrings.push(doc.toString());\r\n        });\r\n        if (docStrings.length === 0) {\r\n            return 'DocumentSet ()';\r\n        }\r\n        else {\r\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\r\n        }\r\n    }\r\n    copy(keyedMap, sortedSet) {\r\n        const newSet = new DocumentSet();\r\n        newSet.comparator = this.comparator;\r\n        newSet.keyedMap = keyedMap;\r\n        newSet.sortedSet = sortedSet;\r\n        return newSet;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\r\n * duplicate events for the same doc.\r\n */\r\nclass DocumentChangeSet {\r\n    constructor() {\r\n        this.changeMap = new SortedMap(DocumentKey.comparator);\r\n    }\r\n    track(change) {\r\n        const key = change.doc.key;\r\n        const oldChange = this.changeMap.get(key);\r\n        if (!oldChange) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n            return;\r\n        }\r\n        // Merge the new change with the existing change.\r\n        if (change.type !== 0 /* ChangeType.Added */ &&\r\n            oldChange.type === 3 /* ChangeType.Metadata */) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n        }\r\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\r\n            oldChange.type !== 1 /* ChangeType.Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: oldChange.type,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* ChangeType.Modified */ &&\r\n            oldChange.type === 2 /* ChangeType.Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* ChangeType.Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* ChangeType.Modified */ &&\r\n            oldChange.type === 0 /* ChangeType.Added */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 0 /* ChangeType.Added */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 1 /* ChangeType.Removed */ &&\r\n            oldChange.type === 0 /* ChangeType.Added */) {\r\n            this.changeMap = this.changeMap.remove(key);\r\n        }\r\n        else if (change.type === 1 /* ChangeType.Removed */ &&\r\n            oldChange.type === 2 /* ChangeType.Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 1 /* ChangeType.Removed */,\r\n                doc: oldChange.doc\r\n            });\r\n        }\r\n        else if (change.type === 0 /* ChangeType.Added */ &&\r\n            oldChange.type === 1 /* ChangeType.Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* ChangeType.Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else {\r\n            // This includes these cases, which don't make sense:\r\n            // Added->Added\r\n            // Removed->Removed\r\n            // Modified->Added\r\n            // Removed->Modified\r\n            // Metadata->Added\r\n            // Removed->Metadata\r\n            fail();\r\n        }\r\n    }\r\n    getChanges() {\r\n        const changes = [];\r\n        this.changeMap.inorderTraversal((key, change) => {\r\n            changes.push(change);\r\n        });\r\n        return changes;\r\n    }\r\n}\r\nclass ViewSnapshot {\r\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\r\n        this.query = query;\r\n        this.docs = docs;\r\n        this.oldDocs = oldDocs;\r\n        this.docChanges = docChanges;\r\n        this.mutatedKeys = mutatedKeys;\r\n        this.fromCache = fromCache;\r\n        this.syncStateChanged = syncStateChanged;\r\n        this.excludesMetadataChanges = excludesMetadataChanges;\r\n        this.hasCachedResults = hasCachedResults;\r\n    }\r\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\r\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\r\n        const changes = [];\r\n        documents.forEach(doc => {\r\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\r\n        });\r\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \r\n        /* syncStateChanged= */ true, \r\n        /* excludesMetadataChanges= */ false, hasCachedResults);\r\n    }\r\n    get hasPendingWrites() {\r\n        return !this.mutatedKeys.isEmpty();\r\n    }\r\n    isEqual(other) {\r\n        if (this.fromCache !== other.fromCache ||\r\n            this.hasCachedResults !== other.hasCachedResults ||\r\n            this.syncStateChanged !== other.syncStateChanged ||\r\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\r\n            !queryEquals(this.query, other.query) ||\r\n            !this.docs.isEqual(other.docs) ||\r\n            !this.oldDocs.isEqual(other.oldDocs)) {\r\n            return false;\r\n        }\r\n        const changes = this.docChanges;\r\n        const otherChanges = other.docChanges;\r\n        if (changes.length !== otherChanges.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < changes.length; i++) {\r\n            if (changes[i].type !== otherChanges[i].type ||\r\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Holds the listeners and the last received ViewSnapshot for a query being\r\n * tracked by EventManager.\r\n */\r\nclass QueryListenersInfo {\r\n    constructor() {\r\n        this.viewSnap = undefined;\r\n        this.listeners = [];\r\n    }\r\n    // Helper methods that checks if the query has listeners that listening to remote store\r\n    hasRemoteListeners() {\r\n        return this.listeners.some(listener => listener.listensToRemoteStore());\r\n    }\r\n}\r\nfunction newEventManager() {\r\n    return new EventManagerImpl();\r\n}\r\nclass EventManagerImpl {\r\n    constructor() {\r\n        this.queries = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        this.snapshotsInSyncListeners = new Set();\r\n    }\r\n}\r\nasync function eventManagerListen(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\r\n    const query = listener.query;\r\n    let queryInfo = eventManagerImpl.queries.get(query);\r\n    if (!queryInfo) {\r\n        queryInfo = new QueryListenersInfo();\r\n        listenerAction = listener.listensToRemoteStore()\r\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\r\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\r\n    }\r\n    else if (!queryInfo.hasRemoteListeners() &&\r\n        listener.listensToRemoteStore()) {\r\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\r\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\r\n    }\r\n    try {\r\n        switch (listenerAction) {\r\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\r\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \r\n                /** enableRemoteListen= */ true);\r\n                break;\r\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\r\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \r\n                /** enableRemoteListen= */ false);\r\n                break;\r\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\r\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\r\n        listener.onError(firestoreError);\r\n        return;\r\n    }\r\n    eventManagerImpl.queries.set(query, queryInfo);\r\n    queryInfo.listeners.push(listener);\r\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\r\n    if (queryInfo.viewSnap) {\r\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\r\n        if (raisedEvent) {\r\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n        }\r\n    }\r\n}\r\nasync function eventManagerUnlisten(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const query = listener.query;\r\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        const i = queryInfo.listeners.indexOf(listener);\r\n        if (i >= 0) {\r\n            queryInfo.listeners.splice(i, 1);\r\n            if (queryInfo.listeners.length === 0) {\r\n                listenerAction = listener.listensToRemoteStore()\r\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\r\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\r\n            }\r\n            else if (!queryInfo.hasRemoteListeners() &&\r\n                listener.listensToRemoteStore()) {\r\n                // The removed listener is the last one that sourced from watch.\r\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\r\n            }\r\n        }\r\n    }\r\n    switch (listenerAction) {\r\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\r\n            eventManagerImpl.queries.delete(query);\r\n            return eventManagerImpl.onUnlisten(query, \r\n            /** disableRemoteListen= */ true);\r\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\r\n            eventManagerImpl.queries.delete(query);\r\n            return eventManagerImpl.onUnlisten(query, \r\n            /** disableRemoteListen= */ false);\r\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\r\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\r\n        default:\r\n            return;\r\n    }\r\n}\r\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    let raisedEvent = false;\r\n    for (const viewSnap of viewSnaps) {\r\n        const query = viewSnap.query;\r\n        const queryInfo = eventManagerImpl.queries.get(query);\r\n        if (queryInfo) {\r\n            for (const listener of queryInfo.listeners) {\r\n                if (listener.onViewSnapshot(viewSnap)) {\r\n                    raisedEvent = true;\r\n                }\r\n            }\r\n            queryInfo.viewSnap = viewSnap;\r\n        }\r\n    }\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction eventManagerOnWatchError(eventManager, query, error) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        for (const listener of queryInfo.listeners) {\r\n            listener.onError(error);\r\n        }\r\n    }\r\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\r\n    // after an error.\r\n    eventManagerImpl.queries.delete(query);\r\n}\r\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.onlineState = onlineState;\r\n    let raisedEvent = false;\r\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\r\n        for (const listener of queryInfo.listeners) {\r\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n            if (listener.applyOnlineStateChange(onlineState)) {\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n    });\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction addSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\r\n    // Immediately fire an initial event, indicating all existing listeners\r\n    // are in-sync.\r\n    observer.next();\r\n}\r\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\r\n}\r\n// Call all global snapshot listeners that have been set.\r\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\r\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\r\n        observer.next();\r\n    });\r\n}\r\nvar ListenerDataSource;\r\n(function (ListenerDataSource) {\r\n    /** Listen to both cache and server changes */\r\n    ListenerDataSource[\"Default\"] = \"default\";\r\n    /** Listen to changes in cache only */\r\n    ListenerDataSource[\"Cache\"] = \"cache\";\r\n})(ListenerDataSource || (ListenerDataSource = {}));\r\n/**\r\n * QueryListener takes a series of internal view snapshots and determines\r\n * when to raise the event.\r\n *\r\n * It uses an Observer to dispatch events.\r\n */\r\nclass QueryListener {\r\n    constructor(query, queryObserver, options) {\r\n        this.query = query;\r\n        this.queryObserver = queryObserver;\r\n        /**\r\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\r\n         * observer. This flag is set to true once we've actually raised an event.\r\n         */\r\n        this.raisedInitialEvent = false;\r\n        this.snap = null;\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        this.options = options || {};\r\n    }\r\n    /**\r\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\r\n     * if applicable (depending on what changed, whether the user has opted into\r\n     * metadata-only changes, etc.). Returns true if a user-facing event was\r\n     * indeed raised.\r\n     */\r\n    onViewSnapshot(snap) {\r\n        if (!this.options.includeMetadataChanges) {\r\n            // Remove the metadata only changes.\r\n            const docChanges = [];\r\n            for (const docChange of snap.docChanges) {\r\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\r\n                    docChanges.push(docChange);\r\n                }\r\n            }\r\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \r\n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\r\n        }\r\n        let raisedEvent = false;\r\n        if (!this.raisedInitialEvent) {\r\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\r\n                this.raiseInitialEvent(snap);\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n        else if (this.shouldRaiseEvent(snap)) {\r\n            this.queryObserver.next(snap);\r\n            raisedEvent = true;\r\n        }\r\n        this.snap = snap;\r\n        return raisedEvent;\r\n    }\r\n    onError(error) {\r\n        this.queryObserver.error(error);\r\n    }\r\n    /** Returns whether a snapshot was raised. */\r\n    applyOnlineStateChange(onlineState) {\r\n        this.onlineState = onlineState;\r\n        let raisedEvent = false;\r\n        if (this.snap &&\r\n            !this.raisedInitialEvent &&\r\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\r\n            this.raiseInitialEvent(this.snap);\r\n            raisedEvent = true;\r\n        }\r\n        return raisedEvent;\r\n    }\r\n    shouldRaiseInitialEvent(snap, onlineState) {\r\n        // Always raise the first event when we're synced\r\n        if (!snap.fromCache) {\r\n            return true;\r\n        }\r\n        // Always raise event if listening to cache\r\n        if (!this.listensToRemoteStore()) {\r\n            return true;\r\n        }\r\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\r\n        // or Online if we wait long enough).\r\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\r\n        // Don't raise the event if we're online, aren't synced yet (checked\r\n        // above) and are waiting for a sync.\r\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\r\n            return false;\r\n        }\r\n        // Raise data from cache if we have any documents, have cached results before,\r\n        // or we are offline.\r\n        return (!snap.docs.isEmpty() ||\r\n            snap.hasCachedResults ||\r\n            onlineState === \"Offline\" /* OnlineState.Offline */);\r\n    }\r\n    shouldRaiseEvent(snap) {\r\n        // We don't need to handle includeDocumentMetadataChanges here because\r\n        // the Metadata only changes have already been stripped out if needed.\r\n        // At this point the only changes we will see are the ones we should\r\n        // propagate.\r\n        if (snap.docChanges.length > 0) {\r\n            return true;\r\n        }\r\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\r\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\r\n            return this.options.includeMetadataChanges === true;\r\n        }\r\n        // Generally we should have hit one of the cases above, but it's possible\r\n        // to get here if there were only metadata docChanges and they got\r\n        // stripped out.\r\n        return false;\r\n    }\r\n    raiseInitialEvent(snap) {\r\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\r\n        this.raisedInitialEvent = true;\r\n        this.queryObserver.next(snap);\r\n    }\r\n    listensToRemoteStore() {\r\n        return this.options.source !== ListenerDataSource.Cache;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A set of changes to what documents are currently in view and out of view for\r\n * a given query. These changes are sent to the LocalStore by the View (via\r\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\r\n */\r\nclass LocalViewChanges {\r\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\r\n        this.targetId = targetId;\r\n        this.fromCache = fromCache;\r\n        this.addedKeys = addedKeys;\r\n        this.removedKeys = removedKeys;\r\n    }\r\n    static fromSnapshot(targetId, viewSnapshot) {\r\n        let addedKeys = documentKeySet();\r\n        let removedKeys = documentKeySet();\r\n        for (const docChange of viewSnapshot.docChanges) {\r\n            switch (docChange.type) {\r\n                case 0 /* ChangeType.Added */:\r\n                    addedKeys = addedKeys.add(docChange.doc.key);\r\n                    break;\r\n                case 1 /* ChangeType.Removed */:\r\n                    removedKeys = removedKeys.add(docChange.doc.key);\r\n                    break;\r\n                // do nothing\r\n            }\r\n        }\r\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to convert objects from bundles to model objects in the SDK.\r\n */\r\nclass BundleConverterImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    toDocumentKey(name) {\r\n        return fromName(this.serializer, name);\r\n    }\r\n    /**\r\n     * Converts a BundleDocument to a MutableDocument.\r\n     */\r\n    toMutableDocument(bundledDoc) {\r\n        if (bundledDoc.metadata.exists) {\r\n            return fromDocument(this.serializer, bundledDoc.document, false);\r\n        }\r\n        else {\r\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\r\n        }\r\n    }\r\n    toSnapshotVersion(time) {\r\n        return fromVersion(time);\r\n    }\r\n}\r\n/**\r\n * A class to process the elements from a bundle, load them into local\r\n * storage and provide progress update while loading.\r\n */\r\nclass BundleLoader {\r\n    constructor(bundleMetadata, localStore, serializer) {\r\n        this.bundleMetadata = bundleMetadata;\r\n        this.localStore = localStore;\r\n        this.serializer = serializer;\r\n        /** Batched queries to be saved into storage */\r\n        this.queries = [];\r\n        /** Batched documents to be saved into storage */\r\n        this.documents = [];\r\n        /** The collection groups affected by this bundle. */\r\n        this.collectionGroups = new Set();\r\n        this.progress = bundleInitialProgress(bundleMetadata);\r\n    }\r\n    /**\r\n     * Adds an element from the bundle to the loader.\r\n     *\r\n     * Returns a new progress if adding the element leads to a new progress,\r\n     * otherwise returns null.\r\n     */\r\n    addSizedElement(element) {\r\n        this.progress.bytesLoaded += element.byteLength;\r\n        let documentsLoaded = this.progress.documentsLoaded;\r\n        if (element.payload.namedQuery) {\r\n            this.queries.push(element.payload.namedQuery);\r\n        }\r\n        else if (element.payload.documentMetadata) {\r\n            this.documents.push({ metadata: element.payload.documentMetadata });\r\n            if (!element.payload.documentMetadata.exists) {\r\n                ++documentsLoaded;\r\n            }\r\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\r\n            this.collectionGroups.add(path.get(path.length - 2));\r\n        }\r\n        else if (element.payload.document) {\r\n            this.documents[this.documents.length - 1].document =\r\n                element.payload.document;\r\n            ++documentsLoaded;\r\n        }\r\n        if (documentsLoaded !== this.progress.documentsLoaded) {\r\n            this.progress.documentsLoaded = documentsLoaded;\r\n            return Object.assign({}, this.progress);\r\n        }\r\n        return null;\r\n    }\r\n    getQueryDocumentMapping(documents) {\r\n        const queryDocumentMap = new Map();\r\n        const bundleConverter = new BundleConverterImpl(this.serializer);\r\n        for (const bundleDoc of documents) {\r\n            if (bundleDoc.metadata.queries) {\r\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n                for (const queryName of bundleDoc.metadata.queries) {\r\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\r\n                    queryDocumentMap.set(queryName, documentKeys);\r\n                }\r\n            }\r\n        }\r\n        return queryDocumentMap;\r\n    }\r\n    /**\r\n     * Update the progress to 'Success' and return the updated progress.\r\n     */\r\n    async complete() {\r\n        const changedDocs = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\r\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\r\n        for (const q of this.queries) {\r\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\r\n        }\r\n        this.progress.taskState = 'Success';\r\n        return {\r\n            progress: this.progress,\r\n            changedCollectionGroups: this.collectionGroups,\r\n            changedDocs\r\n        };\r\n    }\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\r\n * loading a bundle.\r\n */\r\nfunction bundleInitialProgress(metadata) {\r\n    return {\r\n        taskState: 'Running',\r\n        documentsLoaded: 0,\r\n        bytesLoaded: 0,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\r\n * has succeeded.\r\n */\r\nfunction bundleSuccessProgress(metadata) {\r\n    return {\r\n        taskState: 'Success',\r\n        documentsLoaded: metadata.totalDocuments,\r\n        bytesLoaded: metadata.totalBytes,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AddedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\nclass RemovedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\n/**\r\n * View is responsible for computing the final merged truth of what docs are in\r\n * a query. It gets notified of local and remote changes to docs, and applies\r\n * the query filters and limits to determine the most correct possible results.\r\n */\r\nclass View {\r\n    constructor(query, \r\n    /** Documents included in the remote target */\r\n    _syncedDocuments) {\r\n        this.query = query;\r\n        this._syncedDocuments = _syncedDocuments;\r\n        this.syncState = null;\r\n        this.hasCachedResults = false;\r\n        /**\r\n         * A flag whether the view is current with the backend. A view is considered\r\n         * current after it has seen the current flag from the backend and did not\r\n         * lose consistency within the watch stream (e.g. because of an existence\r\n         * filter mismatch).\r\n         */\r\n        this.current = false;\r\n        /** Documents in the view but not in the remote target */\r\n        this.limboDocuments = documentKeySet();\r\n        /** Document Keys that have local changes */\r\n        this.mutatedKeys = documentKeySet();\r\n        this.docComparator = newQueryComparator(query);\r\n        this.documentSet = new DocumentSet(this.docComparator);\r\n    }\r\n    /**\r\n     * The set of remote documents that the server has told us belongs to the target associated with\r\n     * this view.\r\n     */\r\n    get syncedDocuments() {\r\n        return this._syncedDocuments;\r\n    }\r\n    /**\r\n     * Iterates over a set of doc changes, applies the query limit, and computes\r\n     * what the new results should be, what the changes were, and whether we may\r\n     * need to go back to the local cache for more results. Does not make any\r\n     * changes to the view.\r\n     * @param docChanges - The doc changes to apply to this view.\r\n     * @param previousChanges - If this is being called with a refill, then start\r\n     *        with this set of docs and changes instead of the current view.\r\n     * @returns a new set of docs, changes, and refill flag.\r\n     */\r\n    computeDocChanges(docChanges, previousChanges) {\r\n        const changeSet = previousChanges\r\n            ? previousChanges.changeSet\r\n            : new DocumentChangeSet();\r\n        const oldDocumentSet = previousChanges\r\n            ? previousChanges.documentSet\r\n            : this.documentSet;\r\n        let newMutatedKeys = previousChanges\r\n            ? previousChanges.mutatedKeys\r\n            : this.mutatedKeys;\r\n        let newDocumentSet = oldDocumentSet;\r\n        let needsRefill = false;\r\n        // Track the last doc in a (full) limit. This is necessary, because some\r\n        // update (a delete, or an update moving a doc past the old limit) might\r\n        // mean there is some other document in the local cache that either should\r\n        // come (1) between the old last limit doc and the new last document, in the\r\n        // case of updates, or (2) after the new last document, in the case of\r\n        // deletes. So we keep this doc at the old limit to compare the updates to.\r\n        //\r\n        // Note that this should never get used in a refill (when previousChanges is\r\n        // set), because there will only be adds -- no deletes or updates.\r\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\r\n            oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.last()\r\n            : null;\r\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\r\n            oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.first()\r\n            : null;\r\n        docChanges.inorderTraversal((key, entry) => {\r\n            const oldDoc = oldDocumentSet.get(key);\r\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\r\n            const oldDocHadPendingMutations = oldDoc\r\n                ? this.mutatedKeys.has(oldDoc.key)\r\n                : false;\r\n            const newDocHasPendingMutations = newDoc\r\n                ? newDoc.hasLocalMutations ||\r\n                    // We only consider committed mutations for documents that were\r\n                    // mutated during the lifetime of the view.\r\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\r\n                : false;\r\n            let changeApplied = false;\r\n            // Calculate change\r\n            if (oldDoc && newDoc) {\r\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\r\n                if (!docsEqual) {\r\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\r\n                        changeSet.track({\r\n                            type: 2 /* ChangeType.Modified */,\r\n                            doc: newDoc\r\n                        });\r\n                        changeApplied = true;\r\n                        if ((lastDocInLimit &&\r\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\r\n                            (firstDocInLimit &&\r\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\r\n                            // This doc moved from inside the limit to outside the limit.\r\n                            // That means there may be some other doc in the local cache\r\n                            // that should be included instead.\r\n                            needsRefill = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\r\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\r\n                    changeApplied = true;\r\n                }\r\n            }\r\n            else if (!oldDoc && newDoc) {\r\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\r\n                changeApplied = true;\r\n            }\r\n            else if (oldDoc && !newDoc) {\r\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\r\n                changeApplied = true;\r\n                if (lastDocInLimit || firstDocInLimit) {\r\n                    // A doc was removed from a full limit query. We'll need to\r\n                    // requery from the local cache to see if we know about some other\r\n                    // doc that should be in the results.\r\n                    needsRefill = true;\r\n                }\r\n            }\r\n            if (changeApplied) {\r\n                if (newDoc) {\r\n                    newDocumentSet = newDocumentSet.add(newDoc);\r\n                    if (newDocHasPendingMutations) {\r\n                        newMutatedKeys = newMutatedKeys.add(key);\r\n                    }\r\n                    else {\r\n                        newMutatedKeys = newMutatedKeys.delete(key);\r\n                    }\r\n                }\r\n                else {\r\n                    newDocumentSet = newDocumentSet.delete(key);\r\n                    newMutatedKeys = newMutatedKeys.delete(key);\r\n                }\r\n            }\r\n        });\r\n        // Drop documents out to meet limit/limitToLast requirement.\r\n        if (this.query.limit !== null) {\r\n            while (newDocumentSet.size > this.query.limit) {\r\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\r\n                    ? newDocumentSet.last()\r\n                    : newDocumentSet.first();\r\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\r\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\r\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\r\n            }\r\n        }\r\n        return {\r\n            documentSet: newDocumentSet,\r\n            changeSet,\r\n            needsRefill,\r\n            mutatedKeys: newMutatedKeys\r\n        };\r\n    }\r\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\r\n        // We suppress the initial change event for documents that were modified as\r\n        // part of a write acknowledgment (e.g. when the value of a server transform\r\n        // is applied) as Watch will send us the same document again.\r\n        // By suppressing the event, we only raise two user visible events (one with\r\n        // `hasPendingWrites` and the final state of the document) instead of three\r\n        // (one with `hasPendingWrites`, the modified document with\r\n        // `hasPendingWrites` and the final state of the document).\r\n        return (oldDoc.hasLocalMutations &&\r\n            newDoc.hasCommittedMutations &&\r\n            !newDoc.hasLocalMutations);\r\n    }\r\n    /**\r\n     * Updates the view with the given ViewDocumentChanges and optionally updates\r\n     * limbo docs and sync state from the provided target change.\r\n     * @param docChanges - The set of changes to make to the view's docs.\r\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\r\n     *        this change.\r\n     * @param targetChange - A target change to apply for computing limbo docs and\r\n     *        sync state.\r\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\r\n     *        existence filter mismatch. If not explicitly specified, it is treated\r\n     *        equivalently to `false`.\r\n     * @returns A new ViewChange with the given docs, changes, and sync state.\r\n     */\r\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\r\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\r\n        const oldDocs = this.documentSet;\r\n        this.documentSet = docChanges.documentSet;\r\n        this.mutatedKeys = docChanges.mutatedKeys;\r\n        // Sort changes based on type and query comparator\r\n        const changes = docChanges.changeSet.getChanges();\r\n        changes.sort((c1, c2) => {\r\n            return (compareChangeType(c1.type, c2.type) ||\r\n                this.docComparator(c1.doc, c2.doc));\r\n        });\r\n        this.applyTargetChange(targetChange);\r\n        targetIsPendingReset = targetIsPendingReset !== null && targetIsPendingReset !== void 0 ? targetIsPendingReset : false;\r\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\r\n            ? this.updateLimboDocuments()\r\n            : [];\r\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\r\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\r\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\r\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\r\n        const syncStateChanged = newSyncState !== this.syncState;\r\n        this.syncState = newSyncState;\r\n        if (changes.length === 0 && !syncStateChanged) {\r\n            // no changes\r\n            return { limboChanges };\r\n        }\r\n        else {\r\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \r\n            /* excludesMetadataChanges= */ false, targetChange\r\n                ? targetChange.resumeToken.approximateByteSize() > 0\r\n                : false);\r\n            return {\r\n                snapshot: snap,\r\n                limboChanges\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Applies an OnlineState change to the view, potentially generating a\r\n     * ViewChange if the view's syncState changes as a result.\r\n     */\r\n    applyOnlineStateChange(onlineState) {\r\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\r\n            // If we're offline, set `current` to false and then call applyChanges()\r\n            // to refresh our syncState and generate a ViewChange as appropriate. We\r\n            // are guaranteed to get a new TargetChange that sets `current` back to\r\n            // true once the client is back online.\r\n            this.current = false;\r\n            return this.applyChanges({\r\n                documentSet: this.documentSet,\r\n                changeSet: new DocumentChangeSet(),\r\n                mutatedKeys: this.mutatedKeys,\r\n                needsRefill: false\r\n            }, \r\n            /* limboResolutionEnabled= */ false);\r\n        }\r\n        else {\r\n            // No effect, just return a no-op ViewChange.\r\n            return { limboChanges: [] };\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the doc for the given key should be in limbo.\r\n     */\r\n    shouldBeInLimbo(key) {\r\n        // If the remote end says it's part of this query, it's not in limbo.\r\n        if (this._syncedDocuments.has(key)) {\r\n            return false;\r\n        }\r\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\r\n        if (!this.documentSet.has(key)) {\r\n            return false;\r\n        }\r\n        // If there are local changes to the doc, they might explain why the server\r\n        // doesn't know that it's part of the query. So don't put it in limbo.\r\n        // TODO(klimt): Ideally, we would only consider changes that might actually\r\n        // affect this specific query.\r\n        if (this.documentSet.get(key).hasLocalMutations) {\r\n            return false;\r\n        }\r\n        // Everything else is in limbo.\r\n        return true;\r\n    }\r\n    /**\r\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\r\n     * Returns the list of changes to which docs are in limbo.\r\n     */\r\n    applyTargetChange(targetChange) {\r\n        if (targetChange) {\r\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\r\n            targetChange.modifiedDocuments.forEach(key => {\r\n            });\r\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\r\n            this.current = targetChange.current;\r\n        }\r\n    }\r\n    updateLimboDocuments() {\r\n        // We can only determine limbo documents when we're in-sync with the server.\r\n        if (!this.current) {\r\n            return [];\r\n        }\r\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\r\n        // updating many documents.\r\n        const oldLimboDocuments = this.limboDocuments;\r\n        this.limboDocuments = documentKeySet();\r\n        this.documentSet.forEach(doc => {\r\n            if (this.shouldBeInLimbo(doc.key)) {\r\n                this.limboDocuments = this.limboDocuments.add(doc.key);\r\n            }\r\n        });\r\n        // Diff the new limbo docs with the old limbo docs.\r\n        const changes = [];\r\n        oldLimboDocuments.forEach(key => {\r\n            if (!this.limboDocuments.has(key)) {\r\n                changes.push(new RemovedLimboDocument(key));\r\n            }\r\n        });\r\n        this.limboDocuments.forEach(key => {\r\n            if (!oldLimboDocuments.has(key)) {\r\n                changes.push(new AddedLimboDocument(key));\r\n            }\r\n        });\r\n        return changes;\r\n    }\r\n    /**\r\n     * Update the in-memory state of the current view with the state read from\r\n     * persistence.\r\n     *\r\n     * We update the query view whenever a client's primary status changes:\r\n     * - When a client transitions from primary to secondary, it can miss\r\n     *   LocalStorage updates and its query views may temporarily not be\r\n     *   synchronized with the state on disk.\r\n     * - For secondary to primary transitions, the client needs to update the list\r\n     *   of `syncedDocuments` since secondary clients update their query views\r\n     *   based purely on synthesized RemoteEvents.\r\n     *\r\n     * @param queryResult.documents - The documents that match the query according\r\n     * to the LocalStore.\r\n     * @param queryResult.remoteKeys - The keys of the documents that match the\r\n     * query according to the backend.\r\n     *\r\n     * @returns The ViewChange that resulted from this synchronization.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    synchronizeWithPersistedState(queryResult) {\r\n        this._syncedDocuments = queryResult.remoteKeys;\r\n        this.limboDocuments = documentKeySet();\r\n        const docChanges = this.computeDocChanges(queryResult.documents);\r\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\r\n    }\r\n    /**\r\n     * Returns a view snapshot as if this query was just listened to. Contains\r\n     * a document add for every existing document and the `fromCache` and\r\n     * `hasPendingWrites` status of the already established view.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    computeInitialSnapshot() {\r\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\r\n    }\r\n}\r\nfunction compareChangeType(c1, c2) {\r\n    const order = (change) => {\r\n        switch (change) {\r\n            case 0 /* ChangeType.Added */:\r\n                return 1;\r\n            case 2 /* ChangeType.Modified */:\r\n                return 2;\r\n            case 3 /* ChangeType.Metadata */:\r\n                // A metadata change is converted to a modified change at the public\r\n                // api layer.  Since we sort by document key and then change type,\r\n                // metadata and modified changes must be sorted equivalently.\r\n                return 2;\r\n            case 1 /* ChangeType.Removed */:\r\n                return 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    };\r\n    return order(c1) - order(c2);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$3 = 'SyncEngine';\r\n/**\r\n * QueryView contains all of the data that SyncEngine needs to keep track of for\r\n * a particular query.\r\n */\r\nclass QueryView {\r\n    constructor(\r\n    /**\r\n     * The query itself.\r\n     */\r\n    query, \r\n    /**\r\n     * The target number created by the client that is used in the watch\r\n     * stream to identify this query.\r\n     */\r\n    targetId, \r\n    /**\r\n     * The view is responsible for computing the final merged truth of what\r\n     * docs are in the query. It gets notified of local and remote changes,\r\n     * and applies the query filters and limits to determine the most correct\r\n     * possible results.\r\n     */\r\n    view) {\r\n        this.query = query;\r\n        this.targetId = targetId;\r\n        this.view = view;\r\n    }\r\n}\r\n/** Tracks a limbo resolution. */\r\nclass LimboResolution {\r\n    constructor(key) {\r\n        this.key = key;\r\n        /**\r\n         * Set to true once we've received a document. This is used in\r\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\r\n         * decide whether it needs to manufacture a delete event for the target once\r\n         * the target is CURRENT.\r\n         */\r\n        this.receivedDocument = false;\r\n    }\r\n}\r\n/**\r\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\r\n *\r\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\r\n * registered individually. This is done in `syncEngineWrite()` and\r\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\r\n * serve as entry points to RemoteStore's functionality.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass SyncEngineImpl {\r\n    constructor(localStore, remoteStore, eventManager, \r\n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\r\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\r\n        this.localStore = localStore;\r\n        this.remoteStore = remoteStore;\r\n        this.eventManager = eventManager;\r\n        this.sharedClientState = sharedClientState;\r\n        this.currentUser = currentUser;\r\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\r\n        this.syncEngineListener = {};\r\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.queriesByTarget = new Map();\r\n        /**\r\n         * The keys of documents that are in limbo for which we haven't yet started a\r\n         * limbo resolution query. The strings in this set are the result of calling\r\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\r\n         *\r\n         * The `Set` type was chosen because it provides efficient lookup and removal\r\n         * of arbitrary elements and it also maintains insertion order, providing the\r\n         * desired queue-like FIFO semantics.\r\n         */\r\n        this.enqueuedLimboResolutions = new Set();\r\n        /**\r\n         * Keeps track of the target ID for each document that is in limbo with an\r\n         * active target.\r\n         */\r\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n        /**\r\n         * Keeps track of the information about an active limbo resolution for each\r\n         * active target ID that was started for the purpose of limbo resolution.\r\n         */\r\n        this.activeLimboResolutionsByTarget = new Map();\r\n        this.limboDocumentRefs = new ReferenceSet();\r\n        /** Stores user completion handlers, indexed by User and BatchId. */\r\n        this.mutationUserCallbacks = {};\r\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\r\n        this.pendingWritesCallbacks = new Map();\r\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\r\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\r\n        // The primary state is set to `true` or `false` immediately after Firestore\r\n        // startup. In the interim, a client should only be considered primary if\r\n        // `isPrimary` is true.\r\n        this._isPrimaryClient = undefined;\r\n    }\r\n    get isPrimaryClient() {\r\n        return this._isPrimaryClient === true;\r\n    }\r\n}\r\nfunction newSyncEngine(localStore, remoteStore, eventManager, \r\n// PORTING NOTE: Manages state synchronization in multi-tab environments.\r\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\r\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\r\n    if (isPrimary) {\r\n        syncEngine._isPrimaryClient = true;\r\n    }\r\n    return syncEngine;\r\n}\r\n/**\r\n * Initiates the new listen, resolves promise when listen enqueued to the\r\n * server. All the subsequent view snapshots or errors are sent to the\r\n * subscribed handlers. Returns the initial snapshot.\r\n */\r\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    let viewSnapshot;\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    if (queryView) {\r\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\r\n        // already exists when EventManager calls us for the first time. This\r\n        // happens when the primary tab is already listening to this query on\r\n        // behalf of another tab and the user of the primary also starts listening\r\n        // to the query. EventManager will not have an assigned target ID in this\r\n        // case and calls `listen` to obtain this ID.\r\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\r\n        viewSnapshot = queryView.view.computeInitialSnapshot();\r\n    }\r\n    else {\r\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \r\n        /** shouldInitializeView= */ true);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\r\nasync function triggerRemoteStoreListen(syncEngine, query) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \r\n    /** shouldListenToRemote= */ true, \r\n    /** shouldInitializeView= */ false);\r\n}\r\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\r\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\r\n    const targetId = targetData.targetId;\r\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\r\n    // not registering it in shared client state, and directly calculate initial snapshots and\r\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\r\n    // as active watch target.\r\n    const status = shouldListenToRemote\r\n        ? syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId)\r\n        : 'not-current';\r\n    let viewSnapshot;\r\n    if (shouldInitializeView) {\r\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\r\n    }\r\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\r\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Registers a view for a previously unknown query and computes its initial\r\n * snapshot.\r\n */\r\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\r\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\r\n    // targets based on view changes. This allows us to only depend on Limbo\r\n    // changes when user code includes queries.\r\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \r\n    /* usePreviousResults= */ true);\r\n    const view = new View(query, queryResult.remoteKeys);\r\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\r\n    const viewChange = view.applyChanges(viewDocChanges, \r\n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\r\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\r\n    const data = new QueryView(query, targetId, view);\r\n    syncEngineImpl.queryViewsByQuery.set(query, data);\r\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\r\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\r\n    }\r\n    else {\r\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\r\n    }\r\n    return viewChange.snapshot;\r\n}\r\n/** Stops listening to the query. */\r\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    // Only clean up the query view and target if this is the only query mapped\r\n    // to the target.\r\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\r\n    if (queries.length > 1) {\r\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        return;\r\n    }\r\n    // No other queries are mapped to the target, clean up the query and the target.\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        // We need to remove the local query target first to allow us to verify\r\n        // whether any other client is still interested in this target.\r\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\r\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\r\n        if (!targetRemainsActive) {\r\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n            /*keepPersistedTargetData=*/ false)\r\n                .then(() => {\r\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\r\n                if (shouldUnlistenToRemote) {\r\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\r\n                }\r\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n            })\r\n                .catch(ignoreIfPrimaryLeaseLoss);\r\n        }\r\n    }\r\n    else {\r\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n        /*keepPersistedTargetData=*/ true);\r\n    }\r\n}\r\n/** Unlistens to the remote store while still listening to the cache. */\r\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\r\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\r\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\r\n        // watch target.\r\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\r\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\r\n    }\r\n}\r\n/**\r\n * Initiates the write of local mutation batch which involves adding the\r\n * writes to the mutation queue, notifying the remote store about new\r\n * mutations and raising events for any changes this write caused.\r\n *\r\n * The promise returned by this call is resolved when the above steps\r\n * have completed, *not* when the write was acked by the backend. The\r\n * userCallback is resolved once the write was acked/rejected by the\r\n * backend (or failed locally for any other reason).\r\n */\r\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\r\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\r\n    try {\r\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\r\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\r\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    catch (e) {\r\n        // If we can't persist the mutation, we reject the user callback and\r\n        // don't send the mutation. The user can then retry the write.\r\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\r\n        userCallback.reject(error);\r\n    }\r\n}\r\n/**\r\n * Applies one remote event to the sync engine, notifying any views of the\r\n * changes, and releasing any pending mutation batches that would become\r\n * visible because of the snapshot version the remote event contains.\r\n */\r\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\r\n        // Update `receivedDocument` as appropriate for any limbo targets.\r\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\r\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n            if (limboResolution) {\r\n                // Since this is a limbo resolution lookup, it's for a single document\r\n                // and it could be added, modified, or removed, but not a combination.\r\n                hardAssert(targetChange.addedDocuments.size +\r\n                    targetChange.modifiedDocuments.size +\r\n                    targetChange.removedDocuments.size <=\r\n                    1);\r\n                if (targetChange.addedDocuments.size > 0) {\r\n                    limboResolution.receivedDocument = true;\r\n                }\r\n                else if (targetChange.modifiedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                }\r\n                else if (targetChange.removedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                    limboResolution.receivedDocument = false;\r\n                }\r\n                else {\r\n                    // This was probably just a CURRENT targetChange or similar.\r\n                }\r\n            }\r\n        });\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Applies an OnlineState change to the sync engine and notifies any views of\r\n * the change.\r\n */\r\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // If we are the secondary client, we explicitly ignore the remote store's\r\n    // online state (the local client may go offline, even though the primary\r\n    // tab remains online) and only apply the primary tab's online state from\r\n    // SharedClientState.\r\n    if ((syncEngineImpl.isPrimaryClient &&\r\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\r\n        (!syncEngineImpl.isPrimaryClient &&\r\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\r\n        const newViewSnapshots = [];\r\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\r\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\r\n            if (viewChange.snapshot) {\r\n                newViewSnapshots.push(viewChange.snapshot);\r\n            }\r\n        });\r\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\r\n        if (newViewSnapshots.length) {\r\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n        }\r\n        syncEngineImpl.onlineState = onlineState;\r\n        if (syncEngineImpl.isPrimaryClient) {\r\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Rejects the listen for the given targetID. This can be triggered by the\r\n * backend for any active target.\r\n *\r\n * @param syncEngine - The sync engine implementation.\r\n * @param targetId - The targetID corresponds to one previously initiated by the\r\n * user as part of TargetData passed to listen() on RemoteStore.\r\n * @param err - A description of the condition that has forced the rejection.\r\n * Nearly always this will be an indication that the user is no longer\r\n * authorized to see the data matching the target.\r\n */\r\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // PORTING NOTE: Multi-tab only.\r\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    const limboKey = limboResolution && limboResolution.key;\r\n    if (limboKey) {\r\n        // TODO(klimt): We really only should do the following on permission\r\n        // denied errors, but we don't have the cause code here.\r\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\r\n        // This is kind of a hack. Ideally, we would have a method in the local\r\n        // store to purge a document. However, it would be tricky to keep all of\r\n        // the local store's invariants with another method.\r\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\r\n        // TODO(b/217189216): This limbo document should ideally have a read time,\r\n        // so that it is picked up by any read-time based scans. The backend,\r\n        // however, does not send a read time for target removals.\r\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\r\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\r\n        const event = new RemoteEvent(SnapshotVersion.min(), \r\n        /* targetChanges= */ new Map(), \r\n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\r\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\r\n        // Since this query failed, we won't want to manually unlisten to it.\r\n        // We only remove it from bookkeeping after we successfully applied the\r\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\r\n        // this query when the RemoteStore restarts the Watch stream, which should\r\n        // re-trigger the target failure.\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\r\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n    else {\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const batchId = mutationBatchResult.batch.batchId;\r\n    try {\r\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught\r\n        // up), so we raise user callbacks first so that they consistently happen\r\n        // before listen events.\r\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught up),\r\n        // so we raise user callbacks first so that they consistently happen before\r\n        // listen events.\r\n        processUserCallback(syncEngineImpl, batchId, error);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Registers a user callback that resolves when all pending mutations at the moment of calling\r\n * are acknowledged .\r\n */\r\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\r\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\r\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\r\n    }\r\n    try {\r\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\r\n        if (highestBatchId === BATCHID_UNKNOWN) {\r\n            // Trigger the callback right away if there is no pending writes at the moment.\r\n            callback.resolve();\r\n            return;\r\n        }\r\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\r\n        callbacks.push(callback);\r\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\r\n        callback.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\r\n * if there are any.\r\n */\r\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\r\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\r\n        callback.resolve();\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\r\n}\r\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\r\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\r\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\r\n        callbacks.forEach(callback => {\r\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\r\n        });\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.clear();\r\n}\r\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    if (!newCallbacks) {\r\n        newCallbacks = new SortedMap(primitiveComparator);\r\n    }\r\n    newCallbacks = newCallbacks.insert(batchId, callback);\r\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n        newCallbacks;\r\n}\r\n/**\r\n * Resolves or rejects the user callback for the given batch and then discards\r\n * it.\r\n */\r\nfunction processUserCallback(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\r\n    // okay for there to be no callback for this ID.\r\n    if (newCallbacks) {\r\n        const callback = newCallbacks.get(batchId);\r\n        if (callback) {\r\n            if (error) {\r\n                callback.reject(error);\r\n            }\r\n            else {\r\n                callback.resolve();\r\n            }\r\n            newCallbacks = newCallbacks.remove(batchId);\r\n        }\r\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n            newCallbacks;\r\n    }\r\n}\r\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\r\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\r\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        if (error) {\r\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\r\n        }\r\n    }\r\n    syncEngineImpl.queriesByTarget.delete(targetId);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\r\n        limboKeys.forEach(limboKey => {\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboKey);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction removeLimboTarget(syncEngineImpl, key) {\r\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\r\n    // It's possible that the target already got removed because the query failed. In that case,\r\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\r\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\r\n    if (limboTargetId === null) {\r\n        // This target already got removed, because the query failed.\r\n        return;\r\n    }\r\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\r\n    syncEngineImpl.activeLimboTargetsByKey =\r\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\r\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n}\r\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\r\n    for (const limboChange of limboChanges) {\r\n        if (limboChange instanceof AddedLimboDocument) {\r\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\r\n            trackLimboChange(syncEngineImpl, limboChange);\r\n        }\r\n        else if (limboChange instanceof RemovedLimboDocument) {\r\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\r\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboChange.key);\r\n            }\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n}\r\nfunction trackLimboChange(syncEngineImpl, limboChange) {\r\n    const key = limboChange.key;\r\n    const keyString = key.path.canonicalString();\r\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\r\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\r\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\r\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n}\r\n/**\r\n * Starts listens for documents in limbo that are enqueued for resolution,\r\n * subject to a maximum number of concurrent resolutions.\r\n *\r\n * Without bounding the number of concurrent resolutions, the server can fail\r\n * with \"resource exhausted\" errors which can lead to pathological client\r\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\r\n */\r\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\r\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\r\n        syncEngineImpl.activeLimboTargetsByKey.size <\r\n            syncEngineImpl.maxConcurrentLimboResolutions) {\r\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\r\n            .values()\r\n            .next().value;\r\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\r\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\r\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\r\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\r\n    }\r\n}\r\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const newSnaps = [];\r\n    const docChangesInAllViews = [];\r\n    const queriesProcessed = [];\r\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\r\n        // Return early since `onWatchChange()` might not have been assigned yet.\r\n        return;\r\n    }\r\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\r\n        queriesProcessed.push(syncEngineImpl\r\n            .applyDocChanges(queryView, changes, remoteEvent)\r\n            .then(viewSnapshot => {\r\n            // If there are changes, or we are handling a global snapshot, notify\r\n            // secondary clients to update query state.\r\n            if (viewSnapshot || remoteEvent) {\r\n                if (syncEngineImpl.isPrimaryClient) {\r\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, (viewSnapshot === null || viewSnapshot === void 0 ? void 0 : viewSnapshot.fromCache) ? 'not-current' : 'current');\r\n                }\r\n            }\r\n            // Update views if there are actual changes.\r\n            if (!!viewSnapshot) {\r\n                newSnaps.push(viewSnapshot);\r\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\r\n                docChangesInAllViews.push(docChanges);\r\n            }\r\n        }));\r\n    });\r\n    await Promise.all(queriesProcessed);\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\r\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\r\n}\r\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\r\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\r\n    if (viewDocChanges.needsRefill) {\r\n        // The query has a limit and some docs were removed, so we need\r\n        // to re-run the query against the local store to make sure we\r\n        // didn't lose any good docs that had been past the limit.\r\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n        /* usePreviousResults= */ false).then(({ documents }) => {\r\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\r\n        });\r\n    }\r\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\r\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\r\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \r\n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\r\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\r\n    return viewChange.snapshot;\r\n}\r\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\r\n    if (userChanged) {\r\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\r\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\r\n        syncEngineImpl.currentUser = user;\r\n        // Fails tasks waiting for pending writes requested by previous user.\r\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\r\n        // TODO(b/114226417): Consider calling this only in the primary tab.\r\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\r\n    }\r\n}\r\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    if (limboResolution && limboResolution.receivedDocument) {\r\n        return documentKeySet().add(limboResolution.key);\r\n    }\r\n    else {\r\n        let keySet = documentKeySet();\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (!queries) {\r\n            return keySet;\r\n        }\r\n        for (const query of queries) {\r\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\r\n        }\r\n        return keySet;\r\n    }\r\n}\r\n/**\r\n * Reconcile the list of synced documents in an existing view with those\r\n * from persistence.\r\n */\r\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n    /* usePreviousResults= */ true);\r\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Retrieves newly changed documents from remote document cache and raises\r\n * snapshots if needed.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\r\n}\r\n/** Applies a mutation state to an existing batch.  */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\r\n    if (documents === null) {\r\n        // A throttled tab may not have seen the mutation before it was completed\r\n        // and removed from the mutation queue, in which case we won't have cached\r\n        // the affected documents. In this case we can safely ignore the update\r\n        // since that means we didn't apply the mutation locally at all (if we\r\n        // had, we would have cached the affected documents), and so we will just\r\n        // see any resulting document changes via normal remote document updates\r\n        // as applicable.\r\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\r\n        return;\r\n    }\r\n    if (batchState === 'pending') {\r\n        // If we are the primary client, we need to send this write to the\r\n        // backend. Secondary clients will ignore these writes since their remote\r\n        // connection is disabled.\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\r\n        // NOTE: Both these methods are no-ops for batches that originated from\r\n        // other clients.\r\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    ensureWatchCallbacks(syncEngineImpl);\r\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\r\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\r\n        // Secondary tabs only maintain Views for their local listeners and the\r\n        // Views internal state may not be 100% populated (in particular\r\n        // secondary tabs don't track syncedDocuments, the set of documents the\r\n        // server considers to be in the target). So when a secondary becomes\r\n        // primary, we need to need to make sure that all views for all targets\r\n        // match the state on disk.\r\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\r\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\r\n        syncEngineImpl._isPrimaryClient = true;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\r\n        for (const targetData of activeQueries) {\r\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n        }\r\n    }\r\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\r\n        const activeTargets = [];\r\n        let p = Promise.resolve();\r\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\r\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\r\n                activeTargets.push(targetId);\r\n            }\r\n            else {\r\n                p = p.then(() => {\r\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\r\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                    /*keepPersistedTargetData=*/ true);\r\n                });\r\n            }\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n        });\r\n        await p;\r\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\r\n        resetLimboDocuments(syncEngineImpl);\r\n        syncEngineImpl._isPrimaryClient = false;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\r\n    }\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction resetLimboDocuments(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\r\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n    });\r\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\r\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\r\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * Reconcile the query views of the provided query targets with the state from\r\n * persistence. Raises snapshots for any changes that affect the local\r\n * client and returns the updated state of all target's query data.\r\n *\r\n * @param syncEngine - The sync engine implementation\r\n * @param targets - the list of targets with views that need to be recomputed\r\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\r\n * tab to a primary tab\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const activeQueries = [];\r\n    const newViewSnapshots = [];\r\n    for (const targetId of targets) {\r\n        let targetData;\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (queries && queries.length !== 0) {\r\n            // For queries that have a local View, we fetch their current state\r\n            // from LocalStore (as the resume token and the snapshot version\r\n            // might have changed) and reconcile their views with the persisted\r\n            // state (the list of syncedDocuments may have gotten out of sync).\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\r\n            for (const query of queries) {\r\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\r\n                if (viewChange.snapshot) {\r\n                    newViewSnapshots.push(viewChange.snapshot);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For queries that never executed on this client, we need to\r\n            // allocate the target in LocalStore and initialize a new View.\r\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \r\n            /*current=*/ false, targetData.resumeToken);\r\n        }\r\n        activeQueries.push(targetData);\r\n    }\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n    return activeQueries;\r\n}\r\n/**\r\n * Creates a `Query` object from the specified `Target`. There is no way to\r\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\r\n * object.\r\n *\r\n * The synthesized result might be different from the original `Query`, but\r\n * since the synthesized `Query` should return the same results as the\r\n * original one (only the presentation of results might differ), the potential\r\n * difference will not cause issues.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction synthesizeTargetToQuery(target) {\r\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\r\n}\r\n/** Returns the IDs of the clients that are currently active. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction syncEngineGetActiveClients(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (syncEngineImpl._isPrimaryClient) {\r\n        // If we receive a target state notification via WebStorage, we are\r\n        // either already secondary or another tab has taken the primary lease.\r\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\r\n        return;\r\n    }\r\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\r\n    if (query && query.length > 0) {\r\n        switch (state) {\r\n            case 'current':\r\n            case 'not-current': {\r\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\r\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\r\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\r\n                break;\r\n            }\r\n            case 'rejected': {\r\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                /* keepPersistedTargetData */ true);\r\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\r\n                break;\r\n            }\r\n            default:\r\n                fail();\r\n        }\r\n    }\r\n}\r\n/** Adds or removes Watch targets for queries from different tabs. */\r\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    if (!syncEngineImpl._isPrimaryClient) {\r\n        return;\r\n    }\r\n    for (const targetId of added) {\r\n        // A target is already listening to remote store if it is already registered to\r\n        // sharedClientState.\r\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\r\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\r\n        if (targetAlreadyListeningToRemoteStore) {\r\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\r\n            continue;\r\n        }\r\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \r\n        /*current=*/ false, targetData.resumeToken);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n    }\r\n    for (const targetId of removed) {\r\n        // Check that the target is still active since the target might have been\r\n        // removed if it has been rejected by the backend.\r\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\r\n            continue;\r\n        }\r\n        // Release queries that are still active.\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => {\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n            removeAndCleanupTarget(syncEngineImpl, targetId);\r\n        })\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nfunction ensureWatchCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\r\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\r\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\r\n        syncEngineRejectListen.bind(null, syncEngineImpl);\r\n    syncEngineImpl.syncEngineListener.onWatchChange =\r\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\r\n    syncEngineImpl.syncEngineListener.onWatchError =\r\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\r\n    return syncEngineImpl;\r\n}\r\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\r\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\r\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\r\n    return syncEngineImpl;\r\n}\r\n/**\r\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\r\n * the bundle finished loading.\r\n *\r\n * @param syncEngine - SyncEngine to use.\r\n * @param bundleReader - Bundle to load into the SDK.\r\n * @param task - LoadBundleTask used to update the loading progress to public API.\r\n */\r\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\r\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\r\n    });\r\n}\r\n/** Loads a bundle and returns the list of affected collection groups. */\r\nasync function loadBundleImpl(syncEngine, reader, task) {\r\n    try {\r\n        const metadata = await reader.getMetadata();\r\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\r\n        if (skip) {\r\n            await reader.close();\r\n            task._completeWith(bundleSuccessProgress(metadata));\r\n            return Promise.resolve(new Set());\r\n        }\r\n        task._updateProgress(bundleInitialProgress(metadata));\r\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\r\n        let element = await reader.nextElement();\r\n        while (element) {\r\n            ;\r\n            const progress = await loader.addSizedElement(element);\r\n            if (progress) {\r\n                task._updateProgress(progress);\r\n            }\r\n            element = await reader.nextElement();\r\n        }\r\n        const result = await loader.complete();\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \r\n        /* remoteEvent */ undefined);\r\n        // Save metadata, so loading the same bundle will skip.\r\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\r\n        task._completeWith(result.progress);\r\n        return Promise.resolve(result.changedCollectionGroups);\r\n    }\r\n    catch (e) {\r\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\r\n        task._failWith(e);\r\n        return Promise.resolve(new Set());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides all components needed for Firestore with in-memory persistence.\r\n * Uses EagerGC garbage collection.\r\n */\r\nclass MemoryOfflineComponentProvider {\r\n    constructor() {\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        this.sharedClientState = this.createSharedClientState(cfg);\r\n        this.persistence = this.createPersistence(cfg);\r\n        await this.persistence.start();\r\n        this.localStore = this.createLocalStore(cfg);\r\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\r\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        return null;\r\n    }\r\n    createIndexBackfillerScheduler(cfg, localStore) {\r\n        return null;\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createPersistence(cfg) {\r\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n    async terminate() {\r\n        var _a, _b;\r\n        (_a = this.gcScheduler) === null || _a === void 0 ? void 0 : _a.stop();\r\n        (_b = this.indexBackfillerScheduler) === null || _b === void 0 ? void 0 : _b.stop();\r\n        this.sharedClientState.shutdown();\r\n        await this.persistence.shutdown();\r\n    }\r\n}\r\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\r\n    constructor(cacheSizeBytes) {\r\n        super();\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate);\r\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\r\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\r\n    }\r\n    createPersistence(cfg) {\r\n        const lruParams = this.cacheSizeBytes !== undefined\r\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\r\n            : LruParams.DEFAULT;\r\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with IndexedDB persistence.\r\n */\r\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\r\n        super();\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.forceOwnership = forceOwnership;\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        await this.onlineComponentProvider.initialize(this, cfg);\r\n        // Enqueue writes from a previous session\r\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\r\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(() => {\r\n            if (this.gcScheduler && !this.gcScheduler.started) {\r\n                this.gcScheduler.start();\r\n            }\r\n            if (this.indexBackfillerScheduler &&\r\n                !this.indexBackfillerScheduler.started) {\r\n                this.indexBackfillerScheduler.start();\r\n            }\r\n            return Promise.resolve();\r\n        });\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createGarbageCollectionScheduler(cfg, localStore) {\r\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\r\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\r\n    }\r\n    createIndexBackfillerScheduler(cfg, localStore) {\r\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\r\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\r\n    }\r\n    createPersistence(cfg) {\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        const lruParams = this.cacheSizeBytes !== undefined\r\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\r\n            : LruParams.DEFAULT;\r\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with multi-tab IndexedDB\r\n * persistence.\r\n *\r\n * In the legacy client, this provider is used to provide both multi-tab and\r\n * non-multi-tab persistence since we cannot tell at build time whether\r\n * `synchronizeTabs` will be enabled.\r\n */\r\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes) {\r\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.synchronizeTabs = true;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        const syncEngine = this.onlineComponentProvider.syncEngine;\r\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\r\n            this.sharedClientState.syncEngine = {\r\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\r\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\r\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\r\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\r\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\r\n            };\r\n            await this.sharedClientState.start();\r\n        }\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\r\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\r\n            if (this.gcScheduler) {\r\n                if (isPrimary && !this.gcScheduler.started) {\r\n                    this.gcScheduler.start();\r\n                }\r\n                else if (!isPrimary) {\r\n                    this.gcScheduler.stop();\r\n                }\r\n            }\r\n            if (this.indexBackfillerScheduler) {\r\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\r\n                    this.indexBackfillerScheduler.start();\r\n                }\r\n                else if (!isPrimary) {\r\n                    this.indexBackfillerScheduler.stop();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    createSharedClientState(cfg) {\r\n        const window = getWindow();\r\n        if (!WebStorageSharedClientState.isAvailable(window)) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\r\n        }\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\r\n    }\r\n}\r\n/**\r\n * Initializes and wires the components that are needed to interface with the\r\n * network.\r\n */\r\nclass OnlineComponentProvider {\r\n    async initialize(offlineComponentProvider, cfg) {\r\n        if (this.localStore) {\r\n            // OnlineComponentProvider may get initialized multiple times if\r\n            // multi-tab persistence is used.\r\n            return;\r\n        }\r\n        this.localStore = offlineComponentProvider.localStore;\r\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\r\n        this.datastore = this.createDatastore(cfg);\r\n        this.remoteStore = this.createRemoteStore(cfg);\r\n        this.eventManager = this.createEventManager(cfg);\r\n        this.syncEngine = this.createSyncEngine(cfg, \r\n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\r\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\r\n        this.remoteStore.remoteSyncer.handleCredentialChange =\r\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\r\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\r\n    }\r\n    createEventManager(cfg) {\r\n        return newEventManager();\r\n    }\r\n    createDatastore(cfg) {\r\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        const connection = newConnection(cfg.databaseInfo);\r\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\r\n    }\r\n    createRemoteStore(cfg) {\r\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\r\n    }\r\n    createSyncEngine(cfg, startAsPrimary) {\r\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\r\n    }\r\n    async terminate() {\r\n        var _a;\r\n        await remoteStoreShutdown(this.remoteStore);\r\n        (_a = this.datastore) === null || _a === void 0 ? void 0 : _a.terminate();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * How many bytes to read each time when `ReadableStreamReader.read()` is\r\n * called. Only applicable for byte streams that we control (e.g. those backed\r\n * by an UInt8Array).\r\n */\r\nconst DEFAULT_BYTES_PER_READ = 10240;\r\n/**\r\n * Builds a `ByteStreamReader` from a UInt8Array.\r\n * @param source - The data source to use.\r\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\r\n *        will read.\r\n */\r\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\r\n    let readFrom = 0;\r\n    // The TypeScript definition for ReadableStreamReader changed. We use\r\n    // `any` here to allow this code to compile with different versions.\r\n    // See https://github.com/microsoft/TypeScript/issues/42970\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const reader = {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        async read() {\r\n            if (readFrom < source.byteLength) {\r\n                const result = {\r\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\r\n                    done: false\r\n                };\r\n                readFrom += bytesPerRead;\r\n                return result;\r\n            }\r\n            return { done: true };\r\n        },\r\n        async cancel() { },\r\n        releaseLock() { },\r\n        closed: Promise.resolve()\r\n    };\r\n    return reader;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\r\n    if (!argument) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that two boolean options are not set at the same time.\r\n * @internal\r\n */\r\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\r\n    if (argument1 === true && argument2 === true) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a document (indicated by the fact it contains\r\n * an even numbers of segments).\r\n */\r\nfunction validateDocumentPath(path) {\r\n    if (!DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a collection (indicated by the fact it\r\n * contains an odd numbers of segments).\r\n */\r\nfunction validateCollectionPath(path) {\r\n    if (DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Returns true if it's a non-null object without a custom prototype\r\n * (i.e. excludes Array, Date, etc.).\r\n */\r\nfunction isPlainObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        (Object.getPrototypeOf(input) === Object.prototype ||\r\n            Object.getPrototypeOf(input) === null));\r\n}\r\n/** Returns a string describing the type / value of the provided input. */\r\nfunction valueDescription(input) {\r\n    if (input === undefined) {\r\n        return 'undefined';\r\n    }\r\n    else if (input === null) {\r\n        return 'null';\r\n    }\r\n    else if (typeof input === 'string') {\r\n        if (input.length > 20) {\r\n            input = `${input.substring(0, 20)}...`;\r\n        }\r\n        return JSON.stringify(input);\r\n    }\r\n    else if (typeof input === 'number' || typeof input === 'boolean') {\r\n        return '' + input;\r\n    }\r\n    else if (typeof input === 'object') {\r\n        if (input instanceof Array) {\r\n            return 'an array';\r\n        }\r\n        else {\r\n            const customObjectName = tryGetCustomObjectType(input);\r\n            if (customObjectName) {\r\n                return `a custom ${customObjectName} object`;\r\n            }\r\n            else {\r\n                return 'an object';\r\n            }\r\n        }\r\n    }\r\n    else if (typeof input === 'function') {\r\n        return 'a function';\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** try to get the constructor name for an object. */\r\nfunction tryGetCustomObjectType(input) {\r\n    if (input.constructor) {\r\n        return input.constructor.name;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\r\n * underlying instance. Throws if  `obj` is not an instance of `T`.\r\n *\r\n * This cast is used in the Lite and Full SDK to verify instance types for\r\n * arguments passed to the public API.\r\n * @internal\r\n */\r\nfunction cast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    if ('_delegate' in obj) {\r\n        // Unwrap Compat types\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        obj = obj._delegate;\r\n    }\r\n    if (!(obj instanceof constructor)) {\r\n        if (constructor.name === obj.constructor.name) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\r\n                `reference from a different Firestore SDK?`);\r\n        }\r\n        else {\r\n            const description = valueDescription(obj);\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction validatePositiveNumber(functionName, n) {\r\n    if (n <= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * On Node, only supported data source is a `Uint8Array` for now.\r\n */\r\nfunction toByteStreamReader(source, bytesPerRead) {\r\n    if (!(source instanceof Uint8Array)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\r\n    }\r\n    return toByteStreamReaderHelper(source, bytesPerRead);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * A wrapper implementation of Observer<T> that will dispatch events\r\n * asynchronously. To allow immediate silencing, a mute call is added which\r\n * causes events scheduled to no longer be raised.\r\n */\r\nclass AsyncObserver {\r\n    constructor(observer) {\r\n        this.observer = observer;\r\n        /**\r\n         * When set to true, will not raise future events. Necessary to deal with\r\n         * async detachment of listener.\r\n         */\r\n        this.muted = false;\r\n    }\r\n    next(value) {\r\n        if (this.observer.next) {\r\n            this.scheduleEvent(this.observer.next, value);\r\n        }\r\n    }\r\n    error(error) {\r\n        if (this.observer.error) {\r\n            this.scheduleEvent(this.observer.error, error);\r\n        }\r\n        else {\r\n            logError('Uncaught Error in snapshot listener:', error.toString());\r\n        }\r\n    }\r\n    mute() {\r\n        this.muted = true;\r\n    }\r\n    scheduleEvent(eventHandler, event) {\r\n        if (!this.muted) {\r\n            setTimeout(() => {\r\n                if (!this.muted) {\r\n                    eventHandler(event);\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A complete element in the bundle stream, together with the byte length it\r\n * occupies in the stream.\r\n */\r\nclass SizedBundleElement {\r\n    constructor(payload, \r\n    // How many bytes this element takes to store in the bundle.\r\n    byteLength) {\r\n        this.payload = payload;\r\n        this.byteLength = byteLength;\r\n    }\r\n    isBundleMetadata() {\r\n        return 'metadata' in this.payload;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class representing a bundle.\r\n *\r\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\r\n * elements out of the underlying content.\r\n */\r\nclass BundleReaderImpl {\r\n    constructor(\r\n    /** The reader to read from underlying binary bundle data source. */\r\n    reader, serializer) {\r\n        this.reader = reader;\r\n        this.serializer = serializer;\r\n        /** Cached bundle metadata. */\r\n        this.metadata = new Deferred();\r\n        /**\r\n         * Internal buffer to hold bundle content, accumulating incomplete element\r\n         * content.\r\n         */\r\n        this.buffer = new Uint8Array();\r\n        this.textDecoder = newTextDecoder();\r\n        // Read the metadata (which is the first element).\r\n        this.nextElementImpl().then(element => {\r\n            if (element && element.isBundleMetadata()) {\r\n                this.metadata.resolve(element.payload.metadata);\r\n            }\r\n            else {\r\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\r\n            }\r\n        }, error => this.metadata.reject(error));\r\n    }\r\n    close() {\r\n        return this.reader.cancel();\r\n    }\r\n    async getMetadata() {\r\n        return this.metadata.promise;\r\n    }\r\n    async nextElement() {\r\n        // Makes sure metadata is read before proceeding.\r\n        await this.getMetadata();\r\n        return this.nextElementImpl();\r\n    }\r\n    /**\r\n     * Reads from the head of internal buffer, and pulling more data from\r\n     * underlying stream if a complete element cannot be found, until an\r\n     * element(including the prefixed length and the JSON string) is found.\r\n     *\r\n     * Once a complete element is read, it is dropped from internal buffer.\r\n     *\r\n     * Returns either the bundled element, or null if we have reached the end of\r\n     * the stream.\r\n     */\r\n    async nextElementImpl() {\r\n        const lengthBuffer = await this.readLength();\r\n        if (lengthBuffer === null) {\r\n            return null;\r\n        }\r\n        const lengthString = this.textDecoder.decode(lengthBuffer);\r\n        const length = Number(lengthString);\r\n        if (isNaN(length)) {\r\n            this.raiseError(`length string (${lengthString}) is not valid number`);\r\n        }\r\n        const jsonString = await this.readJsonString(length);\r\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\r\n    }\r\n    /** First index of '{' from the underlying buffer. */\r\n    indexOfOpenBracket() {\r\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\r\n    }\r\n    /**\r\n     * Reads from the beginning of the internal buffer, until the first '{', and\r\n     * return the content.\r\n     *\r\n     * If reached end of the stream, returns a null.\r\n     */\r\n    async readLength() {\r\n        while (this.indexOfOpenBracket() < 0) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                break;\r\n            }\r\n        }\r\n        // Broke out of the loop because underlying stream is closed, and there\r\n        // happens to be no more data to process.\r\n        if (this.buffer.length === 0) {\r\n            return null;\r\n        }\r\n        const position = this.indexOfOpenBracket();\r\n        // Broke out of the loop because underlying stream is closed, but still\r\n        // cannot find an open bracket.\r\n        if (position < 0) {\r\n            this.raiseError('Reached the end of bundle when a length string is expected.');\r\n        }\r\n        const result = this.buffer.slice(0, position);\r\n        // Update the internal buffer to drop the read length.\r\n        this.buffer = this.buffer.slice(position);\r\n        return result;\r\n    }\r\n    /**\r\n     * Reads from a specified position from the internal buffer, for a specified\r\n     * number of bytes, pulling more data from the underlying stream if needed.\r\n     *\r\n     * Returns a string decoded from the read bytes.\r\n     */\r\n    async readJsonString(length) {\r\n        while (this.buffer.length < length) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                this.raiseError('Reached the end of bundle when more is expected.');\r\n            }\r\n        }\r\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\r\n        // Update the internal buffer to drop the read json string.\r\n        this.buffer = this.buffer.slice(length);\r\n        return result;\r\n    }\r\n    raiseError(message) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.reader.cancel();\r\n        throw new Error(`Invalid bundle format: ${message}`);\r\n    }\r\n    /**\r\n     * Pulls more data from underlying stream to internal buffer.\r\n     * Returns a boolean indicating whether the stream is finished.\r\n     */\r\n    async pullMoreDataToBuffer() {\r\n        const result = await this.reader.read();\r\n        if (!result.done) {\r\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\r\n            newBuffer.set(this.buffer);\r\n            newBuffer.set(result.value, this.buffer.length);\r\n            this.buffer = newBuffer;\r\n        }\r\n        return result.done;\r\n    }\r\n}\r\nfunction newBundleReader(reader, serializer) {\r\n    return new BundleReaderImpl(reader, serializer);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Internal transaction object responsible for accumulating the mutations to\r\n * perform and the base versions for any documents read.\r\n */\r\nclass Transaction$2 {\r\n    constructor(datastore) {\r\n        this.datastore = datastore;\r\n        // The version of each document that was read during this transaction.\r\n        this.readVersions = new Map();\r\n        this.mutations = [];\r\n        this.committed = false;\r\n        /**\r\n         * A deferred usage error that occurred previously in this transaction that\r\n         * will cause the transaction to fail once it actually commits.\r\n         */\r\n        this.lastTransactionError = null;\r\n        /**\r\n         * Set of documents that have been written in the transaction.\r\n         *\r\n         * When there's more than one write to the same key in a transaction, any\r\n         * writes after the first are handled differently.\r\n         */\r\n        this.writtenDocs = new Set();\r\n    }\r\n    async lookup(keys) {\r\n        this.ensureCommitNotCalled();\r\n        if (this.mutations.length > 0) {\r\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\r\n            throw this.lastTransactionError;\r\n        }\r\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\r\n        docs.forEach(doc => this.recordVersion(doc));\r\n        return docs;\r\n    }\r\n    set(key, data) {\r\n        this.write(data.toMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    update(key, data) {\r\n        try {\r\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\r\n        }\r\n        catch (e) {\r\n            this.lastTransactionError = e;\r\n        }\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    delete(key) {\r\n        this.write(new DeleteMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    async commit() {\r\n        this.ensureCommitNotCalled();\r\n        if (this.lastTransactionError) {\r\n            throw this.lastTransactionError;\r\n        }\r\n        const unwritten = this.readVersions;\r\n        // For each mutation, note that the doc was written.\r\n        this.mutations.forEach(mutation => {\r\n            unwritten.delete(mutation.key.toString());\r\n        });\r\n        // For each document that was read but not written to, we want to perform\r\n        // a `verify` operation.\r\n        unwritten.forEach((_, path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\r\n        });\r\n        await invokeCommitRpc(this.datastore, this.mutations);\r\n        this.committed = true;\r\n    }\r\n    recordVersion(doc) {\r\n        let docVersion;\r\n        if (doc.isFoundDocument()) {\r\n            docVersion = doc.version;\r\n        }\r\n        else if (doc.isNoDocument()) {\r\n            // Represent a deleted doc using SnapshotVersion.min().\r\n            docVersion = SnapshotVersion.min();\r\n        }\r\n        else {\r\n            throw fail();\r\n        }\r\n        const existingVersion = this.readVersions.get(doc.key.toString());\r\n        if (existingVersion) {\r\n            if (!docVersion.isEqual(existingVersion)) {\r\n                // This transaction will fail no matter what.\r\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\r\n            }\r\n        }\r\n        else {\r\n            this.readVersions.set(doc.key.toString(), docVersion);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the version of this document when it was read in this transaction,\r\n     * as a precondition, or no precondition if it was not read.\r\n     */\r\n    precondition(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            if (version.isEqual(SnapshotVersion.min())) {\r\n                return Precondition.exists(false);\r\n            }\r\n            else {\r\n                return Precondition.updateTime(version);\r\n            }\r\n        }\r\n        else {\r\n            return Precondition.none();\r\n        }\r\n    }\r\n    /**\r\n     * Returns the precondition for a document if the operation is an update.\r\n     */\r\n    preconditionForUpdate(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        // The first time a document is written, we want to take into account the\r\n        // read time and existence\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            if (version.isEqual(SnapshotVersion.min())) {\r\n                // The document doesn't exist, so fail the transaction.\r\n                // This has to be validated locally because you can't send a\r\n                // precondition that a document does not exist without changing the\r\n                // semantics of the backend write to be an insert. This is the reverse\r\n                // of what we want, since we want to assert that the document doesn't\r\n                // exist but then send the update and have it fail. Since we can't\r\n                // express that to the backend, we have to validate locally.\r\n                // Note: this can change once we can send separate verify writes in the\r\n                // transaction.\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\r\n            }\r\n            // Document exists, base precondition on document update time.\r\n            return Precondition.updateTime(version);\r\n        }\r\n        else {\r\n            // Document was not read, so we just use the preconditions for a blind\r\n            // update.\r\n            return Precondition.exists(true);\r\n        }\r\n    }\r\n    write(mutation) {\r\n        this.ensureCommitNotCalled();\r\n        this.mutations.push(mutation);\r\n    }\r\n    ensureCommitNotCalled() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * TransactionRunner encapsulates the logic needed to run and retry transactions\r\n * with backoff.\r\n */\r\nclass TransactionRunner {\r\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.datastore = datastore;\r\n        this.options = options;\r\n        this.updateFunction = updateFunction;\r\n        this.deferred = deferred;\r\n        this.attemptsRemaining = options.maxAttempts;\r\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\r\n    }\r\n    /** Runs the transaction and sets the result on deferred. */\r\n    run() {\r\n        this.attemptsRemaining -= 1;\r\n        this.runWithBackOff();\r\n    }\r\n    runWithBackOff() {\r\n        this.backoff.backoffAndRun(async () => {\r\n            const transaction = new Transaction$2(this.datastore);\r\n            const userPromise = this.tryRunUpdateFunction(transaction);\r\n            if (userPromise) {\r\n                userPromise\r\n                    .then(result => {\r\n                    this.asyncQueue.enqueueAndForget(() => {\r\n                        return transaction\r\n                            .commit()\r\n                            .then(() => {\r\n                            this.deferred.resolve(result);\r\n                        })\r\n                            .catch(commitError => {\r\n                            this.handleTransactionError(commitError);\r\n                        });\r\n                    });\r\n                })\r\n                    .catch(userPromiseError => {\r\n                    this.handleTransactionError(userPromiseError);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    tryRunUpdateFunction(transaction) {\r\n        try {\r\n            const userPromise = this.updateFunction(transaction);\r\n            if (isNullOrUndefined(userPromise) ||\r\n                !userPromise.catch ||\r\n                !userPromise.then) {\r\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\r\n                return null;\r\n            }\r\n            return userPromise;\r\n        }\r\n        catch (error) {\r\n            // Do not retry errors thrown by user provided updateFunction.\r\n            this.deferred.reject(error);\r\n            return null;\r\n        }\r\n    }\r\n    handleTransactionError(error) {\r\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\r\n            this.attemptsRemaining -= 1;\r\n            this.asyncQueue.enqueueAndForget(() => {\r\n                this.runWithBackOff();\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n        else {\r\n            this.deferred.reject(error);\r\n        }\r\n    }\r\n    isRetryableTransactionError(error) {\r\n        if (error.name === 'FirebaseError') {\r\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\r\n            // non-matching document versions with ABORTED. These errors should be retried.\r\n            const code = error.code;\r\n            return (code === 'aborted' ||\r\n                code === 'failed-precondition' ||\r\n                code === 'already-exists' ||\r\n                !isPermanentError(code));\r\n        }\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$2 = 'FirestoreClient';\r\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\r\n/** DOMException error code constants. */\r\nconst DOM_EXCEPTION_INVALID_STATE = 11;\r\nconst DOM_EXCEPTION_ABORTED = 20;\r\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\r\n/**\r\n * FirestoreClient is a top-level class that constructs and owns all of the //\r\n * pieces of the client SDK architecture. It is responsible for creating the //\r\n * async queue that is shared by all of the other components in the system. //\r\n */\r\nclass FirestoreClient {\r\n    constructor(authCredentials, appCheckCredentials, \r\n    /**\r\n     * Asynchronous queue responsible for all of our internal processing. When\r\n     * we get incoming work from the user (via public API) or the network\r\n     * (incoming GRPC messages), we should always schedule onto this queue.\r\n     * This ensures all of our work is properly serialized (e.g. we don't\r\n     * start processing a new operation while the previous one is waiting for\r\n     * an async I/O to complete).\r\n     */\r\n    asyncQueue, databaseInfo) {\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.asyncQueue = asyncQueue;\r\n        this.databaseInfo = databaseInfo;\r\n        this.user = User.UNAUTHENTICATED;\r\n        this.clientId = AutoId.newId();\r\n        this.authCredentialListener = () => Promise.resolve();\r\n        this.appCheckCredentialListener = () => Promise.resolve();\r\n        this.authCredentials.start(asyncQueue, async (user) => {\r\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\r\n            await this.authCredentialListener(user);\r\n            this.user = user;\r\n        });\r\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\r\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\r\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\r\n        });\r\n    }\r\n    get configuration() {\r\n        return {\r\n            asyncQueue: this.asyncQueue,\r\n            databaseInfo: this.databaseInfo,\r\n            clientId: this.clientId,\r\n            authCredentials: this.authCredentials,\r\n            appCheckCredentials: this.appCheckCredentials,\r\n            initialUser: this.user,\r\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\r\n        };\r\n    }\r\n    setCredentialChangeListener(listener) {\r\n        this.authCredentialListener = listener;\r\n    }\r\n    setAppCheckTokenChangeListener(listener) {\r\n        this.appCheckCredentialListener = listener;\r\n    }\r\n    /**\r\n     * Checks that the client has not been terminated. Ensures that other methods on //\r\n     * this class cannot be called after the client is terminated. //\r\n     */\r\n    verifyNotTerminated() {\r\n        if (this.asyncQueue.isShuttingDown) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    terminate() {\r\n        this.asyncQueue.enterRestrictedMode();\r\n        const deferred = new Deferred();\r\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n            try {\r\n                if (this._onlineComponents) {\r\n                    await this._onlineComponents.terminate();\r\n                }\r\n                if (this._offlineComponents) {\r\n                    await this._offlineComponents.terminate();\r\n                }\r\n                // The credentials provider must be terminated after shutting down the\r\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\r\n                // tokens.\r\n                this.authCredentials.shutdown();\r\n                this.appCheckCredentials.shutdown();\r\n                deferred.resolve();\r\n            }\r\n            catch (e) {\r\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\r\n                deferred.reject(firestoreError);\r\n            }\r\n        });\r\n        return deferred.promise;\r\n    }\r\n}\r\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\r\n    const configuration = client.configuration;\r\n    await offlineComponentProvider.initialize(configuration);\r\n    let currentUser = configuration.initialUser;\r\n    client.setCredentialChangeListener(async (user) => {\r\n        if (!currentUser.isEqual(user)) {\r\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\r\n            currentUser = user;\r\n        }\r\n    });\r\n    // When a user calls clearPersistence() in one client, all other clients\r\n    // need to be terminated to allow the delete to succeed.\r\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\r\n    client._offlineComponents = offlineComponentProvider;\r\n}\r\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    const offlineComponentProvider = await ensureOfflineComponents(client);\r\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\r\n    await onlineComponentProvider.initialize(offlineComponentProvider, client.configuration);\r\n    // The CredentialChangeListener of the online component provider takes\r\n    // precedence over the offline component provider.\r\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client._onlineComponents = onlineComponentProvider;\r\n}\r\n/**\r\n * Decides whether the provided error allows us to gracefully disable\r\n * persistence (as opposed to crashing the client).\r\n */\r\nfunction canFallbackFromIndexedDbError(error) {\r\n    if (error.name === 'FirebaseError') {\r\n        return (error.code === Code.FAILED_PRECONDITION ||\r\n            error.code === Code.UNIMPLEMENTED);\r\n    }\r\n    else if (typeof DOMException !== 'undefined' &&\r\n        error instanceof DOMException) {\r\n        // There are a few known circumstances where we can open IndexedDb but\r\n        // trying to read/write will fail (e.g. quota exceeded). For\r\n        // well-understood cases, we attempt to detect these and then gracefully\r\n        // fall back to memory persistence.\r\n        // NOTE: Rather than continue to add to this list, we could decide to\r\n        // always fall back, with the risk that we might accidentally hide errors\r\n        // representing actual SDK bugs.\r\n        return (\r\n        // When the browser is out of quota we could get either quota exceeded\r\n        // or an aborted error depending on whether the error happened during\r\n        // schema migration.\r\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\r\n            error.code === DOM_EXCEPTION_ABORTED ||\r\n            // Firefox Private Browsing mode disables IndexedDb and returns\r\n            // INVALID_STATE for any usage.\r\n            error.code === DOM_EXCEPTION_INVALID_STATE);\r\n    }\r\n    return true;\r\n}\r\nasync function ensureOfflineComponents(client) {\r\n    if (!client._offlineComponents) {\r\n        if (client._uninitializedComponentsProvider) {\r\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\r\n            try {\r\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\r\n            }\r\n            catch (e) {\r\n                const error = e;\r\n                if (!canFallbackFromIndexedDbError(error)) {\r\n                    throw error;\r\n                }\r\n                logWarn('Error using user provided cache. Falling back to ' +\r\n                    'memory cache: ' +\r\n                    error);\r\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\r\n            }\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\r\n            await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\r\n        }\r\n    }\r\n    return client._offlineComponents;\r\n}\r\nasync function ensureOnlineComponents(client) {\r\n    if (!client._onlineComponents) {\r\n        if (client._uninitializedComponentsProvider) {\r\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\r\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\r\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\r\n        }\r\n    }\r\n    return client._onlineComponents;\r\n}\r\nfunction getPersistence(client) {\r\n    return ensureOfflineComponents(client).then(c => c.persistence);\r\n}\r\nfunction getLocalStore(client) {\r\n    return ensureOfflineComponents(client).then(c => c.localStore);\r\n}\r\nfunction getRemoteStore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\r\n}\r\nfunction getSyncEngine(client) {\r\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\r\n}\r\nfunction getDatastore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.datastore);\r\n}\r\nasync function getEventManager(client) {\r\n    const onlineComponentProvider = await ensureOnlineComponents(client);\r\n    const eventManager = onlineComponentProvider.eventManager;\r\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\r\n    return eventManager;\r\n}\r\n/** Enables the network connection and re-enqueues all pending operations. */\r\nfunction firestoreClientEnableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(true);\r\n        return remoteStoreEnableNetwork(remoteStore);\r\n    });\r\n}\r\n/** Disables the network connection. Pending operations will not complete. */\r\nfunction firestoreClientDisableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(false);\r\n        return remoteStoreDisableNetwork(remoteStore);\r\n    });\r\n}\r\n/**\r\n * Returns a Promise that resolves when all writes that were pending at the time\r\n * this method was called received server acknowledgement. An acknowledgement\r\n * can be either acceptance or rejection.\r\n */\r\nfunction firestoreClientWaitForPendingWrites(client) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientListen(client, query, options, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    const listener = new QueryListener(query, wrappedObserver, options);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return eventManagerListen(eventManager, listener);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return eventManagerUnlisten(eventManager, listener);\r\n        });\r\n    };\r\n}\r\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return readDocumentFromCache(localStore, docKey, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return executeQueryFromCache(localStore, query, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\r\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\r\n        // above\r\n        try {\r\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\r\n            const datastore = await getDatastore(client);\r\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\r\n        }\r\n        catch (e) {\r\n            deferred.reject(e);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientWrite(client, mutations) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineWrite(syncEngine, mutations, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n        });\r\n    };\r\n}\r\n/**\r\n * Takes an updateFunction in which a set of reads and writes can be performed\r\n * atomically. In the updateFunction, the client can read and write values\r\n * using the supplied transaction object. After the updateFunction, all\r\n * changes will be committed. If a retryable error occurs (ex: some other\r\n * client has changed any of the data referenced), then the updateFunction\r\n * will be called again after a backoff. If the updateFunction still fails\r\n * after all retries, then the transaction will be rejected.\r\n *\r\n * The transaction object passed to the updateFunction contains methods for\r\n * accessing documents and collections. Unlike other datastore access, data\r\n * accessed with the transaction will not reflect local changes that have not\r\n * been committed. For this reason, it is required that all reads are\r\n * performed before any writes. Transactions must be performed while online.\r\n */\r\nfunction firestoreClientTransaction(client, updateFunction, options) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const datastore = await getDatastore(client);\r\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\r\n    });\r\n    return deferred.promise;\r\n}\r\nasync function readDocumentFromCache(localStore, docKey, result) {\r\n    try {\r\n        const document = await localStoreReadDocument(localStore, docKey);\r\n        if (document.isFoundDocument()) {\r\n            result.resolve(document);\r\n        }\r\n        else if (document.isNoDocument()) {\r\n            result.resolve(null);\r\n        }\r\n        else {\r\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\r\n                \"exist on the server. Run again without setting 'source' in \" +\r\n                'the GetOptions to attempt to retrieve the document from the ' +\r\n                'server.)'));\r\n        }\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated document from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: (snap) => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            const exists = snap.docs.has(key);\r\n            if (!exists && snap.fromCache) {\r\n                // TODO(dimond): If we're online and the document doesn't\r\n                // exist then we resolve with a doc.exists set to false. If\r\n                // we're offline however, we reject the Promise in this\r\n                // case. Two options: 1) Cache the negative response from\r\n                // the server so we can deliver that even when you're\r\n                // offline 2) Actually reject the Promise in the online case\r\n                // if the document doesn't exist.\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\r\n            }\r\n            else if (exists &&\r\n                snap.fromCache &&\r\n                options &&\r\n                options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\r\n                    'document does exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached document.)'));\r\n            }\r\n            else {\r\n                result.resolve(snap);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nasync function executeQueryFromCache(localStore, query, result) {\r\n    try {\r\n        const queryResult = await localStoreExecuteQuery(localStore, query, \r\n        /* usePreviousResults= */ true);\r\n        const view = new View(query, queryResult.remoteKeys);\r\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n        const viewChange = view.applyChanges(viewDocChanges, \r\n        /* limboResolutionEnabled= */ false);\r\n        result.resolve(viewChange.snapshot);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated query snapshot from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: snapshot => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            if (snapshot.fromCache && options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\r\n                    'documents may exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached documents.)'));\r\n            }\r\n            else {\r\n                result.resolve(snapshot);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(query, wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\r\n    const reader = createBundleReader(data, newSerializer(databaseId));\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\r\n    });\r\n}\r\nfunction firestoreClientGetNamedQuery(client, queryName) {\r\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\r\n}\r\nfunction createBundleReader(data, serializer) {\r\n    let content;\r\n    if (typeof data === 'string') {\r\n        content = newTextEncoder().encode(data);\r\n    }\r\n    else {\r\n        content = data;\r\n    }\r\n    return newBundleReader(toByteStreamReader(content), serializer);\r\n}\r\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\r\n    });\r\n}\r\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\r\n    });\r\n}\r\nfunction firestoreClientDeleteAllFieldIndexes(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\r\n */\r\nfunction longPollingOptionsEqual(options1, options2) {\r\n    return options1.timeoutSeconds === options2.timeoutSeconds;\r\n}\r\n/**\r\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\r\n * option values as the given instance.\r\n */\r\nfunction cloneLongPollingOptions(options) {\r\n    const clone = {};\r\n    if (options.timeoutSeconds !== undefined) {\r\n        clone.timeoutSeconds = options.timeoutSeconds;\r\n    }\r\n    return clone;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$1 = 'ComponentProvider';\r\n/**\r\n * An instance map that ensures only one Datastore exists per Firestore\r\n * instance.\r\n */\r\nconst datastoreInstances = new Map();\r\n/**\r\n * Removes all components associated with the provided instance. Must be called\r\n * when the `Firestore` instance is terminated.\r\n */\r\nfunction removeComponents(firestore) {\r\n    const datastore = datastoreInstances.get(firestore);\r\n    if (datastore) {\r\n        logDebug(LOG_TAG$1, 'Removing Datastore');\r\n        datastoreInstances.delete(firestore);\r\n        datastore.terminate();\r\n    }\r\n}\r\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\r\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// settings() defaults:\r\nconst DEFAULT_HOST = 'firestore.googleapis.com';\r\nconst DEFAULT_SSL = true;\r\n// The minimum long-polling timeout is hardcoded on the server. The value here\r\n// should be kept in sync with the value used by the server, as the server will\r\n// silently ignore a value below the minimum and fall back to the default.\r\n// Googlers see b/266868871 for relevant discussion.\r\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\r\n// No maximum long-polling timeout is configured in the server, and defaults to\r\n// 30 seconds, which is what Watch appears to use.\r\n// Googlers see b/266868871 for relevant discussion.\r\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\r\n// Whether long-polling auto-detected is enabled by default.\r\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\r\n/**\r\n * A concrete type describing all the values that can be applied via a\r\n * user-supplied `FirestoreSettings` object. This is a separate type so that\r\n * defaults can be supplied and the value can be checked for equality.\r\n */\r\nclass FirestoreSettingsImpl {\r\n    constructor(settings) {\r\n        var _a, _b;\r\n        if (settings.host === undefined) {\r\n            if (settings.ssl !== undefined) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\r\n            }\r\n            this.host = DEFAULT_HOST;\r\n            this.ssl = DEFAULT_SSL;\r\n        }\r\n        else {\r\n            this.host = settings.host;\r\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\r\n        }\r\n        this.credentials = settings.credentials;\r\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\r\n        this.localCache = settings.localCache;\r\n        if (settings.cacheSizeBytes === undefined) {\r\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\r\n        }\r\n        else {\r\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\r\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n            }\r\n            else {\r\n                this.cacheSizeBytes = settings.cacheSizeBytes;\r\n            }\r\n        }\r\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\r\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\r\n        if (this.experimentalForceLongPolling) {\r\n            this.experimentalAutoDetectLongPolling = false;\r\n        }\r\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\r\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\r\n        }\r\n        else {\r\n            // For backwards compatibility, coerce the value to boolean even though\r\n            // the TypeScript compiler has narrowed the type to boolean already.\r\n            // noinspection PointlessBooleanExpressionJS\r\n            this.experimentalAutoDetectLongPolling =\r\n                !!settings.experimentalAutoDetectLongPolling;\r\n        }\r\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\r\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\r\n        this.useFetchStreams = !!settings.useFetchStreams;\r\n    }\r\n    isEqual(other) {\r\n        return (this.host === other.host &&\r\n            this.ssl === other.ssl &&\r\n            this.credentials === other.credentials &&\r\n            this.cacheSizeBytes === other.cacheSizeBytes &&\r\n            this.experimentalForceLongPolling ===\r\n                other.experimentalForceLongPolling &&\r\n            this.experimentalAutoDetectLongPolling ===\r\n                other.experimentalAutoDetectLongPolling &&\r\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\r\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\r\n            this.useFetchStreams === other.useFetchStreams);\r\n    }\r\n}\r\nfunction validateLongPollingOptions(options) {\r\n    if (options.timeoutSeconds !== undefined) {\r\n        if (isNaN(options.timeoutSeconds)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\r\n                `${options.timeoutSeconds} (must not be NaN)`);\r\n        }\r\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\r\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\r\n        }\r\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\r\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\r\n */\r\nclass Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\r\n        this._authCredentials = _authCredentials;\r\n        this._appCheckCredentials = _appCheckCredentials;\r\n        this._databaseId = _databaseId;\r\n        this._app = _app;\r\n        /**\r\n         * Whether it's a Firestore or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore-lite';\r\n        this._persistenceKey = '(lite)';\r\n        this._settings = new FirestoreSettingsImpl({});\r\n        this._settingsFrozen = false;\r\n    }\r\n    /**\r\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\r\n     * instance.\r\n     */\r\n    get app() {\r\n        if (!this._app) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\r\n                'not available');\r\n        }\r\n        return this._app;\r\n    }\r\n    get _initialized() {\r\n        return this._settingsFrozen;\r\n    }\r\n    get _terminated() {\r\n        return this._terminateTask !== undefined;\r\n    }\r\n    _setSettings(settings) {\r\n        if (this._settingsFrozen) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\r\n                'be changed. You can only modify settings before calling any other ' +\r\n                'methods on a Firestore object.');\r\n        }\r\n        this._settings = new FirestoreSettingsImpl(settings);\r\n        if (settings.credentials !== undefined) {\r\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\r\n        }\r\n    }\r\n    _getSettings() {\r\n        return this._settings;\r\n    }\r\n    _freezeSettings() {\r\n        this._settingsFrozen = true;\r\n        return this._settings;\r\n    }\r\n    _delete() {\r\n        if (!this._terminateTask) {\r\n            this._terminateTask = this._terminate();\r\n        }\r\n        return this._terminateTask;\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\r\n    toJSON() {\r\n        return {\r\n            app: this._app,\r\n            databaseId: this._databaseId,\r\n            settings: this._settings\r\n        };\r\n    }\r\n    /**\r\n     * Terminates all components used by this client. Subclasses can override\r\n     * this method to clean up their own dependencies, but must also call this\r\n     * method.\r\n     *\r\n     * Only ever called once.\r\n     */\r\n    _terminate() {\r\n        removeComponents(this);\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Firestore emulator.\r\n *\r\n * Note: This must be called before this instance has been used to do any\r\n * operations.\r\n *\r\n * @param firestore - The `Firestore` instance to configure to connect to the\r\n * emulator.\r\n * @param host - the emulator host (ex: localhost).\r\n * @param port - the emulator port (ex: 9000).\r\n * @param options.mockUserToken - the mock auth token to use for unit testing\r\n * Security Rules.\r\n */\r\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore$1);\r\n    const settings = firestore._getSettings();\r\n    const newHostSetting = `${host}:${port}`;\r\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\r\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\r\n            'will be used.');\r\n    }\r\n    firestore._setSettings(Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: false }));\r\n    if (options.mockUserToken) {\r\n        let token;\r\n        let user;\r\n        if (typeof options.mockUserToken === 'string') {\r\n            token = options.mockUserToken;\r\n            user = User.MOCK_USER;\r\n        }\r\n        else {\r\n            // Let createMockUserToken validate first (catches common mistakes like\r\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\r\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\r\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\r\n            if (!uid) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n            }\r\n            user = new User(uid);\r\n        }\r\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `Query` refers to a query which you can read or listen to. You can also\r\n * construct refined `Query` objects by adding filters and ordering.\r\n */\r\nclass Query {\r\n    // This is the lite version of the Query class in the main SDK.\r\n    /** @hideconstructor protected */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _query) {\r\n        this.converter = converter;\r\n        this._query = _query;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'query';\r\n        this.firestore = firestore;\r\n    }\r\n    withConverter(converter) {\r\n        return new Query(this.firestore, converter, this._query);\r\n    }\r\n}\r\n/**\r\n * A `DocumentReference` refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist.\r\n */\r\nclass DocumentReference {\r\n    /** @hideconstructor */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _key) {\r\n        this.converter = converter;\r\n        this._key = _key;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'document';\r\n        this.firestore = firestore;\r\n    }\r\n    get _path() {\r\n        return this._key.path;\r\n    }\r\n    /**\r\n     * The document's identifier within its collection.\r\n     */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._key.path.canonicalString();\r\n    }\r\n    /**\r\n     * The collection this `DocumentReference` belongs to.\r\n     */\r\n    get parent() {\r\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\r\n    }\r\n    withConverter(converter) {\r\n        return new DocumentReference(this.firestore, converter, this._key);\r\n    }\r\n}\r\n/**\r\n * A `CollectionReference` object can be used for adding documents, getting\r\n * document references, and querying for documents (using {@link (query:1)}).\r\n */\r\nclass CollectionReference extends Query {\r\n    /** @hideconstructor */\r\n    constructor(firestore, converter, _path) {\r\n        super(firestore, converter, newQueryForPath(_path));\r\n        this._path = _path;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'collection';\r\n    }\r\n    /** The collection's identifier. */\r\n    get id() {\r\n        return this._query.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._query.path.canonicalString();\r\n    }\r\n    /**\r\n     * A reference to the containing `DocumentReference` if this is a\r\n     * subcollection. If this isn't a subcollection, the reference is null.\r\n     */\r\n    get parent() {\r\n        const parentPath = this._path.popLast();\r\n        if (parentPath.isEmpty()) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new DocumentReference(this.firestore, \r\n            /* converter= */ null, new DocumentKey(parentPath));\r\n        }\r\n    }\r\n    withConverter(converter) {\r\n        return new CollectionReference(this.firestore, converter, this._path);\r\n    }\r\n}\r\nfunction collection(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    validateNonEmptyArgument('collection', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent.firestore, \r\n        /* converter= */ null, absolutePath);\r\n    }\r\n}\r\n// TODO(firestorelite): Consider using ErrorFactory -\r\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\r\n/**\r\n * Creates and returns a new `Query` instance that includes all documents in the\r\n * database that are contained in a collection or subcollection with the\r\n * given `collectionId`.\r\n *\r\n * @param firestore - A reference to the root `Firestore` instance.\r\n * @param collectionId - Identifies the collections to query over. Every\r\n * collection or subcollection with this ID as the last segment of its path\r\n * will be included. Cannot contain a slash.\r\n * @returns The created `Query`.\r\n */\r\nfunction collectionGroup(firestore, collectionId) {\r\n    firestore = cast(firestore, Firestore$1);\r\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\r\n    if (collectionId.indexOf('/') >= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\r\n            `collectionGroup(). Collection IDs must not contain '/'.`);\r\n    }\r\n    return new Query(firestore, \r\n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\r\n}\r\nfunction doc(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\r\n    // 'undefined' and 'null'.\r\n    if (arguments.length === 1) {\r\n        path = AutoId.newId();\r\n    }\r\n    validateNonEmptyArgument('doc', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent, \r\n        /* converter= */ null, new DocumentKey(absolutePath));\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\r\n    }\r\n}\r\n/**\r\n * Returns true if the provided references are equal.\r\n *\r\n * @param left - A reference to compare.\r\n * @param right - A reference to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction refEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if ((left instanceof DocumentReference ||\r\n        left instanceof CollectionReference) &&\r\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\r\n        return (left.firestore === right.firestore &&\r\n            left.path === right.path &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns true if the provided queries point to the same collection and apply\r\n * the same constraints.\r\n *\r\n * @param left - A `Query` to compare.\r\n * @param right - A `Query` to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction queryEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if (left instanceof Query && right instanceof Query) {\r\n        return (left.firestore === right.firestore &&\r\n            queryEquals(left._query, right._query) &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG = 'AsyncQueue';\r\nclass AsyncQueueImpl {\r\n    constructor() {\r\n        // The last promise in the queue.\r\n        this.tail = Promise.resolve();\r\n        // A list of retryable operations. Retryable operations are run in order and\r\n        // retried with backoff.\r\n        this.retryableOps = [];\r\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\r\n        // be changed again.\r\n        this._isShuttingDown = false;\r\n        // Operations scheduled to be queued in the future. Operations are\r\n        // automatically removed after they are run or canceled.\r\n        this.delayedOperations = [];\r\n        // visible for testing\r\n        this.failure = null;\r\n        // Flag set while there's an outstanding AsyncQueue operation, used for\r\n        // assertion sanity-checks.\r\n        this.operationInProgress = false;\r\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\r\n        this.skipNonRestrictedTasks = false;\r\n        // List of TimerIds to fast-forward delays for.\r\n        this.timerIdsToSkip = [];\r\n        // Backoff timer used to schedule retries for retryable operations\r\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\r\n        // Visibility handler that triggers an immediate retry of all retryable\r\n        // operations. Meant to speed up recovery when we regain file system access\r\n        // after page comes into foreground.\r\n        this.visibilityHandler = () => {\r\n            this.backoff.skipBackoff();\r\n        };\r\n    }\r\n    get isShuttingDown() {\r\n        return this._isShuttingDown;\r\n    }\r\n    /**\r\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\r\n     * we ignore the Promise result).\r\n     */\r\n    enqueueAndForget(op) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueue(op);\r\n    }\r\n    enqueueAndForgetEvenWhileRestricted(op) {\r\n        this.verifyNotFailed();\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueueInternal(op);\r\n    }\r\n    enterRestrictedMode(purgeExistingTasks) {\r\n        if (!this._isShuttingDown) {\r\n            this._isShuttingDown = true;\r\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\r\n        }\r\n    }\r\n    enqueue(op) {\r\n        this.verifyNotFailed();\r\n        if (this._isShuttingDown) {\r\n            // Return a Promise which never resolves.\r\n            return new Promise(() => { });\r\n        }\r\n        // Create a deferred Promise that we can return to the callee. This\r\n        // allows us to return a \"hanging Promise\" only to the callee and still\r\n        // advance the queue even when the operation is not run.\r\n        const task = new Deferred();\r\n        return this.enqueueInternal(() => {\r\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\r\n                // We do not resolve 'task'\r\n                return Promise.resolve();\r\n            }\r\n            op().then(task.resolve, task.reject);\r\n            return task.promise;\r\n        }).then(() => task.promise);\r\n    }\r\n    enqueueRetryable(op) {\r\n        this.enqueueAndForget(() => {\r\n            this.retryableOps.push(op);\r\n            return this.retryNextOp();\r\n        });\r\n    }\r\n    /**\r\n     * Runs the next operation from the retryable queue. If the operation fails,\r\n     * reschedules with backoff.\r\n     */\r\n    async retryNextOp() {\r\n        if (this.retryableOps.length === 0) {\r\n            return;\r\n        }\r\n        try {\r\n            await this.retryableOps[0]();\r\n            this.retryableOps.shift();\r\n            this.backoff.reset();\r\n        }\r\n        catch (e) {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\r\n            }\r\n            else {\r\n                throw e; // Failure will be handled by AsyncQueue\r\n            }\r\n        }\r\n        if (this.retryableOps.length > 0) {\r\n            // If there are additional operations, we re-schedule `retryNextOp()`.\r\n            // This is necessary to run retryable operations that failed during\r\n            // their initial attempt since we don't know whether they are already\r\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\r\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\r\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\r\n            // call scheduled here.\r\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\r\n            // new backoff on every call, there is only ever a single additional\r\n            // operation in the queue.\r\n            this.backoff.backoffAndRun(() => this.retryNextOp());\r\n        }\r\n    }\r\n    enqueueInternal(op) {\r\n        const newTail = this.tail.then(() => {\r\n            this.operationInProgress = true;\r\n            return op()\r\n                .catch((error) => {\r\n                this.failure = error;\r\n                this.operationInProgress = false;\r\n                const message = getMessageOrStack(error);\r\n                logError('INTERNAL UNHANDLED ERROR: ', message);\r\n                // Re-throw the error so that this.tail becomes a rejected Promise and\r\n                // all further attempts to chain (via .then) will just short-circuit\r\n                // and return the rejected Promise.\r\n                throw error;\r\n            })\r\n                .then(result => {\r\n                this.operationInProgress = false;\r\n                return result;\r\n            });\r\n        });\r\n        this.tail = newTail;\r\n        return newTail;\r\n    }\r\n    enqueueAfterDelay(timerId, delayMs, op) {\r\n        this.verifyNotFailed();\r\n        // Fast-forward delays for timerIds that have been overriden.\r\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\r\n            delayMs = 0;\r\n        }\r\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\r\n        this.delayedOperations.push(delayedOp);\r\n        return delayedOp;\r\n    }\r\n    verifyNotFailed() {\r\n        if (this.failure) {\r\n            fail();\r\n        }\r\n    }\r\n    verifyOperationInProgress() {\r\n    }\r\n    /**\r\n     * Waits until all currently queued tasks are finished executing. Delayed\r\n     * operations are not run.\r\n     */\r\n    async drain() {\r\n        // Operations in the queue prior to draining may have enqueued additional\r\n        // operations. Keep draining the queue until the tail is no longer advanced,\r\n        // which indicates that no more new operations were enqueued and that all\r\n        // operations were executed.\r\n        let currentTail;\r\n        do {\r\n            currentTail = this.tail;\r\n            await currentTail;\r\n        } while (currentTail !== this.tail);\r\n    }\r\n    /**\r\n     * For Tests: Determine if a delayed operation with a particular TimerId\r\n     * exists.\r\n     */\r\n    containsDelayedOperation(timerId) {\r\n        for (const op of this.delayedOperations) {\r\n            if (op.timerId === timerId) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * For Tests: Runs some or all delayed operations early.\r\n     *\r\n     * @param lastTimerId - Delayed operations up to and including this TimerId\r\n     * will be drained. Pass TimerId.All to run all delayed operations.\r\n     * @returns a Promise that resolves once all operations have been run.\r\n     */\r\n    runAllDelayedOperationsUntil(lastTimerId) {\r\n        // Note that draining may generate more delayed ops, so we do that first.\r\n        return this.drain().then(() => {\r\n            // Run ops in the same order they'd run if they ran naturally.\r\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\r\n            for (const op of this.delayedOperations) {\r\n                op.skipDelay();\r\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\r\n                    break;\r\n                }\r\n            }\r\n            return this.drain();\r\n        });\r\n    }\r\n    /**\r\n     * For Tests: Skip all subsequent delays for a timer id.\r\n     */\r\n    skipDelaysForTimerId(timerId) {\r\n        this.timerIdsToSkip.push(timerId);\r\n    }\r\n    /** Called once a DelayedOperation is run or canceled. */\r\n    removeDelayedOperation(op) {\r\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\r\n        const index = this.delayedOperations.indexOf(op);\r\n        this.delayedOperations.splice(index, 1);\r\n    }\r\n}\r\nfunction newAsyncQueue() {\r\n    return new AsyncQueueImpl();\r\n}\r\n/**\r\n * Chrome includes Error.message in Error.stack. Other browsers do not.\r\n * This returns expected output of message + stack when available.\r\n * @param error - Error or FirestoreError\r\n */\r\nfunction getMessageOrStack(error) {\r\n    let message = error.message || '';\r\n    if (error.stack) {\r\n        if (error.stack.includes(error.message)) {\r\n            message = error.stack;\r\n        }\r\n        else {\r\n            message = error.message + '\\n' + error.stack;\r\n        }\r\n    }\r\n    return message;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\r\n * loading, as well as task completion and error events.\r\n *\r\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\r\n */\r\nclass LoadBundleTask {\r\n    constructor() {\r\n        this._progressObserver = {};\r\n        this._taskCompletionResolver = new Deferred();\r\n        this._lastProgress = {\r\n            taskState: 'Running',\r\n            totalBytes: 0,\r\n            totalDocuments: 0,\r\n            bytesLoaded: 0,\r\n            documentsLoaded: 0\r\n        };\r\n    }\r\n    /**\r\n     * Registers functions to listen to bundle loading progress events.\r\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\r\n     *   each time a Firestore document is loaded from the bundle.\r\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\r\n     *   error, and there should be no more updates after this.\r\n     * @param complete - Called when the loading task is complete.\r\n     */\r\n    onProgress(next, error, complete) {\r\n        this._progressObserver = {\r\n            next,\r\n            error,\r\n            complete\r\n        };\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\r\n     *\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    catch(onRejected) {\r\n        return this._taskCompletionResolver.promise.catch(onRejected);\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\r\n     *\r\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\r\n     *   The update will always have its `taskState` set to `\"Success\"`.\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    then(onFulfilled, onRejected) {\r\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has completed, with a provided\r\n     * `LoadBundleTaskProgress` object.\r\n     *\r\n     * @private\r\n     */\r\n    _completeWith(progress) {\r\n        this._updateProgress(progress);\r\n        if (this._progressObserver.complete) {\r\n            this._progressObserver.complete();\r\n        }\r\n        this._taskCompletionResolver.resolve(progress);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has failed, with a provided\r\n     * `Error` as the reason.\r\n     *\r\n     * @private\r\n     */\r\n    _failWith(error) {\r\n        this._lastProgress.taskState = 'Error';\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(this._lastProgress);\r\n        }\r\n        if (this._progressObserver.error) {\r\n            this._progressObserver.error(error);\r\n        }\r\n        this._taskCompletionResolver.reject(error);\r\n    }\r\n    /**\r\n     * Notifies a progress update of loading a bundle.\r\n     * @param progress - The new progress.\r\n     *\r\n     * @private\r\n     */\r\n    _updateProgress(progress) {\r\n        this._lastProgress = progress;\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(progress);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Constant used to indicate the LRU garbage collection should be disabled.\r\n * Set this value as the `cacheSizeBytes` on the settings passed to the\r\n * {@link Firestore} instance.\r\n */\r\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\r\n */\r\nclass Firestore extends Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\r\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\r\n        /**\r\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore';\r\n        this._queue = newAsyncQueue();\r\n        this._persistenceKey = (app === null || app === void 0 ? void 0 : app.name) || '[DEFAULT]';\r\n    }\r\n    _terminate() {\r\n        if (!this._firestoreClient) {\r\n            // The client must be initialized to ensure that all subsequent API\r\n            // usage throws an exception.\r\n            configureFirestore(this);\r\n        }\r\n        return this._firestoreClient.terminate();\r\n    }\r\n}\r\n/**\r\n * Initializes a new instance of {@link Firestore} with the provided settings.\r\n * Can only be called before any other function, including\r\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\r\n * equivalent to calling {@link (getFirestore:1)}.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\r\n * be associated.\r\n * @param settings - A settings object to configure the {@link Firestore} instance.\r\n * @param databaseId - The name of the database.\r\n * @returns A newly initialized {@link Firestore} instance.\r\n */\r\nfunction initializeFirestore(app, settings, databaseId) {\r\n    if (!databaseId) {\r\n        databaseId = DEFAULT_DATABASE_NAME;\r\n    }\r\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\r\n    if (provider.isInitialized(databaseId)) {\r\n        const existingInstance = provider.getImmediate({\r\n            identifier: databaseId\r\n        });\r\n        const initialSettings = provider.getOptions(databaseId);\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\r\n                'different options. To avoid this error, call initializeFirestore() with the ' +\r\n                'same options as when it was originally called, or call getFirestore() to return the' +\r\n                ' already initialized instance.');\r\n        }\r\n    }\r\n    if (settings.cacheSizeBytes !== undefined &&\r\n        settings.localCache !== undefined) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\r\n            `be deprecated. Instead, specify the cache size in the cache object`);\r\n    }\r\n    if (settings.cacheSizeBytes !== undefined &&\r\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\r\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n    }\r\n    return provider.initialize({\r\n        options: settings,\r\n        instanceIdentifier: databaseId\r\n    });\r\n}\r\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\r\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\r\n    const databaseId = typeof appOrDatabaseId === 'string'\r\n        ? appOrDatabaseId\r\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\r\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\r\n        identifier: databaseId\r\n    });\r\n    if (!db._initialized) {\r\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)('firestore');\r\n        if (emulator) {\r\n            connectFirestoreEmulator(db, ...emulator);\r\n        }\r\n    }\r\n    return db;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction ensureFirestoreConfigured(firestore) {\r\n    if (!firestore._firestoreClient) {\r\n        configureFirestore(firestore);\r\n    }\r\n    firestore._firestoreClient.verifyNotTerminated();\r\n    return firestore._firestoreClient;\r\n}\r\nfunction configureFirestore(firestore) {\r\n    var _a, _b, _c;\r\n    const settings = firestore._freezeSettings();\r\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\r\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo);\r\n    if (((_b = settings.localCache) === null || _b === void 0 ? void 0 : _b._offlineComponentProvider) &&\r\n        ((_c = settings.localCache) === null || _c === void 0 ? void 0 : _c._onlineComponentProvider)) {\r\n        firestore._firestoreClient._uninitializedComponentsProvider = {\r\n            _offlineKind: settings.localCache.kind,\r\n            _offline: settings.localCache._offlineComponentProvider,\r\n            _online: settings.localCache._onlineComponentProvider\r\n        };\r\n    }\r\n}\r\n/**\r\n * Attempts to enable persistent storage, if possible.\r\n *\r\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\r\n * throw an exception. There are several reasons why this can fail, which can be\r\n * identified by the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab.\r\n *   * unimplemented: The browser is incompatible with the offline persistence\r\n *     implementation.\r\n *\r\n * Note that even after a failure, the {@link Firestore} instance will remain\r\n * usable, however offline persistence will be disabled.\r\n *\r\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\r\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\r\n * {@link clearIndexedDbPersistence}.\r\n *\r\n * Persistence cannot be used in a Node.js environment.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @param persistenceSettings - Optional settings object to configure\r\n * persistence.\r\n * @returns A `Promise` that represents successfully enabling persistent storage.\r\n * @deprecated This function will be removed in a future major release. Instead, set\r\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\r\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\r\n * is already specified will throw an exception.\r\n */\r\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (client._uninitializedComponentsProvider) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\r\n    }\r\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\r\n        'you can use `FirestoreSettings.cache` instead.');\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\r\n * across all tabs, all operations share access to local persistence, including\r\n * shared execution of queries and latency-compensated local document updates\r\n * across all connected instances.\r\n *\r\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\r\n * throw an exception. There are several reasons why this can fail, which can be\r\n * identified by the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab and\r\n *     multi-tab is not enabled.\r\n *   * unimplemented: The browser is incompatible with the offline persistence\r\n *     implementation.\r\n *\r\n * Note that even after a failure, the {@link Firestore} instance will remain\r\n * usable, however offline persistence will be disabled.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @returns A `Promise` that represents successfully enabling persistent\r\n * storage.\r\n * @deprecated This function will be removed in a future major release. Instead, set\r\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\r\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\r\n * is already specified will throw an exception.\r\n */\r\nfunction enableMultiTabIndexedDbPersistence(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (client._uninitializedComponentsProvider) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\r\n    }\r\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\r\n        'you can use `FirestoreSettings.cache` instead.');\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\r\n * If the operation fails with a recoverable error (see\r\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\r\n * but the client remains usable.\r\n */\r\nfunction setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {\r\n    const persistenceResult = new Deferred();\r\n    return client.asyncQueue\r\n        .enqueue(async () => {\r\n        try {\r\n            await setOfflineComponentProvider(client, offlineComponentProvider);\r\n            await setOnlineComponentProvider(client, onlineComponentProvider);\r\n            persistenceResult.resolve();\r\n        }\r\n        catch (e) {\r\n            const error = e;\r\n            if (!canFallbackFromIndexedDbError(error)) {\r\n                throw error;\r\n            }\r\n            logWarn('Error enabling indexeddb cache. Falling back to ' +\r\n                'memory cache: ' +\r\n                error);\r\n            persistenceResult.reject(error);\r\n        }\r\n    })\r\n        .then(() => persistenceResult.promise);\r\n}\r\n/**\r\n * Clears the persistent storage. This includes pending writes and cached\r\n * documents.\r\n *\r\n * Must be called while the {@link Firestore} instance is not started (after the app is\r\n * terminated or when the app is first initialized). On startup, this function\r\n * must be called before other functions (other than {@link\r\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\r\n * instance is still running, the promise will be rejected with the error code\r\n * of `failed-precondition`.\r\n *\r\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\r\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\r\n * dropping existing data but does not attempt to securely overwrite or\r\n * otherwise make cached data unrecoverable. For applications that are sensitive\r\n * to the disclosure of cached data in between user sessions, we strongly\r\n * recommend not enabling persistence at all.\r\n *\r\n * @param firestore - The {@link Firestore} instance to clear persistence for.\r\n * @returns A `Promise` that is resolved when the persistent storage is\r\n * cleared. Otherwise, the promise is rejected with an error.\r\n */\r\nfunction clearIndexedDbPersistence(firestore) {\r\n    if (firestore._initialized && !firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\r\n            'initialized or after it is terminated.');\r\n    }\r\n    const deferred = new Deferred();\r\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n        try {\r\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\r\n            deferred.resolve();\r\n        }\r\n        catch (e) {\r\n            deferred.reject(e);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Waits until all currently pending writes for the active user have been\r\n * acknowledged by the backend.\r\n *\r\n * The returned promise resolves immediately if there are no outstanding writes.\r\n * Otherwise, the promise waits for all previously issued writes (including\r\n * those written in a previous app session), but it does not wait for writes\r\n * that were added after the function is called. If you want to wait for\r\n * additional writes, call `waitForPendingWrites()` again.\r\n *\r\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\r\n * changes.\r\n *\r\n * @returns A `Promise` which resolves when all currently pending writes have been\r\n * acknowledged by the backend.\r\n */\r\nfunction waitForPendingWrites(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWaitForPendingWrites(client);\r\n}\r\n/**\r\n * Re-enables use of the network for this {@link Firestore} instance after a prior\r\n * call to {@link disableNetwork}.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been enabled.\r\n */\r\nfunction enableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientEnableNetwork(client);\r\n}\r\n/**\r\n * Disables network usage for this instance. It can be re-enabled via {@link\r\n * enableNetwork}. While the network is disabled, any snapshot listeners,\r\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\r\n * operations will be queued until the network is restored.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been disabled.\r\n */\r\nfunction disableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientDisableNetwork(client);\r\n}\r\n/**\r\n * Terminates the provided {@link Firestore} instance.\r\n *\r\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\r\n * may be used. Any other function will throw a `FirestoreError`.\r\n *\r\n * To restart after termination, create a new instance of FirebaseFirestore with\r\n * {@link (getFirestore:1)}.\r\n *\r\n * Termination does not cancel any pending writes, and any promises that are\r\n * awaiting a response from the server will not be resolved. If you have\r\n * persistence enabled, the next time you start this instance, it will resume\r\n * sending these writes to the server.\r\n *\r\n * Note: Under normal circumstances, calling `terminate()` is not required. This\r\n * function is useful only when you want to force this instance to release all\r\n * of its resources or in combination with `clearIndexedDbPersistence()` to\r\n * ensure that all local state is destroyed between test runs.\r\n *\r\n * @returns A `Promise` that is resolved when the instance has been successfully\r\n * terminated.\r\n */\r\nfunction terminate(firestore) {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\r\n    return firestore._delete();\r\n}\r\n/**\r\n * Loads a Firestore bundle into the local cache.\r\n *\r\n * @param firestore - The {@link Firestore} instance to load bundles for.\r\n * @param bundleData - An object representing the bundle to be loaded. Valid\r\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\r\n *\r\n * @returns A `LoadBundleTask` object, which notifies callers with progress\r\n * updates, and completion or error events. It can be used as a\r\n * `Promise<LoadBundleTaskProgress>`.\r\n */\r\nfunction loadBundle(firestore, bundleData) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const resultTask = new LoadBundleTask();\r\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\r\n    return resultTask;\r\n}\r\n/**\r\n * Reads a Firestore {@link Query} from local cache, identified by the given\r\n * name.\r\n *\r\n * The named queries are packaged  into bundles on the server side (along\r\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\r\n * in local cache, use this method to extract a {@link Query} by name.\r\n *\r\n * @param firestore - The {@link Firestore} instance to read the query from.\r\n * @param name - The name of the query.\r\n * @returns A `Promise` that is resolved with the Query or `null`.\r\n */\r\nfunction namedQuery(firestore, name) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\r\n        if (!namedQuery) {\r\n            return null;\r\n        }\r\n        return new Query(firestore, null, namedQuery.query);\r\n    });\r\n}\r\nfunction verifyNotInitialized(firestore) {\r\n    if (firestore._initialized || firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\r\n            'enabled. You can only enable persistence before calling any other ' +\r\n            'methods on a Firestore object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerFirestore(variant, useFetchStreams = true) {\r\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const firestoreInstance = new Firestore(new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);\r\n        settings = Object.assign({ useFetchStreams }, settings);\r\n        firestoreInstance._setSettings(settings);\r\n        return firestoreInstance;\r\n    }, 'PUBLIC').setMultipleInstances(true));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Concrete implementation of the Aggregate type.\r\n */\r\nclass AggregateImpl {\r\n    constructor(alias, aggregateType, fieldPath) {\r\n        this.alias = alias;\r\n        this.aggregateType = aggregateType;\r\n        this.fieldPath = fieldPath;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents an aggregation that can be performed by Firestore.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nclass AggregateField {\r\n    /**\r\n     * Create a new AggregateField<T>\r\n     * @param aggregateType Specifies the type of aggregation operation to perform.\r\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\r\n     * @internal\r\n     */\r\n    constructor(aggregateType = 'count', _internalFieldPath) {\r\n        this._internalFieldPath = _internalFieldPath;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'AggregateField';\r\n        this.aggregateType = aggregateType;\r\n    }\r\n}\r\n/**\r\n * The results of executing an aggregation query.\r\n */\r\nclass AggregateQuerySnapshot {\r\n    /** @hideconstructor */\r\n    constructor(query, _userDataWriter, _data) {\r\n        this._userDataWriter = _userDataWriter;\r\n        this._data = _data;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'AggregateQuerySnapshot';\r\n        this.query = query;\r\n    }\r\n    /**\r\n     * Returns the results of the aggregations performed over the underlying\r\n     * query.\r\n     *\r\n     * The keys of the returned object will be the same as those of the\r\n     * `AggregateSpec` object specified to the aggregation method, and the values\r\n     * will be the corresponding aggregation result.\r\n     *\r\n     * @returns The results of the aggregations performed over the underlying\r\n     * query.\r\n     */\r\n    data() {\r\n        return this._userDataWriter.convertObjectMap(this._data);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing an array of bytes.\r\n */\r\nclass Bytes {\r\n    /** @hideconstructor */\r\n    constructor(byteString) {\r\n        this._byteString = byteString;\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\r\n     * bytes.\r\n     *\r\n     * @param base64 - The Base64 string used to create the `Bytes` object.\r\n     */\r\n    static fromBase64String(base64) {\r\n        try {\r\n            return new Bytes(ByteString.fromBase64String(base64));\r\n        }\r\n        catch (e) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Uint8Array.\r\n     *\r\n     * @param array - The Uint8Array used to create the `Bytes` object.\r\n     */\r\n    static fromUint8Array(array) {\r\n        return new Bytes(ByteString.fromUint8Array(array));\r\n    }\r\n    /**\r\n     * Returns the underlying bytes as a Base64-encoded string.\r\n     *\r\n     * @returns The Base64-encoded string created from the `Bytes` object.\r\n     */\r\n    toBase64() {\r\n        return this._byteString.toBase64();\r\n    }\r\n    /**\r\n     * Returns the underlying bytes in a new `Uint8Array`.\r\n     *\r\n     * @returns The Uint8Array created from the `Bytes` object.\r\n     */\r\n    toUint8Array() {\r\n        return this._byteString.toUint8Array();\r\n    }\r\n    /**\r\n     * Returns a string representation of the `Bytes` object.\r\n     *\r\n     * @returns A string representation of the `Bytes` object.\r\n     */\r\n    toString() {\r\n        return 'Bytes(base64: ' + this.toBase64() + ')';\r\n    }\r\n    /**\r\n     * Returns true if this `Bytes` object is equal to the provided one.\r\n     *\r\n     * @param other - The `Bytes` object to compare against.\r\n     * @returns true if this `Bytes` object is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._byteString.isEqual(other._byteString);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `FieldPath` refers to a field in a document. The path may consist of a\r\n * single field name (referring to a top-level field in the document), or a\r\n * list of field names (referring to a nested field in the document).\r\n *\r\n * Create a `FieldPath` by providing field names. If more than one field\r\n * name is provided, the path will point to a nested field in a document.\r\n */\r\nclass FieldPath {\r\n    /**\r\n     * Creates a `FieldPath` from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames - A list of field names.\r\n     */\r\n    constructor(...fieldNames) {\r\n        for (let i = 0; i < fieldNames.length; ++i) {\r\n            if (fieldNames[i].length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\r\n                    'Field names must not be empty.');\r\n            }\r\n        }\r\n        this._internalPath = new FieldPath$1(fieldNames);\r\n    }\r\n    /**\r\n     * Returns true if this `FieldPath` is equal to the provided one.\r\n     *\r\n     * @param other - The `FieldPath` to compare against.\r\n     * @returns true if this `FieldPath` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._internalPath.isEqual(other._internalPath);\r\n    }\r\n}\r\n/**\r\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\r\n * It can be used in queries to sort or filter by the document ID.\r\n */\r\nfunction documentId() {\r\n    return new FieldPath(DOCUMENT_KEY_NAME);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sentinel values that can be used when writing document fields with `set()`\r\n * or `update()`.\r\n */\r\nclass FieldValue {\r\n    /**\r\n     * @param _methodName - The public API endpoint that returns this class.\r\n     * @hideconstructor\r\n     */\r\n    constructor(_methodName) {\r\n        this._methodName = _methodName;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing a geographic location in Firestore. The\r\n * location is represented as latitude/longitude pair.\r\n *\r\n * Latitude values are in the range of [-90, 90].\r\n * Longitude values are in the range of [-180, 180].\r\n */\r\nclass GeoPoint {\r\n    /**\r\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\r\n     * longitude values.\r\n     * @param latitude - The latitude as number between -90 and 90.\r\n     * @param longitude - The longitude as number between -180 and 180.\r\n     */\r\n    constructor(latitude, longitude) {\r\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\r\n        }\r\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\r\n        }\r\n        this._lat = latitude;\r\n        this._long = longitude;\r\n    }\r\n    /**\r\n     * The latitude of this `GeoPoint` instance.\r\n     */\r\n    get latitude() {\r\n        return this._lat;\r\n    }\r\n    /**\r\n     * The longitude of this `GeoPoint` instance.\r\n     */\r\n    get longitude() {\r\n        return this._long;\r\n    }\r\n    /**\r\n     * Returns true if this `GeoPoint` is equal to the provided one.\r\n     *\r\n     * @param other - The `GeoPoint` to compare against.\r\n     * @returns true if this `GeoPoint` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._lat === other._lat && this._long === other._long;\r\n    }\r\n    /** Returns a JSON-serializable representation of this GeoPoint. */\r\n    toJSON() {\r\n        return { latitude: this._lat, longitude: this._long };\r\n    }\r\n    /**\r\n     * Actually private to JS consumers of our API, so this function is prefixed\r\n     * with an underscore.\r\n     */\r\n    _compareTo(other) {\r\n        return (primitiveComparator(this._lat, other._lat) ||\r\n            primitiveComparator(this._long, other._long));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\r\n/** The result of parsing document data (e.g. for a setData call). */\r\nclass ParsedSetData {\r\n    constructor(data, fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        if (this.fieldMask !== null) {\r\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\r\n        }\r\n    }\r\n}\r\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\r\nclass ParsedUpdateData {\r\n    constructor(data, \r\n    // The fieldMask does not include document transforms.\r\n    fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n    }\r\n}\r\nfunction isWrite(dataSource) {\r\n    switch (dataSource) {\r\n        case 0 /* UserDataSource.Set */: // fall through\r\n        case 2 /* UserDataSource.MergeSet */: // fall through\r\n        case 1 /* UserDataSource.Update */:\r\n            return true;\r\n        case 3 /* UserDataSource.Argument */:\r\n        case 4 /* UserDataSource.ArrayArgument */:\r\n            return false;\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\n/** A \"context\" object passed around while parsing user data. */\r\nclass ParseContextImpl {\r\n    /**\r\n     * Initializes a ParseContext with the given source and path.\r\n     *\r\n     * @param settings - The settings for the parser.\r\n     * @param databaseId - The database ID of the Firestore instance.\r\n     * @param serializer - The serializer to use to generate the Value proto.\r\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\r\n     * rather than throw.\r\n     * @param fieldTransforms - A mutable list of field transforms encountered\r\n     * while parsing the data.\r\n     * @param fieldMask - A mutable list of field paths encountered while parsing\r\n     * the data.\r\n     *\r\n     * TODO(b/34871131): We don't support array paths right now, so path can be\r\n     * null to indicate the context represents any location within an array (in\r\n     * which case certain features will not work and errors will be somewhat\r\n     * compromised).\r\n     */\r\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\r\n        this.settings = settings;\r\n        this.databaseId = databaseId;\r\n        this.serializer = serializer;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\r\n        // external call and we need to validate the entire path.\r\n        if (fieldTransforms === undefined) {\r\n            this.validatePath();\r\n        }\r\n        this.fieldTransforms = fieldTransforms || [];\r\n        this.fieldMask = fieldMask || [];\r\n    }\r\n    get path() {\r\n        return this.settings.path;\r\n    }\r\n    get dataSource() {\r\n        return this.settings.dataSource;\r\n    }\r\n    /** Returns a new context with the specified settings overwritten. */\r\n    contextWith(configuration) {\r\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\r\n    }\r\n    childContextForField(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePathSegment(field);\r\n        return context;\r\n    }\r\n    childContextForFieldPath(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePath();\r\n        return context;\r\n    }\r\n    childContextForArray(index) {\r\n        // TODO(b/34871131): We don't support array paths right now; so make path\r\n        // undefined.\r\n        return this.contextWith({ path: undefined, arrayElement: true });\r\n    }\r\n    createError(reason) {\r\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\r\n    }\r\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\r\n    contains(fieldPath) {\r\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\r\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\r\n    }\r\n    validatePath() {\r\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\r\n        // within arrays.\r\n        if (!this.path) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < this.path.length; i++) {\r\n            this.validatePathSegment(this.path.get(i));\r\n        }\r\n    }\r\n    validatePathSegment(segment) {\r\n        if (segment.length === 0) {\r\n            throw this.createError('Document fields must not be empty');\r\n        }\r\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\r\n            throw this.createError('Document fields cannot begin and end with \"__\"');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper for parsing raw user input (provided via the API) into internal model\r\n * classes.\r\n */\r\nclass UserDataReader {\r\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\r\n        this.databaseId = databaseId;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        this.serializer = serializer || newSerializer(databaseId);\r\n    }\r\n    /** Creates a new top-level parse context. */\r\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\r\n        return new ParseContextImpl({\r\n            dataSource,\r\n            methodName,\r\n            targetDoc,\r\n            path: FieldPath$1.emptyPath(),\r\n            arrayElement: false,\r\n            hasConverter\r\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\r\n    }\r\n}\r\nfunction newUserDataReader(firestore) {\r\n    const settings = firestore._freezeSettings();\r\n    const serializer = newSerializer(firestore._databaseId);\r\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\r\n}\r\n/** Parse document data from a set() call. */\r\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\r\n    const context = userDataReader.createContext(options.merge || options.mergeFields\r\n        ? 2 /* UserDataSource.MergeSet */\r\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const updateData = parseObject(input, context);\r\n    let fieldMask;\r\n    let fieldTransforms;\r\n    if (options.merge) {\r\n        fieldMask = new FieldMask(context.fieldMask);\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    else if (options.mergeFields) {\r\n        const validatedFieldPaths = [];\r\n        for (const stringOrFieldPath of options.mergeFields) {\r\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\r\n            if (!context.contains(fieldPath)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\r\n            }\r\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\r\n                validatedFieldPaths.push(fieldPath);\r\n            }\r\n        }\r\n        fieldMask = new FieldMask(validatedFieldPaths);\r\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\r\n    }\r\n    else {\r\n        fieldMask = null;\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\r\n}\r\nclass DeleteFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\r\n            // No transform to add for a delete, but we need to add it to our\r\n            // fieldMask so it gets deleted.\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\r\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\r\n                'of your update data');\r\n        }\r\n        else {\r\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\r\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\r\n                '{merge:true}');\r\n        }\r\n        return null;\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof DeleteFieldValueImpl;\r\n    }\r\n}\r\n/**\r\n * Creates a child context for parsing SerializableFieldValues.\r\n *\r\n * This is different than calling `ParseContext.contextWith` because it keeps\r\n * the fieldTransforms and fieldMask separate.\r\n *\r\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\r\n * Although these values are used with writes, any elements in these FieldValues\r\n * are not considered writes since they cannot contain any FieldValue sentinels,\r\n * etc.\r\n *\r\n * @param fieldValue - The sentinel FieldValue for which to create a child\r\n *     context.\r\n * @param context - The parent context.\r\n * @param arrayElement - Whether or not the FieldValue has an array.\r\n */\r\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\r\n    return new ParseContextImpl({\r\n        dataSource: 3 /* UserDataSource.Argument */,\r\n        targetDoc: context.settings.targetDoc,\r\n        methodName: fieldValue._methodName,\r\n        arrayElement\r\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\r\n}\r\nclass ServerTimestampFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        return new FieldTransform(context.path, new ServerTimestampTransform());\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof ServerTimestampFieldValueImpl;\r\n    }\r\n}\r\nclass ArrayUnionFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof ArrayUnionFieldValueImpl &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\r\n    }\r\n}\r\nclass ArrayRemoveFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof ArrayRemoveFieldValueImpl &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\r\n    }\r\n}\r\nclass NumericIncrementFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _operand) {\r\n        super(methodName);\r\n        this._operand = _operand;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\r\n        return new FieldTransform(context.path, numericIncrement);\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof NumericIncrementFieldValueImpl &&\r\n            this._operand === other._operand);\r\n    }\r\n}\r\n/** Parse update data from an update() call. */\r\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\r\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    forEach(input, (key, value) => {\r\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n        const childContext = context.childContextForFieldPath(path);\r\n        if (value instanceof DeleteFieldValueImpl) {\r\n            // Add it to the field mask, but don't add anything to updateData.\r\n            fieldMaskPaths.push(path);\r\n        }\r\n        else {\r\n            const parsedValue = parseData(value, childContext);\r\n            if (parsedValue != null) {\r\n                fieldMaskPaths.push(path);\r\n                updateData.set(path, parsedValue);\r\n            }\r\n        }\r\n    });\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/** Parse update data from a list of field/value arguments. */\r\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\r\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\r\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\r\n    const values = [value];\r\n    if (moreFieldsAndValues.length % 2 !== 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\r\n            'of arguments that alternate between field names and values.');\r\n    }\r\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\r\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\r\n        values.push(moreFieldsAndValues[i + 1]);\r\n    }\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    // We iterate in reverse order to pick the last value for a field if the\r\n    // user specified the field multiple times.\r\n    for (let i = keys.length - 1; i >= 0; --i) {\r\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\r\n            const path = keys[i];\r\n            let value = values[i];\r\n            // For Compat types, we have to \"extract\" the underlying types before\r\n            // performing validation.\r\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n            const childContext = context.childContextForFieldPath(path);\r\n            if (value instanceof DeleteFieldValueImpl) {\r\n                // Add it to the field mask, but don't add anything to updateData.\r\n                fieldMaskPaths.push(path);\r\n            }\r\n            else {\r\n                const parsedValue = parseData(value, childContext);\r\n                if (parsedValue != null) {\r\n                    fieldMaskPaths.push(path);\r\n                    updateData.set(path, parsedValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/**\r\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\r\n * bound).\r\n *\r\n * @param allowArrays - Whether the query value is an array that may directly\r\n * contain additional arrays (e.g. the operand of an `in` query).\r\n */\r\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\r\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\r\n    const parsed = parseData(input, context);\r\n    return parsed;\r\n}\r\n/**\r\n * Parses user data to Protobuf Values.\r\n *\r\n * @param input - Data to be parsed.\r\n * @param context - A context object representing the current path being parsed,\r\n * the source of the data being parsed, etc.\r\n * @returns The parsed value, or null if the value was a FieldValue sentinel\r\n * that should not be included in the resulting parsed data.\r\n */\r\nfunction parseData(input, context) {\r\n    // Unwrap the API type from the Compat SDK. This will return the API type\r\n    // from firestore-exp.\r\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\r\n    if (looksLikeJsonObject(input)) {\r\n        validatePlainObject('Unsupported field value:', context, input);\r\n        return parseObject(input, context);\r\n    }\r\n    else if (input instanceof FieldValue) {\r\n        // FieldValues usually parse into transforms (except deleteField())\r\n        // in which case we do not want to include this field in our parsed data\r\n        // (as doing so will overwrite the field directly prior to the transform\r\n        // trying to transform it). So we don't add this location to\r\n        // context.fieldMask and we return null as our parsing result.\r\n        parseSentinelFieldValue(input, context);\r\n        return null;\r\n    }\r\n    else if (input === undefined && context.ignoreUndefinedProperties) {\r\n        // If the input is undefined it can never participate in the fieldMask, so\r\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\r\n        // `parseScalarValue` will reject an undefined value.\r\n        return null;\r\n    }\r\n    else {\r\n        // If context.path is null we are inside an array and we don't support\r\n        // field mask paths more granular than the top-level array.\r\n        if (context.path) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        if (input instanceof Array) {\r\n            // TODO(b/34871131): Include the path containing the array in the error\r\n            // message.\r\n            // In the case of IN queries, the parsed data is an array (representing\r\n            // the set of values to be included for the IN query) that may directly\r\n            // contain additional arrays (each representing an individual field\r\n            // value), so we disable this validation.\r\n            if (context.settings.arrayElement &&\r\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\r\n                throw context.createError('Nested arrays are not supported');\r\n            }\r\n            return parseArray(input, context);\r\n        }\r\n        else {\r\n            return parseScalarValue(input, context);\r\n        }\r\n    }\r\n}\r\nfunction parseObject(obj, context) {\r\n    const fields = {};\r\n    if (isEmpty(obj)) {\r\n        // If we encounter an empty object, we explicitly add it to the update\r\n        // mask to ensure that the server creates a map entry.\r\n        if (context.path && context.path.length > 0) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n    }\r\n    else {\r\n        forEach(obj, (key, val) => {\r\n            const parsedValue = parseData(val, context.childContextForField(key));\r\n            if (parsedValue != null) {\r\n                fields[key] = parsedValue;\r\n            }\r\n        });\r\n    }\r\n    return { mapValue: { fields } };\r\n}\r\nfunction parseArray(array, context) {\r\n    const values = [];\r\n    let entryIndex = 0;\r\n    for (const entry of array) {\r\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\r\n        if (parsedEntry == null) {\r\n            // Just include nulls in the array for fields being replaced with a\r\n            // sentinel.\r\n            parsedEntry = { nullValue: 'NULL_VALUE' };\r\n        }\r\n        values.push(parsedEntry);\r\n        entryIndex++;\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\r\n * context.fieldTransforms.\r\n */\r\nfunction parseSentinelFieldValue(value, context) {\r\n    // Sentinels are only supported with writes, and not within arrays.\r\n    if (!isWrite(context.dataSource)) {\r\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\r\n    }\r\n    if (!context.path) {\r\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\r\n    }\r\n    const fieldTransform = value._toFieldTransform(context);\r\n    if (fieldTransform) {\r\n        context.fieldTransforms.push(fieldTransform);\r\n    }\r\n}\r\n/**\r\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\r\n *\r\n * @returns The parsed value\r\n */\r\nfunction parseScalarValue(value, context) {\r\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n    if (value === null) {\r\n        return { nullValue: 'NULL_VALUE' };\r\n    }\r\n    else if (typeof value === 'number') {\r\n        return toNumber(context.serializer, value);\r\n    }\r\n    else if (typeof value === 'boolean') {\r\n        return { booleanValue: value };\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return { stringValue: value };\r\n    }\r\n    else if (value instanceof Date) {\r\n        const timestamp = Timestamp.fromDate(value);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof Timestamp) {\r\n        // Firestore backend truncates precision down to microseconds. To ensure\r\n        // offline mode works the same with regards to truncation, perform the\r\n        // truncation immediately without waiting for the backend to do that.\r\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof GeoPoint) {\r\n        return {\r\n            geoPointValue: {\r\n                latitude: value.latitude,\r\n                longitude: value.longitude\r\n            }\r\n        };\r\n    }\r\n    else if (value instanceof Bytes) {\r\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\r\n    }\r\n    else if (value instanceof DocumentReference) {\r\n        const thisDb = context.databaseId;\r\n        const otherDb = value.firestore._databaseId;\r\n        if (!otherDb.isEqual(thisDb)) {\r\n            throw context.createError('Document reference is for database ' +\r\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\r\n                `for database ${thisDb.projectId}/${thisDb.database}`);\r\n        }\r\n        return {\r\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\r\n        };\r\n    }\r\n    else {\r\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\r\n    }\r\n}\r\n/**\r\n * Checks whether an object looks like a JSON object that should be converted\r\n * into a struct. Normal class/prototype instances are considered to look like\r\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\r\n * GeoPoints, etc. are not considered to look like JSON objects since they map\r\n * to specific FieldValue types other than ObjectValue.\r\n */\r\nfunction looksLikeJsonObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        !(input instanceof Array) &&\r\n        !(input instanceof Date) &&\r\n        !(input instanceof Timestamp) &&\r\n        !(input instanceof GeoPoint) &&\r\n        !(input instanceof Bytes) &&\r\n        !(input instanceof DocumentReference) &&\r\n        !(input instanceof FieldValue));\r\n}\r\nfunction validatePlainObject(message, context, input) {\r\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\r\n        const description = valueDescription(input);\r\n        if (description === 'an object') {\r\n            // Massage the error if it was an object.\r\n            throw context.createError(message + ' a custom object');\r\n        }\r\n        else {\r\n            throw context.createError(message + ' ' + description);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\r\n    // If required, replace the FieldPath Compat class with with the firestore-exp\r\n    // FieldPath.\r\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\r\n    if (path instanceof FieldPath) {\r\n        return path._internalPath;\r\n    }\r\n    else if (typeof path === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, path);\r\n    }\r\n    else {\r\n        const message = 'Field path arguments must be of type string or ';\r\n        throw createError(message, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\n/**\r\n * Matches any characters in a field path string that are reserved.\r\n */\r\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\r\n/**\r\n * Wraps fromDotSeparatedString with an error message about the method that\r\n * was thrown.\r\n * @param methodName - The publicly visible method name\r\n * @param path - The dot-separated string form of a field path which will be\r\n * split on dots.\r\n * @param targetDoc - The document against which the field path will be\r\n * evaluated.\r\n */\r\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\r\n    const found = path.search(FIELD_PATH_RESERVED);\r\n    if (found >= 0) {\r\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\r\n            `'~', '*', '/', '[', or ']'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n    try {\r\n        return new FieldPath(...path.split('.'))._internalPath;\r\n    }\r\n    catch (e) {\r\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\r\n            `begin with '.', end with '.', or contain '..'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\r\n    const hasPath = path && !path.isEmpty();\r\n    const hasDocument = targetDoc !== undefined;\r\n    let message = `Function ${methodName}() called with invalid data`;\r\n    if (hasConverter) {\r\n        message += ' (via `toFirestore()`)';\r\n    }\r\n    message += '. ';\r\n    let description = '';\r\n    if (hasPath || hasDocument) {\r\n        description += ' (found';\r\n        if (hasPath) {\r\n            description += ` in field ${path}`;\r\n        }\r\n        if (hasDocument) {\r\n            description += ` in document ${targetDoc}`;\r\n        }\r\n        description += ')';\r\n    }\r\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\r\n}\r\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\r\nfunction fieldMaskContains(haystack, needle) {\r\n    return haystack.some(v => v.isEqual(needle));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot$1 {\r\n    // Note: This class is stripped down version of the DocumentSnapshot in\r\n    // the legacy SDK. The changes are:\r\n    // - No support for SnapshotMetadata.\r\n    // - No support for SnapshotOptions.\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._key = _key;\r\n        this._document = _document;\r\n        this._converter = _converter;\r\n    }\r\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\r\n     */\r\n    get ref() {\r\n        return new DocumentReference(this._firestore, this._converter, this._key);\r\n    }\r\n    /**\r\n     * Signals whether or not the document at the snapshot's location exists.\r\n     *\r\n     * @returns true if the document exists.\r\n     */\r\n    exists() {\r\n        return this._document !== null;\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * @returns An `Object` containing all fields in the document or `undefined`\r\n     * if the document doesn't exist.\r\n     */\r\n    data() {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * @override\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data() {\r\n        return super.data();\r\n    }\r\n}\r\n/**\r\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument(methodName, arg) {\r\n    if (typeof arg === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, arg);\r\n    }\r\n    else if (arg instanceof FieldPath) {\r\n        return arg._internalPath;\r\n    }\r\n    else {\r\n        return arg._delegate._internalPath;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateHasExplicitOrderByForLimitToLast(query) {\r\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\r\n        query.explicitOrderBy.length === 0) {\r\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\r\n    }\r\n}\r\n/**\r\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\r\n * to a Firestore query.\r\n */\r\nclass AppliableConstraint {\r\n}\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\r\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\r\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\r\n * can then be passed to {@link (query:1)} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */\r\nclass QueryConstraint extends AppliableConstraint {\r\n}\r\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\r\n    let queryConstraints = [];\r\n    if (queryConstraint instanceof AppliableConstraint) {\r\n        queryConstraints.push(queryConstraint);\r\n    }\r\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\r\n    validateQueryConstraintArray(queryConstraints);\r\n    for (const constraint of queryConstraints) {\r\n        query = constraint._apply(query);\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\r\n * a Firestore query by filtering on one or more document fields.\r\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\r\n * be passed to {@link (query:1)} to create a new query instance that also contains\r\n * this `QueryFieldFilterConstraint`.\r\n */\r\nclass QueryFieldFilterConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(_field, _op, _value) {\r\n        super();\r\n        this._field = _field;\r\n        this._op = _op;\r\n        this._value = _value;\r\n        /** The type of this query constraint */\r\n        this.type = 'where';\r\n    }\r\n    static _create(_field, _op, _value) {\r\n        return new QueryFieldFilterConstraint(_field, _op, _value);\r\n    }\r\n    _apply(query) {\r\n        const filter = this._parse(query);\r\n        validateNewFieldFilter(query._query, filter);\r\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\r\n    }\r\n    _parse(query) {\r\n        const reader = newUserDataReader(query.firestore);\r\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\r\n        return filter;\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\r\n * must contain the specified field and that the value should satisfy the\r\n * relation constraint provided.\r\n *\r\n * @param fieldPath - The path to compare\r\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n *   \"&lt;=\", \"!=\").\r\n * @param value - The value for comparison\r\n * @returns The created {@link QueryFieldFilterConstraint}.\r\n */\r\nfunction where(fieldPath, opStr, value) {\r\n    const op = opStr;\r\n    const field = fieldPathFromArgument('where', fieldPath);\r\n    return QueryFieldFilterConstraint._create(field, op, value);\r\n}\r\n/**\r\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\r\n * returned by a Firestore query by performing the logical OR or AND of multiple\r\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\r\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\r\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains the `QueryCompositeFilterConstraint`.\r\n */\r\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _queryConstraints) {\r\n        super();\r\n        this.type = type;\r\n        this._queryConstraints = _queryConstraints;\r\n    }\r\n    static _create(type, _queryConstraints) {\r\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\r\n    }\r\n    _parse(query) {\r\n        const parsedFilters = this._queryConstraints\r\n            .map(queryConstraint => {\r\n            return queryConstraint._parse(query);\r\n        })\r\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\r\n        if (parsedFilters.length === 1) {\r\n            return parsedFilters[0];\r\n        }\r\n        return CompositeFilter.create(parsedFilters, this._getOperator());\r\n    }\r\n    _apply(query) {\r\n        const parsedFilter = this._parse(query);\r\n        if (parsedFilter.getFilters().length === 0) {\r\n            // Return the existing query if not adding any more filters (e.g. an empty\r\n            // composite filter).\r\n            return query;\r\n        }\r\n        validateNewFilter(query._query, parsedFilter);\r\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\r\n    }\r\n    _getQueryConstraints() {\r\n        return this._queryConstraints;\r\n    }\r\n    _getOperator() {\r\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\r\n    }\r\n}\r\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\r\n * the given filter constraints. A disjunction filter includes a document if it\r\n * satisfies any of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */\r\nfunction or(...queryConstraints) {\r\n    // Only support QueryFilterConstraints\r\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\r\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\r\n}\r\n/**\r\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\r\n * the given filter constraints. A conjunction filter includes a document if it\r\n * satisfies all of the given filters.\r\n *\r\n * @param queryConstraints - Optional. The list of\r\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\r\n * created with calls to {@link where}, {@link or}, or {@link and}.\r\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\r\n */\r\nfunction and(...queryConstraints) {\r\n    // Only support QueryFilterConstraints\r\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\r\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\r\n}\r\n/**\r\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\r\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\r\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\r\n * instance that also contains this `QueryOrderByConstraint`.\r\n *\r\n * Note: Documents that do not contain the orderBy field will not be present in\r\n * the query result.\r\n */\r\nclass QueryOrderByConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(_field, _direction) {\r\n        super();\r\n        this._field = _field;\r\n        this._direction = _direction;\r\n        /** The type of this query constraint */\r\n        this.type = 'orderBy';\r\n    }\r\n    static _create(_field, _direction) {\r\n        return new QueryOrderByConstraint(_field, _direction);\r\n    }\r\n    _apply(query) {\r\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\r\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\r\n * specified field, optionally in descending order instead of ascending.\r\n *\r\n * Note: Documents that do not contain the specified field will not be present\r\n * in the query result.\r\n *\r\n * @param fieldPath - The field to sort by.\r\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\r\n * not specified, order will be ascending.\r\n * @returns The created {@link QueryOrderByConstraint}.\r\n */\r\nfunction orderBy(fieldPath, directionStr = 'asc') {\r\n    const direction = directionStr;\r\n    const path = fieldPathFromArgument('orderBy', fieldPath);\r\n    return QueryOrderByConstraint._create(path, direction);\r\n}\r\n/**\r\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\r\n * a Firestore query.\r\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\r\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryLimitConstraint`.\r\n */\r\nclass QueryLimitConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _limit, _limitType) {\r\n        super();\r\n        this.type = type;\r\n        this._limit = _limit;\r\n        this._limitType = _limitType;\r\n    }\r\n    static _create(type, _limit, _limitType) {\r\n        return new QueryLimitConstraint(type, _limit, _limitType);\r\n    }\r\n    _apply(query) {\r\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\r\n * documents.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */\r\nfunction limit(limit) {\r\n    validatePositiveNumber('limit', limit);\r\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\r\n}\r\n/**\r\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\r\n * documents.\r\n *\r\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\r\n * otherwise an exception will be thrown during execution.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link QueryLimitConstraint}.\r\n */\r\nfunction limitToLast(limit) {\r\n    validatePositiveNumber('limitToLast', limit);\r\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\r\n}\r\n/**\r\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\r\n * result set returned by a Firestore query.\r\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\r\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\r\n * new query instance that also contains this `QueryStartAtConstraint`.\r\n */\r\nclass QueryStartAtConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    static _create(type, _docOrFields, _inclusive) {\r\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\r\n    }\r\n}\r\nfunction startAt(...docOrFields) {\r\n    return QueryStartAtConstraint._create('startAt', docOrFields, \r\n    /*inclusive=*/ true);\r\n}\r\nfunction startAfter(...docOrFields) {\r\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\n/**\r\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\r\n * result set returned by a Firestore query.\r\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\r\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\r\n * query instance that also contains this `QueryEndAtConstraint`.\r\n */\r\nclass QueryEndAtConstraint extends QueryConstraint {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The type of this query constraint */\r\n    type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    static _create(type, _docOrFields, _inclusive) {\r\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\r\n    }\r\n}\r\nfunction endBefore(...docOrFields) {\r\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\nfunction endAt(...docOrFields) {\r\n    return QueryEndAtConstraint._create('endAt', docOrFields, \r\n    /*inclusive=*/ true);\r\n}\r\n/** Helper function to create a bound from a document or fields */\r\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\r\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\r\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\r\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\r\n    }\r\n    else {\r\n        const reader = newUserDataReader(query.firestore);\r\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\r\n    }\r\n}\r\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\r\n    let fieldValue;\r\n    if (fieldPath.isKeyField()) {\r\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\r\n        }\r\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n            const referenceList = [];\r\n            for (const arrayValue of value) {\r\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\r\n            }\r\n            fieldValue = { arrayValue: { values: referenceList } };\r\n        }\r\n        else {\r\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\r\n        }\r\n    }\r\n    else {\r\n        if (op === \"in\" /* Operator.IN */ ||\r\n            op === \"not-in\" /* Operator.NOT_IN */ ||\r\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n        }\r\n        fieldValue = parseQueryValue(dataReader, methodName, value, \r\n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\r\n    }\r\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\r\n    return filter;\r\n}\r\nfunction newQueryOrderBy(query, fieldPath, direction) {\r\n    if (query.startAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    if (query.endAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    const orderBy = new OrderBy(fieldPath, direction);\r\n    return orderBy;\r\n}\r\n/**\r\n * Create a `Bound` from a query and a document.\r\n *\r\n * Note that the `Bound` will always include the key of the document\r\n * and so only the provided document will compare equal to the returned\r\n * position.\r\n *\r\n * Will throw if the document does not contain all fields of the order by\r\n * of the query or if any of the fields in the order by are an uncommitted\r\n * server timestamp.\r\n */\r\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\r\n    if (!doc) {\r\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\r\n            `${methodName}().`);\r\n    }\r\n    const components = [];\r\n    // Because people expect to continue/end a query at the exact document\r\n    // provided, we need to use the implicit sort order rather than the explicit\r\n    // sort order, because it's guaranteed to contain the document key. That way\r\n    // the position becomes unambiguous and the query continues/ends exactly at\r\n    // the provided document. Without the key (by using the explicit sort\r\n    // orders), multiple documents could match the position, yielding duplicate\r\n    // results.\r\n    for (const orderBy of queryNormalizedOrderBy(query)) {\r\n        if (orderBy.field.isKeyField()) {\r\n            components.push(refValue(databaseId, doc.key));\r\n        }\r\n        else {\r\n            const value = doc.data.field(orderBy.field);\r\n            if (isServerTimestamp(value)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\r\n                    'document for which the field \"' +\r\n                    orderBy.field +\r\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\r\n                    'this field is unknown, you cannot start/end a query with it.)');\r\n            }\r\n            else if (value !== null) {\r\n                components.push(value);\r\n            }\r\n            else {\r\n                const field = orderBy.field.canonicalString();\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\r\n                    `document for which the field '${field}' (used as the ` +\r\n                    `orderBy) does not exist.`);\r\n            }\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Converts a list of field values to a `Bound` for the given query.\r\n */\r\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\r\n    // Use explicit order by's because it has to match the query the user made\r\n    const orderBy = query.explicitOrderBy;\r\n    if (values.length > orderBy.length) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\r\n            `The number of arguments must be less than or equal to the ` +\r\n            `number of orderBy() clauses`);\r\n    }\r\n    const components = [];\r\n    for (let i = 0; i < values.length; i++) {\r\n        const rawValue = values[i];\r\n        const orderByComponent = orderBy[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            if (typeof rawValue !== 'string') {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\r\n                    `${methodName}(), but got a ${typeof rawValue}`);\r\n            }\r\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\r\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\r\n                    `'${rawValue}' contains a slash.`);\r\n            }\r\n            const path = query.path.child(ResourcePath.fromString(rawValue));\r\n            if (!DocumentKey.isDocumentKey(path)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\r\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\r\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\r\n                    `of segments.`);\r\n            }\r\n            const key = new DocumentKey(path);\r\n            components.push(refValue(databaseId, key));\r\n        }\r\n        else {\r\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\r\n            components.push(wrapped);\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\r\n * appropriate errors if the value is anything other than a `DocumentReference`\r\n * or `string`, or if the string is malformed.\r\n */\r\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\r\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\r\n    if (typeof documentIdValue === 'string') {\r\n        if (documentIdValue === '') {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\r\n                'must provide a valid document ID, but it was an empty string.');\r\n        }\r\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\r\n                `documentId(), you must provide a plain document ID, but ` +\r\n                `'${documentIdValue}' contains a '/' character.`);\r\n        }\r\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\r\n        if (!DocumentKey.isDocumentKey(path)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\r\n                `documentId(), the value provided must result in a valid document path, ` +\r\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\r\n        }\r\n        return refValue(databaseId, new DocumentKey(path));\r\n    }\r\n    else if (documentIdValue instanceof DocumentReference) {\r\n        return refValue(databaseId, documentIdValue._key);\r\n    }\r\n    else {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\r\n            `string or a DocumentReference, but it was: ` +\r\n            `${valueDescription(documentIdValue)}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that the value passed into a disjunctive filter satisfies all\r\n * array requirements.\r\n */\r\nfunction validateDisjunctiveFilterElements(value, operator) {\r\n    if (!Array.isArray(value) || value.length === 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\r\n            `'${operator.toString()}' filters.`);\r\n    }\r\n}\r\n/**\r\n * Given an operator, returns the set of operators that cannot be used with it.\r\n *\r\n * This is not a comprehensive check, and this function should be removed in the\r\n * long term. Validations should occur in the Firestore backend.\r\n *\r\n * Operators in a query must adhere to the following set of rules:\r\n * 1. Only one inequality per query.\r\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\r\n */\r\nfunction conflictingOps(op) {\r\n    switch (op) {\r\n        case \"!=\" /* Operator.NOT_EQUAL */:\r\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\r\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\r\n        case \"in\" /* Operator.IN */:\r\n            return [\"not-in\" /* Operator.NOT_IN */];\r\n        case \"not-in\" /* Operator.NOT_IN */:\r\n            return [\r\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\r\n                \"in\" /* Operator.IN */,\r\n                \"not-in\" /* Operator.NOT_IN */,\r\n                \"!=\" /* Operator.NOT_EQUAL */\r\n            ];\r\n        default:\r\n            return [];\r\n    }\r\n}\r\nfunction validateNewFieldFilter(query, fieldFilter) {\r\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\r\n    if (conflictingOp !== null) {\r\n        // Special case when it's a duplicate op to give a slightly clearer error message.\r\n        if (conflictingOp === fieldFilter.op) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\r\n                `'${fieldFilter.op.toString()}' filter.`);\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\r\n                `with '${conflictingOp.toString()}' filters.`);\r\n        }\r\n    }\r\n}\r\nfunction validateNewFilter(query, filter) {\r\n    let testQuery = query;\r\n    const subFilters = filter.getFlattenedFilters();\r\n    for (const subFilter of subFilters) {\r\n        validateNewFieldFilter(testQuery, subFilter);\r\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\r\n    }\r\n}\r\n// Checks if any of the provided filter operators are included in the given list of filters and\r\n// returns the first one that is, or null if none are.\r\nfunction findOpInsideFilters(filters, operators) {\r\n    for (const filter of filters) {\r\n        for (const fieldFilter of filter.getFlattenedFilters()) {\r\n            if (operators.indexOf(fieldFilter.op) >= 0) {\r\n                return fieldFilter.op;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\r\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\r\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\r\n    }\r\n}\r\nfunction validateQueryConstraintArray(queryConstraint) {\r\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\r\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\r\n    if (compositeFilterCount > 1 ||\r\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\r\n            'more than one filter at the top level. Consider nesting the multiple ' +\r\n            'filters within an `and(...)` statement. For example: ' +\r\n            'change `query(query, where(...), or(...))` to ' +\r\n            '`query(query, and(where(...), or(...)))`.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts Firestore's internal types to the JavaScript types that we expose\r\n * to the user.\r\n *\r\n * @internal\r\n */\r\nclass AbstractUserDataWriter {\r\n    convertValue(value, serverTimestampBehavior = 'none') {\r\n        switch (typeOrder(value)) {\r\n            case 0 /* TypeOrder.NullValue */:\r\n                return null;\r\n            case 1 /* TypeOrder.BooleanValue */:\r\n                return value.booleanValue;\r\n            case 2 /* TypeOrder.NumberValue */:\r\n                return normalizeNumber(value.integerValue || value.doubleValue);\r\n            case 3 /* TypeOrder.TimestampValue */:\r\n                return this.convertTimestamp(value.timestampValue);\r\n            case 4 /* TypeOrder.ServerTimestampValue */:\r\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\r\n            case 5 /* TypeOrder.StringValue */:\r\n                return value.stringValue;\r\n            case 6 /* TypeOrder.BlobValue */:\r\n                return this.convertBytes(normalizeByteString(value.bytesValue));\r\n            case 7 /* TypeOrder.RefValue */:\r\n                return this.convertReference(value.referenceValue);\r\n            case 8 /* TypeOrder.GeoPointValue */:\r\n                return this.convertGeoPoint(value.geoPointValue);\r\n            case 9 /* TypeOrder.ArrayValue */:\r\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\r\n            case 10 /* TypeOrder.ObjectValue */:\r\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\r\n            default:\r\n                throw fail();\r\n        }\r\n    }\r\n    convertObject(mapValue, serverTimestampBehavior) {\r\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\r\n        const result = {};\r\n        forEach(fields, (key, value) => {\r\n            result[key] = this.convertValue(value, serverTimestampBehavior);\r\n        });\r\n        return result;\r\n    }\r\n    convertGeoPoint(value) {\r\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\r\n    }\r\n    convertArray(arrayValue, serverTimestampBehavior) {\r\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\r\n    }\r\n    convertServerTimestamp(value, serverTimestampBehavior) {\r\n        switch (serverTimestampBehavior) {\r\n            case 'previous':\r\n                const previousValue = getPreviousValue(value);\r\n                if (previousValue == null) {\r\n                    return null;\r\n                }\r\n                return this.convertValue(previousValue, serverTimestampBehavior);\r\n            case 'estimate':\r\n                return this.convertTimestamp(getLocalWriteTime(value));\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    convertTimestamp(value) {\r\n        const normalizedValue = normalizeTimestamp(value);\r\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\r\n    }\r\n    convertDocumentKey(name, expectedDatabaseId) {\r\n        const resourcePath = ResourcePath.fromString(name);\r\n        hardAssert(isValidResourceName(resourcePath));\r\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\r\n        const key = new DocumentKey(resourcePath.popFirst(5));\r\n        if (!databaseId.isEqual(expectedDatabaseId)) {\r\n            // TODO(b/64130202): Somehow support foreign references.\r\n            logError(`Document ${key} contains a document ` +\r\n                `reference within a different database (` +\r\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\r\n                `supported. It will be treated as a reference in the current ` +\r\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\r\n                `instead.`);\r\n        }\r\n        return key;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts custom model object of type T into `DocumentData` by applying the\r\n * converter if it exists.\r\n *\r\n * This function is used when converting user objects to `DocumentData`\r\n * because we want to provide the user with a more specific error message if\r\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\r\n * call.\r\n */\r\nfunction applyFirestoreDataConverter(converter, value, options) {\r\n    let convertedValue;\r\n    if (converter) {\r\n        if (options && (options.merge || options.mergeFields)) {\r\n            // Cast to `any` in order to satisfy the union type constraint on\r\n            // toFirestore().\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            convertedValue = converter.toFirestore(value, options);\r\n        }\r\n        else {\r\n            convertedValue = converter.toFirestore(value);\r\n        }\r\n    }\r\n    else {\r\n        convertedValue = value;\r\n    }\r\n    return convertedValue;\r\n}\r\nclass LiteUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Create an AggregateField object that can be used to compute the sum of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to sum across the result set.\r\n */\r\nfunction sum(field) {\r\n    return new AggregateField('sum', fieldPathFromArgument$1('sum', field));\r\n}\r\n/**\r\n * Create an AggregateField object that can be used to compute the average of\r\n * a specified field over a range of documents in the result set of a query.\r\n * @param field Specifies the field to average across the result set.\r\n */\r\nfunction average(field) {\r\n    return new AggregateField('avg', fieldPathFromArgument$1('average', field));\r\n}\r\n/**\r\n * Create an AggregateField object that can be used to compute the count of\r\n * documents in the result set of a query.\r\n */\r\nfunction count() {\r\n    return new AggregateField('count');\r\n}\r\n/**\r\n * Compares two 'AggregateField` instances for equality.\r\n *\r\n * @param left Compare this AggregateField to the `right`.\r\n * @param right Compare this AggregateField to the `left`.\r\n */\r\nfunction aggregateFieldEqual(left, right) {\r\n    var _a, _b;\r\n    return (left instanceof AggregateField &&\r\n        right instanceof AggregateField &&\r\n        left.aggregateType === right.aggregateType &&\r\n        ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) ===\r\n            ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString()));\r\n}\r\n/**\r\n * Compares two `AggregateQuerySnapshot` instances for equality.\r\n *\r\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\r\n * underlying queries that compare equal, and the same data.\r\n *\r\n * @param left - The first `AggregateQuerySnapshot` to compare.\r\n * @param right - The second `AggregateQuerySnapshot` to compare.\r\n *\r\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\r\n * otherwise.\r\n */\r\nfunction aggregateQuerySnapshotEqual(left, right) {\r\n    return (queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data()));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isPartialObserver(obj) {\r\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\r\n}\r\n/**\r\n * Returns true if obj is an object and contains at least one of the specified\r\n * methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    const object = obj;\r\n    for (const method of methods) {\r\n        if (method in object && typeof object[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Metadata about a snapshot, describing the state of the snapshot.\r\n */\r\nclass SnapshotMetadata {\r\n    /** @hideconstructor */\r\n    constructor(hasPendingWrites, fromCache) {\r\n        this.hasPendingWrites = hasPendingWrites;\r\n        this.fromCache = fromCache;\r\n    }\r\n    /**\r\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     *\r\n     * @param other - The `SnapshotMetadata` to compare against.\r\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (this.hasPendingWrites === other.hasPendingWrites &&\r\n            this.fromCache === other.fromCache);\r\n    }\r\n}\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot extends DocumentSnapshot$1 {\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\r\n        super(_firestore, userDataWriter, key, document, converter);\r\n        this._firestore = _firestore;\r\n        this._firestoreImpl = _firestore;\r\n        this.metadata = metadata;\r\n    }\r\n    /**\r\n     * Returns whether or not the data exists. True if the document exists.\r\n     */\r\n    exists() {\r\n        return super.exists();\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document or `undefined` if\r\n     * the document doesn't exist.\r\n     */\r\n    data(options = {}) {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot, options);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * By default, a `serverTimestamp()` that has not yet been set to\r\n     * its final value will be returned as `null`. You can override this by\r\n     * passing an options object.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @param options - An options object to configure how the field is retrieved\r\n     * from the snapshot (for example the desired behavior for server timestamps\r\n     * that have not yet been set to their final value).\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath, options = {}) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot extends DocumentSnapshot {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @override\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data(options = {}) {\r\n        return super.data(options);\r\n    }\r\n}\r\n/**\r\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\r\n * representing the results of a query. The documents can be accessed as an\r\n * array via the `docs` property or enumerated using the `forEach` method. The\r\n * number of documents can be determined via the `empty` and `size`\r\n * properties.\r\n */\r\nclass QuerySnapshot {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._snapshot = _snapshot;\r\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\r\n        this.query = query;\r\n    }\r\n    /** An array of all the documents in the `QuerySnapshot`. */\r\n    get docs() {\r\n        const result = [];\r\n        this.forEach(doc => result.push(doc));\r\n        return result;\r\n    }\r\n    /** The number of documents in the `QuerySnapshot`. */\r\n    get size() {\r\n        return this._snapshot.docs.size;\r\n    }\r\n    /** True if there are no documents in the `QuerySnapshot`. */\r\n    get empty() {\r\n        return this.size === 0;\r\n    }\r\n    /**\r\n     * Enumerates all of the documents in the `QuerySnapshot`.\r\n     *\r\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\r\n     * each document in the snapshot.\r\n     * @param thisArg - The `this` binding for the callback.\r\n     */\r\n    forEach(callback, thisArg) {\r\n        this._snapshot.docs.forEach(doc => {\r\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\r\n        });\r\n    }\r\n    /**\r\n     * Returns an array of the documents changes since the last snapshot. If this\r\n     * is the first snapshot, all documents will be in the list as 'added'\r\n     * changes.\r\n     *\r\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\r\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\r\n     * snapshot events.\r\n     */\r\n    docChanges(options = {}) {\r\n        const includeMetadataChanges = !!options.includeMetadataChanges;\r\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\r\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\r\n        }\r\n        if (!this._cachedChanges ||\r\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\r\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\r\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\r\n        }\r\n        return this._cachedChanges;\r\n    }\r\n}\r\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\r\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\r\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\r\n        let index = 0;\r\n        return querySnapshot._snapshot.docChanges.map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            change.doc;\r\n            return {\r\n                type: 'added',\r\n                doc,\r\n                oldIndex: -1,\r\n                newIndex: index++\r\n            };\r\n        });\r\n    }\r\n    else {\r\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\r\n        // to lookup the index of a document.\r\n        let indexTracker = querySnapshot._snapshot.oldDocs;\r\n        return querySnapshot._snapshot.docChanges\r\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\r\n            .map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            let oldIndex = -1;\r\n            let newIndex = -1;\r\n            if (change.type !== 0 /* ChangeType.Added */) {\r\n                oldIndex = indexTracker.indexOf(change.doc.key);\r\n                indexTracker = indexTracker.delete(change.doc.key);\r\n            }\r\n            if (change.type !== 1 /* ChangeType.Removed */) {\r\n                indexTracker = indexTracker.add(change.doc);\r\n                newIndex = indexTracker.indexOf(change.doc.key);\r\n            }\r\n            return {\r\n                type: resultChangeType(change.type),\r\n                doc,\r\n                oldIndex,\r\n                newIndex\r\n            };\r\n        });\r\n    }\r\n}\r\nfunction resultChangeType(type) {\r\n    switch (type) {\r\n        case 0 /* ChangeType.Added */:\r\n            return 'added';\r\n        case 2 /* ChangeType.Modified */:\r\n        case 3 /* ChangeType.Metadata */:\r\n            return 'modified';\r\n        case 1 /* ChangeType.Removed */:\r\n            return 'removed';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\r\n// metadata\r\n/**\r\n * Returns true if the provided snapshots are equal.\r\n *\r\n * @param left - A snapshot to compare.\r\n * @param right - A snapshot to compare.\r\n * @returns true if the snapshots are equal.\r\n */\r\nfunction snapshotEqual(left, right) {\r\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            left._key.isEqual(right._key) &&\r\n            (left._document === null\r\n                ? right._document === null\r\n                : left._document.isEqual(right._document)) &&\r\n            left._converter === right._converter);\r\n    }\r\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            queryEqual(left.query, right.query) &&\r\n            left.metadata.isEqual(right.metadata) &&\r\n            left._snapshot.isEqual(right._snapshot));\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Reads the document referred to by this `DocumentReference`.\r\n *\r\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\r\n * for data from the server, but it may return cached data or fail if you are\r\n * offline and the server cannot be reached. To specify this behavior, invoke\r\n * {@link getDocFromCache} or {@link getDocFromServer}.\r\n *\r\n * @param reference - The reference of the document to fetch.\r\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDoc(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\nclass ExpUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from cache.\r\n * Returns an error if the document is not currently cached.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromCache(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \r\n    /* fromCache= */ true), reference.converter));\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from the server.\r\n * Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromServer(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\r\n        source: 'server'\r\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot`.\r\n *\r\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\r\n * waiting for data from the server, but it may return cached data or fail if\r\n * you are offline and the server cannot be reached. To specify this behavior,\r\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocs(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    validateHasExplicitOrderByForLimitToLast(query._query);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\r\n * Returns an empty result set if no documents matching the query are currently\r\n * cached.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromCache(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from the\r\n * server. Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromServer(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\r\n        source: 'server'\r\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\nfunction setDoc(reference, data, options) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\r\n    const dataReader = newUserDataReader(firestore);\r\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\r\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const dataReader = newUserDataReader(firestore);\r\n    // For Compat types, we have to \"extract\" the underlying types before\r\n    // performing validation.\r\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n    let parsed;\r\n    if (typeof fieldOrUpdateData === 'string' ||\r\n        fieldOrUpdateData instanceof FieldPath) {\r\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n    }\r\n    else {\r\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\r\n    }\r\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\n/**\r\n * Deletes the document referred to by the specified `DocumentReference`.\r\n *\r\n * @param reference - A reference to the document to delete.\r\n * @returns A Promise resolved once the document has been successfully\r\n * deleted from the backend (note that it won't resolve while you're offline).\r\n */\r\nfunction deleteDoc(reference) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\r\n    return executeWrite(firestore, mutations);\r\n}\r\n/**\r\n * Add a new document to specified `CollectionReference` with the given data,\r\n * assigning it a document ID automatically.\r\n *\r\n * @param reference - A reference to the collection to add this document to.\r\n * @param data - An Object containing the data for the new document.\r\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\r\n * newly created document after it has been written to the backend (Note that it\r\n * won't resolve while you're offline).\r\n */\r\nfunction addDoc(reference, data) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const docRef = doc(reference);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\r\n    const dataReader = newUserDataReader(reference.firestore);\r\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\r\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\r\n    return executeWrite(firestore, [mutation]).then(() => docRef);\r\n}\r\nfunction onSnapshot(reference, ...args) {\r\n    var _a, _b, _c;\r\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\r\n    let options = {\r\n        includeMetadataChanges: false,\r\n        source: 'default'\r\n    };\r\n    let currArg = 0;\r\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\r\n        options = args[currArg];\r\n        currArg++;\r\n    }\r\n    const internalOptions = {\r\n        includeMetadataChanges: options.includeMetadataChanges,\r\n        source: options.source\r\n    };\r\n    if (isPartialObserver(args[currArg])) {\r\n        const userObserver = args[currArg];\r\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\r\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\r\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\r\n    }\r\n    let observer;\r\n    let firestore;\r\n    let internalQuery;\r\n    if (reference instanceof DocumentReference) {\r\n        firestore = cast(reference.firestore, Firestore);\r\n        internalQuery = newQueryForPath(reference._key.path);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n    }\r\n    else {\r\n        const query = cast(reference, Query);\r\n        firestore = cast(query.firestore, Firestore);\r\n        internalQuery = query._query;\r\n        const userDataWriter = new ExpUserDataWriter(firestore);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n        validateHasExplicitOrderByForLimitToLast(reference._query);\r\n    }\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\r\n}\r\nfunction onSnapshotsInSync(firestore, arg) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const observer = isPartialObserver(arg)\r\n        ? arg\r\n        : {\r\n            next: arg\r\n        };\r\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\r\n}\r\n/**\r\n * Locally writes `mutations` on the async queue.\r\n * @internal\r\n */\r\nfunction executeWrite(firestore, mutations) {\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWrite(client, mutations);\r\n}\r\n/**\r\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\r\n * to a {@link DocumentSnapshot}.\r\n */\r\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\r\n    const doc = snapshot.docs.get(ref._key);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Calculates the number of documents in the result set of the given query\r\n * without actually downloading the documents.\r\n *\r\n * Using this function to count the documents is efficient because only the\r\n * final count, not the documents' data, is downloaded. This function can\r\n * count the documents in cases where the result set is prohibitively large to\r\n * download entirely (thousands of documents).\r\n *\r\n * The result received from the server is presented, unaltered, without\r\n * considering any local state. That is, documents in the local cache are not\r\n * taken into consideration, neither are local modifications not yet\r\n * synchronized with the server. Previously-downloaded results, if any, are not\r\n * used. Every invocation of this function necessarily involves a round trip to\r\n * the server.\r\n *\r\n * @param query The query whose result set size is calculated.\r\n * @returns A Promise that will be resolved with the count; the count can be\r\n * retrieved from `snapshot.data().count`, where `snapshot` is the\r\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\r\n */\r\nfunction getCountFromServer(query) {\r\n    const countQuerySpec = {\r\n        count: count()\r\n    };\r\n    return getAggregateFromServer(query, countQuerySpec);\r\n}\r\n/**\r\n * Calculates the specified aggregations over the documents in the result\r\n * set of the given query without actually downloading the documents.\r\n *\r\n * Using this function to perform aggregations is efficient because only the\r\n * final aggregation values, not the documents' data, are downloaded. This\r\n * function can perform aggregations of the documents in cases where the result\r\n * set is prohibitively large to download entirely (thousands of documents).\r\n *\r\n * The result received from the server is presented, unaltered, without\r\n * considering any local state. That is, documents in the local cache are not\r\n * taken into consideration, neither are local modifications not yet\r\n * synchronized with the server. Previously-downloaded results, if any, are not\r\n * used. Every invocation of this function necessarily involves a round trip to\r\n * the server.\r\n *\r\n * @param query The query whose result set is aggregated over.\r\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\r\n * to perform over the result set. The AggregateSpec specifies aliases for each\r\n * aggregate, which can be used to retrieve the aggregate result.\r\n * @example\r\n * ```typescript\r\n * const aggregateSnapshot = await getAggregateFromServer(query, {\r\n *   countOfDocs: count(),\r\n *   totalHours: sum('hours'),\r\n *   averageScore: average('score')\r\n * });\r\n *\r\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\r\n * const totalHours: number = aggregateSnapshot.data().totalHours;\r\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\r\n * ```\r\n */\r\nfunction getAggregateFromServer(query, aggregateSpec) {\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\r\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\r\n    });\r\n    // Run the aggregation and convert the results\r\n    return firestoreClientRunAggregateQuery(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\r\n}\r\n/**\r\n * Converts the core aggregration result to an `AggregateQuerySnapshot`\r\n * that can be returned to the consumer.\r\n * @param query\r\n * @param aggregateResult Core aggregation result\r\n * @internal\r\n */\r\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\r\n    return querySnapshot;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryLocalCacheImpl {\r\n    constructor(settings) {\r\n        this.kind = 'memory';\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        if (settings === null || settings === void 0 ? void 0 : settings.garbageCollector) {\r\n            this._offlineComponentProvider =\r\n                settings.garbageCollector._offlineComponentProvider;\r\n        }\r\n        else {\r\n            this._offlineComponentProvider = new MemoryOfflineComponentProvider();\r\n        }\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass PersistentLocalCacheImpl {\r\n    constructor(settings) {\r\n        this.kind = 'persistent';\r\n        let tabManager;\r\n        if (settings === null || settings === void 0 ? void 0 : settings.tabManager) {\r\n            settings.tabManager._initialize(settings);\r\n            tabManager = settings.tabManager;\r\n        }\r\n        else {\r\n            tabManager = persistentSingleTabManager(undefined);\r\n            tabManager._initialize(settings);\r\n        }\r\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\r\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass MemoryEagerGabageCollectorImpl {\r\n    constructor() {\r\n        this.kind = 'memoryEager';\r\n        this._offlineComponentProvider = new MemoryOfflineComponentProvider();\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\nclass MemoryLruGabageCollectorImpl {\r\n    constructor(cacheSize) {\r\n        this.kind = 'memoryLru';\r\n        this._offlineComponentProvider = new LruGcMemoryOfflineComponentProvider(cacheSize);\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n}\r\n/**\r\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\r\n * default garbage collector unless it is explicitly specified otherwise.\r\n */\r\nfunction memoryEagerGarbageCollector() {\r\n    return new MemoryEagerGabageCollectorImpl();\r\n}\r\n/**\r\n * Creates an instance of `MemoryLruGarbageCollector`.\r\n *\r\n * A target size can be specified as part of the setting parameter. The\r\n * collector will start deleting documents once the cache size exceeds\r\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\r\n */\r\nfunction memoryLruGarbageCollector(settings) {\r\n    return new MemoryLruGabageCollectorImpl(settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\r\n}\r\n/**\r\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\r\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\r\n */\r\nfunction memoryLocalCache(settings) {\r\n    return new MemoryLocalCacheImpl(settings);\r\n}\r\n/**\r\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\r\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\r\n *\r\n * Persistent cache cannot be used in a Node.js environment.\r\n */\r\nfunction persistentLocalCache(settings) {\r\n    return new PersistentLocalCacheImpl(settings);\r\n}\r\nclass SingleTabManagerImpl {\r\n    constructor(forceOwnership) {\r\n        this.forceOwnership = forceOwnership;\r\n        this.kind = 'persistentSingleTab';\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _initialize(settings) {\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        this._offlineComponentProvider = new IndexedDbOfflineComponentProvider(this._onlineComponentProvider, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes, this.forceOwnership);\r\n    }\r\n}\r\nclass MultiTabManagerImpl {\r\n    constructor() {\r\n        this.kind = 'PersistentMultipleTab';\r\n    }\r\n    toJSON() {\r\n        return { kind: this.kind };\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _initialize(settings) {\r\n        this._onlineComponentProvider = new OnlineComponentProvider();\r\n        this._offlineComponentProvider = new MultiTabOfflineComponentProvider(this._onlineComponentProvider, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\r\n    }\r\n}\r\n/**\r\n * Creates an instance of `PersistentSingleTabManager`.\r\n *\r\n * @param settings Configures the created tab manager.\r\n */\r\nfunction persistentSingleTabManager(settings) {\r\n    return new SingleTabManagerImpl(settings === null || settings === void 0 ? void 0 : settings.forceOwnership);\r\n}\r\n/**\r\n * Creates an instance of `PersistentMultipleTabManager`.\r\n */\r\nfunction persistentMultipleTabManager() {\r\n    return new MultiTabManagerImpl();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_TRANSACTION_OPTIONS = {\r\n    maxAttempts: 5\r\n};\r\nfunction validateTransactionOptions(options) {\r\n    if (options.maxAttempts < 1) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A write batch, used to perform multiple writes as a single atomic unit.\r\n *\r\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\r\n * provides methods for adding writes to the write batch. None of the writes\r\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\r\n * called.\r\n */\r\nclass WriteBatch {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _commitHandler) {\r\n        this._firestore = _firestore;\r\n        this._commitHandler = _commitHandler;\r\n        this._mutations = [];\r\n        this._committed = false;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    set(documentRef, data, options) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\r\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    /**\r\n     * Commits all of the writes in this write batch as a single atomic unit.\r\n     *\r\n     * The result of these writes will only be reflected in document reads that\r\n     * occur after the returned promise resolves. If the client is offline, the\r\n     * write fails. If you would like to see local modifications or buffer writes\r\n     * until the client is online, use the full Firestore SDK.\r\n     *\r\n     * @returns A `Promise` resolved once all of the writes in the batch have been\r\n     * successfully written to the backend as an atomic unit (note that it won't\r\n     * resolve while you're offline).\r\n     */\r\n    commit() {\r\n        this._verifyNotCommitted();\r\n        this._committed = true;\r\n        if (this._mutations.length > 0) {\r\n            return this._commitHandler(this._mutations);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _verifyNotCommitted() {\r\n        if (this._committed) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\r\n                'has been called.');\r\n        }\r\n    }\r\n}\r\nfunction validateReference(documentRef, firestore) {\r\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\r\n    if (documentRef.firestore !== firestore) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\r\n    }\r\n    else {\r\n        return documentRef;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\r\n// legacy SDK.\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction$1 {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        this._firestore = _firestore;\r\n        this._transaction = _transaction;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\r\n        return this._transaction.lookup([ref._key]).then(docs => {\r\n            if (!docs || docs.length !== 1) {\r\n                return fail();\r\n            }\r\n            const doc = docs[0];\r\n            if (doc.isFoundDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\r\n            }\r\n            else if (doc.isNoDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\r\n            }\r\n            else {\r\n                throw fail();\r\n            }\r\n        });\r\n    }\r\n    set(documentRef, value, options) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\r\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._transaction.set(ref._key, parsed);\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._transaction.update(ref._key, parsed);\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._transaction.delete(ref._key);\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction extends Transaction$1 {\r\n    // This class implements the same logic as the Transaction API in the Lite SDK\r\n    // but is subclassed in order to return its own DocumentSnapshot types.\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        super(_firestore, _transaction);\r\n        this._firestore = _firestore;\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\r\n        return super\r\n            .get(documentRef)\r\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\r\n        /* hasPendingWrites= */ false, \r\n        /* fromCache= */ false), ref.converter));\r\n    }\r\n}\r\n/**\r\n * Executes the given `updateFunction` and then attempts to commit the changes\r\n * applied within the transaction. If any document read within the transaction\r\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\r\n * commit after 5 attempts, the transaction fails.\r\n *\r\n * The maximum number of writes allowed in a single transaction is 500.\r\n *\r\n * @param firestore - A reference to the Firestore database to run this\r\n * transaction against.\r\n * @param updateFunction - The function to execute within the transaction\r\n * context.\r\n * @param options - An options object to configure maximum number of attempts to\r\n * commit.\r\n * @returns If the transaction completed successfully or was explicitly aborted\r\n * (the `updateFunction` returned a failed promise), the promise returned by the\r\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\r\n * rejected promise with the corresponding failure error is returned.\r\n */\r\nfunction runTransaction(firestore, updateFunction, options) {\r\n    firestore = cast(firestore, Firestore);\r\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\r\n    validateTransactionOptions(optionsWithDefaults);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\r\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\r\n */\r\nfunction deleteField() {\r\n    return new DeleteFieldValueImpl('deleteField');\r\n}\r\n/**\r\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\r\n * include a server-generated timestamp in the written data.\r\n */\r\nfunction serverTimestamp() {\r\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\r\n * value that already exists on the server. Each specified element that doesn't\r\n * already exist in the array will be added to the end. If the field being\r\n * modified is not already an array it will be overwritten with an array\r\n * containing exactly the specified elements.\r\n *\r\n * @param elements - The elements to union into the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`.\r\n */\r\nfunction arrayUnion(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\r\n * updateDoc:1} that tells the server to remove the given elements from any\r\n * array value that already exists on the server. All instances of each element\r\n * specified will be removed from the array. If the field being modified is not\r\n * already an array it will be overwritten with an empty array.\r\n *\r\n * @param elements - The elements to remove from the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction arrayRemove(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\r\n * the given value.\r\n *\r\n * If either the operand or the current field value uses floating point\r\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\r\n * integers, values outside of JavaScript's safe number range\r\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\r\n * precision loss. Furthermore, once processed by the Firestore backend, all\r\n * integer operations are capped between -2^63 and 2^63-1.\r\n *\r\n * If the current field value is not of type `number`, or if the field does not\r\n * yet exist, the transformation sets the field to the given value.\r\n *\r\n * @param n - The value to increment by.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction increment(n) {\r\n    return new NumericIncrementFieldValueImpl('increment', n);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a write batch, used for performing multiple writes as a single\r\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\r\n * is 500.\r\n *\r\n * Unlike transactions, write batches are persisted offline and therefore are\r\n * preferable when you don't need to condition your writes on read data.\r\n *\r\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\r\n * writes.\r\n */\r\nfunction writeBatch(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    ensureFirestoreConfigured(firestore);\r\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (!client._uninitializedComponentsProvider ||\r\n        ((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offlineKind) === 'memory') {\r\n        // PORTING NOTE: We don't return an error if the user has not enabled\r\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\r\n        logWarn('Cannot enable indexes when persistence is disabled');\r\n        return Promise.resolve();\r\n    }\r\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\r\n    return firestoreClientSetIndexConfiguration(client, parsedIndexes);\r\n}\r\nfunction parseIndexes(jsonOrConfiguration) {\r\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\r\n        ? tryParseJson(jsonOrConfiguration)\r\n        : jsonOrConfiguration;\r\n    const parsedIndexes = [];\r\n    if (Array.isArray(indexConfiguration.indexes)) {\r\n        for (const index of indexConfiguration.indexes) {\r\n            const collectionGroup = tryGetString(index, 'collectionGroup');\r\n            const segments = [];\r\n            if (Array.isArray(index.fields)) {\r\n                for (const field of index.fields) {\r\n                    const fieldPathString = tryGetString(field, 'fieldPath');\r\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\r\n                    if (field.arrayConfig === 'CONTAINS') {\r\n                        segments.push(new IndexSegment(fieldPath, 2 /* IndexKind.CONTAINS */));\r\n                    }\r\n                    else if (field.order === 'ASCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 0 /* IndexKind.ASCENDING */));\r\n                    }\r\n                    else if (field.order === 'DESCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 1 /* IndexKind.DESCENDING */));\r\n                    }\r\n                }\r\n            }\r\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\r\n        }\r\n    }\r\n    return parsedIndexes;\r\n}\r\nfunction tryParseJson(json) {\r\n    try {\r\n        return JSON.parse(json);\r\n    }\r\n    catch (e) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON: ' + (e === null || e === void 0 ? void 0 : e.message));\r\n    }\r\n}\r\nfunction tryGetString(data, property) {\r\n    if (typeof data[property] !== 'string') {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\r\n    }\r\n    return data[property];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\r\n * for local query execution.\r\n *\r\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\r\n */\r\nclass PersistentCacheIndexManager {\r\n    /** @hideconstructor */\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'PersistentCacheIndexManager';\r\n    }\r\n}\r\n/**\r\n * Returns the PersistentCache Index Manager used by the given `Firestore`\r\n * object.\r\n *\r\n * @return The `PersistentCacheIndexManager` instance, or `null` if local\r\n * persistent storage is not in use.\r\n */\r\nfunction getPersistentCacheIndexManager(firestore) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore);\r\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\r\n    if (cachedInstance) {\r\n        return cachedInstance;\r\n    }\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    if (((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offlineKind) !== 'persistent') {\r\n        return null;\r\n    }\r\n    const instance = new PersistentCacheIndexManager(client);\r\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\r\n    return instance;\r\n}\r\n/**\r\n * Enables the SDK to create persistent cache indexes automatically for local\r\n * query execution when the SDK believes cache indexes can help improve\r\n * performance.\r\n *\r\n * This feature is disabled by default.\r\n */\r\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\r\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\r\n}\r\n/**\r\n * Stops creating persistent cache indexes automatically for local query\r\n * execution. The indexes which have been created by calling\r\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\r\n */\r\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\r\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\r\n}\r\n/**\r\n * Removes all persistent cache indexes.\r\n *\r\n * Please note this function will also deletes indexes generated by\r\n * `setIndexConfiguration()`, which is deprecated.\r\n */\r\nfunction deleteAllPersistentCacheIndexes(indexManager) {\r\n    indexManager._client.verifyNotTerminated();\r\n    const promise = firestoreClientDeleteAllFieldIndexes(indexManager._client);\r\n    promise\r\n        .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\r\n        .catch(error => logWarn('deleting all persistent cache indexes failed', error));\r\n}\r\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\r\n    indexManager._client.verifyNotTerminated();\r\n    const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(indexManager._client, isEnabled);\r\n    promise\r\n        .then(_ => logDebug(`setting persistent cache index auto creation ` +\r\n        `isEnabled=${isEnabled} succeeded`))\r\n        .catch(error => logWarn(`setting persistent cache index auto creation ` +\r\n        `isEnabled=${isEnabled} failed`, error));\r\n}\r\n/**\r\n * Maps `Firestore` instances to their corresponding\r\n * `PersistentCacheIndexManager` instances.\r\n *\r\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\r\n * `Firestore` instance is garbage collected. This emulates a private member\r\n * as described in https://goo.gle/454yvug.\r\n */\r\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Testing hooks for use by Firestore's integration test suite to reach into the\r\n * SDK internals to validate logic and behavior that is not visible from the\r\n * public API surface.\r\n *\r\n * @internal\r\n */\r\nclass TestingHooks {\r\n    constructor() {\r\n        throw new Error('instances of this class should not be created');\r\n    }\r\n    /**\r\n     * Registers a callback to be notified when an existence filter mismatch\r\n     * occurs in the Watch listen stream.\r\n     *\r\n     * The relative order in which callbacks are notified is unspecified; do not\r\n     * rely on any particular ordering. If a given callback is registered multiple\r\n     * times then it will be notified multiple times, once per registration.\r\n     *\r\n     * @param callback the callback to invoke upon existence filter mismatch.\r\n     *\r\n     * @return a function that, when called, unregisters the given callback; only\r\n     * the first invocation of the returned function does anything; all subsequent\r\n     * invocations do nothing.\r\n     */\r\n    static onExistenceFilterMismatch(callback) {\r\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\r\n    }\r\n}\r\n/**\r\n * The implementation of `TestingHooksSpi`.\r\n */\r\nclass TestingHooksSpiImpl {\r\n    constructor() {\r\n        this.existenceFilterMismatchCallbacksById = new Map();\r\n    }\r\n    static get instance() {\r\n        if (!testingHooksSpiImplInstance) {\r\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\r\n            setTestingHooksSpi(testingHooksSpiImplInstance);\r\n        }\r\n        return testingHooksSpiImplInstance;\r\n    }\r\n    notifyOnExistenceFilterMismatch(info) {\r\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\r\n    }\r\n    onExistenceFilterMismatch(callback) {\r\n        const id = Symbol();\r\n        const callbacks = this.existenceFilterMismatchCallbacksById;\r\n        callbacks.set(id, callback);\r\n        return () => callbacks.delete(id);\r\n    }\r\n}\r\nlet testingHooksSpiImplInstance = null;\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0o7QUFDaEc7QUFDSTtBQUNLO0FBQ29IO0FBQ3ZIO0FBQ007QUFDdEI7QUFDWTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFPLFVBQVUsWUFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0Esc0NBQXNDLFlBQVksS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHFDQUFxQyxZQUFZLEtBQUssSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsVUFBVSxVQUFVLEtBQUssYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0hBQWdIO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsTUFBTSwyQkFBMkIsS0FBSyw4QkFBOEIsWUFBWSxHQUFHLE9BQU8sYUFBYTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxREFBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQSwwQ0FBMEMsV0FBVyxnQkFBZ0I7QUFDckU7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVcsWUFBWSxNQUFNO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxHQUFHLEVBQUU7QUFDeEM7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLEVBQUUseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFxRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsR0FBRywwQkFBMEI7QUFDNUU7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsR0FBRyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxHQUFHLG9DQUFvQztBQUNoRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUIsYUFBYSxvQkFBb0IsYUFBYSwyQkFBMkI7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBLG1DQUFtQyxjQUFjLG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLElBQUksYUFBYSxJQUFJLGdDQUFnQztBQUMxRixjQUFjLGNBQWMsaUJBQWlCO0FBQzdDLGNBQWMsZ0JBQWdCLG1CQUFtQjtBQUNqRCxjQUFjLGlCQUFpQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUNBQWlDLEdBQUcsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDLEVBQUUsV0FBVyxFQUFFLDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QyxZQUFZLGdCQUFnQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpRUFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpRUFBTztBQUNoQyx5QkFBeUIsaUVBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUVBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpRUFBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLGlFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLDBCQUEwQixrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0IsR0FBRyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksMkJBQTJCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkIsYUFBYSx1QkFBdUI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWdFO0FBQ3ZGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhLFdBQVc7QUFDckcsK0NBQStDLHlDQUF5QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2Q0FBNkM7QUFDdEYsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQSw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLHdEQUF3RCwwQkFBMEI7QUFDbEYsdUJBQXVCLHFDQUFxQztBQUM1RCxpQ0FBaUMsZ0JBQWdCO0FBQ2pELHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGtCQUFrQjtBQUNuRCx1QkFBdUIsc0NBQXNDO0FBQzdELHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBZ0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0dBQStHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkdBQTZHLGNBQWM7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSEFBcUgsY0FBYztBQUNuSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEZBQTBGLGNBQWM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0lBQWtJLGVBQWU7QUFDako7QUFDQTtBQUNBLEtBQUs7QUFDTCx3R0FBd0csZUFBZTtBQUN2SDtBQUNBO0FBQ0EsS0FBSztBQUNMLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFJQUFxSSxlQUFlO0FBQ3BKLHVJQUF1SSxlQUFlO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEMsbUNBQW1DO0FBQ2pGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0VBQStFLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLElBQUksY0FBYztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxJQUFJLDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUyxJQUFJLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixXQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFRO0FBQ2hCO0FBQ0E7QUFDQSwrQkFBK0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxRQUFRO0FBQ2hGO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCLEdBQUcsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixHQUFHLGVBQWU7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRLEtBQUssTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTLEtBQUssTUFBTTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTLEtBQUssTUFBTTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLEdBQUcsc0JBQXNCO0FBQ2hHLGlEQUFpRCwwQkFBMEIsR0FBRyxzQkFBc0I7QUFDcEcsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx1QkFBdUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QixPQUFPLGFBQWEsT0FBTyxZQUFZO0FBQ3pHO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBa0MsYUFBYSxpQ0FBaUM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQWdCO0FBQ2xDLGtCQUFrQixzREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLElBQUksVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLElBQUksVUFBVTtBQUMxRDtBQUNBO0FBQ0EsMERBQTBELGNBQWMsNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTLEVBQUUsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLFdBQVcsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QyxRQUFRLFdBQVcsVUFBVTtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLFdBQVcsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxRQUFRLFdBQVcsVUFBVTtBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsV0FBVyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekUsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQTZDLEVBQUUsY0FBYztBQUN2RyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QyxFQUFFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUEyQztBQUN4RTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkMsRUFBRSxjQUFjO0FBQ3RHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBMkMsRUFBRSxjQUFjO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFvQjtBQUNsRCxXQUFXLGdFQUEwQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGdDQUFnQyxvQkFBb0I7QUFDcEQsc0NBQXNDLDBCQUEwQjtBQUNoRSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGdDQUFnQztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkJBQTJCO0FBQ3hHLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHNDQUFzQztBQUM1RztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUksSUFBSSxFQUFFO0FBQ3JDO0FBQ0EsdURBQXVELElBQUksSUFBSSxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsK0JBQStCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0Q0FBNEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnREFBZ0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYSxvQ0FBb0MsYUFBYTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWEsTUFBTSxhQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSkFBcUosTUFBTSxNQUFNLFlBQVk7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SixNQUFNLE1BQU0sWUFBWTtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGlCQUFpQixpQkFBaUIsWUFBWTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYSw2Q0FBNkMsRUFBRTtBQUNoSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSx5QkFBeUI7QUFDeko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0ZBQWtGO0FBQ2pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLE9BQU87QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyw2QkFBNkI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JILDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxHQUFHLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZSxrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBLElBQUksdUJBQXVCO0FBQzNCLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSxxQkFBcUIsaUNBQWlDLGdCQUFnQixpQkFBaUI7QUFDdkY7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw2QkFBNkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdFQUF3RSxxREFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLGlGQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLEdBQUcsd0JBQXdCO0FBQ3JFLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxzREFBc0Q7QUFDdEQsd0JBQXdCLElBQUksdUJBQXVCLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBYTtBQUMvQixJQUFJLGlFQUFrQixLQUFLLDBEQUFTLDRCQUE0QixtREFBbUQ7QUFDbkg7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFELGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsR0FBRyxrQkFBa0I7QUFDMUQsZ0NBQWdDLGlCQUFpQixHQUFHLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0JBQXdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUUsSUFBSSxjQUFjLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUc7QUFDbEUsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLG1CQUFtQjtBQUN6RSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkUsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSxlQUFlO0FBQ3hFLFVBQVU7QUFDVjtBQUNBLHlCQUF5QixpQ0FBaUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBaUMsTUFBTSxxQ0FBcUM7QUFDaEYsOERBQThELFVBQVU7QUFDeEUsSUFBSSxXQUFXLDJCQUEyQixpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsMEJBQTBCLFlBQVksR0FBRyxTQUFTLE1BQU0sVUFBVTtBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLDBCQUEwQixZQUFZLEdBQUcsU0FBUyxNQUFNLFVBQVU7QUFDbEUsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsMkJBQTJCLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFLElBQUksbUJBQW1CLDJCQUEyQixpQkFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekUsSUFBSSxzQkFBc0IsMkJBQTJCLGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLElBQUkscUJBQXFCLDJCQUEyQixpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLEdBQUc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxnQkFBZ0IsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3RELHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEUsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUsscURBQXFELFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQSw4RkFBOEYsMEJBQTBCO0FBQ3hILHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQSxtQkFBbUIscUJBQXFCLEdBQUcsb0JBQW9CO0FBQy9EO0FBQ0EsNkJBQTZCLDZCQUE2QixHQUFHLDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlEQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QixJQUFJLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLElBQUksd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRixJQUFJLDJDQUEyQyxPQUFPLFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkMsSUFBSSw4Q0FBOEM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUEyQyxJQUFJO0FBQ2pHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLElBQUk7QUFDeEUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQTJDLElBQUk7QUFDakcsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0Usb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlsRTtBQUN6bEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWJsZS1xdWl6Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9maXJlc3RvcmUvZGlzdC9pbmRleC5ub2RlLm1qcz82MmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVtb3ZlU2VydmljZUluc3RhbmNlLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiwgU0RLX1ZFUlNJT04gYXMgU0RLX1ZFUlNJT04kMSB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBpbnNwZWN0LCBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSBmcm9tICd1dGlsJztcbmltcG9ydCB7IEZpcmViYXNlRXJyb3IsIGNyZWF0ZU1vY2tVc2VyVG9rZW4sIGdldE1vZHVsYXJJbnN0YW5jZSwgZGVlcEVxdWFsLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQsIGdldFVBLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNTYWZhcmkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlcyQxIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEludGVnZXIsIE1kNSB9IGZyb20gJ0BmaXJlYmFzZS93ZWJjaGFubmVsLXdyYXBwZXInO1xuaW1wb3J0ICogYXMgZ3JwYyBmcm9tICdAZ3JwYy9ncnBjLWpzJztcbmltcG9ydCAqIGFzIHByb3RvTG9hZGVyIGZyb20gJ0BncnBjL3Byb3RvLWxvYWRlcic7XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiNC42LjFcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFNpbXBsZSB3cmFwcGVyIGFyb3VuZCBhIG51bGxhYmxlIFVJRC4gTW9zdGx5IGV4aXN0cyB0byBtYWtlIGNvZGUgbW9yZVxyXG4gKiByZWFkYWJsZS5cclxuICovXHJcbmNsYXNzIFVzZXIge1xyXG4gICAgY29uc3RydWN0b3IodWlkKSB7XHJcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XHJcbiAgICB9XHJcbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudWlkICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBrZXkgcmVwcmVzZW50aW5nIHRoaXMgdXNlciwgc3VpdGFibGUgZm9yIGluY2x1c2lvbiBpbiBhXHJcbiAgICAgKiBkaWN0aW9uYXJ5LlxyXG4gICAgICovXHJcbiAgICB0b0tleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3VpZDonICsgdGhpcy51aWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cy11c2VyJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyVXNlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlclVzZXIudWlkID09PSB0aGlzLnVpZDtcclxuICAgIH1cclxufVxyXG4vKiogQSB1c2VyIHdpdGggYSBudWxsIFVJRC4gKi9cclxuVXNlci5VTkFVVEhFTlRJQ0FURUQgPSBuZXcgVXNlcihudWxsKTtcclxuLy8gVE9ETyhtaWtlbGVoZW4pOiBMb29rIGludG8gZ2V0dGluZyBhIHByb3BlciB1aWQtZXF1aXZhbGVudCBmb3JcclxuLy8gbm9uLUZpcmViYXNlQXV0aCBwcm92aWRlcnMuXHJcblVzZXIuR09PR0xFX0NSRURFTlRJQUxTID0gbmV3IFVzZXIoJ2dvb2dsZS1jcmVkZW50aWFscy11aWQnKTtcclxuVXNlci5GSVJTVF9QQVJUWSA9IG5ldyBVc2VyKCdmaXJzdC1wYXJ0eS11aWQnKTtcclxuVXNlci5NT0NLX1VTRVIgPSBuZXcgVXNlcignbW9jay11c2VyJyk7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjEwLjExLjFcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gc2V0U0RLVmVyc2lvbih2ZXJzaW9uKSB7XHJcbiAgICBTREtfVkVSU0lPTiA9IHZlcnNpb247XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIEZvcm1hdHMgYW4gb2JqZWN0IGFzIGEgSlNPTiBzdHJpbmcsIHN1aXRhYmxlIGZvciBsb2dnaW5nLiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRKU09OKHZhbHVlKSB7XHJcbiAgICAvLyB1dGlsLmluc3BlY3QoKSByZXN1bHRzIGluIG11Y2ggbW9yZSByZWFkYWJsZSBvdXRwdXQgdGhhbiBKU09OLnN0cmluZ2lmeSgpXHJcbiAgICByZXR1cm4gaW5zcGVjdCh2YWx1ZSwgeyBkZXB0aDogMTAwIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9maXJlc3RvcmUnKTtcclxuLy8gSGVscGVyIG1ldGhvZHMgYXJlIG5lZWRlZCBiZWNhdXNlIHZhcmlhYmxlcyBjYW4ndCBiZSBleHBvcnRlZCBhcyByZWFkL3dyaXRlXHJcbmZ1bmN0aW9uIGdldExvZ0xldmVsKCkge1xyXG4gICAgcmV0dXJuIGxvZ0NsaWVudC5sb2dMZXZlbDtcclxufVxyXG4vKipcclxuICogU2V0cyB0aGUgdmVyYm9zaXR5IG9mIENsb3VkIEZpcmVzdG9yZSBsb2dzIChkZWJ1ZywgZXJyb3IsIG9yIHNpbGVudCkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2dMZXZlbCAtIFRoZSB2ZXJib3NpdHkgeW91IHNldCBmb3IgYWN0aXZpdHkgYW5kIGVycm9yIGxvZ2dpbmcuIENhblxyXG4gKiAgIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcclxuICpcclxuICogICA8dWw+XHJcbiAqICAgICA8bGk+YGRlYnVnYCBmb3IgdGhlIG1vc3QgdmVyYm9zZSBsb2dnaW5nIGxldmVsLCBwcmltYXJpbHkgZm9yXHJcbiAqICAgICBkZWJ1Z2dpbmcuPC9saT5cclxuICogICAgIDxsaT5gZXJyb3JgIHRvIGxvZyBlcnJvcnMgb25seS48L2xpPlxyXG4gKiAgICAgPGxpPjxjb2RlPmBzaWxlbnRgIHRvIHR1cm4gb2ZmIGxvZ2dpbmcuPC9saT5cclxuICogICA8L3VsPlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcclxuICAgIGxvZ0NsaWVudC5zZXRMb2dMZXZlbChsb2dMZXZlbCk7XHJcbn1cclxuZnVuY3Rpb24gbG9nRGVidWcobXNnLCAuLi5vYmopIHtcclxuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XHJcbiAgICAgICAgbG9nQ2xpZW50LmRlYnVnKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbG9nRXJyb3IobXNnLCAuLi5vYmopIHtcclxuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuRVJST1IpIHtcclxuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XHJcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbG9nV2Fybihtc2csIC4uLm9iaikge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5XQVJOKSB7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xyXG4gICAgICAgIGxvZ0NsaWVudC53YXJuKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIGFkZGl0aW9uYWwgbG9nIHBhcmFtZXRlciB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGFyZ1RvU3RyaW5nKG9iaikge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRKU09OKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgdG8gSlNPTiBmYWlsZWQsIGp1c3QgbG9nIHRoZSBvYmplY3QgZGlyZWN0bHlcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cclxuICogTWVzc2FnZXMgYXJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxyXG4gKlxyXG4gKiBSZXR1cm5zIGBuZXZlcmAgYW5kIGNhbiBiZSB1c2VkIGluIGV4cHJlc3Npb25zOlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBsZXQgZnV0dXJlVmFyID0gZmFpbCgnbm90IGltcGxlbWVudGVkIHlldCcpO1xyXG4gKi9cclxuZnVuY3Rpb24gZmFpbChmYWlsdXJlID0gJ1VuZXhwZWN0ZWQgc3RhdGUnKSB7XHJcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXHJcbiAgICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBGSVJFU1RPUkUgKCR7U0RLX1ZFUlNJT059KSBJTlRFUk5BTCBBU1NFUlRJT04gRkFJTEVEOiBgICsgZmFpbHVyZTtcclxuICAgIGxvZ0Vycm9yKG1lc3NhZ2UpO1xyXG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmVzdG9yZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcclxuICAgIC8vIHRoYXQgY2Fubm90IGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIuIChBbHNvIGl0IHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyXHJcbiAgICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcclxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXHJcbiAqXHJcbiAqIE1lc3NhZ2VzIGFyZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cclxuICovXHJcbmZ1bmN0aW9uIGhhcmRBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXHJcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxyXG4gKlxyXG4gKiBUaGUgY29kZSBvZiBjYWxsc2l0ZXMgaW52b2tpbmcgdGhpcyBmdW5jdGlvbiBhcmUgc3RyaXBwZWQgb3V0IGluIHByb2R1Y3Rpb25cclxuICogYnVpbGRzLiBBbnkgc2lkZS1lZmZlY3RzIG9mIGNvZGUgd2l0aGluIHRoZSBkZWJ1Z0Fzc2VydCgpIGludm9jYXRpb24gd2lsbCBub3RcclxuICogaGFwcGVuIGluIHRoaXMgY2FzZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWJ1Z0Fzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAuIEluIG5vbi1wcm9kdWN0aW9uIGJ1aWxkcywgdmVyaWZpZXMgdGhhdCBgb2JqYCBpcyBhblxyXG4gKiBpbnN0YW5jZSBvZiBgVGAgYmVmb3JlIGNhc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWJ1Z0Nhc3Qob2JqLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3RydWN0b3IpIHtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQ29kZSA9IHtcclxuICAgIC8vIENhdXNlcyBhcmUgY29waWVkIGZyb206XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxyXG4gICAgLyoqIE5vdCBhbiBlcnJvcjsgcmV0dXJuZWQgb24gc3VjY2Vzcy4gKi9cclxuICAgIE9LOiAnb2snLFxyXG4gICAgLyoqIFRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCAodHlwaWNhbGx5IGJ5IHRoZSBjYWxsZXIpLiAqL1xyXG4gICAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICAgIC8qKiBVbmtub3duIGVycm9yIG9yIGFuIGVycm9yIGZyb20gYSBkaWZmZXJlbnQgZXJyb3IgZG9tYWluLiAqL1xyXG4gICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGllbnQgc3BlY2lmaWVkIGFuIGludmFsaWQgYXJndW1lbnQuIE5vdGUgdGhhdCB0aGlzIGRpZmZlcnMgZnJvbVxyXG4gICAgICogRkFJTEVEX1BSRUNPTkRJVElPTi4gSU5WQUxJRF9BUkdVTUVOVCBpbmRpY2F0ZXMgYXJndW1lbnRzIHRoYXQgYXJlXHJcbiAgICAgKiBwcm9ibGVtYXRpYyByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZSBvZiB0aGUgc3lzdGVtIChlLmcuLCBhIG1hbGZvcm1lZCBmaWxlXHJcbiAgICAgKiBuYW1lKS5cclxuICAgICAqL1xyXG4gICAgSU5WQUxJRF9BUkdVTUVOVDogJ2ludmFsaWQtYXJndW1lbnQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFkbGluZSBleHBpcmVkIGJlZm9yZSBvcGVyYXRpb24gY291bGQgY29tcGxldGUuIEZvciBvcGVyYXRpb25zIHRoYXRcclxuICAgICAqIGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIHN5c3RlbSwgdGhpcyBlcnJvciBtYXkgYmUgcmV0dXJuZWQgZXZlbiBpZiB0aGVcclxuICAgICAqIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gRm9yIGV4YW1wbGUsIGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxyXG4gICAgICogZnJvbSBhIHNlcnZlciBjb3VsZCBoYXZlIGJlZW4gZGVsYXllZCBsb25nIGVub3VnaCBmb3IgdGhlIGRlYWRsaW5lIHRvXHJcbiAgICAgKiBleHBpcmUuXHJcbiAgICAgKi9cclxuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxyXG4gICAgLyoqIFNvbWUgcmVxdWVzdGVkIGVudGl0eSAoZS5nLiwgZmlsZSBvciBkaXJlY3RvcnkpIHdhcyBub3QgZm91bmQuICovXHJcbiAgICBOT1RfRk9VTkQ6ICdub3QtZm91bmQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIGVudGl0eSB0aGF0IHdlIGF0dGVtcHRlZCB0byBjcmVhdGUgKGUuZy4sIGZpbGUgb3IgZGlyZWN0b3J5KSBhbHJlYWR5XHJcbiAgICAgKiBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIEFMUkVBRFlfRVhJU1RTOiAnYWxyZWFkeS1leGlzdHMnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGVyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIHRoZSBzcGVjaWZpZWQgb3BlcmF0aW9uLlxyXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBmb3IgcmVqZWN0aW9ucyBjYXVzZWQgYnkgZXhoYXVzdGluZ1xyXG4gICAgICogc29tZSByZXNvdXJjZSAodXNlIFJFU09VUkNFX0VYSEFVU1RFRCBpbnN0ZWFkIGZvciB0aG9zZSBlcnJvcnMpLlxyXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBpZiB0aGUgY2FsbGVyIGNhbiBub3QgYmUgaWRlbnRpZmllZFxyXG4gICAgICogKHVzZSBVTkFVVEhFTlRJQ0FURUQgaW5zdGVhZCBmb3IgdGhvc2UgZXJyb3JzKS5cclxuICAgICAqL1xyXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXF1ZXN0IGRvZXMgbm90IGhhdmUgdmFsaWQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgZm9yIHRoZVxyXG4gICAgICogb3BlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIHJlc291cmNlIGhhcyBiZWVuIGV4aGF1c3RlZCwgcGVyaGFwcyBhIHBlci11c2VyIHF1b3RhLCBvciBwZXJoYXBzIHRoZVxyXG4gICAgICogZW50aXJlIGZpbGUgc3lzdGVtIGlzIG91dCBvZiBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogT3BlcmF0aW9uIHdhcyByZWplY3RlZCBiZWNhdXNlIHRoZSBzeXN0ZW0gaXMgbm90IGluIGEgc3RhdGUgcmVxdWlyZWQgZm9yXHJcbiAgICAgKiB0aGUgb3BlcmF0aW9uJ3MgZXhlY3V0aW9uLiBGb3IgZXhhbXBsZSwgZGlyZWN0b3J5IHRvIGJlIGRlbGV0ZWQgbWF5IGJlXHJcbiAgICAgKiBub24tZW1wdHksIGFuIHJtZGlyIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIGEgbm9uLWRpcmVjdG9yeSwgZXRjLlxyXG4gICAgICpcclxuICAgICAqIEEgbGl0bXVzIHRlc3QgdGhhdCBtYXkgaGVscCBhIHNlcnZpY2UgaW1wbGVtZW50b3IgaW4gZGVjaWRpbmdcclxuICAgICAqIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiwgQUJPUlRFRCwgYW5kIFVOQVZBSUxBQkxFOlxyXG4gICAgICogIChhKSBVc2UgVU5BVkFJTEFCTEUgaWYgdGhlIGNsaWVudCBjYW4gcmV0cnkganVzdCB0aGUgZmFpbGluZyBjYWxsLlxyXG4gICAgICogIChiKSBVc2UgQUJPUlRFRCBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeSBhdCBhIGhpZ2hlci1sZXZlbFxyXG4gICAgICogICAgICAoZS5nLiwgcmVzdGFydGluZyBhIHJlYWQtbW9kaWZ5LXdyaXRlIHNlcXVlbmNlKS5cclxuICAgICAqICAoYykgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVudGlsXHJcbiAgICAgKiAgICAgIHRoZSBzeXN0ZW0gc3RhdGUgaGFzIGJlZW4gZXhwbGljaXRseSBmaXhlZC4gRS5nLiwgaWYgYW4gXCJybWRpclwiXHJcbiAgICAgKiAgICAgIGZhaWxzIGJlY2F1c2UgdGhlIGRpcmVjdG9yeSBpcyBub24tZW1wdHksIEZBSUxFRF9QUkVDT05ESVRJT05cclxuICAgICAqICAgICAgc2hvdWxkIGJlIHJldHVybmVkIHNpbmNlIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXRyeSB1bmxlc3NcclxuICAgICAqICAgICAgdGhleSBoYXZlIGZpcnN0IGZpeGVkIHVwIHRoZSBkaXJlY3RvcnkgYnkgZGVsZXRpbmcgZmlsZXMgZnJvbSBpdC5cclxuICAgICAqICAoZCkgVXNlIEZBSUxFRF9QUkVDT05ESVRJT04gaWYgdGhlIGNsaWVudCBwZXJmb3JtcyBjb25kaXRpb25hbFxyXG4gICAgICogICAgICBSRVNUIEdldC9VcGRhdGUvRGVsZXRlIG9uIGEgcmVzb3VyY2UgYW5kIHRoZSByZXNvdXJjZSBvbiB0aGVcclxuICAgICAqICAgICAgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBjb25kaXRpb24uIEUuZy4sIGNvbmZsaWN0aW5nXHJcbiAgICAgKiAgICAgIHJlYWQtbW9kaWZ5LXdyaXRlIG9uIHRoZSBzYW1lIHJlc291cmNlLlxyXG4gICAgICovXHJcbiAgICBGQUlMRURfUFJFQ09ORElUSU9OOiAnZmFpbGVkLXByZWNvbmRpdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQsIHR5cGljYWxseSBkdWUgdG8gYSBjb25jdXJyZW5jeSBpc3N1ZSBsaWtlXHJcbiAgICAgKiBzZXF1ZW5jZXIgY2hlY2sgZmFpbHVyZXMsIHRyYW5zYWN0aW9uIGFib3J0cywgZXRjLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxyXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxyXG4gICAgICovXHJcbiAgICBBQk9SVEVEOiAnYWJvcnRlZCcsXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbiB3YXMgYXR0ZW1wdGVkIHBhc3QgdGhlIHZhbGlkIHJhbmdlLiBFLmcuLCBzZWVraW5nIG9yIHJlYWRpbmdcclxuICAgICAqIHBhc3QgZW5kIG9mIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogVW5saWtlIElOVkFMSURfQVJHVU1FTlQsIHRoaXMgZXJyb3IgaW5kaWNhdGVzIGEgcHJvYmxlbSB0aGF0IG1heSBiZSBmaXhlZFxyXG4gICAgICogaWYgdGhlIHN5c3RlbSBzdGF0ZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSAzMi1iaXQgZmlsZSBzeXN0ZW0gd2lsbFxyXG4gICAgICogZ2VuZXJhdGUgSU5WQUxJRF9BUkdVTUVOVCBpZiBhc2tlZCB0byByZWFkIGF0IGFuIG9mZnNldCB0aGF0IGlzIG5vdCBpbiB0aGVcclxuICAgICAqIHJhbmdlIFswLDJeMzItMV0sIGJ1dCBpdCB3aWxsIGdlbmVyYXRlIE9VVF9PRl9SQU5HRSBpZiBhc2tlZCB0byByZWFkIGZyb21cclxuICAgICAqIGFuIG9mZnNldCBwYXN0IHRoZSBjdXJyZW50IGZpbGUgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGVyZSBpcyBhIGZhaXIgYml0IG9mIG92ZXJsYXAgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OIGFuZFxyXG4gICAgICogT1VUX09GX1JBTkdFLiBXZSByZWNvbW1lbmQgdXNpbmcgT1VUX09GX1JBTkdFICh0aGUgbW9yZSBzcGVjaWZpYyBlcnJvcilcclxuICAgICAqIHdoZW4gaXQgYXBwbGllcyBzbyB0aGF0IGNhbGxlcnMgd2hvIGFyZSBpdGVyYXRpbmcgdGhyb3VnaCBhIHNwYWNlIGNhblxyXG4gICAgICogZWFzaWx5IGxvb2sgZm9yIGFuIE9VVF9PRl9SQU5HRSBlcnJvciB0byBkZXRlY3Qgd2hlbiB0aGV5IGFyZSBkb25lLlxyXG4gICAgICovXHJcbiAgICBPVVRfT0ZfUkFOR0U6ICdvdXQtb2YtcmFuZ2UnLFxyXG4gICAgLyoqIE9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgb3Igbm90IHN1cHBvcnRlZC9lbmFibGVkIGluIHRoaXMgc2VydmljZS4gKi9cclxuICAgIFVOSU1QTEVNRU5URUQ6ICd1bmltcGxlbWVudGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZXJyb3JzLiBNZWFucyBzb21lIGludmFyaWFudHMgZXhwZWN0ZWQgYnkgdW5kZXJseWluZyBTeXN0ZW0gaGFzXHJcbiAgICAgKiBiZWVuIGJyb2tlbi4gSWYgeW91IHNlZSBvbmUgb2YgdGhlc2UgZXJyb3JzLCBTb21ldGhpbmcgaXMgdmVyeSBicm9rZW4uXHJcbiAgICAgKi9cclxuICAgIElOVEVSTkFMOiAnaW50ZXJuYWwnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFRoaXMgaXMgYSBtb3N0IGxpa2VseSBhIHRyYW5zaWVudFxyXG4gICAgICogY29uZGl0aW9uIGFuZCBtYXkgYmUgY29ycmVjdGVkIGJ5IHJldHJ5aW5nIHdpdGggYSBiYWNrb2ZmLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxyXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxyXG4gICAgICovXHJcbiAgICBVTkFWQUlMQUJMRTogJ3VuYXZhaWxhYmxlJyxcclxuICAgIC8qKiBVbnJlY292ZXJhYmxlIGRhdGEgbG9zcyBvciBjb3JydXB0aW9uLiAqL1xyXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xyXG59O1xyXG4vKiogQW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgb3BlcmF0aW9uLiAqL1xyXG5jbGFzcyBGaXJlc3RvcmVFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFja2VuZCBlcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBjb2RlLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBjdXN0b20gZXJyb3IgZGVzY3JpcHRpb24uXHJcbiAgICAgKi9cclxuICAgIG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcihjb2RlLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgLy8gSEFDSzogV2Ugd3JpdGUgYSB0b1N0cmluZyBwcm9wZXJ0eSBkaXJlY3RseSBiZWNhdXNlIEVycm9yIGlzIG5vdCBhIHJlYWxcclxuICAgICAgICAvLyBjbGFzcyBhbmQgc28gaW5oZXJpdGFuY2UgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkuIFdlIGNvdWxkIGFsdGVybmF0aXZlbHlcclxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBcImJhY2stZG9vciBpbmhlcml0YW5jZVwiIHRyaWNrIHRoYXQgRmlyZWJhc2VFcnJvciBkb2VzLlxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLm5hbWV9OiBbY29kZT0ke3RoaXMuY29kZX1dOiAke3RoaXMubWVzc2FnZX1gO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERlZmVycmVkIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgT0F1dGhUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ09BdXRoJztcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt2YWx1ZX1gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cclxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5VTkFVVEhFTlRJQ0FURUQpKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbn1cclxuLyoqXHJcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyByZXR1cm5zIGEgY29uc3RhbnQgdG9rZW4uIFVzZWQgZm9yXHJcbiAqIGVtdWxhdG9yIHRva2VuIG1vY2tpbmcuXHJcbiAqL1xyXG5jbGFzcyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyB0aGUgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIHNldENoYW5nZUxpc3RlbmVyKClcclxuICAgICAgICAgKiBUaGlzIGlzbid0IGFjdHVhbGx5IG5lY2Vzc2FyeSBzaW5jZSB0aGUgVUlEIG5ldmVyIGNoYW5nZXMsIGJ1dCB3ZSB1c2UgdGhpc1xyXG4gICAgICAgICAqIHRvIHZlcmlmeSB0aGUgbGlzdGVuIGNvbnRyYWN0IGlzIGFkaGVyZWQgdG8gaW4gdGVzdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW4pO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBjaGFuZ2VMaXN0ZW5lcjtcclxuICAgICAgICAvLyBGaXJlIHdpdGggaW5pdGlhbCB1c2VyLlxyXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcih0aGlzLnRva2VuLnVzZXIpKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIgPSBhdXRoUHJvdmlkZXI7XHJcbiAgICAgICAgLyoqIFRyYWNrcyB0aGUgY3VycmVudCBVc2VyLiAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBVc2VyLlVOQVVUSEVOVElDQVRFRDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudGVyIHVzZWQgdG8gZGV0ZWN0IGlmIHRoZSB0b2tlbiBjaGFuZ2VkIHdoaWxlIGEgZ2V0VG9rZW4gcmVxdWVzdCB3YXNcclxuICAgICAgICAgKiBvdXRzdGFuZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRva2VuQ291bnRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF1dGggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICBsZXQgbGFzdFRva2VuSWQgPSB0aGlzLnRva2VuQ291bnRlcjtcclxuICAgICAgICAvLyBBIGNoYW5nZSBsaXN0ZW5lciB0aGF0IHByZXZlbnRzIGRvdWJsZS1maXJpbmcgZm9yIHRoZSBzYW1lIHRva2VuIGNoYW5nZS5cclxuICAgICAgICBjb25zdCBndWFyZGVkQ2hhbmdlTGlzdGVuZXIgPSB1c2VyID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Db3VudGVyICE9PSBsYXN0VG9rZW5JZCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdFRva2VuSWQgPSB0aGlzLnRva2VuQ291bnRlcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VMaXN0ZW5lcih1c2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQSBwcm9taXNlIHRoYXQgY2FuIGJlIHdhaXRlZCBvbiB0byBibG9jayBvbiB0aGUgbmV4dCB0b2tlbiBjaGFuZ2UuXHJcbiAgICAgICAgLy8gVGhpcyBwcm9taXNlIGlzIHJlLWNyZWF0ZWQgYWZ0ZXIgZWFjaCBjaGFuZ2UuXHJcbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50b2tlbkNvdW50ZXIrKztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHRoaXMuZ2V0VXNlcigpO1xyXG4gICAgICAgICAgICBuZXh0VG9rZW4ucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRVc2VyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhd2FpdE5leHRUb2tlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRva2VuQXR0ZW1wdCA9IG5leHRUb2tlbjtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUb2tlbkF0dGVtcHQucHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRVc2VyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZWdpc3RlckF1dGggPSAoYXV0aCkgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdBdXRoIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aC5hZGRBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBhd2FpdE5leHRUb2tlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIub25Jbml0KGF1dGggPT4gcmVnaXN0ZXJBdXRoKGF1dGgpKTtcclxuICAgICAgICAvLyBPdXIgdXNlcnMgY2FuIGluaXRpYWxpemUgQXV0aCByaWdodCBhZnRlciBGaXJlc3RvcmUsIHNvIHdlIGdpdmUgaXRcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgY29tcG9uZW50IGZyYW1ld29yayBiZWZvcmUgd2VcclxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0byBzdGFydCB1cCBpbiB1bmF1dGhlbnRpY2F0ZWQgbW9kZS5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGggPSB0aGlzLmF1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChhdXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJBdXRoKGF1dGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXV0aCBpcyBzdGlsbCBub3QgYXZhaWxhYmxlLCBwcm9jZWVkIHdpdGggYG51bGxgIHVzZXJcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdBdXRoIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4ucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgYXdhaXROZXh0VG9rZW4oKTtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIC8vIFRha2Ugbm90ZSBvZiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdG9rZW5Db3VudGVyIHNvIHRoYXQgdGhpcyBtZXRob2RcclxuICAgICAgICAvLyBjYW4gZmFpbCAod2l0aCBhbiBBQk9SVEVEIGVycm9yKSBpZiB0aGVyZSBpcyBhIHRva2VuIGNoYW5nZSB3aGlsZSB0aGVcclxuICAgICAgICAvLyByZXF1ZXN0IGlzIG91dHN0YW5kaW5nLlxyXG4gICAgICAgIGNvbnN0IGluaXRpYWxUb2tlbkNvdW50ZXIgPSB0aGlzLnRva2VuQ291bnRlcjtcclxuICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlUmVmcmVzaDtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuRGF0YSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdCBzaW5jZSB0aGUgdG9rZW4gY2hhbmdlZCB3aGlsZSB0aGUgcmVxdWVzdCB3YXNcclxuICAgICAgICAgICAgLy8gb3V0c3RhbmRpbmcgc28gdGhlIHJlc3BvbnNlIGlzIHBvdGVudGlhbGx5IGZvciBhIHByZXZpb3VzIHVzZXIgKHdoaWNoXHJcbiAgICAgICAgICAgIC8vIHVzZXIsIHdlIGNhbid0IGJlIHN1cmUpLlxyXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkNvdW50ZXIgIT09IGluaXRpYWxUb2tlbkNvdW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ2dldFRva2VuIGFib3J0ZWQgZHVlIHRvIHRva2VuIGNoYW5nZS4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0eXBlb2YgdG9rZW5EYXRhLmFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPQXV0aFRva2VuKHRva2VuRGF0YS5hY2Nlc3NUb2tlbiwgdGhpcy5jdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkge1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQXV0aC5nZXRVaWQoKSBjYW4gcmV0dXJuIG51bGwgZXZlbiB3aXRoIGEgdXNlciBsb2dnZWQgaW4uIEl0IGlzIGJlY2F1c2VcclxuICAgIC8vIGdldFVpZCgpIGlzIHN5bmNocm9ub3VzLCBidXQgdGhlIGF1dGggY29kZSBwb3B1bGF0aW5nIFVpZCBpcyBhc3luY2hyb25vdXMuXHJcbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgaW4gdGhlIEF1dGhUb2tlbkxpc3RlbmVyIGNhbGxiYWNrXHJcbiAgICAvLyB0byBndWFyYW50ZWUgdG8gZ2V0IHRoZSBhY3R1YWwgdXNlci5cclxuICAgIGdldFVzZXIoKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFVpZCA9IHRoaXMuYXV0aCAmJiB0aGlzLmF1dGguZ2V0VWlkKCk7XHJcbiAgICAgICAgaGFyZEFzc2VydChjdXJyZW50VWlkID09PSBudWxsIHx8IHR5cGVvZiBjdXJyZW50VWlkID09PSAnc3RyaW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyKGN1cnJlbnRVaWQpO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbiAqIEZpcnN0UGFydHlUb2tlbiBwcm92aWRlcyBhIGZyZXNoIHRva2VuIGVhY2ggdGltZSBpdHMgdmFsdWVcclxuICogaXMgcmVxdWVzdGVkLCBiZWNhdXNlIGlmIHRoZSB0b2tlbiBpcyB0b28gb2xkLCByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkLlxyXG4gKiBUZWNobmljYWxseSB0aGlzIG1heSBubyBsb25nZXIgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBTREsgc2hvdWxkIGdyYWNlZnVsbHlcclxuICogcmVjb3ZlciBmcm9tIHVuYXV0aGVudGljYXRlZCBlcnJvcnMgKHNlZSBiLzMzMTQ3ODE4IGZvciBjb250ZXh0KSwgYnV0IGl0J3NcclxuICogc2FmZXIgdG8ga2VlcCB0aGUgaW1wbGVtZW50YXRpb24gYXMtaXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJzdFBhcnR5VG9rZW4ge1xyXG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbkluZGV4ID0gc2Vzc2lvbkluZGV4O1xyXG4gICAgICAgIHRoaXMuaWFtVG9rZW4gPSBpYW1Ub2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdGaXJzdFBhcnR5JztcclxuICAgICAgICB0aGlzLnVzZXIgPSBVc2VyLkZJUlNUX1BBUlRZO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgdXNpbmcgYSBwcm92aWRlZCBmYWN0b3J5IGZ1bmN0aW9uLCBvciByZXR1cm5cclxuICAgICAqIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGdldEF1dGhUb2tlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5GYWN0b3J5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dGhUb2tlbkZhY3RvcnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBoZWFkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctQXV0aFVzZXInLCB0aGlzLnNlc3Npb25JbmRleCk7XHJcbiAgICAgICAgLy8gVXNlIGFycmF5IG5vdGF0aW9uIHRvIHByZXZlbnQgbWluaWZpY2F0aW9uXHJcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlclRva2VuVmFsdWUgPSB0aGlzLmdldEF1dGhUb2tlbigpO1xyXG4gICAgICAgIGlmIChhdXRoSGVhZGVyVG9rZW5WYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXJUb2tlblZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaWFtVG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ1gtR29vZy1JYW0tQXV0aG9yaXphdGlvbi1Ub2tlbicsIHRoaXMuaWFtVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVycztcclxuICAgIH1cclxufVxyXG4vKlxyXG4gKiBQcm92aWRlcyB1c2VyIGNyZWRlbnRpYWxzIHJlcXVpcmVkIGZvciB0aGUgRmlyZXN0b3JlIEphdmFTY3JpcHQgU0RLXHJcbiAqIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdXNlciwgdXNpbmcgdGVjaG5pcXVlIHRoYXQgaXMgb25seSBhdmFpbGFibGVcclxuICogdG8gYXBwbGljYXRpb25zIGhvc3RlZCBieSBHb29nbGUuXHJcbiAqL1xyXG5jbGFzcyBGaXJzdFBhcnR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbkluZGV4ID0gc2Vzc2lvbkluZGV4O1xyXG4gICAgICAgIHRoaXMuaWFtVG9rZW4gPSBpYW1Ub2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlyc3RQYXJ0eVRva2VuKHRoaXMuc2Vzc2lvbkluZGV4LCB0aGlzLmlhbVRva2VuLCB0aGlzLmF1dGhUb2tlbkZhY3RvcnkpKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdWlkLlxyXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcihVc2VyLkZJUlNUX1BBUlRZKSk7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHsgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XHJcbn1cclxuY2xhc3MgQXBwQ2hlY2tUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnQXBwQ2hlY2snO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCd4LWZpcmViYXNlLWFwcGNoZWNrJywgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXIgPSBhcHBDaGVja1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3Qgb25Ub2tlbkNoYW5nZWQgPSB0b2tlblJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlblJlc3VsdC5lcnJvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCBgRXJyb3IgZ2V0dGluZyBBcHAgQ2hlY2sgdG9rZW47IHVzaW5nIHBsYWNlaG9sZGVyIHRva2VuIGluc3RlYWQuIEVycm9yOiAke3Rva2VuUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG9rZW5VcGRhdGVkID0gdG9rZW5SZXN1bHQudG9rZW4gIT09IHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gdG9rZW5SZXN1bHQudG9rZW47XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBSZWNlaXZlZCAke3Rva2VuVXBkYXRlZCA/ICduZXcnIDogJ2V4aXN0aW5nJ30gdG9rZW4uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlblVwZGF0ZWRcclxuICAgICAgICAgICAgICAgID8gY2hhbmdlTGlzdGVuZXIodG9rZW5SZXN1bHQudG9rZW4pXHJcbiAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKHRva2VuUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBvblRva2VuQ2hhbmdlZCh0b2tlblJlc3VsdCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJBcHBDaGVjayA9IChhcHBDaGVjaykgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVjayA9IGFwcENoZWNrO1xyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlci5vbkluaXQoYXBwQ2hlY2sgPT4gcmVnaXN0ZXJBcHBDaGVjayhhcHBDaGVjaykpO1xyXG4gICAgICAgIC8vIE91ciB1c2VycyBjYW4gaW5pdGlhbGl6ZSBBcHBDaGVjayBhZnRlciBGaXJlc3RvcmUsIHNvIHdlIGdpdmUgaXRcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgY29tcG9uZW50IGZyYW1ld29yay5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBDaGVjayA9IHRoaXMuYXBwQ2hlY2tQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBDaGVjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXBwQ2hlY2soYXBwQ2hlY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgQXBwQ2hlY2sgaXMgc3RpbGwgbm90IGF2YWlsYWJsZSwgcHJvY2VlZCB3aXRob3V0IGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsICdBcHBDaGVjayBub3QgeWV0IGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIGNvbnN0IGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VSZWZyZXNoO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcENoZWNrLmdldFRva2VuKGZvcmNlUmVmcmVzaCkudGhlbih0b2tlblJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlblJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0eXBlb2YgdG9rZW5SZXN1bHQudG9rZW4gPT09ICdzdHJpbmcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IHRva2VuUmVzdWx0LnRva2VuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcHBDaGVja1Rva2VuKHRva2VuUmVzdWx0LnRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVjay5yZW1vdmVUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBBcHBDaGVjayB0b2tlbiBwcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXBwQ2hlY2tUb2tlbignJykpO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikgeyB9XHJcbiAgICBzaHV0ZG93bigpIHsgfVxyXG59XHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBDcmVkZW50aWFsc1Byb3ZpZGVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZlxyXG4gKiB0aGUgY3JlZGVudGlhbHMgcGFzc2VkIGluLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzKSB7XHJcbiAgICBpZiAoIWNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKCk7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGNyZWRlbnRpYWxzWyd0eXBlJ10pIHtcclxuICAgICAgICBjYXNlICdmaXJzdFBhcnR5JzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXJzdFBhcnR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHNbJ3Nlc3Npb25JbmRleCddIHx8ICcwJywgY3JlZGVudGlhbHNbJ2lhbVRva2VuJ10gfHwgbnVsbCwgY3JlZGVudGlhbHNbJ2F1dGhUb2tlbkZhY3RvcnknXSB8fCBudWxsKTtcclxuICAgICAgICBjYXNlICdwcm92aWRlcic6XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVkZW50aWFsc1snY2xpZW50J107XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ21ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciBmYWlsZWQgZHVlIHRvIGludmFsaWQgY3JlZGVudGlhbCB0eXBlJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBgbkJ5dGVzYCBvZiByYW5kb20gYnl0ZXMuXHJcbiAqXHJcbiAqIElmIGBuQnl0ZXMgPCAwYCAsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobkJ5dGVzKSB7XHJcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMkMShuQnl0ZXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGFscGhhbnVtZXJpYyBJRHMgb2YgYSBzcGVjaWZpZWQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogRXhwb3J0ZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cclxuICovXHJcbmNsYXNzIEF1dG9JZCB7XHJcbiAgICBzdGF0aWMgbmV3SWQoKSB7XHJcbiAgICAgICAgLy8gQWxwaGFudW1lcmljIGNoYXJhY3RlcnNcclxuICAgICAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgLy8gVGhlIGxhcmdlc3QgYnl0ZSB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgYGNoYXIubGVuZ3RoYC5cclxuICAgICAgICBjb25zdCBtYXhNdWx0aXBsZSA9IE1hdGguZmxvb3IoMjU2IC8gY2hhcnMubGVuZ3RoKSAqIGNoYXJzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYXV0b0lkID0gJyc7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gMjA7XHJcbiAgICAgICAgd2hpbGUgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByYW5kb21CeXRlcyg0MCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IGFyZSBbMCwgbWF4TXVsdGlwbGUpLCB0aGlzIGVuc3VyZXMgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIGV2ZW5seSBtYXBwZWQgdG8gaW5kaWNlcyBvZiBgY2hhcnNgIHZpYSBhIG1vZHVsbyBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0b0lkLmxlbmd0aCA8IHRhcmdldExlbmd0aCAmJiBieXRlc1tpXSA8IG1heE11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b0lkICs9IGNoYXJzLmNoYXJBdChieXRlc1tpXSAlIGNoYXJzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF1dG9JZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQgPiByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuLyoqIEhlbHBlciB0byBjb21wYXJlIGFycmF5cyB1c2luZyBpc0VxdWFsKCkuICovXHJcbmZ1bmN0aW9uIGFycmF5RXF1YWxzKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0LmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGNvbXBhcmF0b3IodmFsdWUsIHJpZ2h0W2luZGV4XSkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbW1lZGlhdGUgbGV4aWNvZ3JhcGhpY2FsbHktZm9sbG93aW5nIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgdG9cclxuICogY29uc3RydWN0IGFuIGluY2x1c2l2ZSByYW5nZSBmb3IgaW5kZXhlZGRiIGl0ZXJhdG9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGltbWVkaWF0ZVN1Y2Nlc3NvcihzKSB7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGlucHV0IHN0cmluZywgd2l0aCBhbiBhZGRpdGlvbmFsIE5VTCBieXRlIGFwcGVuZGVkLlxyXG4gICAgcmV0dXJuIHMgKyAnXFwwJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUaGUgZWFybGllc3QgZGF0ZSBzdXBwb3J0ZWQgYnkgRmlyZXN0b3JlIHRpbWVzdGFtcHMgKDAwMDEtMDEtMDFUMDA6MDA6MDBaKS5cclxuY29uc3QgTUlOX1NFQ09ORFMgPSAtNjIxMzU1OTY4MDA7XHJcbi8vIE51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiBhIG1pbGxpc2Vjb25kLlxyXG5jb25zdCBNU19UT19OQU5PUyA9IDFlNjtcclxuLyoqXHJcbiAqIEEgYFRpbWVzdGFtcGAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvclxyXG4gKiBjYWxlbmRhciwgcmVwcmVzZW50ZWQgYXMgc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXQgbmFub3NlY29uZFxyXG4gKiByZXNvbHV0aW9uIGluIFVUQyBFcG9jaCB0aW1lLlxyXG4gKlxyXG4gKiBJdCBpcyBlbmNvZGVkIHVzaW5nIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXHJcbiAqIEdyZWdvcmlhbiBjYWxlbmRhciBiYWNrd2FyZHMgdG8geWVhciBvbmUuIEl0IGlzIGVuY29kZWQgYXNzdW1pbmcgYWxsIG1pbnV0ZXNcclxuICogYXJlIDYwIHNlY29uZHMgbG9uZywgaS5lLiBsZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcCBzZWNvbmRcclxuICogdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbi4gUmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xyXG4gKiA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlcyBhbmQgZnVydGhlciBzcGVjaWZpY2F0aW9ucywgcmVmZXIgdG8gdGhlXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3Byb3RvYnVmL2Jsb2IvbWFzdGVyL3NyYy9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIHwgVGltZXN0YW1wIGRlZmluaXRpb259LlxyXG4gKi9cclxuY2xhc3MgVGltZXN0YW1wIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxyXG4gICAgICogICAgIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cclxuICAgICAqICAgICA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXHJcbiAgICAgKiBAcGFyYW0gbmFub3NlY29uZHMgLSBUaGUgbm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kXHJcbiAgICAgKiAgICAgcmVzb2x1dGlvbi4gTmVnYXRpdmUgc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmVcclxuICAgICAqICAgICBub24tbmVnYXRpdmUgbmFub3NlY29uZHMgdmFsdWVzIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlXHJcbiAgICAgKiAgICAgZnJvbSAwIHRvIDk5OSw5OTksOTk5IGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxyXG4gICAgICovXHJcbiAgICBzZWNvbmRzLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uKlxyXG4gICAgICovXHJcbiAgICBuYW5vc2Vjb25kcykge1xyXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY29uZHM7XHJcbiAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzO1xyXG4gICAgICAgIGlmIChuYW5vc2Vjb25kcyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYW5vc2Vjb25kcyA+PSAxZTkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWNvbmRzIDwgTUlOX1NFQ09ORFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHdpbGwgYnJlYWsgaW4gdGhlIHllYXIgMTAsMDAwLlxyXG4gICAgICAgIGlmIChzZWNvbmRzID49IDI1MzQwMjMwMDgwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCB3aXRoIHRoZSBjdXJyZW50IGRhdGUsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wIGZyb20gdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBpbml0aWFsaXplIHRoZSBgVGltZXN0YW1wYCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXHJcbiAgICAgKiAgICAgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2hcclxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIHRoZSBnaXZlblxyXG4gICAgICogICAgIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IG5hbm9zID0gTWF0aC5mbG9vcigobWlsbGlzZWNvbmRzIC0gc2Vjb25kcyAqIDEwMDApICogTVNfVE9fTkFOT1MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHNlY29uZHMsIG5hbm9zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdC4gVGhpcyBjb252ZXJzaW9uXHJcbiAgICAgKiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbiBzaW5jZSBgRGF0ZWAgb2JqZWN0cyBvbmx5IHN1cHBvcnQgbWlsbGlzZWNvbmRcclxuICAgICAqIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXNcclxuICAgICAqICAgICB0aGlzIGBUaW1lc3RhbXBgLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cclxuICAgICAqL1xyXG4gICAgdG9EYXRlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRvTWlsbGlzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGBUaW1lc3RhbXBgIHRvIGEgbnVtZXJpYyB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcyBzaW5jZVxyXG4gICAgICogZXBvY2gpLiBUaGlzIG9wZXJhdGlvbiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW4gdGltZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgdGltZXN0YW1wLCByZXByZXNlbnRlZCBhc1xyXG4gICAgICogICAgIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXHJcbiAgICAgKi9cclxuICAgIHRvTWlsbGlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKiAxMDAwICsgdGhpcy5uYW5vc2Vjb25kcyAvIE1TX1RPX05BTk9TO1xyXG4gICAgfVxyXG4gICAgX2NvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMgPT09IG90aGVyLnNlY29uZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5uYW5vc2Vjb25kcywgb3RoZXIubmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLnNlY29uZHMsIG90aGVyLnNlY29uZHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgVGltZXN0YW1wYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgVGltZXN0YW1wYCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqL1xyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIuc2Vjb25kcyA9PT0gdGhpcy5zZWNvbmRzICYmIG90aGVyLm5hbm9zZWNvbmRzID09PSB0aGlzLm5hbm9zZWNvbmRzKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnVGltZXN0YW1wKHNlY29uZHM9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcyArXHJcbiAgICAgICAgICAgICcsIG5hbm9zZWNvbmRzPScgK1xyXG4gICAgICAgICAgICB0aGlzLm5hbm9zZWNvbmRzICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVGltZXN0YW1wYC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBzZWNvbmRzOiB0aGlzLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aGlzLm5hbm9zZWNvbmRzIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgb2JqZWN0IHRvIGEgcHJpbWl0aXZlIHN0cmluZywgd2hpY2ggYWxsb3dzIGBUaW1lc3RhbXBgIG9iamVjdHNcclxuICAgICAqIHRvIGJlIGNvbXBhcmVkIHVzaW5nIHRoZSBgPmAsIGA8PWAsIGA+PWAgYW5kIGA+YCBvcGVyYXRvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhbHVlT2YoKSB7XHJcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZm9ybSA8c2Vjb25kcz4uPG5hbm9zZWNvbmRzPiB3aGVyZVxyXG4gICAgICAgIC8vIDxzZWNvbmRzPiBpcyB0cmFuc2xhdGVkIHRvIGhhdmUgYSBub24tbmVnYXRpdmUgdmFsdWUgYW5kIGJvdGggPHNlY29uZHM+XHJcbiAgICAgICAgLy8gYW5kIDxuYW5vc2Vjb25kcz4gYXJlIGxlZnQtcGFkZGVkIHdpdGggemVyb2VzIHRvIGJlIGEgY29uc2lzdGVudCBsZW5ndGguXHJcbiAgICAgICAgLy8gU3RyaW5ncyB3aXRoIHRoaXMgZm9ybWF0IHRoZW4gaGF2ZSBhIGxleGlvZ3JhcGhpY2FsIG9yZGVyaW5nIHRoYXQgbWF0Y2hlc1xyXG4gICAgICAgIC8vIHRoZSBleHBlY3RlZCBvcmRlcmluZy4gVGhlIDxzZWNvbmRzPiB0cmFuc2xhdGlvbiBpcyBkb25lIHRvIGF2b2lkIGhhdmluZ1xyXG4gICAgICAgIC8vIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduIChpLmUuIGEgbGVhZGluZyAnLScgY2hhcmFjdGVyKSBpbiBpdHMgc3RyaW5nXHJcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdoaWNoIHdvdWxkIGFmZmVjdCBpdHMgbGV4aW9ncmFwaGljYWwgb3JkZXJpbmcuXHJcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTZWNvbmRzID0gdGhpcy5zZWNvbmRzIC0gTUlOX1NFQ09ORFM7XHJcbiAgICAgICAgLy8gTm90ZTogVXAgdG8gMTIgZGVjaW1hbCBkaWdpdHMgYXJlIHJlcXVpcmVkIHRvIHJlcHJlc2VudCBhbGwgdmFsaWRcclxuICAgICAgICAvLyAnc2Vjb25kcycgdmFsdWVzLlxyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFNlY29uZHMgPSBTdHJpbmcoYWRqdXN0ZWRTZWNvbmRzKS5wYWRTdGFydCgxMiwgJzAnKTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWROYW5vc2Vjb25kcyA9IFN0cmluZyh0aGlzLm5hbm9zZWNvbmRzKS5wYWRTdGFydCg5LCAnMCcpO1xyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTZWNvbmRzICsgJy4nICsgZm9ybWF0dGVkTmFub3NlY29uZHM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGluIEZpcmVzdG9yZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgdmVyc2lvblxyXG4gKiB0aW1lc3RhbXAsIHN1Y2ggYXMgdXBkYXRlX3RpbWUgb3IgcmVhZF90aW1lLlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RWZXJzaW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21UaW1lc3RhbXAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWluKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKG5ldyBUaW1lc3RhbXAoMCwgMCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1heCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbihuZXcgVGltZXN0YW1wKDI1MzQwMjMwMDc5OSwgMWU5IC0gMSkpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLl9jb21wYXJlVG8ob3RoZXIudGltZXN0YW1wKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuaXNFcXVhbChvdGhlci50aW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlcnNpb24gZm9yIHVzZSBpbiBzcGVjIHRlc3RzLiAqL1xyXG4gICAgdG9NaWNyb3NlY29uZHMoKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBtaWNyb3NlY29uZHMuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLnNlY29uZHMgKiAxZTYgKyB0aGlzLnRpbWVzdGFtcC5uYW5vc2Vjb25kcyAvIDEwMDA7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ1NuYXBzaG90VmVyc2lvbignICsgdGhpcy50aW1lc3RhbXAudG9TdHJpbmcoKSArICcpJztcclxuICAgIH1cclxuICAgIHRvVGltZXN0YW1wKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBET0NVTUVOVF9LRVlfTkFNRSA9ICdfX25hbWVfXyc7XHJcbi8qKlxyXG4gKiBQYXRoIHJlcHJlc2VudHMgYW4gb3JkZXJlZCBzZXF1ZW5jZSBvZiBzdHJpbmcgc2VnbWVudHMuXHJcbiAqL1xyXG5jbGFzcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID4gc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoIC0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMubGVuID0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW47XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIEJhc2VQYXRoLmNvbXBhcmF0b3IodGhpcywgb3RoZXIpID09PSAwO1xyXG4gICAgfVxyXG4gICAgY2hpbGQobmFtZU9yUGF0aCkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcclxuICAgICAgICBpZiAobmFtZU9yUGF0aCBpbnN0YW5jZW9mIEJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIG5hbWVPclBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuYW1lT3JQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgaW5kZXggb2Ygb25lIHBhc3QgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgcGF0aC4gKi9cclxuICAgIGxpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgcG9wRmlyc3Qoc2l6ZSkge1xyXG4gICAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyAxIDogc2l6ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQgKyBzaXplLCB0aGlzLmxlbmd0aCAtIHNpemUpO1xyXG4gICAgfVxyXG4gICAgcG9wTGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBmaXJzdFNlZ21lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXRdO1xyXG4gICAgfVxyXG4gICAgbGFzdFNlZ21lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBnZXQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLm9mZnNldCArIGluZGV4XTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgaXNQcmVmaXhPZihvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPCB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IG90aGVyLmdldChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNJbW1lZGlhdGVQYXJlbnRPZihwb3RlbnRpYWxDaGlsZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCArIDEgIT09IHBvdGVudGlhbENoaWxkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IHBvdGVudGlhbENoaWxkLmdldChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaChmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9mZnNldCwgZW5kID0gdGhpcy5saW1pdCgpOyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgZm4odGhpcy5zZWdtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wYXJhdG9yKHAxLCBwMikge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHAxLmxlbmd0aCwgcDIubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwMS5nZXQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcDIuZ2V0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPiByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAxLmxlbmd0aCA8IHAyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwMS5sZW5ndGggPiBwMi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHNsYXNoLXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHJlc291cmNlcyAoZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucylcclxuICogd2l0aGluIEZpcmVzdG9yZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZXNvdXJjZVBhdGggZXh0ZW5kcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXHJcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcclxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cclxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuam9pbignLycpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwYXRoXHJcbiAgICAgKiB3aGVyZSBlYWNoIHBhdGggc2VnbWVudCBoYXMgYmVlbiBlbmNvZGVkIHdpdGhcclxuICAgICAqIGBlbmNvZGVVUklDb21wb25lbnRgLlxyXG4gICAgICovXHJcbiAgICB0b1VyaUVuY29kZWRTdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJlc291cmNlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gc2xhc2gtZGVsaW1pdGVkIHN0cmluZy4gSWYgbXVsdGlwbGVcclxuICAgICAqIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFsbCBjb21wb25lbnRzIGFyZSBjb21iaW5lZC4gTGVhZGluZyBhbmQgdHJhaWxpbmdcclxuICAgICAqIHNsYXNoZXMgZnJvbSBhbGwgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcoLi4ucGF0aENvbXBvbmVudHMpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXHJcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcclxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHNlZ21lbnQgKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIC8vIGluIHRoZW0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhbGluZyBzbGFzaGVkLlxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKC4uLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoc2VnbWVudCA9PiBzZWdtZW50Lmxlbmd0aCA+IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaWRlbnRpZmllclJlZ0V4cCA9IC9eW19hLXpBLVpdW19hLXpBLVowLTldKiQvO1xyXG4vKipcclxuICogQSBkb3Qtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgc3ViLW9iamVjdHMgd2l0aGluIGEgZG9jdW1lbnQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmllbGRQYXRoJDEgZXh0ZW5kcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb3VsZCBiZSB1c2VkIGFzIGEgc2VnbWVudCBpbiBhIGZpZWxkIHBhdGhcclxuICAgICAqIHdpdGhvdXQgZXNjYXBpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkSWRlbnRpZmllcihzZWdtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXJSZWdFeHAudGVzdChzZWdtZW50KTtcclxuICAgIH1cclxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KClcclxuICAgICAgICAgICAgLm1hcChzdHIgPT4ge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9gL2csICdcXFxcYCcpO1xyXG4gICAgICAgICAgICBpZiAoIUZpZWxkUGF0aCQxLmlzVmFsaWRJZGVudGlmaWVyKHN0cikpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9ICdgJyArIHN0ciArICdgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmllbGQgcmVmZXJlbmNlcyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGlzS2V5RmllbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMuZ2V0KDApID09PSBET0NVTUVOVF9LRVlfTkFNRTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGtleUZpZWxkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW0RPQ1VNRU5UX0tFWV9OQU1FXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGZpZWxkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXItZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiAtIFNwbGl0dGluZyB0aGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhbGxvd2VkIChmb3Igbm93IGF0IGxlYXN0KS5cclxuICAgICAqIC0gRW1wdHkgc2VnbWVudHMgd2l0aGluIHRoZSBzdHJpbmcgKGUuZy4gaWYgdGhlcmUgYXJlIHR3byBjb25zZWN1dGl2ZVxyXG4gICAgICogICBzZXBhcmF0b3JzKSBhcmUgbm90IGFsbG93ZWQuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyhiLzM3MjQ0MTU3KTogd2Ugc2hvdWxkIG1ha2UgdGhpcyBtb3JlIHN0cmljdC4gUmlnaHQgbm93LCBpdCBhbGxvd3NcclxuICAgICAqIG5vbi1pZGVudGlmaWVyIHBhdGggY29tcG9uZW50cywgZXZlbiBpZiB0aGV5IGFyZW4ndCBlc2NhcGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNlcnZlckZvcm1hdChwYXRoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBhZGRDdXJyZW50U2VnbWVudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaW5CYWNrdGlja3MgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBwYXRoW2ldO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1BhdGggaGFzIHRyYWlsaW5nIGVzY2FwZSBjaGFyYWN0ZXI6ICcgKyBwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXRoW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmICghKG5leHQgPT09ICdcXFxcJyB8fCBuZXh0ID09PSAnLicgfHwgbmV4dCA9PT0gJ2AnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogJyArIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSAhaW5CYWNrdGlja3M7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJy4nICYmICFpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xyXG4gICAgICAgIGlmIChpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVW50ZXJtaW5hdGVkIGAgaW4gcGF0aDogJyArIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShbXSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRLZXkge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21OYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpLnBvcEZpcnN0KDUpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sbGVjdGlvbkdyb3VwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgucG9wTGFzdCgpLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBpcyBpbiB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb25JZC4gKi9cclxuICAgIGhhc0NvbGxlY3Rpb25JZChjb2xsZWN0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMucGF0aC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKSA9PT0gY29sbGVjdGlvbklkKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGdyb3VwIChpLmUuIHRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgY29sbGVjdGlvbikgZm9yIHRoaXMga2V5LiAqL1xyXG4gICAgZ2V0Q29sbGVjdGlvbkdyb3VwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgcGF0aCB0byB0aGUgcGFyZW50IGNvbGxlY3Rpb24uICovXHJcbiAgICBnZXRDb2xsZWN0aW9uUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKHRoaXMucGF0aCwgb3RoZXIucGF0aCkgPT09IDApO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBhcmF0b3IoazEsIGsyKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKGsxLnBhdGgsIGsyLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzRG9jdW1lbnRLZXkocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCAlIDIgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgZG9jdW1lbnQga2V5IHdpdGggdGhlIGdpdmVuIHNlZ21lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byB0aGUgZG9jdW1lbnRcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIERvY3VtZW50S2V5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU2VnbWVudHMoc2VnbWVudHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMuc2xpY2UoKSkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgaW5pdGlhbCBtdXRhdGlvbiBiYXRjaCBpZCBmb3IgZWFjaCBpbmRleC4gR2V0cyB1cGRhdGVkIGR1cmluZyBpbmRleFxyXG4gKiBiYWNrZmlsbC5cclxuICovXHJcbmNvbnN0IElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCA9IC0xO1xyXG4vKipcclxuICogVGhlIGluaXRpYWwgc2VxdWVuY2UgbnVtYmVyIGZvciBlYWNoIGluZGV4LiBHZXRzIHVwZGF0ZWQgZHVyaW5nIGluZGV4XHJcbiAqIGJhY2tmaWxsLlxyXG4gKi9cclxuY29uc3QgSU5JVElBTF9TRVFVRU5DRV9OVU1CRVIgPSAwO1xyXG4vKipcclxuICogQW4gaW5kZXggZGVmaW5pdGlvbiBmb3IgZmllbGQgaW5kZXhlcyBpbiBGaXJlc3RvcmUuXHJcbiAqXHJcbiAqIEV2ZXJ5IGluZGV4IGlzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoZSBkZWZpbml0aW9uIGNvbnRhaW5zIGEgbGlzdFxyXG4gKiBvZiBmaWVsZHMgYW5kIHRoZWlyIGluZGV4IGtpbmQgKHdoaWNoIGNhbiBiZSBgQVNDRU5ESU5HYCwgYERFU0NFTkRJTkdgIG9yXHJcbiAqIGBDT05UQUlOU2AgZm9yIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueSBxdWVyaWVzKS5cclxuICpcclxuICogVW5saWtlIHRoZSBiYWNrZW5kLCB0aGUgU0RLIGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBjb2xsZWN0aW9uIG9yXHJcbiAqIGNvbGxlY3Rpb24gZ3JvdXAtc2NvcGVkIGluZGljZXMuIEV2ZXJ5IGluZGV4IGNhbiBiZSB1c2VkIGZvciBib3RoIHNpbmdsZVxyXG4gKiBjb2xsZWN0aW9uIGFuZCBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaWVsZEluZGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggSUQuIFJldHVybnMgLTEgaWYgdGhlIGluZGV4IElEIGlzIG5vdCBhdmFpbGFibGUgKGUuZy4gdGhlIGluZGV4XHJcbiAgICAgKiBoYXMgbm90IHlldCBiZWVuIHBlcnNpc3RlZCkuXHJcbiAgICAgKi9cclxuICAgIGluZGV4SWQsIFxyXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uIElEIHRoaXMgaW5kZXggYXBwbGllcyB0by4gKi9cclxuICAgIGNvbGxlY3Rpb25Hcm91cCwgXHJcbiAgICAvKiogVGhlIGZpZWxkIHNlZ21lbnRzIGZvciB0aGlzIGluZGV4LiAqL1xyXG4gICAgZmllbGRzLCBcclxuICAgIC8qKiBTaG93cyBob3cgdXAtdG8tZGF0ZSB0aGUgaW5kZXggaXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuICovXHJcbiAgICBpbmRleFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcclxuICAgICAgICB0aGlzLmluZGV4U3RhdGUgPSBpbmRleFN0YXRlO1xyXG4gICAgfVxyXG59XHJcbi8qKiBBbiBJRCBmb3IgYW4gaW5kZXggdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIHBlcnNpc3RlbmNlLiAgKi9cclxuRmllbGRJbmRleC5VTktOT1dOX0lEID0gLTE7XHJcbi8qKiBSZXR1cm5zIHRoZSBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnkgc2VnbWVudCBmb3IgdGhpcyBpbmRleC4gKi9cclxuZnVuY3Rpb24gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KSB7XHJcbiAgICByZXR1cm4gZmllbGRJbmRleC5maWVsZHMuZmluZChzID0+IHMua2luZCA9PT0gMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pO1xyXG59XHJcbi8qKiBSZXR1cm5zIGFsbCBkaXJlY3Rpb25hbCAoYXNjZW5kaW5nL2Rlc2NlbmRpbmcpIHNlZ21lbnRzIGZvciB0aGlzIGluZGV4LiAqL1xyXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSB7XHJcbiAgICByZXR1cm4gZmllbGRJbmRleC5maWVsZHMuZmlsdGVyKHMgPT4gcy5raW5kICE9PSAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG9yZGVyIG9mIHRoZSBkb2N1bWVudCBrZXkgY29tcG9uZW50IGZvciB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIFdlYiBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0S2V5T3JkZXIoZmllbGRJbmRleCkge1xyXG4gICAgY29uc3QgZGlyZWN0aW9uYWxTZWdtZW50cyA9IGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpO1xyXG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsU2VnbWVudHMubGVuZ3RoID09PSAwXHJcbiAgICAgICAgPyAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cclxuICAgICAgICA6IGRpcmVjdGlvbmFsU2VnbWVudHNbZGlyZWN0aW9uYWxTZWdtZW50cy5sZW5ndGggLSAxXS5raW5kO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyBpbmRleGVzIGJ5IGNvbGxlY3Rpb24gZ3JvdXAgYW5kIHNlZ21lbnRzLiBJZ25vcmVzIHVwZGF0ZSB0aW1lIGFuZFxyXG4gKiBpbmRleCBJRC5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkSW5kZXhTZW1hbnRpY0NvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcclxuICAgIGxldCBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuY29sbGVjdGlvbkdyb3VwLCByaWdodC5jb2xsZWN0aW9uR3JvdXApO1xyXG4gICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgIGNtcCA9IGluZGV4U2VnbWVudENvbXBhcmF0b3IobGVmdC5maWVsZHNbaV0sIHJpZ2h0LmZpZWxkc1tpXSk7XHJcbiAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7XHJcbn1cclxuLyoqIFJldHVybnMgYSBkZWJ1ZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQgaW5kZXggKi9cclxuZnVuY3Rpb24gZmllbGRJbmRleFRvU3RyaW5nKGZpZWxkSW5kZXgpIHtcclxuICAgIHJldHVybiBgaWQ9JHtmaWVsZEluZGV4LmluZGV4SWR9fGNnPSR7ZmllbGRJbmRleC5jb2xsZWN0aW9uR3JvdXB9fGY9JHtmaWVsZEluZGV4LmZpZWxkcy5tYXAoZiA9PiBgJHtmLmZpZWxkUGF0aH06JHtmLmtpbmR9YCkuam9pbignLCcpfWA7XHJcbn1cclxuLyoqIEFuIGluZGV4IGNvbXBvbmVudCBjb25zaXN0aW5nIG9mIGZpZWxkIHBhdGggYW5kIGluZGV4IHR5cGUuICAqL1xyXG5jbGFzcyBJbmRleFNlZ21lbnQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIGZpZWxkIHBhdGggb2YgdGhlIGNvbXBvbmVudC4gKi9cclxuICAgIGZpZWxkUGF0aCwgXHJcbiAgICAvKiogVGhlIGZpZWxkcyBzb3J0aW5nIG9yZGVyLiAqL1xyXG4gICAga2luZCkge1xyXG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gZmllbGRQYXRoO1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5kZXhTZWdtZW50Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgY21wID0gRmllbGRQYXRoJDEuY29tcGFyYXRvcihsZWZ0LmZpZWxkUGF0aCwgcmlnaHQuZmllbGRQYXRoKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5raW5kLCByaWdodC5raW5kKTtcclxufVxyXG4vKipcclxuICogU3RvcmVzIHRoZSBcImhpZ2ggd2F0ZXIgbWFya1wiIHRoYXQgaW5kaWNhdGVzIGhvdyB1cGRhdGVkIHRoZSBJbmRleCBpcyBmb3IgdGhlXHJcbiAqIGN1cnJlbnQgdXNlci5cclxuICovXHJcbmNsYXNzIEluZGV4U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGVuIHRoZSBpbmRleCB3YXMgbGFzdCB1cGRhdGVkIChyZWxhdGl2ZSB0byBvdGhlciBpbmRleGVzKS5cclxuICAgICAqL1xyXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxyXG4gICAgLyoqIFRoZSB0aGUgbGF0ZXN0IGluZGV4ZWQgcmVhZCB0aW1lLCBkb2N1bWVudCBhbmQgYmF0Y2ggaWQuICovXHJcbiAgICBvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIHN0YXRlIG9mIGFuIGluZGV4IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBiYWNrZmlsbGVkLiAqL1xyXG4gICAgc3RhdGljIGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhTdGF0ZShJTklUSUFMX1NFUVVFTkNFX05VTUJFUiwgSW5kZXhPZmZzZXQubWluKCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIG9mZnNldCB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyB3aXRoIGEgcmVhZCB0aW1lIGhpZ2hlciB0aGFuXHJcbiAqIGByZWFkVGltZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShyZWFkVGltZSwgbGFyZ2VzdEJhdGNoSWQpIHtcclxuICAgIC8vIFdlIHdhbnQgdG8gY3JlYXRlIGFuIG9mZnNldCB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyB3aXRoIGEgcmVhZCB0aW1lXHJcbiAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHByb3ZpZGVkIHJlYWQgdGltZS4gVG8gZG8gc28sIHdlIHRlY2huaWNhbGx5IG5lZWQgdG9cclxuICAgIC8vIGNyZWF0ZSBhbiBvZmZzZXQgZm9yIGAocmVhZFRpbWUsIE1BWF9ET0NVTUVOVF9LRVkpYC4gV2hpbGUgd2UgY291bGQgdXNlXHJcbiAgICAvLyBVbmljb2RlIGNvZGVwb2ludHMgdG8gZ2VuZXJhdGUgTUFYX0RPQ1VNRU5UX0tFWSwgaXQgaXMgbXVjaCBlYXNpZXIgdG8gdXNlXHJcbiAgICAvLyBgKHJlYWRUaW1lICsgMSwgRG9jdW1lbnRLZXkuZW1wdHkoKSlgIHNpbmNlIGA+IERvY3VtZW50S2V5LmVtcHR5KClgIG1hdGNoZXNcclxuICAgIC8vIGFsbCB2YWxpZCBkb2N1bWVudCBJRHMuXHJcbiAgICBjb25zdCBzdWNjZXNzb3JTZWNvbmRzID0gcmVhZFRpbWUudG9UaW1lc3RhbXAoKS5zZWNvbmRzO1xyXG4gICAgY29uc3Qgc3VjY2Vzc29yTmFub3MgPSByZWFkVGltZS50b1RpbWVzdGFtcCgpLm5hbm9zZWNvbmRzICsgMTtcclxuICAgIGNvbnN0IHN1Y2Nlc3NvciA9IFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKHN1Y2Nlc3Nvck5hbm9zID09PSAxZTlcclxuICAgICAgICA/IG5ldyBUaW1lc3RhbXAoc3VjY2Vzc29yU2Vjb25kcyArIDEsIDApXHJcbiAgICAgICAgOiBuZXcgVGltZXN0YW1wKHN1Y2Nlc3NvclNlY29uZHMsIHN1Y2Nlc3Nvck5hbm9zKSk7XHJcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KHN1Y2Nlc3NvciwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgbGFyZ2VzdEJhdGNoSWQpO1xyXG59XHJcbi8qKiBDcmVhdGVzIGEgbmV3IG9mZnNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnQuICovXHJcbmZ1bmN0aW9uIG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KSB7XHJcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KGRvY3VtZW50LnJlYWRUaW1lLCBkb2N1bWVudC5rZXksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XHJcbn1cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgbGF0ZXN0IHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIElEIHRoYXQgd2VyZSBwcm9jZXNzZWQgZm9yIGFuXHJcbiAqIGluZGV4LlxyXG4gKi9cclxuY2xhc3MgSW5kZXhPZmZzZXQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRlc3QgcmVhZCB0aW1lIHZlcnNpb24gdGhhdCBoYXMgYmVlbiBpbmRleGVkIGJ5IEZpcmVzdG9yZSBmb3IgdGhpc1xyXG4gICAgICogZmllbGQgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHJlYWRUaW1lLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGtleSBvZiB0aGUgbGFzdCBkb2N1bWVudCB0aGF0IHdhcyBpbmRleGVkIGZvciB0aGlzIHF1ZXJ5LiBVc2VcclxuICAgICAqIGBEb2N1bWVudEtleS5lbXB0eSgpYCBpZiBubyBkb2N1bWVudCBoYXMgYmVlbiBpbmRleGVkLlxyXG4gICAgICovXHJcbiAgICBkb2N1bWVudEtleSwgXHJcbiAgICAvKlxyXG4gICAgICogVGhlIGxhcmdlc3QgbXV0YXRpb24gYmF0Y2ggaWQgdGhhdCdzIGJlZW4gcHJvY2Vzc2VkIGJ5IEZpcmVzdG9yZS5cclxuICAgICAqL1xyXG4gICAgbGFyZ2VzdEJhdGNoSWQpIHtcclxuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xyXG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGFuIG9mZnNldCB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xyXG4gICAgc3RhdGljIG1pbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGFuIG9mZnNldCB0aGF0IHNvcnRzIGFmdGVyIGFsbCByZWd1bGFyIG9mZnNldHMuICovXHJcbiAgICBzdGF0aWMgbWF4KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoU25hcHNob3RWZXJzaW9uLm1heCgpLCBEb2N1bWVudEtleS5lbXB0eSgpLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluZGV4T2Zmc2V0Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgbGV0IGNtcCA9IGxlZnQucmVhZFRpbWUuY29tcGFyZVRvKHJpZ2h0LnJlYWRUaW1lKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgY21wID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmRvY3VtZW50S2V5LCByaWdodC5kb2N1bWVudEtleSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQubGFyZ2VzdEJhdGNoSWQsIHJpZ2h0Lmxhcmdlc3RCYXRjaElkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHID0gJ1RoZSBjdXJyZW50IHRhYiBpcyBub3QgaW4gdGhlIHJlcXVpcmVkIHN0YXRlIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uICcgK1xyXG4gICAgJ0l0IG1pZ2h0IGJlIG5lY2Vzc2FyeSB0byByZWZyZXNoIHRoZSBicm93c2VyIHRhYi4nO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIHJlcHJlc2VudGluZyBhIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLCBlbmNhcHN1bGF0aW5nIGJvdGggdGhlXHJcbiAqIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UgbnVtYmVycyBhcyB3ZWxsIGFzIGEgbGlzdCBvZiBvbkNvbW1pdHRlZCBsaXN0ZW5lcnMuXHJcbiAqXHJcbiAqIFdoZW4geW91IGNhbGwgUGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oKSwgaXQgd2lsbCBjcmVhdGUgYSB0cmFuc2FjdGlvbiBhbmRcclxuICogcGFzcyBpdCB0byB5b3VyIGNhbGxiYWNrLiBZb3UgdGhlbiBwYXNzIGl0IHRvIGFueSBtZXRob2QgdGhhdCBvcGVyYXRlc1xyXG4gKiBvbiBwZXJzaXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWRkT25Db21taXR0ZWRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICByYWlzZU9uQ29tbWl0dGVkRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGUgZXJyb3IgdGhyb3duIGJ5IGEgTG9jYWxTdG9yZSBvcGVyYXRpb24uIElmIGEgTG9jYWxTdG9yZVxyXG4gKiBvcGVyYXRpb24gZmFpbHMgYmVjYXVzZSB0aGUgcHJpbWFyeSBsZWFzZSBoYXMgYmVlbiB0YWtlbiBieSBhbm90aGVyIGNsaWVudCxcclxuICogd2UgaWdub3JlIHRoZSBlcnJvciAodGhlIHBlcnNpc3RlbmNlIGxheWVyIHdpbGwgaW1tZWRpYXRlbHkgY2FsbFxyXG4gKiBgYXBwbHlQcmltYXJ5TGVhc2VgIHRvIHByb3BhZ2F0ZSB0aGUgcHJpbWFyeSBzdGF0ZSBjaGFuZ2UpLiBBbGwgb3RoZXIgZXJyb3JzXHJcbiAqIGFyZSByZS10aHJvd24uXHJcbiAqXHJcbiAqIEBwYXJhbSBlcnIgLSBBbiBlcnJvciByZXR1cm5lZCBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB3ZSByZWNvdmVyZWQsIG9yIHRoZSBvcmlnaW5hbCBlcnJvci5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnIpIHtcclxuICAgIGlmIChlcnIuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OICYmXHJcbiAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpIHtcclxuICAgICAgICBsb2dEZWJ1ZygnTG9jYWxTdG9yZScsICdVbmV4cGVjdGVkbHkgbG9zdCBwcmltYXJ5IGxlYXNlJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBlcnNpc3RlbmNlUHJvbWlzZSBpcyBlc3NlbnRpYWxseSBhIHJlLWltcGxlbWVudGF0aW9uIG9mIFByb21pc2UgZXhjZXB0XHJcbiAqIGl0IGhhcyBhIC5uZXh0KCkgbWV0aG9kIGluc3RlYWQgb2YgLnRoZW4oKSBhbmQgLm5leHQoKSBhbmQgLmNhdGNoKCkgY2FsbGJhY2tzXHJcbiAqIGFyZSBleGVjdXRlZCBzeW5jaHJvbm91c2x5IHdoZW4gYSBQZXJzaXN0ZW5jZVByb21pc2UgcmVzb2x2ZXMgcmF0aGVyIHRoYW5cclxuICogYXN5bmNocm9ub3VzbHkgKFByb21pc2UgaW1wbGVtZW50YXRpb25zIHVzZSBzZXRJbW1lZGlhdGUoKSBvciBzaW1pbGFyKS5cclxuICpcclxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gaW50ZXJvcGVyYXRlIHdpdGggSW5kZXhlZERCIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBjb21taXQgdHJhbnNhY3Rpb25zIGlmIGNvbnRyb2wgaXMgcmV0dXJuZWQgdG8gdGhlIGV2ZW50IGxvb3Agd2l0aG91dFxyXG4gKiBzeW5jaHJvbm91c2x5IGluaXRpYXRpbmcgYW5vdGhlciBvcGVyYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBOT1RFOiAudGhlbigpIGFuZCAuY2F0Y2goKSBvbmx5IGFsbG93IGEgc2luZ2xlIGNvbnN1bWVyLCB1bmxpa2Ugbm9ybWFsXHJcbiAqIFByb21pc2VzLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVuY2VQcm9taXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gTk9URTogbmV4dC9jYXRjaENhbGxiYWNrIHdpbGwgYWx3YXlzIHBvaW50IHRvIG91ciBvd24gd3JhcHBlciBmdW5jdGlvbnMsXHJcbiAgICAgICAgLy8gbm90IHRoZSB1c2VyJ3MgcmF3IG5leHQoKSBvciBjYXRjaCgpIGNhbGxiYWNrcy5cclxuICAgICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAvLyBXaGVuIHRoZSBvcGVyYXRpb24gcmVzb2x2ZXMsIHdlJ2xsIHNldCByZXN1bHQgb3IgZXJyb3IgYW5kIG1hcmsgaXNEb25lLlxyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIC50aGVuKCkgb3IgLmNhdGNoKCkgYXJlIGNhbGxlZCBhbmQgcHJldmVudHMgYWRkaXRpb25hbFxyXG4gICAgICAgIC8vIGNoYWluaW5nLlxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNhbGxiYWNrKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIHVubGVzcyBUIGlzIFZvaWQsIGJ1dCB3ZSBjYW4ndCBleHByZXNzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGluIHRoZSB0eXBlIHN5c3RlbS5cclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGxiYWNrKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhdGNoQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCh1bmRlZmluZWQsIGZuKTtcclxuICAgIH1cclxuICAgIG5leHQobmV4dEZuLCBjYXRjaEZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN1Y2Nlc3MobmV4dEZuLCB0aGlzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCB0aGlzLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1Byb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3cmFwVXNlckZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBlcnNpc3RlbmNlUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmV4dEZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gbmV4dEZuKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHRGbiwgdGhlbiBSIG11c3QgYmUgdGhlIHNhbWUgYXMgVFxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGNhdGNoRm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFVzZXJGdW5jdGlvbigoKSA9PiBjYXRjaEZuKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlc29sdmUocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVqZWN0KGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhaXRGb3IoXHJcbiAgICAvLyBBY2NlcHQgYWxsIFByb21pc2UgdHlwZXMgaW4gd2FpdEZvcigpLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGFsbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IGV4cGVjdGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGFsbC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgKytleHBlY3RlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICArK3Jlc29sdmVkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgJiYgcmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHJlamVjdChlcnIpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIHByZWRpY2F0ZSBmdW5jdGlvbnMgdGhhdCBhc3luY2hyb25vdXNseSBldmFsdWF0ZSB0byBhXHJcbiAgICAgKiBib29sZWFuLCBpbXBsZW1lbnRzIGEgc2hvcnQtY2lyY3VpdGluZyBgb3JgIGJldHdlZW4gdGhlIHJlc3VsdHMuIFByZWRpY2F0ZXNcclxuICAgICAqIHdpbGwgYmUgZXZhbHVhdGVkIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYHRydWVgLCB0aGVuIHN0b3AuIFRoZSBmaW5hbFxyXG4gICAgICogcmVzdWx0IHdpbGwgYmUgd2hldGhlciBhbnkgb2YgdGhlbSByZXR1cm5lZCBgdHJ1ZWAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvcihwcmVkaWNhdGVzKSB7XHJcbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgcHJlZGljYXRlcykge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KGlzVHJ1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGlzVHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmb3JFYWNoKGNvbGxlY3Rpb24sIGYpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgociwgcykgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGYuY2FsbCh0aGlzLCByLCBzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmN1cnJlbnRseSBtYXAgYWxsIGFycmF5IGVsZW1lbnRzIHRocm91Z2ggYXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWFwQXJyYXkoYXJyYXksIGYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRDb3VudCk7XHJcbiAgICAgICAgICAgIGxldCByZXNvbHZlZENvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgZihhcnJheVtjdXJyZW50XSkubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbY3VycmVudF0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgKytyZXNvbHZlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZENvdW50ID09PSBleHBlY3RlZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHJlamVjdChlcnIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byByZWN1cnNpdmUgUGVyc2lzdGVuY2VQcm9taXNlIGNhbGxzLCB0aGF0IGF2b2lkc1xyXG4gICAgICogcG90ZW50aWFsIG1lbW9yeSBwcm9ibGVtcyBmcm9tIHVuYm91bmRlZCBjaGFpbnMgb2YgcHJvbWlzZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBhY3Rpb25gIHdpbGwgYmUgY2FsbGVkIHJlcGVhdGVkbHkgd2hpbGUgYGNvbmRpdGlvbmAgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRvV2hpbGUoY29uZGl0aW9uLCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uKCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHByb2Nlc3MoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBSZWZlcmVuY2VzIHRvIGB3aW5kb3dgIGFyZSBndWFyZGVkIGJ5IFNpbXBsZURiLmlzQXZhaWxhYmxlKClcclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmNvbnN0IExPR19UQUckaSA9ICdTaW1wbGVEYic7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgZm9yIGFuIEluZGV4ZWREYiB0cmFuc2FjdGlvbiB0aGF0IGZhaWxzXHJcbiAqIHdpdGggYSBET01FeGNlcHRpb24uXHJcbiAqL1xyXG5jb25zdCBUUkFOU0FDVElPTl9SRVRSWV9DT1VOVCA9IDM7XHJcbi8qKlxyXG4gKiBXcmFwcyBhbiBJREJUcmFuc2FjdGlvbiBhbmQgZXhwb3NlcyBhIHN0b3JlKCkgbWV0aG9kIHRvIGdldCBhIGhhbmRsZSB0byBhXHJcbiAqIHNwZWNpZmljIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmNsYXNzIFNpbXBsZURiVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYWN0aW9uLCB0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcclxuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgSW5kZXhlZERiIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLm9uYWJvcnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgdHJhbnNhY3Rpb24uZXJyb3IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlcnJvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgb3BlbihkYiwgYWN0aW9uLCBtb2RlLCBvYmplY3RTdG9yZU5hbWVzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKGFjdGlvbiwgZGIudHJhbnNhY3Rpb24ob2JqZWN0U3RvcmVOYW1lcywgbW9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjb21wbGV0aW9uUHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGFib3J0KGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0Fib3J0aW5nIHRyYW5zYWN0aW9uOicsIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDbGllbnQtaW5pdGlhdGVkIGFib3J0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXliZUNvbW1pdCgpIHtcclxuICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBWMyBJbmRleGVkREIsIHdlIGludm9rZSBjb21taXQoKSBleHBsaWNpdGx5IHRvXHJcbiAgICAgICAgLy8gc3BlZWQgdXAgaW5kZXggREIgcHJvY2Vzc2luZyBpZiB0aGUgZXZlbnQgbG9vcCByZW1haW5zIGJsb2Nrcy5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIGNvbnN0IG1heWJlVjNJbmRleGVkRGIgPSB0aGlzLnRyYW5zYWN0aW9uO1xyXG4gICAgICAgIGlmICghdGhpcy5hYm9ydGVkICYmIHR5cGVvZiBtYXliZVYzSW5kZXhlZERiLmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBtYXliZVYzSW5kZXhlZERiLmNvbW1pdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFNpbXBsZURiU3RvcmU8S2V5VHlwZSwgVmFsdWVUeXBlPiBmb3IgdGhlIHNwZWNpZmllZCBzdG9yZS4gQWxsXHJcbiAgICAgKiBvcGVyYXRpb25zIHBlcmZvcm1lZCBvbiB0aGUgU2ltcGxlRGJTdG9yZSBoYXBwZW4gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoaXNcclxuICAgICAqIHRyYW5zYWN0aW9uIGFuZCBpdCBjYW5ub3QgYmUgdXNlZCBhbnltb3JlIG9uY2UgdGhlIHRyYW5zYWN0aW9uIGlzXHJcbiAgICAgKiBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHdlIGNhbid0IGFjdHVhbGx5IGVuZm9yY2UgdGhhdCB0aGUgS2V5VHlwZSBhbmQgVmFsdWVUeXBlIGFyZVxyXG4gICAgICogY29ycmVjdCwgYnV0IHRoZXkgYWxsb3cgdHlwZSBzYWZldHkgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgY29uc3VtaW5nIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIHN0b3JlKHN0b3JlTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy50cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGJTdG9yZShzdG9yZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgSW5kZXhlZERiIHdpdGggYSBzaW1wbGlmaWVkIGludGVyZmFjZSB0aGF0IHVzZXNcclxuICogUHJvbWlzZS1saWtlIHJldHVybiB2YWx1ZXMgdG8gY2hhaW4gb3BlcmF0aW9ucy4gUmVhbCBwcm9taXNlcyBjYW5ub3QgYmUgdXNlZFxyXG4gKiBzaW5jZSAudGhlbigpIGNvbnRpbnVhdGlvbnMgYXJlIGV4ZWN1dGVkIGFzeW5jaHJvbm91c2x5IChlLmcuIHZpYVxyXG4gKiAuc2V0SW1tZWRpYXRlKSwgd2hpY2ggd291bGQgY2F1c2UgSW5kZXhlZERCIHRvIGVuZCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIFNlZSBQZXJzaXN0ZW5jZVByb21pc2UgZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmNsYXNzIFNpbXBsZURiIHtcclxuICAgIC8qXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpbXBsZURiIHdyYXBwZXIgZm9yIEluZGV4ZWREYiBkYXRhYmFzZSBgbmFtZWAuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGB2ZXJzaW9uYCBtdXN0IG5vdCBiZSBhIGRvd25ncmFkZS4gSW5kZXhlZERCIGRvZXMgbm90IHN1cHBvcnRcclxuICAgICAqIGRvd25ncmFkaW5nIHRoZSBzY2hlbWEgdmVyc2lvbi4gV2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IGFueSB3YXkgdG8gZG9cclxuICAgICAqIHZlcnNpb25pbmcgb3V0c2lkZSBvZiBJbmRleGVkREIncyB2ZXJzaW9uaW5nIG1lY2hhbmlzbSwgYXMgb25seVxyXG4gICAgICogdmVyc2lvbi11cGdyYWRlIHRyYW5zYWN0aW9ucyBhcmUgYWxsb3dlZCB0byBkbyB0aGluZ3MgbGlrZSBjcmVhdGVcclxuICAgICAqIG9iamVjdHN0b3Jlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmVyc2lvbiwgc2NoZW1hQ29udmVydGVyKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hQ29udmVydGVyID0gc2NoZW1hQ29udmVydGVyO1xyXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xyXG4gICAgICAgIC8vIE5PVEU6IEFjY29yZGluZyB0byBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk3MDUwLCB0aGVcclxuICAgICAgICAvLyBidWcgd2UncmUgY2hlY2tpbmcgZm9yIHNob3VsZCBleGlzdCBpbiBpT1MgPj0gMTIuMiBhbmQgPCAxMywgYnV0IGZvclxyXG4gICAgICAgIC8vIHdoYXRldmVyIHJlYXNvbiBpdCdzIG11Y2ggaGFyZGVyIHRvIGhpdCBhZnRlciAxMi4yIHNvIHdlIG9ubHkgcHJvYWN0aXZlbHlcclxuICAgICAgICAvLyBsb2cgb24gMTIuMi5cclxuICAgICAgICBpZiAoaU9TVmVyc2lvbiA9PT0gMTIuMikge1xyXG4gICAgICAgICAgICBsb2dFcnJvcignRmlyZXN0b3JlIHBlcnNpc3RlbmNlIHN1ZmZlcnMgZnJvbSBhIGJ1ZyBpbiBpT1MgMTIuMiAnICtcclxuICAgICAgICAgICAgICAgICdTYWZhcmkgdGhhdCBtYXkgY2F1c2UgeW91ciBhcHAgdG8gc3RvcCB3b3JraW5nLiBTZWUgJyArXHJcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU2NDk2Mjk2LzExMDkxNSBmb3IgZGV0YWlscyAnICtcclxuICAgICAgICAgICAgICAgICdhbmQgYSBwb3RlbnRpYWwgd29ya2Fyb3VuZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogRGVsZXRlcyB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLiAqL1xyXG4gICAgc3RhdGljIGRlbGV0ZShuYW1lKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUmVtb3ZpbmcgZGF0YWJhc2U6JywgbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHdpbmRvdy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSkpLnRvUHJvbWlzZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBJbmRleGVkREIgaXMgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAqL1xyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChTaW1wbGVEYi5pc01vY2tQZXJzaXN0ZW5jZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBleHRlbnNpdmVseSB1c2UgaW5kZXhlZCBhcnJheSB2YWx1ZXMgYW5kIGNvbXBvdW5kIGtleXMsXHJcbiAgICAgICAgLy8gd2hpY2ggSUUgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQuIEhvd2V2ZXIsIHRoZXkgc3RpbGwgaGF2ZSBpbmRleGVkREJcclxuICAgICAgICAvLyBkZWZpbmVkIG9uIHRoZSB3aW5kb3csIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoZW0gaGVyZSBhbmQgbWFrZSBzdXJlXHJcbiAgICAgICAgLy8gdG8gcmV0dXJuIHRoYXQgcGVyc2lzdGVuY2UgaXMgbm90IGVuYWJsZWQgZm9yIHRob3NlIGJyb3dzZXJzLlxyXG4gICAgICAgIC8vIEZvciB0cmFja2luZyBzdXBwb3J0IG9mIHRoaXMgZmVhdHVyZSwgc2VlIGhlcmU6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9zdGF0dXMvaW5kZXhlZGRiYXJyYXlzYW5kbXVsdGllbnRyeXN1cHBvcnQvXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIFVBIHN0cmluZyB0byBmaW5kIG91dCB0aGUgYnJvd3Nlci5cclxuICAgICAgICBjb25zdCB1YSA9IGdldFVBKCk7XHJcbiAgICAgICAgLy8gSUUgMTBcclxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgTVNJRSAxMC4wOyBXaW5kb3dzIE5UIDYuMjsgVHJpZGVudC82LjApJztcclxuICAgICAgICAvLyBJRSAxMVxyXG4gICAgICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMzsgVHJpZGVudC83LjA7IHJ2OjExLjApIGxpa2UgR2Vja28nO1xyXG4gICAgICAgIC8vIEVkZ2VcclxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXT1c2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCxcclxuICAgICAgICAvLyBsaWtlIEdlY2tvKSBDaHJvbWUvMzkuMC4yMTcxLjcxIFNhZmFyaS81MzcuMzYgRWRnZS8xMi4wJztcclxuICAgICAgICAvLyBpT1MgU2FmYXJpOiBEaXNhYmxlIGZvciB1c2VycyBydW5uaW5nIGlPUyB2ZXJzaW9uIDwgMTAuXHJcbiAgICAgICAgY29uc3QgaU9TVmVyc2lvbiA9IFNpbXBsZURiLmdldElPU1ZlcnNpb24odWEpO1xyXG4gICAgICAgIGNvbnN0IGlzVW5zdXBwb3J0ZWRJT1MgPSAwIDwgaU9TVmVyc2lvbiAmJiBpT1NWZXJzaW9uIDwgMTA7XHJcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VyOiBEaXNhYmxlIGZvciB1c2Vyc2UgcnVubmluZyB2ZXJzaW9uIDwgNC41LlxyXG4gICAgICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uID0gZ2V0QW5kcm9pZFZlcnNpb24odWEpO1xyXG4gICAgICAgIGNvbnN0IGlzVW5zdXBwb3J0ZWRBbmRyb2lkID0gMCA8IGFuZHJvaWRWZXJzaW9uICYmIGFuZHJvaWRWZXJzaW9uIDwgNC41O1xyXG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdNU0lFICcpID4gMCB8fFxyXG4gICAgICAgICAgICB1YS5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fFxyXG4gICAgICAgICAgICB1YS5pbmRleE9mKCdFZGdlLycpID4gMCB8fFxyXG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkSU9TIHx8XHJcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRBbmRyb2lkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBiYWNraW5nIEluZGV4ZWREQiBzdG9yZSBpcyB0aGUgTm9kZSBJbmRleGVkREJTaGltXHJcbiAgICAgKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGVtY2xpb24vSW5kZXhlZERCU2hpbSkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc01vY2tQZXJzaXN0ZW5jZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgKChfYSA9IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuVVNFX01PQ0tfUEVSU0lTVEVOQ0UpID09PSAnWUVTJyk7XHJcbiAgICB9XHJcbiAgICAvKiogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZnJvbSBhIHRyYW5zYWN0aW9uLiAqL1xyXG4gICAgc3RhdGljIGdldFN0b3JlKHR4biwgc3RvcmUpIHtcclxuICAgICAgICByZXR1cm4gdHhuLnN0b3JlKHN0b3JlKTtcclxuICAgIH1cclxuICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuICAgIC8qKiBQYXJzZSBVc2VyIEFnZW50IHRvIGRldGVybWluZSBpT1MgdmVyc2lvbi4gUmV0dXJucyAtMSBpZiBub3QgZm91bmQuICovXHJcbiAgICBzdGF0aWMgZ2V0SU9TVmVyc2lvbih1YSkge1xyXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb25SZWdleCA9IHVhLm1hdGNoKC9pKD86cGhvbmV8cGFkfHBvZCkgb3MgKFtcXGRfXSspL2kpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBpT1NWZXJzaW9uUmVnZXhcclxuICAgICAgICAgICAgPyBpT1NWZXJzaW9uUmVnZXhbMV0uc3BsaXQoJ18nKS5zbGljZSgwLCAyKS5qb2luKCcuJylcclxuICAgICAgICAgICAgOiAnLTEnO1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIodmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UsIGNyZWF0aW5nIG9yIHVwZ3JhZGluZyBpdCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGVuc3VyZURiKGFjdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5kYikge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdPcGVuaW5nIGRhdGFiYXNlOicsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGIgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEludmVzdGlnYXRlIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbmRleGVkREJfQVBJL1VzaW5nX0luZGV4ZWREQlxyXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdHMgSUU5IGFuZCBvbGRlciBXZWJLaXQgYnJvd3NlcnMgaGFuZGxlIHVwZ3JhZGVcclxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudGx5LiBUaGV5IGV4cGVjdCBzZXRWZXJzaW9uLCBhcyBkZXNjcmliZWQgaGVyZTpcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJWZXJzaW9uQ2hhbmdlUmVxdWVzdC9zZXRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5uYW1lLCB0aGlzLnZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgJ0Nhbm5vdCB1cGdyYWRlIEluZGV4ZWREQiBzY2hlbWEgd2hpbGUgYW5vdGhlciB0YWIgaXMgb3Blbi4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdDbG9zZSBhbGwgdGFicyB0aGF0IGFjY2VzcyBGaXJlc3RvcmUgYW5kIHJlbG9hZCB0aGlzIHBhZ2UgdG8gcHJvY2VlZC4nKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC50YXJnZXQuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdWZXJzaW9uRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnQSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBGaXJlc3RvcmUgU0RLIHdhcyBwcmV2aW91c2x5IHVzZWQgYW5kIHNvIHRoZSBwZXJzaXN0ZWQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB2ZXJzaW9uIG9mIHRoZSBTREsgeW91IGFyZSBub3cgdXNpbmcuIFRoZSBTREsgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lsbCBvcGVyYXRlIHdpdGggcGVyc2lzdGVuY2UgZGlzYWJsZWQuIElmIHlvdSBuZWVkIHBlcnNpc3RlbmNlLCBwbGVhc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmUtdXBncmFkZSB0byBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIFNESyBvciBlbHNlIGNsZWFyIHRoZSBwZXJzaXN0ZWQgSW5kZXhlZERCICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEgZm9yIHlvdXIgYXBwIHRvIHN0YXJ0IGZyZXNoLicpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1VuYWJsZSB0byBvcGVuIGFuIEluZGV4ZWREQiBjb25uZWN0aW9uLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBydW5uaW5nIGluIGEgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSBicm93c2luZyBzZXNzaW9uIG9uIGEgYnJvd3NlciB3aG9zZSBwcml2YXRlIGJyb3dzaW5nIHNlc3Npb25zIGRvIG5vdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdXBwb3J0IEluZGV4ZWREQjogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdEYXRhYmFzZSBcIicgKyB0aGlzLm5hbWUgKyAnXCIgcmVxdWlyZXMgdXBncmFkZSBmcm9tIHZlcnNpb246JywgZXZlbnQub2xkVmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29udmVydGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVPclVwZ3JhZGUoZGIsIHJlcXVlc3QudHJhbnNhY3Rpb24sIGV2ZW50Lm9sZFZlcnNpb24sIHRoaXMudmVyc2lvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdEYXRhYmFzZSB1cGdyYWRlIHRvIHZlcnNpb24gJyArIHRoaXMudmVyc2lvbiArICcgY29tcGxldGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kYi5vbnZlcnNpb25jaGFuZ2UgPSBldmVudCA9PiB0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRiO1xyXG4gICAgfVxyXG4gICAgc2V0VmVyc2lvbkNoYW5nZUxpc3RlbmVyKHZlcnNpb25DaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyID0gdmVyc2lvbkNoYW5nZUxpc3RlbmVyO1xyXG4gICAgICAgIGlmICh0aGlzLmRiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGIub252ZXJzaW9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkNoYW5nZUxpc3RlbmVyKGV2ZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIG9iamVjdFN0b3JlcywgdHJhbnNhY3Rpb25Gbikge1xyXG4gICAgICAgIGNvbnN0IHJlYWRvbmx5ID0gbW9kZSA9PT0gJ3JlYWRvbmx5JztcclxuICAgICAgICBsZXQgYXR0ZW1wdE51bWJlciA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgKythdHRlbXB0TnVtYmVyO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IHRoaXMuZW5zdXJlRGIoYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gU2ltcGxlRGJUcmFuc2FjdGlvbi5vcGVuKHRoaXMuZGIsIGFjdGlvbiwgcmVhZG9ubHkgPyAncmVhZG9ubHknIDogJ3JlYWR3cml0ZScsIG9iamVjdFN0b3Jlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkZuUmVzdWx0ID0gdHJhbnNhY3Rpb25Gbih0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm1heWJlQ29tbWl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCB0aGUgdHJhbnNhY3Rpb24gaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgYWN0dWFsbHkgcmVjb3ZlciwgYW5kIGNhbGxpbmcgYGFib3J0KClgIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uJ3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0aW9uIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIFRoaXMgaW4gdHVybiBtZWFucyB0aGF0IHdlIHdvbid0IHVzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGB0cmFuc2FjdGlvbkZuUmVzdWx0YCBiZWxvdy4gV2UgcmV0dXJuIGEgcmVqZWN0aW9uIGhlcmUgc28gdGhhdCB3ZSBkb24ndCBhZGQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zc2liaWxpdHkgb2YgcmV0dXJuaW5nIGB2b2lkYCB0byB0aGUgdHlwZSBvZiBgdHJhbnNhY3Rpb25GblJlc3VsdGAuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBcyBub3RlZCBhYm92ZSwgZXJyb3JzIGFyZSBwcm9wYWdhdGVkIGJ5IGFib3J0aW5nIHRoZSB0cmFuc2FjdGlvbi4gU29cclxuICAgICAgICAgICAgICAgIC8vIHdlIHN3YWxsb3cgYW55IGVycm9yIGhlcmUgdG8gYXZvaWQgdGhlIGJyb3dzZXIgbG9nZ2luZyBpdCBhcyB1bmhhbmRsZWQuXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkZuUmVzdWx0LmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgKGkuZS4gSW5kZXhlZERiJ3Mgb25zdWNjZXNzIGV2ZW50IHRvXHJcbiAgICAgICAgICAgICAgICAvLyBmaXJlKSwgYnV0IHN0aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgdHJhbnNhY3Rpb25GblJlc3VsdCBiYWNrIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVyLlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tcGxldGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25GblJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhzY2htaWR0LXNlYmFzdGlhbik6IFdlIGNvdWxkIHByb2JhYmx5IGJlIHNtYXJ0ZXIgYWJvdXQgdGhpcyBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG5vdCByZXRyeSBleGNlcHRpb25zIHRoYXQgYXJlIGxpa2VseSB1bnJlY292ZXJhYmxlIChzdWNoIGFzIHF1b3RhXHJcbiAgICAgICAgICAgICAgICAvLyBleGNlZWRlZCBlcnJvcnMpLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2Fubm90IHVzZSBhbiBpbnN0YW5jZW9mIGNoZWNrIGZvciBGaXJlc3RvcmVFeGNlcHRpb24sIHNpbmNlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGlzIHdyYXBwZWQgaW4gYSBnZW5lcmljIGVycm9yIGJ5IG91ciBhc3luYy9hd2FpdCBoYW5kbGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5YWJsZSA9IGVycm9yLm5hbWUgIT09ICdGaXJlYmFzZUVycm9yJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHROdW1iZXIgPCBUUkFOU0FDVElPTl9SRVRSWV9DT1VOVDtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1RyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yOicsIGVycm9yLm1lc3NhZ2UsICdSZXRyeWluZzonLCByZXRyeWFibGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRiID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKiBQYXJzZSBVc2VyIEFnZW50IHRvIGRldGVybWluZSBBbmRyb2lkIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xyXG5mdW5jdGlvbiBnZXRBbmRyb2lkVmVyc2lvbih1YSkge1xyXG4gICAgY29uc3QgYW5kcm9pZFZlcnNpb25SZWdleCA9IHVhLm1hdGNoKC9BbmRyb2lkIChbXFxkLl0rKS9pKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBhbmRyb2lkVmVyc2lvblJlZ2V4XHJcbiAgICAgICAgPyBhbmRyb2lkVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCcuJykuc2xpY2UoMCwgMikuam9pbignLicpXHJcbiAgICAgICAgOiAnLTEnO1xyXG4gICAgcmV0dXJuIE51bWJlcih2ZXJzaW9uKTtcclxufVxyXG4vKipcclxuICogQSBjb250cm9sbGVyIGZvciBpdGVyYXRpbmcgb3ZlciBhIGtleSByYW5nZSBvciBpbmRleC4gSXQgYWxsb3dzIGFuIGl0ZXJhdGVcclxuICogY2FsbGJhY2sgdG8gZGVsZXRlIHRoZSBjdXJyZW50bHktcmVmZXJlbmNlZCBvYmplY3QsIG9yIGp1bXAgdG8gYSBuZXcga2V5XHJcbiAqIHdpdGhpbiB0aGUga2V5IHJhbmdlIG9yIGluZGV4LlxyXG4gKi9cclxuY2xhc3MgSXRlcmF0aW9uQ29udHJvbGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYkN1cnNvcikge1xyXG4gICAgICAgIHRoaXMuZGJDdXJzb3IgPSBkYkN1cnNvcjtcclxuICAgICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm5leHRLZXkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNraXBUb0tleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0S2V5O1xyXG4gICAgfVxyXG4gICAgc2V0IGN1cnNvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZGJDdXJzb3IgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHN0b3AgaXRlcmF0aW9uIGF0IGFueSBwb2ludC5cclxuICAgICAqL1xyXG4gICAgZG9uZSgpIHtcclxuICAgICAgICB0aGlzLnNob3VsZFN0b3AgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gc2tpcCB0byB0aGF0IG5leHQga2V5LCB3aGljaCBjb3VsZCBiZVxyXG4gICAgICogYW4gaW5kZXggb3IgYSBwcmltYXJ5IGtleS5cclxuICAgICAqL1xyXG4gICAgc2tpcChrZXkpIHtcclxuICAgICAgICB0aGlzLm5leHRLZXkgPSBrZXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSB0aGUgY3VycmVudCBjdXJzb3IgdmFsdWUgZnJvbSB0aGUgb2JqZWN0IHN0b3JlLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFlvdSBDQU5OT1QgZG8gdGhpcyB3aXRoIGEga2V5c09ubHkgcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QodGhpcy5kYkN1cnNvci5kZWxldGUoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEFuIGVycm9yIHRoYXQgd3JhcHMgZXhjZXB0aW9ucyB0aGF0IHRocm93biBkdXJpbmcgSW5kZXhlZERCIGV4ZWN1dGlvbi4gKi9cclxuY2xhc3MgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIEZpcmVzdG9yZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjdGlvbk5hbWUsIGNhdXNlKSB7XHJcbiAgICAgICAgc3VwZXIoQ29kZS5VTkFWQUlMQUJMRSwgYEluZGV4ZWREQiB0cmFuc2FjdGlvbiAnJHthY3Rpb25OYW1lfScgZmFpbGVkOiAke2NhdXNlfWApO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcclxuICAgIH1cclxufVxyXG4vKiogVmVyaWZpZXMgd2hldGhlciBgZWAgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpIHtcclxuICAgIC8vIFVzZSBuYW1lIGVxdWFsaXR5LCBhcyBpbnN0YW5jZW9mIGNoZWNrcyBvbiBlcnJvcnMgZG9uJ3Qgd29yayB3aXRoIGVycm9yc1xyXG4gICAgLy8gdGhhdCB3cmFwIG90aGVyIGVycm9ycy5cclxuICAgIHJldHVybiBlLm5hbWUgPT09ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcclxufVxyXG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBJREJPYmplY3RTdG9yZSBwcm92aWRpbmcgYW4gQVBJIHRoYXQ6XHJcbiAqXHJcbiAqIDEpIEhhcyBnZW5lcmljIEtleVR5cGUgLyBWYWx1ZVR5cGUgcGFyYW1ldGVycyB0byBwcm92aWRlIHN0cm9uZ2x5LXR5cGVkXHJcbiAqIG1ldGhvZHMgZm9yIGFjdGluZyBhZ2FpbnN0IHRoZSBvYmplY3Qgc3RvcmUuXHJcbiAqIDIpIERlYWxzIHdpdGggSW5kZXhlZERCJ3Mgb25zdWNjZXNzIC8gb25lcnJvciBldmVudCBjYWxsYmFja3MsIG1ha2luZyBldmVyeVxyXG4gKiBtZXRob2QgcmV0dXJuIGEgUGVyc2lzdGVuY2VQcm9taXNlIGluc3RlYWQuXHJcbiAqIDMpIFByb3ZpZGVzIGEgaGlnaGVyLWxldmVsIEFQSSB0byBhdm9pZCBuZWVkaW5nIHRvIGRvIGV4Y2Vzc2l2ZSB3cmFwcGluZyBvZlxyXG4gKiBpbnRlcm1lZGlhdGUgSW5kZXhlZERCIHR5cGVzIChJREJDdXJzb3JXaXRoVmFsdWUsIGV0Yy4pXHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVEYlN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xyXG4gICAgfVxyXG4gICAgcHV0KGtleU9yVmFsdWUsIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHJlcXVlc3Q7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUFVUJywgdGhpcy5zdG9yZS5uYW1lLCBrZXlPclZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnN0b3JlLnB1dCh2YWx1ZSwga2V5T3JWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdQVVQnLCB0aGlzLnN0b3JlLm5hbWUsICc8YXV0by1rZXk+Jywga2V5T3JWYWx1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnN0b3JlLnB1dChrZXlPclZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHZhbHVlIGludG8gYW4gT2JqZWN0IFN0b3JlIGFuZCByZXR1cm5zIHRoZSBuZXcga2V5LiBTaW1pbGFyIHRvXHJcbiAgICAgKiBJbmRleGVkRGIncyBgYWRkKClgLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgb24gcHJpbWFyeSBrZXkgY29sbGlzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgb2JqZWN0IHRvIHdyaXRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBhZGQodmFsdWUpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdBREQnLCB0aGlzLnN0b3JlLm5hbWUsIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuYWRkKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGZyb20gdGhlIHNwZWNpZmllZCBzdG9yZSwgb3IgbnVsbFxyXG4gICAgICogaWYgbm8gb2JqZWN0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBrZXkgVGhlIGtleSBvZiB0aGUgb2JqZWN0IHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBvciBudWxsIGlmIG5vIG9iamVjdCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5nZXQoa2V5KTtcclxuICAgICAgICAvLyBXZSdyZSBkb2luZyBhbiB1bnNhZmUgY2FzdCB0byBWYWx1ZVR5cGUuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCkubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgbm9uZXhpc3RlbmNlIHRvIG51bGwuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdHRVQnLCB0aGlzLnN0b3JlLm5hbWUsIGtleSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdERUxFVEUnLCB0aGlzLnN0b3JlLm5hbWUsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB3ZSBldmVyIG5lZWQgbW9yZSBvZiB0aGUgY291bnQgdmFyaWFudHMsIHdlIGNhbiBhZGQgb3ZlcmxvYWRzLiBGb3Igbm93LFxyXG4gICAgICogYWxsIHdlIG5lZWQgaXMgdG8gY291bnQgZXZlcnl0aGluZyBpbiBhIHN0b3JlLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBzdG9yZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQ09VTlQnLCB0aGlzLnN0b3JlLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmNvdW50KCk7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgbG9hZEFsbChpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0ZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSk7XHJcbiAgICAgICAgLy8gVXNlIGBnZXRBbGwoKWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgSW5kZXhlZERCIHYzLCBhcyBpdCBpcyByb3VnaGx5XHJcbiAgICAgICAgLy8gMjAlIGZhc3Rlci5cclxuICAgICAgICBjb25zdCBzdG9yZSA9IGl0ZXJhdGVPcHRpb25zLmluZGV4XHJcbiAgICAgICAgICAgID8gdGhpcy5zdG9yZS5pbmRleChpdGVyYXRlT3B0aW9ucy5pbmRleClcclxuICAgICAgICAgICAgOiB0aGlzLnN0b3JlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuZ2V0QWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoaXRlcmF0ZU9wdGlvbnMucmFuZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGl0ZXJhdGVPcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMgZnJvbSB0aGUgcHJvdmlkZWQgaW5kZXggcmFuZ2UuIExvYWRzIGFsbFxyXG4gICAgICogZWxlbWVudHMgaWYgbm8gbGltaXQgaXMgcHJvdmlkZWQuXHJcbiAgICAgKi9cclxuICAgIGxvYWRGaXJzdChyYW5nZSwgY291bnQpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5nZXRBbGwocmFuZ2UsIGNvdW50ID09PSBudWxsID8gdW5kZWZpbmVkIDogY291bnQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVBbGwoaW5kZXhPclJhbmdlLCByYW5nZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RFTEVURSBBTEwnLCB0aGlzLnN0b3JlLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSk7XHJcbiAgICAgICAgb3B0aW9ucy5rZXlzT25seSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYWxsaW5nIGRlbGV0ZSgpIG9uIGEgY3Vyc29yIGlzIGRvY3VtZW50ZWQgYXMgbW9yZSBlZmZpY2llbnQgdGhhblxyXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGRlbGV0ZSgpIG9uIGFuIG9iamVjdCBzdG9yZSB3aXRoIGEgc2luZ2xlIGtleVxyXG4gICAgICAgICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQk9iamVjdFN0b3JlL2RlbGV0ZSksXHJcbiAgICAgICAgICAgIC8vIGhvd2V2ZXIsIHRoaXMgcmVxdWlyZXMgdXMgKm5vdCogdG8gdXNlIGEga2V5c09ubHkgY3Vyc29yXHJcbiAgICAgICAgICAgIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCQ3Vyc29yL2RlbGV0ZSkuIFdlXHJcbiAgICAgICAgICAgIC8vIG1heSB3YW50IHRvIGNvbXBhcmUgdGhlIHBlcmZvcm1hbmNlIG9mIGVhY2ggbWV0aG9kLlxyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbC5kZWxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGl0ZXJhdGUob3B0aW9uc09yQ2FsbGJhY2ssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYSBzdG9yZSwgYnV0IHdhaXRzIGZvciB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gY29tcGxldGUgZm9yXHJcbiAgICAgKiBlYWNoIGVudHJ5IGJlZm9yZSBpdGVyYXRpbmcgdGhlIG5leHQgZW50cnkuIFRoaXMgYWxsb3dzIHRoZSBjYWxsYmFjayB0byBkb1xyXG4gICAgICogYXN5bmNocm9ub3VzIHdvcmsgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXRlcmF0aW9uIHNob3VsZCBjb250aW51ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBgdHJ1ZWAgdG8gY29udGludWUgaXRlcmF0aW9uLCBhbmRcclxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpdGVyYXRlU2VyaWFsKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgY3Vyc29yUmVxdWVzdCA9IHRoaXMuY3Vyc29yKHt9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IudmFsdWUpLm5leHQoc2hvdWxkQ29udGludWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb250aW51ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGl0ZXJhdGVDdXJzb3IoY3Vyc29yUmVxdWVzdCwgZm4pIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgSXRlcmF0aW9uQ29udHJvbGxlcihjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclJlc3VsdCA9IGZuKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IudmFsdWUsIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJSZXN1bHQgaW5zdGFuY2VvZiBQZXJzaXN0ZW5jZVByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHVzZXJSZXN1bHQuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5kb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHVzZXJQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzRG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIuc2tpcFRvS2V5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY29udHJvbGxlci5za2lwVG9LZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocmVzdWx0cykpO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XHJcbiAgICAgICAgbGV0IGluZGV4TmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoaW5kZXhPclJhbmdlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yUmFuZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBpbmRleE9yUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IGluZGV4T3JSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXhOYW1lLCByYW5nZSB9O1xyXG4gICAgfVxyXG4gICAgY3Vyc29yKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gJ25leHQnO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3ByZXYnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RvcmUuaW5kZXgob3B0aW9ucy5pbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXNPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgub3BlbktleUN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUub3BlbkN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHMgYW4gSURCUmVxdWVzdCBpbiBhIFBlcnNpc3RlbmNlUHJvbWlzZSwgdXNpbmcgdGhlIG9uc3VjY2VzcyAvIG9uZXJyb3JcclxuICogaGFuZGxlcnMgdG8gcmVzb2x2ZSAvIHJlamVjdCB0aGUgUGVyc2lzdGVuY2VQcm9taXNlIGFzIGFwcHJvcHJpYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLy8gR3VhcmQgc28gd2Ugb25seSByZXBvcnQgdGhlIGVycm9yIG9uY2UuXHJcbmxldCByZXBvcnRlZElPU0Vycm9yID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXJyb3IpIHtcclxuICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xyXG4gICAgaWYgKGlPU1ZlcnNpb24gPj0gMTIuMiAmJiBpT1NWZXJzaW9uIDwgMTMpIHtcclxuICAgICAgICBjb25zdCBJT1NfRVJST1IgPSAnQW4gaW50ZXJuYWwgZXJyb3Igd2FzIGVuY291bnRlcmVkIGluIHRoZSBJbmRleGVkIERhdGFiYXNlIHNlcnZlcic7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5kZXhPZihJT1NfRVJST1IpID49IDApIHtcclxuICAgICAgICAgICAgLy8gV3JhcCBlcnJvciBpbiBhIG1vcmUgZGVzY3JpcHRpdmUgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBuZXdFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcignaW50ZXJuYWwnLCBgSU9TX0lOREVYRUREQl9CVUcxOiBJbmRleGVkRGIgaGFzIHRocm93biAnJHtJT1NfRVJST1J9Jy4gVGhpcyBpcyBsaWtlbHkgYCArXHJcbiAgICAgICAgICAgICAgICBgZHVlIHRvIGFuIHVuYXZvaWRhYmxlIGJ1ZyBpbiBpT1MuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTY0OTYyOTYvMTEwOTE1IGAgK1xyXG4gICAgICAgICAgICAgICAgYGZvciBkZXRhaWxzIGFuZCBhIHBvdGVudGlhbCB3b3JrYXJvdW5kLmApO1xyXG4gICAgICAgICAgICBpZiAoIXJlcG9ydGVkSU9TRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlcG9ydGVkSU9TRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYSBnbG9iYWwgZXhjZXB0aW9uIG91dHNpZGUgb2YgdGhpcyBwcm9taXNlIGNoYWluLCBmb3IgdGhlIHVzZXIgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbGx5IGNhdGNoLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3RXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3RXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XG5cbmNvbnN0IExPR19UQUckaCA9ICdJbmRleEJhY2tmaWxsZXInO1xyXG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBpbmRleCBiYWNrZmlsbCBhZnRlciBTREsgaW5pdGlhbGl6YXRpb24uICovXHJcbmNvbnN0IElOSVRJQUxfQkFDS0ZJTExfREVMQVlfTVMgPSAxNSAqIDEwMDA7XHJcbi8qKiBNaW5pbXVtIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gYmFja2ZpbGwgY2hlY2tzLCBhZnRlciB0aGUgZmlyc3Qgb25lLiAqL1xyXG5jb25zdCBSRUdVTEFSX0JBQ0tGSUxMX0RFTEFZX01TID0gNjAgKiAxMDAwO1xyXG4vKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGRvY3VtZW50cyB0byBwcm9jZXNzIGVhY2ggdGltZSBiYWNrZmlsbCgpIGlzIGNhbGxlZC4gKi9cclxuY29uc3QgTUFYX0RPQ1VNRU5UU19UT19QUk9DRVNTID0gNTA7XHJcbi8qKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBJbmRleCBCYWNrZmlsbGVyLiAqL1xyXG5jbGFzcyBJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgYmFja2ZpbGxlcikge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5iYWNrZmlsbGVyID0gYmFja2ZpbGxlcjtcclxuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZShJTklUSUFMX0JBQ0tGSUxMX0RFTEFZX01TKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGFzaykge1xyXG4gICAgICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFzayAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIHNjaGVkdWxlKGRlbGF5KSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgU2NoZWR1bGVkIGluICR7ZGVsYXl9bXNgKTtcclxuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkoXCJpbmRleF9iYWNrZmlsbFwiIC8qIFRpbWVySWQuSW5kZXhCYWNrZmlsbCAqLywgZGVsYXksIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50c1Byb2Nlc3NlZCA9IGF3YWl0IHRoaXMuYmFja2ZpbGxlci5iYWNrZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgRG9jdW1lbnRzIHdyaXR0ZW46ICR7ZG9jdW1lbnRzUHJvY2Vzc2VkfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCAnSWdub3JpbmcgSW5kZXhlZERCIGVycm9yIGR1cmluZyBpbmRleCBiYWNrZmlsbDogJywgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZShSRUdVTEFSX0JBQ0tGSUxMX0RFTEFZX01TKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKiogSW1wbGVtZW50cyB0aGUgc3RlcHMgZm9yIGJhY2tmaWxsaW5nIGluZGV4ZXMuICovXHJcbmNsYXNzIEluZGV4QmFja2ZpbGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogTG9jYWxTdG9yZSBwcm92aWRlcyBhY2Nlc3MgdG8gSW5kZXhNYW5hZ2VyIGFuZCBMb2NhbERvY3VtZW50Vmlldy5cclxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgd2lsbCB1cGRhdGUgd2hlbiB0aGUgdXNlciBjaGFuZ2VzLiBDb25zZXF1ZW50bHksXHJcbiAgICAgKiBtYWtpbmcgYSBsb2NhbCBjb3B5IG9mIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcgd2lsbCByZXF1aXJlXHJcbiAgICAgKiB1cGRhdGVzIG92ZXIgdGltZS4gVGhlIHNpbXBsZXIgc29sdXRpb24gaXMgdG8gcmVseSBvbiBMb2NhbFN0b3JlIHRvIGhhdmVcclxuICAgICAqIGFuIHVwLXRvLWRhdGUgcmVmZXJlbmNlcyB0byBJbmRleE1hbmFnZXIgYW5kIExvY2FsRG9jdW1lbnRTdG9yZS5cclxuICAgICAqL1xyXG4gICAgbG9jYWxTdG9yZSwgcGVyc2lzdGVuY2UpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgIH1cclxuICAgIGFzeW5jIGJhY2tmaWxsKG1heERvY3VtZW50c1RvUHJvY2VzcyA9IE1BWF9ET0NVTUVOVFNfVE9fUFJPQ0VTUykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdCYWNrZmlsbCBJbmRleGVzJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHRoaXMud3JpdGVJbmRleEVudHJpZXModHhuLCBtYXhEb2N1bWVudHNUb1Byb2Nlc3MpKTtcclxuICAgIH1cclxuICAgIC8qKiBXcml0ZXMgaW5kZXggZW50cmllcyB1bnRpbCB0aGUgY2FwIGlzIHJlYWNoZWQuIFJldHVybnMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcHJvY2Vzc2VkLiAqL1xyXG4gICAgd3JpdGVJbmRleEVudHJpZXModHJhbnNhdGlvbiwgbWF4RG9jdW1lbnRzVG9Qcm9jZXNzKSB7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ29sbGVjdGlvbkdyb3VwcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgZG9jdW1lbnRzUmVtYWluaW5nID0gbWF4RG9jdW1lbnRzVG9Qcm9jZXNzO1xyXG4gICAgICAgIGxldCBjb250aW51ZUxvb3AgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZG9XaGlsZSgoKSA9PiBjb250aW51ZUxvb3AgPT09IHRydWUgJiYgZG9jdW1lbnRzUmVtYWluaW5nID4gMCwgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxyXG4gICAgICAgICAgICAgICAgLmdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKGNvbGxlY3Rpb25Hcm91cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMuaGFzKGNvbGxlY3Rpb25Hcm91cCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZUxvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFByb2Nlc3NpbmcgY29sbGVjdGlvbjogJHtjb2xsZWN0aW9uR3JvdXB9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVFbnRyaWVzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYXRpb24sIGNvbGxlY3Rpb25Hcm91cCwgZG9jdW1lbnRzUmVtYWluaW5nKS5uZXh0KGRvY3VtZW50c1Byb2Nlc3NlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50c1JlbWFpbmluZyAtPSBkb2N1bWVudHNQcm9jZXNzZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMuYWRkKGNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gbWF4RG9jdW1lbnRzVG9Qcm9jZXNzIC0gZG9jdW1lbnRzUmVtYWluaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGVudHJpZXMgZm9yIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uIGdyb3VwLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHByb2Nlc3NlZC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVFbnRyaWVzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGRvY3VtZW50c1JlbWFpbmluZ1VuZGVyQ2FwKSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBlYXJsaWVzdCBvZmZzZXQgb2YgYWxsIGZpZWxkIGluZGV4ZXMgdG8gcXVlcnkgdGhlIGxvY2FsIGNhY2hlLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgIC5nZXRNaW5PZmZzZXRGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApXHJcbiAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nT2Zmc2V0ID0+IHRoaXMubG9jYWxTdG9yZS5sb2NhbERvY3VtZW50c1xyXG4gICAgICAgICAgICAuZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBleGlzdGluZ09mZnNldCwgZG9jdW1lbnRzUmVtYWluaW5nVW5kZXJDYXApXHJcbiAgICAgICAgICAgIC5uZXh0KG5leHRCYXRjaCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3MgPSBuZXh0QmF0Y2guY2hhbmdlcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgICAgIC51cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3MpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLmdldE5ld09mZnNldChleGlzdGluZ09mZnNldCwgbmV4dEJhdGNoKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KG5ld09mZnNldCA9PiB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBVcGRhdGluZyBvZmZzZXQ6ICR7bmV3T2Zmc2V0fWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXIudXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG5ld09mZnNldCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBkb2NzLnNpemUpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBuZXh0IG9mZnNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzLiAqL1xyXG4gICAgZ2V0TmV3T2Zmc2V0KGV4aXN0aW5nT2Zmc2V0LCBsb29rdXBSZXN1bHQpIHtcclxuICAgICAgICBsZXQgbWF4T2Zmc2V0ID0gZXhpc3RpbmdPZmZzZXQ7XHJcbiAgICAgICAgbG9va3VwUmVzdWx0LmNoYW5nZXMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3T2Zmc2V0LCBtYXhPZmZzZXQpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbmV3T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChtYXhPZmZzZXQucmVhZFRpbWUsIG1heE9mZnNldC5kb2N1bWVudEtleSwgTWF0aC5tYXgobG9va3VwUmVzdWx0LmJhdGNoSWQsIGV4aXN0aW5nT2Zmc2V0Lmxhcmdlc3RCYXRjaElkKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIGBMaXN0ZW5TZXF1ZW5jZWAgaXMgYSBtb25vdG9uaWMgc2VxdWVuY2UuIEl0IGlzIGluaXRpYWxpemVkIHdpdGggYSBtaW5pbXVtIHZhbHVlIHRvXHJcbiAqIGV4Y2VlZC4gQWxsIHN1YnNlcXVlbnQgY2FsbHMgdG8gbmV4dCB3aWxsIHJldHVybiBpbmNyZWFzaW5nIHZhbHVlcy4gSWYgcHJvdmlkZWQgd2l0aCBhXHJcbiAqIGBTZXF1ZW5jZU51bWJlclN5bmNlcmAsIGl0IHdpbGwgYWRkaXRpb25hbGx5IGJ1bXAgaXRzIG5leHQgdmFsdWUgd2hlbiB0b2xkIG9mIGEgbmV3IHZhbHVlLCBhc1xyXG4gKiB3ZWxsIGFzIHdyaXRlIG91dCBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgaXQgcHJvZHVjZXMgdmlhIGBuZXh0KClgLlxyXG4gKi9cclxuY2xhc3MgTGlzdGVuU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IocHJldmlvdXNWYWx1ZSwgc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xyXG4gICAgICAgIGlmIChzZXF1ZW5jZU51bWJlclN5bmNlcikge1xyXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlclN5bmNlci5zZXF1ZW5jZU51bWJlckhhbmRsZXIgPSBzZXF1ZW5jZU51bWJlciA9PiB0aGlzLnNldFByZXZpb3VzVmFsdWUoc2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlciA9PiBzZXF1ZW5jZU51bWJlclN5bmNlci53cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRQcmV2aW91c1ZhbHVlKGV4dGVybmFsUHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IE1hdGgubWF4KGV4dGVybmFsUHJldmlvdXNWYWx1ZSwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSArK3RoaXMucHJldmlvdXNWYWx1ZTtcclxuICAgICAgICBpZiAodGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlcihuZXh0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG59XHJcbkxpc3RlblNlcXVlbmNlLklOVkFMSUQgPSAtMTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgZXNjYXBlQ2hhciA9ICdcXHUwMDAxJztcclxuY29uc3QgZW5jb2RlZFNlcGFyYXRvckNoYXIgPSAnXFx1MDAwMSc7XHJcbmNvbnN0IGVuY29kZWROdWwgPSAnXFx1MDAxMCc7XHJcbmNvbnN0IGVuY29kZWRFc2NhcGUgPSAnXFx1MDAxMSc7XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgcmVzb3VyY2UgcGF0aCBpbnRvIGEgSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0uXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBlbmNvZGVTZWdtZW50KHBhdGguZ2V0KGkpLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgc2luZ2xlIHNlZ21lbnQgb2YgYSByZXNvdXJjZSBwYXRoIGludG8gdGhlIGdpdmVuIHJlc3VsdCAqL1xyXG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50KHNlZ21lbnQsIHJlc3VsdEJ1Zikge1xyXG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdEJ1ZjtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzZWdtZW50LmNoYXJBdChpKTtcclxuICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgY2FzZSAnXFwwJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyICsgZW5jb2RlZE51bDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGVzY2FwZUNoYXI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQ2hhciArIGVuY29kZWRFc2NhcGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqIEVuY29kZXMgYSBwYXRoIHNlcGFyYXRvciBpbnRvIHRoZSBnaXZlbiByZXN1bHQgKi9cclxuZnVuY3Rpb24gZW5jb2RlU2VwYXJhdG9yKHJlc3VsdCkge1xyXG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUNoYXIgKyBlbmNvZGVkU2VwYXJhdG9yQ2hhcjtcclxufVxyXG4vKipcclxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0gb2YgYSByZXNvdXJjZSBwYXRoIGludG9cclxuICogYSBSZXNvdXJjZVBhdGggaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3Qgc3VpdGFibGUgZm9yIHVzZSB3aXRoXHJcbiAqIGRlY29kaW5nIHJlc291cmNlIG5hbWVzIGZyb20gdGhlIHNlcnZlcjsgdGhvc2UgYXJlIE9uZSBQbGF0Zm9ybSBmb3JtYXRcclxuICogc3RyaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVJlc291cmNlUGF0aChwYXRoKSB7XHJcbiAgICAvLyBFdmVudCB0aGUgZW1wdHkgcGF0aCBtdXN0IGVuY29kZSBhcyBhIHBhdGggb2YgYXQgbGVhc3QgbGVuZ3RoIDIuIEEgcGF0aFxyXG4gICAgLy8gd2l0aCBleGFjdGx5IDIgbXVzdCBiZSB0aGUgZW1wdHkgcGF0aC5cclxuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgaGFyZEFzc2VydChsZW5ndGggPj0gMik7XHJcbiAgICBpZiAobGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChwYXRoLmNoYXJBdCgwKSA9PT0gZXNjYXBlQ2hhciAmJiBwYXRoLmNoYXJBdCgxKSA9PT0gZW5jb2RlZFNlcGFyYXRvckNoYXIpO1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XHJcbiAgICB9XHJcbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyBjYW5ub3QgZXhpc3QgcGFzdCB0aGUgc2Vjb25kLXRvLWxhc3QgcG9zaXRpb24gaW4gdGhlXHJcbiAgICAvLyBzb3VyY2UgdmFsdWUuXHJcbiAgICBjb25zdCBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4ID0gbGVuZ3RoIC0gMjtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XHJcbiAgICBsZXQgc2VnbWVudEJ1aWxkZXIgPSAnJztcclxuICAgIGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgLy8gVGhlIGxhc3QgdHdvIGNoYXJhY3RlcnMgb2YgYSB2YWxpZCBlbmNvZGVkIHBhdGggbXVzdCBiZSBhIHNlcGFyYXRvciwgc29cclxuICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIGFuIGVuZCB0byB0aGlzIHNlZ21lbnQuXHJcbiAgICAgICAgY29uc3QgZW5kID0gcGF0aC5pbmRleE9mKGVzY2FwZUNoYXIsIHN0YXJ0KTtcclxuICAgICAgICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4KSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IHBhdGguY2hhckF0KGVuZCArIDEpO1xyXG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xyXG4gICAgICAgICAgICBjYXNlIGVuY29kZWRTZXBhcmF0b3JDaGFyOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBpZWNlID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50QnVpbGRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzZWdtZW50IHRoYXQgZXhjbHVkZXMgXFwwXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIFxcMDAxXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGN1cnJlbnRQaWVjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IGN1cnJlbnRQaWVjZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudEJ1aWxkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlbmNvZGVkTnVsOlxyXG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSAnXFwwJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGVuY29kZWRFc2NhcGU6XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXNjYXBlIGNoYXJhY3RlciBjYW4gYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHRvIGVuY29kZSBpdHNlbGYuXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgZW5kICsgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgKyAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxID0gJ3JlbW90ZURvY3VtZW50cyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIG5hbWUgJ293bmVyJyBpcyBjaG9zZW4gdG8gZW5zdXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGhcclxuICogb2xkZXIgY2xpZW50cyB0aGF0IG9ubHkgc3VwcG9ydGVkIHNpbmdsZSBsb2NrZWQgYWNjZXNzIHRvIHRoZSBwZXJzaXN0ZW5jZVxyXG4gKiBsYXllci5cclxuICovXHJcbmNvbnN0IERiUHJpbWFyeUNsaWVudFN0b3JlID0gJ293bmVyJztcclxuLyoqXHJcbiAqIFRoZSBrZXkgc3RyaW5nIHVzZWQgZm9yIHRoZSBzaW5nbGUgb2JqZWN0IHRoYXQgZXhpc3RzIGluIHRoZVxyXG4gKiBEYlByaW1hcnlDbGllbnQgc3RvcmUuXHJcbiAqL1xyXG5jb25zdCBEYlByaW1hcnlDbGllbnRLZXkgPSAnb3duZXInO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXHJcbmNvbnN0IERiTXV0YXRpb25RdWV1ZVN0b3JlID0gJ211dGF0aW9uUXVldWVzJztcclxuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB1c2VySWQgcHJvcGVydHkuICovXHJcbmNvbnN0IERiTXV0YXRpb25RdWV1ZUtleVBhdGggPSAndXNlcklkJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xyXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hTdG9yZSA9ICdtdXRhdGlvbnMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHVzZXJJZCwgYmF0Y2hJZCBwcm9wZXJ0aWVzLiAqL1xyXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hLZXlQYXRoID0gJ2JhdGNoSWQnO1xyXG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIGxvb2t1cCBvZiBtdXRhdGlvbnMgYnkgdXNlci4gKi9cclxuY29uc3QgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4ID0gJ3VzZXJNdXRhdGlvbnNJbmRleCc7XHJcbi8qKiBUaGUgdXNlciBtdXRhdGlvbnMgaW5kZXggaXMga2V5ZWQgYnkgW3VzZXJJZCwgYmF0Y2hJZF0gcGFpcnMuICovXHJcbmNvbnN0IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoID0gWyd1c2VySWQnLCAnYmF0Y2hJZCddO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIFt1c2VySWRdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4IHRvIGl0ZXJhdGVcclxuICogb3ZlciBhbGwgb2YgYSB1c2VyJ3MgZG9jdW1lbnQgbXV0YXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yVXNlcih1c2VySWQpIHtcclxuICAgIHJldHVybiBbdXNlcklkXTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIFt1c2VySWQsIGVuY29kZWRQYXRoXSBrZXkgZm9yIHVzZSBpbiB0aGUgRGJEb2N1bWVudE11dGF0aW9uc1xyXG4gKiBpbmRleCB0byBpdGVyYXRlIG92ZXIgYWxsIGF0IGRvY3VtZW50IG11dGF0aW9ucyBmb3IgYSBnaXZlbiBwYXRoIG9yIGxvd2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh1c2VySWQsIHBhdGgpIHtcclxuICAgIHJldHVybiBbdXNlcklkLCBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCldO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVsbCBpbmRleCBrZXkgb2YgW3VzZXJJZCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdIGZvciBpbnNlcnRpbmdcclxuICogYW5kIGRlbGV0aW5nIGludG8gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnMgaW5kZXguXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdEYkRvY3VtZW50TXV0YXRpb25LZXkodXNlcklkLCBwYXRoLCBiYXRjaElkKSB7XHJcbiAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLCBiYXRjaElkXTtcclxufVxyXG4vKipcclxuICogQmVjYXVzZSB3ZSBzdG9yZSBhbGwgdGhlIHVzZWZ1bCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBzdG9yZSBpbiB0aGUga2V5LFxyXG4gKiB0aGVyZSBpcyBubyB1c2VmdWwgaW5mb3JtYXRpb24gdG8gc3RvcmUgYXMgdGhlIHZhbHVlLiBUaGUgcmF3ICh1bmVuY29kZWQpXHJcbiAqIHBhdGggY2Fubm90IGJlIHN0b3JlZCBiZWNhdXNlIEluZGV4ZWREYiBkb2Vzbid0IHN0b3JlIHByb3RvdHlwZVxyXG4gKiBpbmZvcm1hdGlvbi5cclxuICovXHJcbmNvbnN0IERiRG9jdW1lbnRNdXRhdGlvblBsYWNlaG9sZGVyID0ge307XHJcbmNvbnN0IERiRG9jdW1lbnRNdXRhdGlvblN0b3JlID0gJ2RvY3VtZW50TXV0YXRpb25zJztcclxuY29uc3QgRGJSZW1vdGVEb2N1bWVudFN0b3JlID0gJ3JlbW90ZURvY3VtZW50c1YxNCc7XHJcbi8qKlxyXG4gKiBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIHJlbW90ZSBkb2N1bWVudHMgc3RvcmUsIHdoaWNoIGFsbG93cyBmb3IgZWZmaWNpZW50XHJcbiAqIGFjY2VzcyBieSBjb2xsZWN0aW9uIHBhdGggYW5kIHJlYWQgdGltZS5cclxuICovXHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoID0gW1xyXG4gICAgJ3ByZWZpeFBhdGgnLFxyXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXHJcbiAgICAncmVhZFRpbWUnLFxyXG4gICAgJ2RvY3VtZW50SWQnXHJcbl07XHJcbi8qKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgYnkga2V5LiAqL1xyXG5jb25zdCBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCA9ICdkb2N1bWVudEtleUluZGV4JztcclxuY29uc3QgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXhQYXRoID0gW1xyXG4gICAgJ3ByZWZpeFBhdGgnLFxyXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXHJcbiAgICAnZG9jdW1lbnRJZCdcclxuXTtcclxuLyoqXHJcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGRvY3VtZW50cyBieSBjb2xsZWN0aW9uIGdyb3VwIGFuZCByZWFkXHJcbiAqIHRpbWUuXHJcbiAqXHJcbiAqIFRoaXMgaW5kZXggaXMgdXNlZCBieSB0aGUgaW5kZXggYmFja2ZpbGxlci5cclxuICovXHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBJbmRleCc7XHJcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleFBhdGggPSBbXHJcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcclxuICAgICdyZWFkVGltZScsXHJcbiAgICAncHJlZml4UGF0aCcsXHJcbiAgICAnZG9jdW1lbnRJZCdcclxuXTtcclxuY29uc3QgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlID0gJ3JlbW90ZURvY3VtZW50R2xvYmFsJztcclxuY29uc3QgRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSA9ICdyZW1vdGVEb2N1bWVudEdsb2JhbEtleSc7XHJcbmNvbnN0IERiVGFyZ2V0U3RvcmUgPSAndGFyZ2V0cyc7XHJcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdGFyZ2V0SWQgcHJvcGVydHkuICovXHJcbmNvbnN0IERiVGFyZ2V0S2V5UGF0aCA9ICd0YXJnZXRJZCc7XHJcbi8qKiBUaGUgbmFtZSBvZiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4LiAqL1xyXG5jb25zdCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0luZGV4TmFtZSA9ICdxdWVyeVRhcmdldHNJbmRleCc7XHJcbi8qKlxyXG4gKiBUaGUgaW5kZXggb2YgYWxsIGNhbm9uaWNhbElkcyB0byB0aGUgdGFyZ2V0cyB0aGF0IHRoZXkgbWF0Y2guIFRoaXMgaXMgbm90XHJcbiAqIGEgdW5pcXVlIG1hcHBpbmcgYmVjYXVzZSBjYW5vbmljYWxJZCBkb2VzIG5vdCBwcm9taXNlIGEgdW5pcXVlIG5hbWUgZm9yIGFsbFxyXG4gKiBwb3NzaWJsZSBxdWVyaWVzLCBzbyB3ZSBhcHBlbmQgdGhlIHRhcmdldElkIHRvIG1ha2UgdGhlIG1hcHBpbmcgdW5pcXVlLlxyXG4gKi9cclxuY29uc3QgRGJUYXJnZXRRdWVyeVRhcmdldHNLZXlQYXRoID0gWydjYW5vbmljYWxJZCcsICd0YXJnZXRJZCddO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXHJcbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnRTdG9yZSA9ICd0YXJnZXREb2N1bWVudHMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHRhcmdldElkLCBwYXRoIHByb3BlcnRpZXMuICovXHJcbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoID0gWyd0YXJnZXRJZCcsICdwYXRoJ107XHJcbi8qKiBUaGUgaW5kZXggbmFtZSBmb3IgdGhlIHJldmVyc2UgaW5kZXguICovXHJcbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCA9ICdkb2N1bWVudFRhcmdldHNJbmRleCc7XHJcbi8qKiBXZSBhbHNvIG5lZWQgdG8gY3JlYXRlIHRoZSByZXZlcnNlIGluZGV4IGZvciB0aGVzZSBwcm9wZXJ0aWVzLiAqL1xyXG5jb25zdCBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzS2V5UGF0aCA9IFsncGF0aCcsICd0YXJnZXRJZCddO1xyXG4vKipcclxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXHJcbiAqIERiVGFyZ2V0R2xvYmFsIHN0b3JlLlxyXG4gKi9cclxuY29uc3QgRGJUYXJnZXRHbG9iYWxLZXkgPSAndGFyZ2V0R2xvYmFsS2V5JztcclxuY29uc3QgRGJUYXJnZXRHbG9iYWxTdG9yZSA9ICd0YXJnZXRHbG9iYWwnO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuY29uc3QgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUgPSAnY29sbGVjdGlvblBhcmVudHMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIGNvbGxlY3Rpb25JZCwgcGFyZW50IHByb3BlcnRpZXMuICovXHJcbmNvbnN0IERiQ29sbGVjdGlvblBhcmVudEtleVBhdGggPSBbJ2NvbGxlY3Rpb25JZCcsICdwYXJlbnQnXTtcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiQ2xpZW50TWV0YWRhdGFTdG9yZSA9ICdjbGllbnRNZXRhZGF0YSc7XHJcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgY2xpZW50SWQgcHJvcGVydGllcy4gKi9cclxuY29uc3QgRGJDbGllbnRNZXRhZGF0YUtleVBhdGggPSAnY2xpZW50SWQnO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuY29uc3QgRGJCdW5kbGVTdG9yZSA9ICdidW5kbGVzJztcclxuY29uc3QgRGJCdW5kbGVLZXlQYXRoID0gJ2J1bmRsZUlkJztcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiTmFtZWRRdWVyeVN0b3JlID0gJ25hbWVkUXVlcmllcyc7XHJcbmNvbnN0IERiTmFtZWRRdWVyeUtleVBhdGggPSAnbmFtZSc7XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlID0gJ2luZGV4Q29uZmlndXJhdGlvbic7XHJcbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uS2V5UGF0aCA9ICdpbmRleElkJztcclxuLyoqXHJcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBpbmRleCBjb25maWd1cmF0aW9ucyBieSBjb2xsZWN0aW9uXHJcbiAqIGdyb3VwLlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcclxuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cclxuICogcGVyc2lzdGVuY2UgdmlhIG11bHRpLXRhYi5cclxuICovXHJcbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xyXG5jb25zdCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCA9ICdjb2xsZWN0aW9uR3JvdXAnO1xyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuY29uc3QgRGJJbmRleFN0YXRlU3RvcmUgPSAnaW5kZXhTdGF0ZSc7XHJcbmNvbnN0IERiSW5kZXhTdGF0ZUtleVBhdGggPSBbJ2luZGV4SWQnLCAndWlkJ107XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgaW4gYSBjb2xsZWN0aW9uIHNvcnRlZCBieSBsYXN0XHJcbiAqIHVwZGF0ZSB0aW1lLiBVc2VkIGJ5IHRoZSBiYWNrZmlsbGVyLlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcclxuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cclxuICogcGVyc2lzdGVuY2UgdmlhIG11bHRpLXRhYi5cclxuICovXHJcbmNvbnN0IERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXggPSAnc2VxdWVuY2VOdW1iZXJJbmRleCc7XHJcbmNvbnN0IERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXhQYXRoID0gWyd1aWQnLCAnc2VxdWVuY2VOdW1iZXInXTtcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiSW5kZXhFbnRyeVN0b3JlID0gJ2luZGV4RW50cmllcyc7XHJcbmNvbnN0IERiSW5kZXhFbnRyeUtleVBhdGggPSBbXHJcbiAgICAnaW5kZXhJZCcsXHJcbiAgICAndWlkJyxcclxuICAgICdhcnJheVZhbHVlJyxcclxuICAgICdkaXJlY3Rpb25hbFZhbHVlJyxcclxuICAgICdvcmRlcmVkRG9jdW1lbnRLZXknLFxyXG4gICAgJ2RvY3VtZW50S2V5J1xyXG5dO1xyXG5jb25zdCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4ID0gJ2RvY3VtZW50S2V5SW5kZXgnO1xyXG5jb25zdCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4UGF0aCA9IFtcclxuICAgICdpbmRleElkJyxcclxuICAgICd1aWQnLFxyXG4gICAgJ29yZGVyZWREb2N1bWVudEtleSdcclxuXTtcclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5U3RvcmUgPSAnZG9jdW1lbnRPdmVybGF5cyc7XHJcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5S2V5UGF0aCA9IFtcclxuICAgICd1c2VySWQnLFxyXG4gICAgJ2NvbGxlY3Rpb25QYXRoJyxcclxuICAgICdkb2N1bWVudElkJ1xyXG5dO1xyXG5jb25zdCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4ID0gJ2NvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4JztcclxuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGggPSBbXHJcbiAgICAndXNlcklkJyxcclxuICAgICdjb2xsZWN0aW9uUGF0aCcsXHJcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXHJcbl07XHJcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4ID0gJ2NvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCc7XHJcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4UGF0aCA9IFtcclxuICAgICd1c2VySWQnLFxyXG4gICAgJ2NvbGxlY3Rpb25Hcm91cCcsXHJcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXHJcbl07XHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcclxuY29uc3QgVjFfU1RPUkVTID0gW1xyXG4gICAgRGJNdXRhdGlvblF1ZXVlU3RvcmUsXHJcbiAgICBEYk11dGF0aW9uQmF0Y2hTdG9yZSxcclxuICAgIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlLFxyXG4gICAgRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEsXHJcbiAgICBEYlRhcmdldFN0b3JlLFxyXG4gICAgRGJQcmltYXJ5Q2xpZW50U3RvcmUsXHJcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxyXG4gICAgRGJUYXJnZXREb2N1bWVudFN0b3JlXHJcbl07XHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcclxuY29uc3QgVjNfU1RPUkVTID0gVjFfU1RPUkVTO1xyXG4vLyBOb3RlOiBEYlJlbW90ZURvY3VtZW50Q2hhbmdlcyBpcyBubyBsb25nZXIgdXNlZCBhbmQgZHJvcHBlZCB3aXRoIHY5LlxyXG5jb25zdCBWNF9TVE9SRVMgPSBbLi4uVjNfU1RPUkVTLCBEYkNsaWVudE1ldGFkYXRhU3RvcmVdO1xyXG5jb25zdCBWNl9TVE9SRVMgPSBbLi4uVjRfU1RPUkVTLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmVdO1xyXG5jb25zdCBWOF9TVE9SRVMgPSBbLi4uVjZfU1RPUkVTLCBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZV07XHJcbmNvbnN0IFYxMV9TVE9SRVMgPSBbLi4uVjhfU1RPUkVTLCBEYkJ1bmRsZVN0b3JlLCBEYk5hbWVkUXVlcnlTdG9yZV07XHJcbmNvbnN0IFYxMl9TVE9SRVMgPSBbLi4uVjExX1NUT1JFUywgRGJEb2N1bWVudE92ZXJsYXlTdG9yZV07XHJcbmNvbnN0IFYxM19TVE9SRVMgPSBbXHJcbiAgICBEYk11dGF0aW9uUXVldWVTdG9yZSxcclxuICAgIERiTXV0YXRpb25CYXRjaFN0b3JlLFxyXG4gICAgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUsXHJcbiAgICBEYlJlbW90ZURvY3VtZW50U3RvcmUsXHJcbiAgICBEYlRhcmdldFN0b3JlLFxyXG4gICAgRGJQcmltYXJ5Q2xpZW50U3RvcmUsXHJcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxyXG4gICAgRGJUYXJnZXREb2N1bWVudFN0b3JlLFxyXG4gICAgRGJDbGllbnRNZXRhZGF0YVN0b3JlLFxyXG4gICAgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlLFxyXG4gICAgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUsXHJcbiAgICBEYkJ1bmRsZVN0b3JlLFxyXG4gICAgRGJOYW1lZFF1ZXJ5U3RvcmUsXHJcbiAgICBEYkRvY3VtZW50T3ZlcmxheVN0b3JlXHJcbl07XHJcbmNvbnN0IFYxNF9TVE9SRVMgPSBWMTNfU1RPUkVTO1xyXG5jb25zdCBWMTVfU1RPUkVTID0gW1xyXG4gICAgLi4uVjE0X1NUT1JFUyxcclxuICAgIERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsXHJcbiAgICBEYkluZGV4U3RhdGVTdG9yZSxcclxuICAgIERiSW5kZXhFbnRyeVN0b3JlXHJcbl07XHJcbmNvbnN0IFYxNl9TVE9SRVMgPSBWMTVfU1RPUkVTO1xyXG4vKiogUmV0dXJucyB0aGUgb2JqZWN0IHN0b3JlcyBmb3IgdGhlIHByb3ZpZGVkIHNjaGVtYS4gKi9cclxuZnVuY3Rpb24gZ2V0T2JqZWN0U3RvcmVzKHNjaGVtYVZlcnNpb24pIHtcclxuICAgIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNikge1xyXG4gICAgICAgIHJldHVybiBWMTZfU1RPUkVTO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTUpIHtcclxuICAgICAgICByZXR1cm4gVjE1X1NUT1JFUztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE0KSB7XHJcbiAgICAgICAgcmV0dXJuIFYxNF9TVE9SRVM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMykge1xyXG4gICAgICAgIHJldHVybiBWMTNfU1RPUkVTO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTIpIHtcclxuICAgICAgICByZXR1cm4gVjEyX1NUT1JFUztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIFYxMV9TVE9SRVM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiVHJhbnNhY3Rpb24gZXh0ZW5kcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHNpbXBsZURiVHJhbnNhY3Rpb24sIGN1cnJlbnRTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVEYlRyYW5zYWN0aW9uID0gc2ltcGxlRGJUcmFuc2FjdGlvbjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZU51bWJlciA9IGN1cnJlbnRTZXF1ZW5jZU51bWJlcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XHJcbiAgICBjb25zdCBpbmRleGVkRGJUcmFuc2FjdGlvbiA9IGRlYnVnQ2FzdCh0eG4pO1xyXG4gICAgcmV0dXJuIFNpbXBsZURiLmdldFN0b3JlKGluZGV4ZWREYlRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHN0b3JlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG59XHJcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1hcFRvQXJyYXkob2JqLCBmbikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihvYmpba2V5XSwga2V5LCBvYmopKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xyXG4vLyB0cmVlLlxyXG5jbGFzcyBTb3J0ZWRNYXAge1xyXG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvciwgcm9vdCkge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdCA/IHJvb3QgOiBMTFJCTm9kZS5FTVBUWTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvciwgdGhpcy5yb290XHJcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvciwgdGhpcy5yb290XHJcbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3IpXHJcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGlzIHNvcnRlZCBtYXAsIG9yIC0xIGlmIGl0IGRvZXNuJ3RcclxuICAgIC8vIGV4aXN0LlxyXG4gICAgaW5kZXhPZihrZXkpIHtcclxuICAgICAgICAvLyBOdW1iZXIgb2Ygbm9kZXMgdGhhdCB3ZXJlIHBydW5lZCB3aGVuIGRlc2NlbmRpbmcgcmlnaHRcclxuICAgICAgICBsZXQgcHJ1bmVkTm9kZXMgPSAwO1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJ1bmVkTm9kZXMgKyBub2RlLmxlZnQuc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ291bnQgYWxsIG5vZGVzIGxlZnQgb2YgdGhlIG5vZGUgcGx1cyB0aGUgbm9kZSBpdHNlbGZcclxuICAgICAgICAgICAgICAgIHBydW5lZE5vZGVzICs9IG5vZGUubGVmdC5zaXplICsgMTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vZGUgbm90IGZvdW5kXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbWFwLlxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaXplO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBrZXkgaW4gdGhlIG1hcC5cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1pbktleSgpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIG1hcC5cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgLy8gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaChmbikge1xyXG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBmbihrLCB2KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9ucy5wdXNoKGAke2t9OiR7dn1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBgeyR7ZGVzY3JpcHRpb25zLmpvaW4oJywgJyl9fWA7XHJcbiAgICB9XHJcbiAgICAvLyBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXNcclxuICAgIC8vIGFib3J0ZWQuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cclxuICAgIGdldEl0ZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBudWxsLCB0aGlzLmNvbXBhcmF0b3IsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwga2V5LCB0aGlzLmNvbXBhcmF0b3IsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCB0cnVlKTtcclxuICAgIH1cclxufSAvLyBlbmQgU29ydGVkTWFwXHJcbi8vIEFuIGl0ZXJhdG9yIG92ZXIgYW4gTExSQk5vZGUuXHJcbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2UpIHtcclxuICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IGlzUmV2ZXJzZTtcclxuICAgICAgICB0aGlzLm5vZGVTdGFjayA9IFtdO1xyXG4gICAgICAgIGxldCBjbXAgPSAxO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcclxuICAgICAgICAgICAgaWYgKHN0YXJ0S2V5ICYmIGlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgY21wICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb3VyIHN0YXJ0IGtleS4gUHVzaCBpdCBvbiB0aGUgc3RhY2ssXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RvcCBpdGVyYXRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZ3JlYXRlciB0aGFuIG91ciBzdGFydCBrZXksIGFkZCBpdCB0byB0aGUgc3RhY2sgYW5kIG1vdmVcclxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBoYXNOZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTdGFjay5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tbdGhpcy5ub2RlU3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcclxuICAgIH1cclxufSAvLyBlbmQgU29ydGVkTWFwSXRlcmF0b3JcclxuLy8gUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrIHRyZWUuXHJcbmNsYXNzIExMUkJOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBMTFJCTm9kZS5FTVBUWTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5sZWZ0LnNpemUgKyAxICsgdGhpcy5yaWdodC5zaXplO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZSwgb3B0aW9uYWxseSByZXBsYWNpbmcgcGllY2VzIG9mIGl0LlxyXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSAhPSBudWxsID8ga2V5IDogdGhpcy5rZXksIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMudmFsdWUsIGNvbG9yICE9IG51bGwgPyBjb2xvciA6IHRoaXMuY29sb3IsIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLmxlZnQsIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IHRoaXMucmlnaHQpO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgLy8gZm9yIGVhY2ggbm9kZS4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHx8XHJcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvblxyXG4gICAgLy8gZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgIC8vIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbi5cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxyXG4gICAgbWluKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4oKS5rZXk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihrZXksIG4ua2V5KTtcclxuICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciksIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCB2YWx1ZSwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZU1pbigpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTExSQk5vZGUuRU1QVFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZCgpICYmICFuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbigpLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbi5maXhVcCgpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cclxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICBsZXQgc21hbGxlc3Q7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZCgpICYmICFuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkUmlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW4oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcclxuICAgIH1cclxuICAgIGlzUmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBuZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxyXG4gICAgZml4VXAoKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkKCkgJiYgIW4ubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZCgpICYmIG4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZCgpICYmIG4ucmlnaHQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICBtb3ZlUmVkTGVmdCgpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwKCk7XHJcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yb3RhdGVSaWdodCgpKTtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdCgpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICBtb3ZlUmVkUmlnaHQoKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xyXG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIHJvdGF0ZUxlZnQoKSB7XHJcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlUmlnaHQoKSB7XHJcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XHJcbiAgICB9XHJcbiAgICBjb2xvckZsaXAoKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XHJcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2soKTtcclxuICAgICAgICBpZiAoTWF0aC5wb3coMi4wLCBibGFja0RlcHRoKSA8PSB0aGlzLnNpemUgKyAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEluIGEgYmFsYW5jZWQgUkIgdHJlZSwgdGhlIGJsYWNrLWRlcHRoIChudW1iZXIgb2YgYmxhY2sgbm9kZXMpIGZyb20gcm9vdCB0b1xyXG4gICAgLy8gbGVhdmVzIGlzIGVxdWFsIG9uIGJvdGggc2lkZXMuICBUaGlzIGZ1bmN0aW9uIHZlcmlmaWVzIHRoYXQgb3IgYXNzZXJ0cy5cclxuICAgIGNoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVkKCkgJiYgdGhpcy5sZWZ0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMubGVmdC5jaGVjaygpO1xyXG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZCgpID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSAvLyBlbmQgTExSQk5vZGVcclxuLy8gRW1wdHkgbm9kZSBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgTExSQiB0cmVlcy5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuTExSQk5vZGUuRU1QVFkgPSBudWxsO1xyXG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xyXG5MTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xyXG4vLyBSZXByZXNlbnRzIGFuIGVtcHR5IG5vZGUgKGEgbGVhZiBub2RlIGluIHRoZSBSZWQtQmxhY2sgVHJlZSkuXHJcbmNsYXNzIExMUkJFbXB0eU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbGVmdCgpIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcmlnaHQoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZC5cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlzUmVkKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIEZvciB0ZXN0aW5nLlxyXG4gICAgY2hlY2tNYXhEZXB0aCgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNoZWNrKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59IC8vIGVuZCBMTFJCRW1wdHlOb2RlXHJcbkxMUkJOb2RlLkVNUFRZID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFNvcnRlZFNldCBpcyBhbiBpbW11dGFibGUgKGNvcHktb24td3JpdGUpIGNvbGxlY3Rpb24gdGhhdCBob2xkcyBlbGVtZW50c1xyXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuXHJcbiAqXHJcbiAqIE5PVEU6IGlmIHByb3ZpZGVkIGNvbXBhcmF0b3IgcmV0dXJucyAwIGZvciB0d28gZWxlbWVudHMsIHdlIGNvbnNpZGVyIHRoZW0gdG9cclxuICogYmUgZXF1YWwhXHJcbiAqL1xyXG5jbGFzcyBTb3J0ZWRTZXQge1xyXG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvcikge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgaGFzKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldChlbGVtKSAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIGZpcnN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWluS2V5KCk7XHJcbiAgICB9XHJcbiAgICBsYXN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNpemU7XHJcbiAgICB9XHJcbiAgICBpbmRleE9mKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmluZGV4T2YoZWxlbSk7XHJcbiAgICB9XHJcbiAgICAvKiogSXRlcmF0ZXMgZWxlbWVudHMgaW4gb3JkZXIgZGVmaW5lZCBieSBcImNvbXBhcmF0b3JcIiAqL1xyXG4gICAgZm9yRWFjaChjYikge1xyXG4gICAgICAgIHRoaXMuZGF0YS5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XHJcbiAgICAgICAgICAgIGNiKGspO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogSXRlcmF0ZXMgb3ZlciBgZWxlbWBzIHN1Y2ggdGhhdDogcmFuZ2VbMF0gJmx0Oz0gZWxlbSAmbHQ7IHJhbmdlWzFdLiAqL1xyXG4gICAgZm9yRWFjaEluUmFuZ2UocmFuZ2UsIGNiKSB7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20ocmFuZ2VbMF0pO1xyXG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3IoZWxlbS5rZXksIHJhbmdlWzFdKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2IoZWxlbS5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBgZWxlbWBzIHN1Y2ggdGhhdDogc3RhcnQgJmx0Oz0gZWxlbSB1bnRpbCBmYWxzZSBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaFdoaWxlKGNiLCBzdGFydCkge1xyXG4gICAgICAgIGxldCBpdGVyO1xyXG4gICAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IoZWxlbS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEZpbmRzIHRoZSBsZWFzdCBlbGVtZW50IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgZWxlbWAuICovXHJcbiAgICBmaXJzdEFmdGVyT3JFcXVhbChlbGVtKSB7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oZWxlbSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXIuaGFzTmV4dCgpID8gaXRlci5nZXROZXh0KCkua2V5IDogbnVsbDtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkU2V0SXRlcmF0b3IodGhpcy5kYXRhLmdldEl0ZXJhdG9yKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlcmF0b3JGcm9tKGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkU2V0SXRlcmF0b3IodGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShrZXkpKTtcclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCAqL1xyXG4gICAgYWRkKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUoZWxlbSkuaW5zZXJ0KGVsZW0sIHRydWUpKTtcclxuICAgIH1cclxuICAgIC8qKiBEZWxldGVzIGFuIGVsZW1lbnQgKi9cclxuICAgIGRlbGV0ZShlbGVtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhlbGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pKTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICB1bmlvbldpdGgob3RoZXIpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICAvLyBNYWtlIHN1cmUgYHJlc3VsdGAgYWx3YXlzIHJlZmVycyB0byB0aGUgbGFyZ2VyIG9uZSBvZiB0aGUgdHdvIHNldHMuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5zaXplIDwgb3RoZXIuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBvdGhlcjtcclxuICAgICAgICAgICAgb3RoZXIgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdGhlci5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGVsZW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTb3J0ZWRTZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRoaXNJdCA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIGNvbnN0IG90aGVySXQgPSBvdGhlci5kYXRhLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGhpc0VsZW0gPSB0aGlzSXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJFbGVtID0gb3RoZXJJdC5nZXROZXh0KCkua2V5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKHRoaXNFbGVtLCBvdGhlckVsZW0pICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0b0FycmF5KCkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKHRhcmdldElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGVsZW0gPT4gcmVzdWx0LnB1c2goZWxlbSkpO1xyXG4gICAgICAgIHJldHVybiAnU29ydGVkU2V0KCcgKyByZXN1bHQudG9TdHJpbmcoKSArICcpJztcclxuICAgIH1cclxuICAgIGNvcHkoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTb3J0ZWRTZXQodGhpcy5jb21wYXJhdG9yKTtcclxuICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTb3J0ZWRTZXRJdGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpdGVyKSB7XHJcbiAgICAgICAgdGhpcy5pdGVyID0gaXRlcjtcclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5nZXROZXh0KCkua2V5O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyLmhhc05leHQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIHNvcnRlZCBzZXRzIGZvciBlcXVhbGl0eSB1c2luZyB0aGVpciBuYXR1cmFsIG9yZGVyaW5nLiBUaGVcclxuICogbWV0aG9kIGNvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gYW5kIGludm9rZXMgYG9uQWRkYCBmb3IgZXZlcnkgZWxlbWVudCB0aGF0XHJcbiAqIGlzIGluIGBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluXHJcbiAqIGBiZWZvcmVgIGJ1dCBtaXNzaW5nIGZyb20gYGFmdGVyYC5cclxuICpcclxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcclxuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cclxuICpcclxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBzZXQuXHJcbiAqIEBwYXJhbSBhZnRlciAtIFRoZSBlbGVtZW50cyB0byBkaWZmIGFnYWluc3QgdGhlIG9yaWdpbmFsIHNldC5cclxuICogQHBhcmFtIGNvbXBhcmF0b3IgLSBUaGUgY29tcGFyYXRvciBmb3IgdGhlIGVsZW1lbnRzIGluIGJlZm9yZSBhbmQgYWZ0ZXIuXHJcbiAqIEBwYXJhbSBvbkFkZCAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBgXHJcbiAqIGFmdGVyYCBidXQgbm90IGBiZWZvcmVgLlxyXG4gKiBAcGFyYW0gb25SZW1vdmUgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2ZcclxuICogYGJlZm9yZWAgYnV0IG5vdCBgYWZ0ZXJgLlxyXG4gKi9cclxuZnVuY3Rpb24gZGlmZlNvcnRlZFNldHMoYmVmb3JlLCBhZnRlciwgY29tcGFyYXRvciwgb25BZGQsIG9uUmVtb3ZlKSB7XHJcbiAgICBjb25zdCBiZWZvcmVJdCA9IGJlZm9yZS5nZXRJdGVyYXRvcigpO1xyXG4gICAgY29uc3QgYWZ0ZXJJdCA9IGFmdGVyLmdldEl0ZXJhdG9yKCk7XHJcbiAgICBsZXQgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xyXG4gICAgbGV0IGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XHJcbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHR3byBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIHVzaW5nIHRoZSBvcmRlcmluZyBkZWZpbmVkIGJ5XHJcbiAgICAvLyBgY29tcGFyYXRvcmAuXHJcbiAgICB3aGlsZSAoYmVmb3JlVmFsdWUgfHwgYWZ0ZXJWYWx1ZSkge1xyXG4gICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGJlZm9yZVZhbHVlICYmIGFmdGVyVmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihiZWZvcmVWYWx1ZSwgYWZ0ZXJWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgcmVtb3ZlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkXHJcbiAgICAgICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcclxuICAgICAgICAgICAgICAgIC8vIGlzIG9ubHkgaW4gYGFmdGVyYC5cclxuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiZWZvcmVWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRkZWQpIHtcclxuICAgICAgICAgICAgb25BZGQoYWZ0ZXJWYWx1ZSk7XHJcbiAgICAgICAgICAgIGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgb25SZW1vdmUoYmVmb3JlVmFsdWUpO1xyXG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XHJcbiAgICAgICAgICAgIGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgaXRlcmF0b3Igb3IgYHVuZGVmaW5lZGAgaWYgbm9uZSBhdmFpbGFibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZHZhbmNlSXRlcmF0b3IoaXQpIHtcclxuICAgIHJldHVybiBpdC5oYXNOZXh0KCkgPyBpdC5nZXROZXh0KCkgOiB1bmRlZmluZWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGZpZWxkcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhcnRpYWxseSBwYXRjaCBhIGRvY3VtZW50LlxyXG4gKiBGaWVsZE1hc2sgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIE9iamVjdFZhbHVlLlxyXG4gKiBFeGFtcGxlczpcclxuICogICBmb28gLSBPdmVyd3JpdGVzIGZvbyBlbnRpcmVseSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgZm9vIGlzIG5vdFxyXG4gKiAgICAgICAgIHByZXNlbnQgaW4gdGhlIGNvbXBhbmlvbiBPYmplY3RWYWx1ZSwgdGhlIGZpZWxkIGlzIGRlbGV0ZWQuXHJcbiAqICAgZm9vLmJhciAtIE92ZXJ3cml0ZXMgb25seSB0aGUgZmllbGQgYmFyIG9mIHRoZSBvYmplY3QgZm9vLlxyXG4gKiAgICAgICAgICAgICBJZiBmb28gaXMgbm90IGFuIG9iamVjdCwgZm9vIGlzIHJlcGxhY2VkIHdpdGggYW4gb2JqZWN0XHJcbiAqICAgICAgICAgICAgIGNvbnRhaW5pbmcgZm9vXHJcbiAqL1xyXG5jbGFzcyBGaWVsZE1hc2sge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0aW9uIG9mIEZpZWxkTWFza1xyXG4gICAgICAgIC8vIFNvcnQgdGhlIGZpZWxkIG1hc2sgdG8gc3VwcG9ydCBgRmllbGRNYXNrLmlzRXF1YWwoKWAgYW5kIGFzc2VydCBiZWxvdy5cclxuICAgICAgICBmaWVsZHMuc29ydChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhbXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgRmllbGRNYXNrIG9iamVjdCB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYWRkaW5nIGFsbCB0aGUgZ2l2ZW5cclxuICAgICAqIGZpZWxkcyBwYXRocyB0byB0aGlzIGZpZWxkIG1hc2suXHJcbiAgICAgKi9cclxuICAgIHVuaW9uV2l0aChleHRyYUZpZWxkcykge1xyXG4gICAgICAgIGxldCBtZXJnZWRNYXNrU2V0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBvZiB0aGlzLmZpZWxkcykge1xyXG4gICAgICAgICAgICBtZXJnZWRNYXNrU2V0ID0gbWVyZ2VkTWFza1NldC5hZGQoZmllbGRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgZXh0cmFGaWVsZHMpIHtcclxuICAgICAgICAgICAgbWVyZ2VkTWFza1NldCA9IG1lcmdlZE1hc2tTZXQuYWRkKGZpZWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKG1lcmdlZE1hc2tTZXQudG9BcnJheSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCBgZmllbGRQYXRoYCBpcyBpbmNsdWRlZCBieSBhdCBsZWFzdCBvbmUgZmllbGQgaW4gdGhpcyBmaWVsZFxyXG4gICAgICogbWFzay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGFuIE8obikgb3BlcmF0aW9uLCB3aGVyZSBgbmAgaXMgdGhlIHNpemUgb2YgdGhlIGZpZWxkIG1hc2suXHJcbiAgICAgKi9cclxuICAgIGNvdmVycyhmaWVsZFBhdGgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTWFza1BhdGggb2YgdGhpcy5maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkTWFza1BhdGguaXNQcmVmaXhPZihmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKHRoaXMuZmllbGRzLCBvdGhlci5maWVsZHMsIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBDb252ZXJ0cyBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJpbmFyeSBzdHJpbmcuICovXHJcbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XHJcbiAgICAvLyBOb3RlOiBXZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBiYXNlNjQgc3RyaW5nIGhlcmUgdmlhIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSBvZiBpbmRleGluZy5cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbmNvZGVkLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG59XHJcbi8qKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgdG8gYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuICovXHJcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChyYXcpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShyYXcsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbn1cclxuLyoqIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIEJhc2U2NCBjb252ZXJzaW9uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLiAqL1xyXG5mdW5jdGlvbiBpc0Jhc2U2NEF2YWlsYWJsZSgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbW11dGFibGUgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgXCJwcm90b1wiIGJ5dGUgc3RyaW5nLlxyXG4gKlxyXG4gKiBQcm90byBieXRlIHN0cmluZ3MgY2FuIGVpdGhlciBiZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdzIG9yIFVpbnQ4QXJyYXlzIHdoZW5cclxuICogc2VudCBvbiB0aGUgd2lyZS4gVGhpcyBjbGFzcyBhYnN0cmFjdHMgYXdheSB0aGlzIGRpZmZlcmVudGlhdGlvbiBieSBob2xkaW5nXHJcbiAqIHRoZSBwcm90byBieXRlIHN0cmluZyBpbiBhIGNvbW1vbiBjbGFzcyB0aGF0IG11c3QgYmUgY29udmVydGVkIGludG8gYSBzdHJpbmdcclxuICogYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBwcm90by5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBCeXRlU3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKGJpbmFyeVN0cmluZykge1xyXG4gICAgICAgIHRoaXMuYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XHJcbiAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gZGVjb2RlQmFzZTY0KGJhc2U2NCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlU3RyaW5nKGJpbmFyeVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcclxuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTsgUmVtb3ZlIHRoZSBjb3B5IG9mIHRoZSBieXRlIHN0cmluZyBoZXJlIGFzIHRoaXMgbWV0aG9kXHJcbiAgICAgICAgLy8gaXMgZnJlcXVlbnRseSBjYWxsZWQgZHVyaW5nIGluZGV4aW5nLlxyXG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5KGFycmF5KTtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJpbmcoYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkrKyksIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdG9CYXNlNjQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NCh0aGlzLmJpbmFyeVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICB0b1VpbnQ4QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tQmluYXJ5U3RyaW5nKHRoaXMuYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIGFwcHJveGltYXRlQnl0ZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aCAqIDI7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLmJpbmFyeVN0cmluZywgb3RoZXIuYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcgPT09IG90aGVyLmJpbmFyeVN0cmluZztcclxuICAgIH1cclxufVxyXG5CeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HID0gbmV3IEJ5dGVTdHJpbmcoJycpO1xyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gVWludDhhcnJheSB0byBhIGJpbmFyeSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5hcnlTdHJpbmdGcm9tVWludDhBcnJheShhcnJheSkge1xyXG4gICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGJpbmFyeVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiaW5hcnlTdHJpbmc7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGEgYmluYXJ5IHN0cmluZyB0byBhbiBVaW50OEFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gdWludDhBcnJheUZyb21CaW5hcnlTdHJpbmcoYmluYXJ5U3RyaW5nKSB7XHJcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYnVmZmVyW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEEgUmVnRXhwIG1hdGNoaW5nIElTTyA4NjAxIFVUQyB0aW1lc3RhbXBzIHdpdGggb3B0aW9uYWwgZnJhY3Rpb24uXHJcbmNvbnN0IElTT19USU1FU1RBTVBfUkVHX0VYUCA9IG5ldyBSZWdFeHAoL15cXGR7NH0tXFxkXFxkLVxcZFxcZFRcXGRcXGQ6XFxkXFxkOlxcZFxcZCg/OlxcLihcXGQrKSk/WiQvKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB2YWx1ZXMgZm9yIGEgdGltZXN0YW1wIHZhbHVlIGludG8gYSBcInNlY29uZHMgYW5kXHJcbiAqIG5hbm9zXCIgcmVwcmVzZW50YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSkge1xyXG4gICAgaGFyZEFzc2VydCghIWRhdGUpO1xyXG4gICAgLy8gVGhlIGpzb24gaW50ZXJmYWNlIChmb3IgdGhlIGJyb3dzZXIpIHdpbGwgcmV0dXJuIGFuIGlzbyB0aW1lc3RhbXAgc3RyaW5nLFxyXG4gICAgLy8gd2hpbGUgdGhlIHByb3RvIGpzIGxpYnJhcnkgKGZvciBub2RlKSB3aWxsIHJldHVybiBhXHJcbiAgICAvLyBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGluc3RhbmNlLlxyXG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFRoZSBkYXRlIHN0cmluZyBjYW4gaGF2ZSBoaWdoZXIgcHJlY2lzaW9uIChuYW5vcykgdGhhbiB0aGUgRGF0ZSBjbGFzc1xyXG4gICAgICAgIC8vIChtaWxsaXMpLCBzbyB3ZSBkbyBzb21lIGN1c3RvbSBwYXJzaW5nIGhlcmUuXHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIG5hbm9zIHJpZ2h0IG91dCBvZiB0aGUgc3RyaW5nLlxyXG4gICAgICAgIGxldCBuYW5vcyA9IDA7XHJcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSBJU09fVElNRVNUQU1QX1JFR19FWFAuZXhlYyhkYXRlKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KCEhZnJhY3Rpb24pO1xyXG4gICAgICAgIGlmIChmcmFjdGlvblsxXSkge1xyXG4gICAgICAgICAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIG91dCB0byA5IGRpZ2l0cyAobmFub3MpLlxyXG4gICAgICAgICAgICBsZXQgbmFub1N0ciA9IGZyYWN0aW9uWzFdO1xyXG4gICAgICAgICAgICBuYW5vU3RyID0gKG5hbm9TdHIgKyAnMDAwMDAwMDAwJykuc3Vic3RyKDAsIDkpO1xyXG4gICAgICAgICAgICBuYW5vcyA9IE51bWJlcihuYW5vU3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIGRhdGUgdG8gZ2V0IHRoZSBzZWNvbmRzLlxyXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihwYXJzZWREYXRlLmdldFRpbWUoKSAvIDEwMDApO1xyXG4gICAgICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUT0RPKGIvMzcyODIyMzcpOiBVc2Ugc3RyaW5ncyBmb3IgUHJvdG8zIHRpbWVzdGFtcHNcclxuICAgICAgICAvLyBhc3NlcnQoIXRoaXMub3B0aW9ucy51c2VQcm90bzNKc29uLFxyXG4gICAgICAgIC8vICAgJ1RoZSB0aW1lc3RhbXAgaW5zdGFuY2UgZm9ybWF0IHJlcXVpcmVzIFByb3RvIEpTLicpO1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBub3JtYWxpemVOdW1iZXIoZGF0ZS5zZWNvbmRzKTtcclxuICAgICAgICBjb25zdCBuYW5vcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLm5hbm9zKTtcclxuICAgICAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIG51bWJlcnMgaW50byBhIEphdmFTY3JpcHQgbnVtYmVyLlxyXG4gKiBSZXR1cm5zIDAgaWYgdGhlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAvLyBUT0RPKGJqb3JuaWNrKTogSGFuZGxlIGludDY0IGdyZWF0ZXIgdGhhbiA1MyBiaXRzLlxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG4vKiogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHR5cGVzIGZvciBCbG9icyBpbnRvIGEgQnl0ZVN0cmluZy4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQnl0ZVN0cmluZyhibG9iKSB7XHJcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhibG9iKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KGJsb2IpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbG9jYWxseS1hcHBsaWVkIFNlcnZlclRpbWVzdGFtcC5cclxuICpcclxuICogU2VydmVyIFRpbWVzdGFtcHMgYXJlIGJhY2tlZCBieSBNYXBWYWx1ZXMgdGhhdCBjb250YWluIGFuIGludGVybmFsIGZpZWxkXHJcbiAqIGBfX3R5cGVfX2Agd2l0aCBhIHZhbHVlIG9mIGBzZXJ2ZXJfdGltZXN0YW1wYC4gVGhlIHByZXZpb3VzIHZhbHVlIGFuZCBsb2NhbFxyXG4gKiB3cml0ZSB0aW1lIGFyZSBzdG9yZWQgaW4gaXRzIGBfX3ByZXZpb3VzX3ZhbHVlX19gIGFuZCBgX19sb2NhbF93cml0ZV90aW1lX19gXHJcbiAqIGZpZWxkcyByZXNwZWN0aXZlbHkuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIFNlcnZlclRpbWVzdGFtcFZhbHVlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBhcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFcclxuICogICB0cmFuc2Zvcm0uIFRoZXkgY2FuIG9ubHkgZXhpc3QgaW4gdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gVGhlcmVmb3JlXHJcbiAqICAgdGhleSBkbyBub3QgbmVlZCB0byBiZSBwYXJzZWQgb3Igc2VyaWFsaXplZC5cclxuICogLSBXaGVuIGV2YWx1YXRlZCBsb2NhbGx5IChlLmcuIGZvciBzbmFwc2hvdC5kYXRhKCkpLCB0aGV5IGJ5IGRlZmF1bHRcclxuICogICBldmFsdWF0ZSB0byBgbnVsbGAuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgcGFzc2luZyBjdXN0b21cclxuICogICBGaWVsZFZhbHVlT3B0aW9ucyB0byB2YWx1ZSgpLlxyXG4gKiAtIFdpdGggcmVzcGVjdCB0byBvdGhlciBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZXMsIHRoZXkgc29ydCBieSB0aGVpclxyXG4gKiAgIGxvY2FsV3JpdGVUaW1lLlxyXG4gKi9cclxuY29uc3QgU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTCA9ICdzZXJ2ZXJfdGltZXN0YW1wJztcclxuY29uc3QgVFlQRV9LRVkgPSAnX190eXBlX18nO1xyXG5jb25zdCBQUkVWSU9VU19WQUxVRV9LRVkgPSAnX19wcmV2aW91c192YWx1ZV9fJztcclxuY29uc3QgTE9DQUxfV1JJVEVfVElNRV9LRVkgPSAnX19sb2NhbF93cml0ZV90aW1lX18nO1xyXG5mdW5jdGlvbiBpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IHR5cGUgPSAoX2IgPSAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tYXBWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwge30pW1RZUEVfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0cmluZ1ZhbHVlO1xyXG4gICAgcmV0dXJuIHR5cGUgPT09IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgU2VydmVyVGltZXN0YW1wIHByb3RvIHZhbHVlICh1c2luZyB0aGUgaW50ZXJuYWwgZm9ybWF0KS5cclxuICovXHJcbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCQxKGxvY2FsV3JpdGVUaW1lLCBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICBjb25zdCBtYXBWYWx1ZSA9IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgW1RZUEVfS0VZXToge1xyXG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWU6IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW0xPQ0FMX1dSSVRFX1RJTUVfS0VZXToge1xyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzOiBsb2NhbFdyaXRlVGltZS5zZWNvbmRzLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbm9zOiBsb2NhbFdyaXRlVGltZS5uYW5vc2Vjb25kc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFdlIHNob3VsZCBhdm9pZCBzdG9yaW5nIGRlZXBseSBuZXN0ZWQgc2VydmVyIHRpbWVzdGFtcCBtYXAgdmFsdWVzXHJcbiAgICAvLyBiZWNhdXNlIHdlIG5ldmVyIHVzZSB0aGUgaW50ZXJtZWRpYXRlIFwicHJldmlvdXMgdmFsdWVzXCIuXHJcbiAgICAvLyBGb3IgZXhhbXBsZTpcclxuICAgIC8vIHByZXZpb3VzOiA0MkwsIGFkZDogdDEsIHJlc3VsdDogdDEgLT4gNDJMXHJcbiAgICAvLyBwcmV2aW91czogdDEsICBhZGQ6IHQyLCByZXN1bHQ6IHQyIC0+IDQyTCAoTk9UIHQyIC0+IHQxIC0+IDQyTClcclxuICAgIC8vIHByZXZpb3VzOiB0MiwgIGFkZDogdDMsIHJlc3VsdDogdDMgLT4gNDJMIChOT1QgdDMgLT4gdDIgLT4gdDEgLT4gNDJMKVxyXG4gICAgLy8gYGdldFByZXZpb3VzVmFsdWVgIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBzZXJ2ZXIgdGltZXN0YW1wcyB0byBmaW5kIHRoZVxyXG4gICAgLy8gbGVhc3QgcmVjZW50IFZhbHVlLlxyXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgaXNTZXJ2ZXJUaW1lc3RhbXAocHJldmlvdXNWYWx1ZSkpIHtcclxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZShwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgbWFwVmFsdWUuZmllbGRzW1BSRVZJT1VTX1ZBTFVFX0tFWV0gPSBwcmV2aW91c1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbWFwVmFsdWUgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGJlZm9yZSB0aGlzIFNlcnZlclRpbWVzdGFtcCB3YXMgc2V0LlxyXG4gKlxyXG4gKiBQcmVzZXJ2aW5nIHRoZSBwcmV2aW91cyB2YWx1ZXMgYWxsb3dzIHRoZSB1c2VyIHRvIGRpc3BsYXkgdGhlIGxhc3QgcmVzb2xlZFxyXG4gKiB2YWx1ZSB1bnRpbCB0aGUgYmFja2VuZCByZXNwb25kcyB3aXRoIHRoZSB0aW1lc3RhbXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKSB7XHJcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdmFsdWUubWFwVmFsdWUuZmllbGRzW1BSRVZJT1VTX1ZBTFVFX0tFWV07XHJcbiAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAocHJldmlvdXNWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UHJldmlvdXNWYWx1ZShwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsb2NhbCB0aW1lIGF0IHdoaWNoIHRoaXMgdGltZXN0YW1wIHdhcyBmaXJzdCBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMb2NhbFdyaXRlVGltZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgbG9jYWxXcml0ZVRpbWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUubWFwVmFsdWUuZmllbGRzW0xPQ0FMX1dSSVRFX1RJTUVfS0VZXS50aW1lc3RhbXBWYWx1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChsb2NhbFdyaXRlVGltZS5zZWNvbmRzLCBsb2NhbFdyaXRlVGltZS5uYW5vcyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRGF0YWJhc2VJbmZvIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIERhdGFiYXNlSW5mbyB1c2luZyB0aGUgcHJvdmlkZWQgaG9zdCwgZGF0YWJhc2VJZCBhbmRcclxuICAgICAqIHBlcnNpc3RlbmNlS2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhYmFzZUlkIC0gVGhlIGRhdGFiYXNlIHRvIHVzZS5cclxuICAgICAqIEBwYXJhbSBhcHBJZCAtIFRoZSBGaXJlYmFzZSBBcHAgSWQuXHJcbiAgICAgKiBAcGFyYW0gcGVyc2lzdGVuY2VLZXkgLSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIEZpcmVzdG9yZSdzIGxvY2FsXHJcbiAgICAgKiBzdG9yYWdlICh1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGRhdGFiYXNlSWQpLlxyXG4gICAgICogQHBhcmFtIGhvc3QgLSBUaGUgRmlyZXN0b3JlIGJhY2tlbmQgaG9zdCB0byBjb25uZWN0IHRvLlxyXG4gICAgICogQHBhcmFtIHNzbCAtIFdoZXRoZXIgdG8gdXNlIFNTTCB3aGVuIGNvbm5lY3RpbmcuXHJcbiAgICAgKiBAcGFyYW0gZm9yY2VMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBmb3JjZUxvbmdQb2xsaW5nIG9wdGlvblxyXG4gICAgICogd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cclxuICAgICAqIEBwYXJhbSBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgLSBXaGV0aGVyIHRvIHVzZSB0aGUgZGV0ZWN0QnVmZmVyaW5nUHJveHlcclxuICAgICAqIG9wdGlvbiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxyXG4gICAgICogQHBhcmFtIGxvbmdQb2xsaW5nT3B0aW9ucyBPcHRpb25zIHRoYXQgY29uZmlndXJlIGxvbmctcG9sbGluZy5cclxuICAgICAqIEBwYXJhbSB1c2VGZXRjaFN0cmVhbXMgV2hldGhlciB0byB1c2UgdGhlIEZldGNoIEFQSSBpbnN0ZWFkIG9mXHJcbiAgICAgKiBYTUxIVFRQUmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIGhvc3QsIHNzbCwgZm9yY2VMb25nUG9sbGluZywgYXV0b0RldGVjdExvbmdQb2xsaW5nLCBsb25nUG9sbGluZ09wdGlvbnMsIHVzZUZldGNoU3RyZWFtcykge1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcclxuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xyXG4gICAgICAgIHRoaXMuc3NsID0gc3NsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VMb25nUG9sbGluZyA9IGZvcmNlTG9uZ1BvbGxpbmc7XHJcbiAgICAgICAgdGhpcy5hdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBhdXRvRGV0ZWN0TG9uZ1BvbGxpbmc7XHJcbiAgICAgICAgdGhpcy5sb25nUG9sbGluZ09wdGlvbnMgPSBsb25nUG9sbGluZ09wdGlvbnM7XHJcbiAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSB1c2VGZXRjaFN0cmVhbXM7XHJcbiAgICB9XHJcbn1cclxuLyoqIFRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWUgZm9yIGEgcHJvamVjdC4gKi9cclxuY29uc3QgREVGQVVMVF9EQVRBQkFTRV9OQU1FID0gJyhkZWZhdWx0KSc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhYmFzZSBJRCBhIEZpcmVzdG9yZSBjbGllbnQgaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIERhdGFiYXNlSWQge1xyXG4gICAgY29uc3RydWN0b3IocHJvamVjdElkLCBkYXRhYmFzZSkge1xyXG4gICAgICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSBkYXRhYmFzZSA/IGRhdGFiYXNlIDogREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZCgnJywgJycpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVmYXVsdERhdGFiYXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlID09PSBERUZBVUxUX0RBVEFCQVNFX05BTUU7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIERhdGFiYXNlSWQgJiZcclxuICAgICAgICAgICAgb3RoZXIucHJvamVjdElkID09PSB0aGlzLnByb2plY3RJZCAmJlxyXG4gICAgICAgICAgICBvdGhlci5kYXRhYmFzZSA9PT0gdGhpcy5kYXRhYmFzZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGF0YWJhc2VJZEZyb21BcHAoYXBwLCBkYXRhYmFzZSkge1xyXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmFwcGx5KGFwcC5vcHRpb25zLCBbJ3Byb2plY3RJZCddKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdcInByb2plY3RJZFwiIG5vdCBwcm92aWRlZCBpbiBmaXJlYmFzZS5pbml0aWFsaXplQXBwLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZUlkKGFwcC5vcHRpb25zLnByb2plY3RJZCwgZGF0YWJhc2UpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBTZW50aW5lbCB2YWx1ZSB0aGF0IHNvcnRzIGJlZm9yZSBhbnkgTXV0YXRpb24gQmF0Y2ggSUQuICovXHJcbmNvbnN0IEJBVENISURfVU5LTk9XTiA9IC0xO1xyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFyaWFibGUgaXMgZWl0aGVyIHVuZGVmaW5lZCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHZhbHVlIHJlcHJlc2VudHMgLTAuICovXHJcbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKHZhbHVlKSB7XHJcbiAgICAvLyBEZXRlY3QgaWYgdGhlIHZhbHVlIGlzIC0wLjAuIEJhc2VkIG9uIHBvbHlmaWxsIGZyb21cclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gMSAvIC0wO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSBpbnRlZ2VyIHJhbmdlXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0IGZvciBiZWluZyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSByYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiZcclxuICAgICAgICAhaXNOZWdhdGl2ZVplcm8odmFsdWUpICYmXHJcbiAgICAgICAgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiZcclxuICAgICAgICB2YWx1ZSA+PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX1RZUEUgPSAnX19tYXhfXyc7XHJcbmNvbnN0IE1BWF9WQUxVRSA9IHtcclxuICAgIG1hcFZhbHVlOiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgICdfX3R5cGVfXyc6IHsgc3RyaW5nVmFsdWU6IE1BWF9WQUxVRV9UWVBFIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IE1JTl9WQUxVRSA9IHtcclxuICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXHJcbn07XHJcbi8qKiBFeHRyYWN0cyB0aGUgYmFja2VuZCdzIHR5cGUgb3JkZXIgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZS4gKi9cclxuZnVuY3Rpb24gdHlwZU9yZGVyKHZhbHVlKSB7XHJcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdhcnJheVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc01heFZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUZXN0cyBgbGVmdGAgYW5kIGByaWdodGAgZm9yIGVxdWFsaXR5IGJhc2VkIG9uIHRoZSBiYWNrZW5kIHNlbWFudGljcy4gKi9cclxuZnVuY3Rpb24gdmFsdWVFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XHJcbiAgICBjb25zdCByaWdodFR5cGUgPSB0eXBlT3JkZXIocmlnaHQpO1xyXG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5ib29sZWFuVmFsdWUgPT09IHJpZ2h0LmJvb2xlYW5WYWx1ZTtcclxuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TG9jYWxXcml0ZVRpbWUobGVmdCkuaXNFcXVhbChnZXRMb2NhbFdyaXRlVGltZShyaWdodCkpO1xyXG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnN0cmluZ1ZhbHVlID09PSByaWdodC5zdHJpbmdWYWx1ZTtcclxuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2JFcXVhbHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnJlZmVyZW5jZVZhbHVlID09PSByaWdodC5yZWZlcmVuY2VWYWx1ZTtcclxuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZW9Qb2ludEVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSwgcmlnaHQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHZhbHVlRXF1YWxzKTtcclxuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgY2FzZSA5MDA3MTk5MjU0NzQwOTkxIC8qIFR5cGVPcmRlci5NYXhWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmICh0eXBlb2YgbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICB0eXBlb2YgcmlnaHQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgbGVmdC50aW1lc3RhbXBWYWx1ZS5sZW5ndGggPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIFVzZSBzdHJpbmcgZXF1YWxpdHkgZm9yIElTTyA4NjAxIHRpbWVzdGFtcHNcclxuICAgICAgICByZXR1cm4gbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gcmlnaHQudGltZXN0YW1wVmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGxlZnQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgcmV0dXJuIChsZWZ0VGltZXN0YW1wLnNlY29uZHMgPT09IHJpZ2h0VGltZXN0YW1wLnNlY29uZHMgJiZcclxuICAgICAgICBsZWZ0VGltZXN0YW1wLm5hbm9zID09PSByaWdodFRpbWVzdGFtcC5uYW5vcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgPT09XHJcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpICYmXHJcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpID09PVxyXG4gICAgICAgICAgICBub3JtYWxpemVOdW1iZXIocmlnaHQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpKTtcclxufVxyXG5mdW5jdGlvbiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyhsZWZ0LmJ5dGVzVmFsdWUpLmlzRXF1YWwobm9ybWFsaXplQnl0ZVN0cmluZyhyaWdodC5ieXRlc1ZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gbGVmdCAmJiAnaW50ZWdlclZhbHVlJyBpbiByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuaW50ZWdlclZhbHVlKSA9PT0gbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmludGVnZXJWYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBsZWZ0ICYmICdkb3VibGVWYWx1ZScgaW4gcmlnaHQpIHtcclxuICAgICAgICBjb25zdCBuMSA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmRvdWJsZVZhbHVlKTtcclxuICAgICAgICBjb25zdCBuMiA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZVplcm8objEpID09PSBpc05lZ2F0aXZlWmVybyhuMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4objEpICYmIGlzTmFOKG4yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb2JqZWN0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5tYXBWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCByaWdodE1hcCA9IHJpZ2h0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcclxuICAgIGlmIChvYmplY3RTaXplKGxlZnRNYXApICE9PSBvYmplY3RTaXplKHJpZ2h0TWFwKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGxlZnRNYXApIHtcclxuICAgICAgICBpZiAobGVmdE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodE1hcFtrZXldID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICF2YWx1ZUVxdWFscyhsZWZ0TWFwW2tleV0sIHJpZ2h0TWFwW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBBcnJheVZhbHVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gKi9cclxuZnVuY3Rpb24gYXJyYXlWYWx1ZUNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICAgIHJldHVybiAoKGhheXN0YWNrLnZhbHVlcyB8fCBbXSkuZmluZCh2ID0+IHZhbHVlRXF1YWxzKHYsIG5lZWRsZSkpICE9PSB1bmRlZmluZWQpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHR5cGVPcmRlcihsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHR5cGVPcmRlcihyaWdodCk7XHJcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUeXBlLCByaWdodFR5cGUpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxyXG4gICAgICAgIGNhc2UgOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmJvb2xlYW5WYWx1ZSwgcmlnaHQuYm9vbGVhblZhbHVlKTtcclxuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZU51bWJlcnMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LnRpbWVzdGFtcFZhbHVlLCByaWdodC50aW1lc3RhbXBWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVUaW1lc3RhbXBzKGdldExvY2FsV3JpdGVUaW1lKGxlZnQpLCBnZXRMb2NhbFdyaXRlVGltZShyaWdodCkpO1xyXG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuc3RyaW5nVmFsdWUsIHJpZ2h0LnN0cmluZ1ZhbHVlKTtcclxuICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCbG9icyhsZWZ0LmJ5dGVzVmFsdWUsIHJpZ2h0LmJ5dGVzVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlUmVmZXJlbmNlcyhsZWZ0LnJlZmVyZW5jZVZhbHVlLCByaWdodC5yZWZlcmVuY2VWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUdlb1BvaW50cyhsZWZ0Lmdlb1BvaW50VmFsdWUsIHJpZ2h0Lmdlb1BvaW50VmFsdWUpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMobGVmdC5hcnJheVZhbHVlLCByaWdodC5hcnJheVZhbHVlKTtcclxuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVNYXBzKGxlZnQubWFwVmFsdWUsIHJpZ2h0Lm1hcFZhbHVlKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIobGVmdC5pbnRlZ2VyVmFsdWUgfHwgbGVmdC5kb3VibGVWYWx1ZSk7XHJcbiAgICBjb25zdCByaWdodE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUgfHwgcmlnaHQuZG91YmxlVmFsdWUpO1xyXG4gICAgaWYgKGxlZnROdW1iZXIgPCByaWdodE51bWJlcikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnROdW1iZXIgPiByaWdodE51bWJlcikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdE51bWJlciA9PT0gcmlnaHROdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG9uZSBvciBib3RoIGFyZSBOYU4uXHJcbiAgICAgICAgaWYgKGlzTmFOKGxlZnROdW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTihyaWdodE51bWJlcikgPyAwIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZVRpbWVzdGFtcHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICB0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgbGVmdC5sZW5ndGggPT09IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlZnRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAobGVmdCk7XHJcbiAgICBjb25zdCByaWdodFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChyaWdodCk7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VGltZXN0YW1wLnNlY29uZHMsIHJpZ2h0VGltZXN0YW1wLnNlY29uZHMpO1xyXG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAubmFub3MsIHJpZ2h0VGltZXN0YW1wLm5hbm9zKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlUmVmZXJlbmNlcyhsZWZ0UGF0aCwgcmlnaHRQYXRoKSB7XHJcbiAgICBjb25zdCBsZWZ0U2VnbWVudHMgPSBsZWZ0UGF0aC5zcGxpdCgnLycpO1xyXG4gICAgY29uc3QgcmlnaHRTZWdtZW50cyA9IHJpZ2h0UGF0aC5zcGxpdCgnLycpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0U2VnbWVudHMubGVuZ3RoICYmIGkgPCByaWdodFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzW2ldLCByaWdodFNlZ21lbnRzW2ldKTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0U2VnbWVudHMubGVuZ3RoLCByaWdodFNlZ21lbnRzLmxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUdlb1BvaW50cyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3Iobm9ybWFsaXplTnVtYmVyKGxlZnQubGF0aXR1ZGUpLCBub3JtYWxpemVOdW1iZXIocmlnaHQubGF0aXR1ZGUpKTtcclxuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sb25naXR1ZGUpLCBub3JtYWxpemVOdW1iZXIocmlnaHQubG9uZ2l0dWRlKSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUJsb2JzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQpO1xyXG4gICAgcmV0dXJuIGxlZnRCeXRlcy5jb21wYXJlVG8ocmlnaHRCeXRlcyk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdEFycmF5ID0gbGVmdC52YWx1ZXMgfHwgW107XHJcbiAgICBjb25zdCByaWdodEFycmF5ID0gcmlnaHQudmFsdWVzIHx8IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXJyYXkubGVuZ3RoICYmIGkgPCByaWdodEFycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IHZhbHVlQ29tcGFyZShsZWZ0QXJyYXlbaV0sIHJpZ2h0QXJyYXlbaV0pO1xyXG4gICAgICAgIGlmIChjb21wYXJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRBcnJheS5sZW5ndGgsIHJpZ2h0QXJyYXkubGVuZ3RoKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlTWFwcyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSAmJiByaWdodCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJpZ2h0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnRNYXApO1xyXG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodE1hcCk7XHJcbiAgICAvLyBFdmVuIHRob3VnaCBNYXBWYWx1ZXMgYXJlIGxpa2VseSBzb3J0ZWQgY29ycmVjdGx5IGJhc2VkIG9uIHRoZWlyIGluc2VydGlvblxyXG4gICAgLy8gb3JkZXIgKGUuZy4gd2hlbiByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kKSwgbG9jYWwgbW9kaWZpY2F0aW9ucyBjYW4gYnJpbmdcclxuICAgIC8vIGVsZW1lbnRzIG91dCBvZiBvcmRlci4gV2UgbmVlZCB0byByZS1zb3J0IHRoZSBlbGVtZW50cyB0byBlbnN1cmUgdGhhdFxyXG4gICAgLy8gY2Fub25pY2FsIElEcyBhcmUgaW5kZXBlbmRlbnQgb2YgaW5zZXJ0aW9uIG9yZGVyLlxyXG4gICAgbGVmdEtleXMuc29ydCgpO1xyXG4gICAgcmlnaHRLZXlzLnNvcnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBrZXlDb21wYXJlID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoa2V5Q29tcGFyZSAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5Q29tcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IHZhbHVlQ29tcGFyZShsZWZ0TWFwW2xlZnRLZXlzW2ldXSwgcmlnaHRNYXBbcmlnaHRLZXlzW2ldXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXMubGVuZ3RoLCByaWdodEtleXMubGVuZ3RoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZSBwcm92aWRlZCBmaWVsZCB2YWx1ZSAoYXMgdXNlZCBpbiBUYXJnZXRcclxuICogc2VyaWFsaXphdGlvbikuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5vbmljYWxJZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNhbm9uaWZ5VmFsdWUodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5VmFsdWUodmFsdWUpIHtcclxuICAgIGlmICgnbnVsbFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmJvb2xlYW5WYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuaW50ZWdlclZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmRvdWJsZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjYW5vbmlmeVRpbWVzdGFtcCh2YWx1ZS50aW1lc3RhbXBWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5Qnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5R2VvUG9pbnQodmFsdWUuZ2VvUG9pbnRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlBcnJheSh2YWx1ZS5hcnJheVZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlNYXAodmFsdWUubWFwVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykudG9CYXNlNjQoKTtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeVRpbWVzdGFtcCh0aW1lc3RhbXApIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcclxuICAgIHJldHVybiBgdGltZSgke25vcm1hbGl6ZWRUaW1lc3RhbXAuc2Vjb25kc30sJHtub3JtYWxpemVkVGltZXN0YW1wLm5hbm9zfSlgO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5R2VvUG9pbnQoZ2VvUG9pbnQpIHtcclxuICAgIHJldHVybiBgZ2VvKCR7Z2VvUG9pbnQubGF0aXR1ZGV9LCR7Z2VvUG9pbnQubG9uZ2l0dWRlfSlgO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5UmVmZXJlbmNlKHJlZmVyZW5jZVZhbHVlKSB7XHJcbiAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlNYXAobWFwVmFsdWUpIHtcclxuICAgIC8vIEl0ZXJhdGlvbiBvcmRlciBpbiBKYXZhU2NyaXB0IGlzIG5vdCBndWFyYW50ZWVkLiBUbyBlbnN1cmUgdGhhdCB3ZSBnZW5lcmF0ZVxyXG4gICAgLy8gbWF0Y2hpbmcgY2Fub25pY2FsIElEcyBmb3IgaWRlbnRpY2FsIG1hcHMsIHdlIG5lZWQgdG8gc29ydCB0aGUga2V5cy5cclxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhtYXBWYWx1ZS5maWVsZHMgfHwge30pLnNvcnQoKTtcclxuICAgIGxldCByZXN1bHQgPSAneyc7XHJcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xyXG4gICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBgJHtrZXl9OiR7Y2Fub25pZnlWYWx1ZShtYXBWYWx1ZS5maWVsZHNba2V5XSl9YDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQgKyAnfSc7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlBcnJheShhcnJheVZhbHVlKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gJ1snO1xyXG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcclxuICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gY2Fub25pZnlWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgJ10nO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIChhbmQgd2lsZGx5IGluYWNjdXJhdGUpIGluLW1lbW9yeSBzaXplIGZvciB0aGUgZmllbGRcclxuICogdmFsdWUuXHJcbiAqXHJcbiAqIFRoZSBtZW1vcnkgc2l6ZSB0YWtlcyBpbnRvIGFjY291bnQgb25seSB0aGUgYWN0dWFsIHVzZXIgZGF0YSBhcyBpdCByZXNpZGVzXHJcbiAqIGluIG1lbW9yeSBhbmQgaWdub3JlcyBvYmplY3Qgb3ZlcmhlYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVTaXplKHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcclxuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIG1hZGUgdXAgb2YgdHdvIGRpc3RpbmN0IG51bWJlcnMgKHNlY29uZHMgKyBuYW5vc2Vjb25kcylcclxuICAgICAgICAgICAgcmV0dXJuIDE2O1xyXG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgPyAxNiArIGVzdGltYXRlQnl0ZVNpemUocHJldmlvdXNWYWx1ZSkgOiAxNjtcclxuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXM6XHJcbiAgICAgICAgICAgIC8vIFwiSmF2YVNjcmlwdCdzIFN0cmluZyB0eXBlIGlzIFsuLi5dIGEgc2V0IG9mIGVsZW1lbnRzIG9mIDE2LWJpdCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAvLyBpbnRlZ2VyIHZhbHVlc1wiXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZS5sZW5ndGggKiAyO1xyXG4gICAgICAgIGNhc2UgNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKS5hcHByb3hpbWF0ZUJ5dGVTaXplKCk7XHJcbiAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlZmVyZW5jZVZhbHVlLmxlbmd0aDtcclxuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XHJcbiAgICAgICAgICAgIC8vIEdlb1BvaW50cyBhcmUgbWFkZSB1cCBvZiB0d28gZGlzdGluY3QgbnVtYmVycyAobGF0aXR1ZGUgKyBsb25naXR1ZGUpXHJcbiAgICAgICAgICAgIHJldHVybiAxNjtcclxuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZUFycmF5Qnl0ZVNpemUodmFsdWUuYXJyYXlWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBlc3RpbWF0ZU1hcEJ5dGVTaXplKHZhbHVlLm1hcFZhbHVlKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXN0aW1hdGVNYXBCeXRlU2l6ZShtYXBWYWx1ZSkge1xyXG4gICAgbGV0IHNpemUgPSAwO1xyXG4gICAgZm9yRWFjaChtYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbCkgPT4ge1xyXG4gICAgICAgIHNpemUgKz0ga2V5Lmxlbmd0aCArIGVzdGltYXRlQnl0ZVNpemUodmFsKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNpemU7XHJcbn1cclxuZnVuY3Rpb24gZXN0aW1hdGVBcnJheUJ5dGVTaXplKGFycmF5VmFsdWUpIHtcclxuICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLnJlZHVjZSgocHJldmlvdXNTaXplLCB2YWx1ZSkgPT4gcHJldmlvdXNTaXplICsgZXN0aW1hdGVCeXRlU2l6ZSh2YWx1ZSksIDApO1xyXG59XHJcbi8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgZGF0YWJhc2UgYW5kIGtleS4gKi9cclxuZnVuY3Rpb24gcmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZmVyZW5jZVZhbHVlOiBgcHJvamVjdHMvJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0vZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YFxyXG4gICAgfTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gSW50ZWdlclZhbHVlIC4gKi9cclxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBEb3VibGVWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNEb3VibGUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGVpdGhlciBhbiBJbnRlZ2VyVmFsdWUgb3IgYSBEb3VibGVWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IGlzRG91YmxlKHZhbHVlKTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gQXJyYXlWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2FycmF5VmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE51bGxWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNOdWxsVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdudWxsVmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBOYU4uICovXHJcbmZ1bmN0aW9uIGlzTmFuVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWUgJiYgaXNOYU4oTnVtYmVyKHZhbHVlLmRvdWJsZVZhbHVlKSk7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgTWFwVmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzTWFwVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdtYXBWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UpIHtcclxuICAgIGlmIChzb3VyY2UuZ2VvUG9pbnRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLnRpbWVzdGFtcFZhbHVlICYmXHJcbiAgICAgICAgdHlwZW9mIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnRpbWVzdGFtcFZhbHVlKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcclxuICAgICAgICBmb3JFYWNoKHNvdXJjZS5tYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbCkgPT4gKHRhcmdldC5tYXBWYWx1ZS5maWVsZHNba2V5XSA9IGRlZXBDbG9uZSh2YWwpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNvdXJjZS5hcnJheVZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBhcnJheVZhbHVlOiB7IHZhbHVlczogW10gfSB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFycmF5VmFsdWUudmFsdWVzW2ldID0gZGVlcENsb25lKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlKTtcclxuICAgIH1cclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBWYWx1ZSByZXByZXNlbnRzIHRoZSBjYW5vbmljYWwge0BsaW5rICNNQVhfVkFMVUV9IC4gKi9cclxuZnVuY3Rpb24gaXNNYXhWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICgoKCh2YWx1ZS5tYXBWYWx1ZSB8fCB7fSkuZmllbGRzIHx8IHt9KVsnX190eXBlX18nXSB8fCB7fSkuc3RyaW5nVmFsdWUgPT09XHJcbiAgICAgICAgTUFYX1ZBTFVFX1RZUEUpO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRoZSBsb3dlc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiB2YWx1ZSB0eXBlIChpbmNsdXNpdmUpLiAqL1xyXG5mdW5jdGlvbiB2YWx1ZXNHZXRMb3dlckJvdW5kKHZhbHVlKSB7XHJcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBib29sZWFuVmFsdWU6IGZhbHNlIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IE5hTiB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiB7IHNlY29uZHM6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogJycgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGJ5dGVzVmFsdWU6ICcnIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKERhdGFiYXNlSWQuZW1wdHkoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBnZW9Qb2ludFZhbHVlOiB7IGxhdGl0dWRlOiAtOTAsIGxvbmdpdHVkZTogLTE4MCB9IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7fSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IG1hcFZhbHVlOiB7fSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogUmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGV4Y2x1c2l2ZSkuICovXHJcbmZ1bmN0aW9uIHZhbHVlc0dldFVwcGVyQm91bmQodmFsdWUpIHtcclxuICAgIGlmICgnbnVsbFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IE5hTiB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiB7IHNlY29uZHM6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogJycgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKERhdGFiYXNlSWQuZW1wdHkoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdhcnJheVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IG1hcFZhbHVlOiB7fSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxvd2VyQm91bmRDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBjbXAgPSB2YWx1ZUNvbXBhcmUobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xyXG4gICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgJiYgIXJpZ2h0LmluY2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFsZWZ0LmluY2x1c2l2ZSAmJiByaWdodC5pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIHVwcGVyQm91bmRDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBjbXAgPSB2YWx1ZUNvbXBhcmUobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xyXG4gICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgJiYgIXJpZ2h0LmluY2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWxlZnQuaW5jbHVzaXZlICYmIHJpZ2h0LmluY2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBPYmplY3RWYWx1ZSByZXByZXNlbnRzIGEgTWFwVmFsdWUgaW4gdGhlIEZpcmVzdG9yZSBQcm90byBhbmQgb2ZmZXJzIHRoZVxyXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIGZpZWxkcyAodmlhIHRoZSBPYmplY3RWYWx1ZUJ1aWxkZXIpLlxyXG4gKi9cclxuY2xhc3MgT2JqZWN0VmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7fSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggb3IgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBwYXRoIG9yIG51bGwgaWYgdGhlIHBhdGggaXMgbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgZmllbGQocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5nZXQoaSldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKGN1cnJlbnRMZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5sYXN0U2VnbWVudCgpXTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZmllbGQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gc2V0LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGZpZWxkc01hcFtwYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJvdmlkZWQgZmllbGRzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBBIG1hcCBvZiBmaWVsZHMgdG8gdmFsdWVzIChvciBudWxsIGZvciBkZWxldGVzKS5cclxuICAgICAqL1xyXG4gICAgc2V0QWxsKGRhdGEpIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gRmllbGRQYXRoJDEuZW1wdHlQYXRoKCk7XHJcbiAgICAgICAgbGV0IHVwc2VydHMgPSB7fTtcclxuICAgICAgICBsZXQgZGVsZXRlcyA9IFtdO1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUsIHBhdGgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNJbW1lZGlhdGVQYXJlbnRPZihwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGF0IHRoaXMgcGFyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcclxuICAgICAgICAgICAgICAgIHVwc2VydHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdXBzZXJ0c1twYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaChwYXRoLmxhc3RTZWdtZW50KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIHVwc2VydHMsIGRlbGV0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWVsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIG5vIGZpZWxkIGF0IHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHBhdGgsIG5vdGhpbmcgaXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IHRoaXMuZmllbGQocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGlmIChpc01hcFZhbHVlKG5lc3RlZFZhbHVlKSAmJiBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkc1twYXRoLmxhc3RTZWdtZW50KCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHModGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAgdGhhdCBjb250YWlucyB0aGUgbGVhZiBlbGVtZW50IG9mIGBwYXRoYC4gSWYgdGhlIHBhcmVudFxyXG4gICAgICogZW50cnkgZG9lcyBub3QgeWV0IGV4aXN0LCBvciBpZiBpdCBpcyBub3QgYSBtYXAsIGEgbmV3IG1hcCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEZpZWxkc01hcChwYXRoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICghY3VycmVudC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZSA9IHsgZmllbGRzOiB7fSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkc1twYXRoLmdldChpKV07XHJcbiAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShuZXh0KSB8fCAhbmV4dC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZmllcyBgZmllbGRzTWFwYCBieSBhZGRpbmcsIHJlcGxhY2luZyBvciBkZWxldGluZyB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBhcHBseUNoYW5nZXMoZmllbGRzTWFwLCBpbnNlcnRzLCBkZWxldGVzKSB7XHJcbiAgICAgICAgZm9yRWFjaChpbnNlcnRzLCAoa2V5LCB2YWwpID0+IChmaWVsZHNNYXBba2V5XSA9IHZhbCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZGVsZXRlcykge1xyXG4gICAgICAgICAgICBkZWxldGUgZmllbGRzTWFwW2ZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKGRlZXBDbG9uZSh0aGlzLnZhbHVlKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBGaWVsZE1hc2sgYnVpbHQgZnJvbSBhbGwgZmllbGRzIGluIGEgTWFwVmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0RmllbGRNYXNrKHZhbHVlKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcclxuICAgIGZvckVhY2godmFsdWUuZmllbGRzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gbmV3IEZpZWxkUGF0aCQxKFtrZXldKTtcclxuICAgICAgICBpZiAoaXNNYXBWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbmVzdGVkTWFzayA9IGV4dHJhY3RGaWVsZE1hc2sodmFsdWUubWFwVmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBuZXN0ZWRNYXNrLmZpZWxkcztcclxuICAgICAgICAgICAgaWYgKG5lc3RlZEZpZWxkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBlbXB0eSBtYXAgYnkgYWRkaW5nIGl0IHRvIHRoZSBGaWVsZE1hc2suXHJcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGxlYWYgbm9kZXMuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZFBhdGggb2YgbmVzdGVkRmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGguY2hpbGQobmVzdGVkUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGUgbGVhZlxyXG4gICAgICAgICAgICAvLyBub2Rlcy5cclxuICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soZmllbGRzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGRvY3VtZW50IGluIEZpcmVzdG9yZSB3aXRoIGEga2V5LCB2ZXJzaW9uLCBkYXRhIGFuZCB3aGV0aGVyIGl0XHJcbiAqIGhhcyBsb2NhbCBtdXRhdGlvbnMgYXBwbGllZCB0byBpdC5cclxuICpcclxuICogRG9jdW1lbnRzIGNhbiB0cmFuc2l0aW9uIGJldHdlZW4gc3RhdGVzIHZpYSBgY29udmVydFRvRm91bmREb2N1bWVudCgpYCxcclxuICogYGNvbnZlcnRUb05vRG9jdW1lbnQoKWAgYW5kIGBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQoKWAuIElmIGEgZG9jdW1lbnQgZG9lc1xyXG4gKiBub3QgdHJhbnNpdGlvbiB0byBvbmUgb2YgdGhlc2Ugc3RhdGVzIGV2ZW4gYWZ0ZXIgYWxsIG11dGF0aW9ucyBoYXZlIGJlZW5cclxuICogYXBwbGllZCwgYGlzVmFsaWREb2N1bWVudCgpYCByZXR1cm5zIGZhbHNlIGFuZCB0aGUgZG9jdW1lbnQgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogZnJvbSBhbGwgdmlld3MuXHJcbiAqL1xyXG5jbGFzcyBNdXRhYmxlRG9jdW1lbnQge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkb2N1bWVudFR5cGUsIHZlcnNpb24sIHJlYWRUaW1lLCBjcmVhdGVUaW1lLCBkYXRhLCBkb2N1bWVudFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSBkb2N1bWVudFR5cGU7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVUaW1lID0gY3JlYXRlVGltZTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IGRvY3VtZW50U3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkb2N1bWVudCB3aXRoIG5vIGtub3duIHZlcnNpb24gb3IgZGF0YSwgYnV0IHdoaWNoIGNhbiBzZXJ2ZSBhc1xyXG4gICAgICogYmFzZSBkb2N1bWVudCBmb3IgbXV0YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi8sIFxyXG4gICAgICAgIC8qIHZlcnNpb24gKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIGV4aXN0IHdpdGggdGhlIGdpdmVuIGRhdGEgYXQgdGhlXHJcbiAgICAgKiBnaXZlbiB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbmV3Rm91bmREb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi8sIFxyXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXHJcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIGNyZWF0ZVRpbWUsIHZhbHVlLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gbm90IGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uLiAqL1xyXG4gICAgc3RhdGljIG5ld05vRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8sIFxyXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXHJcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbiBidXRcclxuICAgICAqIHdob3NlIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cclxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbmV3VW5rbm93bkRvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi8sIFxyXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXHJcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGV4aXN0cyBhbmQgdGhhdCBpdHMgdmVyc2lvblxyXG4gICAgICogYW5kIGRhdGEgYXJlIGtub3duLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Gb3VuZERvY3VtZW50KHZlcnNpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgLy8gSWYgYSBkb2N1bWVudCBpcyBzd2l0Y2hpbmcgc3RhdGUgZnJvbSBiZWluZyBhbiBpbnZhbGlkIG9yIGRlbGV0ZWRcclxuICAgICAgICAvLyBkb2N1bWVudCB0byBhIHZhbGlkIChGT1VORF9ET0NVTUVOVCkgZG9jdW1lbnQsIGVpdGhlciBkdWUgdG8gcmVjZWl2aW5nIGFuXHJcbiAgICAgICAgLy8gdXBkYXRlIGZyb20gV2F0Y2ggb3IgZHVlIHRvIGFwcGx5aW5nIGEgbG9jYWwgc2V0IG11dGF0aW9uIG9uIHRvcFxyXG4gICAgICAgIC8vIG9mIGEgZGVsZXRlZCBkb2N1bWVudCwgb3VyIGJlc3QgZ3Vlc3MgYWJvdXQgaXRzIGNyZWF0ZVRpbWUgd291bGQgYmUgdGhlXHJcbiAgICAgICAgLy8gdmVyc2lvbiBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdHJhbnNpdGlvbmVkIHRvIGEgRk9VTkRfRE9DVU1FTlQuXHJcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGltZS5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgJiZcclxuICAgICAgICAgICAgKHRoaXMuZG9jdW1lbnRUeXBlID09PSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPT09IDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi8pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IHZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLztcclxuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndCBleGlzdCBhdCB0aGUgZ2l2ZW5cclxuICAgICAqIHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb05vRG9jdW1lbnQodmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLztcclxuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYXQgYSBnaXZlbiB2ZXJzaW9uIGJ1dFxyXG4gICAgICogdGhhdCBpdHMgZGF0YSBpcyBub3Qga25vd24gKGUuZy4gYSBkb2N1bWVudCB0aGF0IHdhcyB1cGRhdGVkIHdpdGhvdXQgYSBrbm93blxyXG4gICAgICogYmFzZSBkb2N1bWVudCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1Vua25vd25Eb2N1bWVudCh2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SGFzTG9jYWxNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMSAvKiBEb2N1bWVudFN0YXRlLkhBU19MT0NBTF9NVVRBVElPTlMgKi87XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0UmVhZFRpbWUocmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzTG9jYWxNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gMSAvKiBEb2N1bWVudFN0YXRlLkhBU19MT0NBTF9NVVRBVElPTlMgKi87XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPT09IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcclxuICAgIH1cclxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc0xvY2FsTXV0YXRpb25zIHx8IHRoaXMuaGFzQ29tbWl0dGVkTXV0YXRpb25zO1xyXG4gICAgfVxyXG4gICAgaXNWYWxpZERvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSAhPT0gMCAvKiBEb2N1bWVudFR5cGUuSU5WQUxJRCAqLztcclxuICAgIH1cclxuICAgIGlzRm91bmREb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNOb0RvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XHJcbiAgICB9XHJcbiAgICBpc1Vua25vd25Eb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi87XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIE11dGFibGVEb2N1bWVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLmtleS5pc0VxdWFsKG90aGVyLmtleSkgJiZcclxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uLmlzRXF1YWwob3RoZXIudmVyc2lvbikgJiZcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPT09IG90aGVyLmRvY3VtZW50VHlwZSAmJlxyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPT09IG90aGVyLmRvY3VtZW50U3RhdGUgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmlzRXF1YWwob3RoZXIuZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgbXV0YWJsZUNvcHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQodGhpcy5rZXksIHRoaXMuZG9jdW1lbnRUeXBlLCB0aGlzLnZlcnNpb24sIHRoaXMucmVhZFRpbWUsIHRoaXMuY3JlYXRlVGltZSwgdGhpcy5kYXRhLmNsb25lKCksIHRoaXMuZG9jdW1lbnRTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKGBEb2N1bWVudCgke3RoaXMua2V5fSwgJHt0aGlzLnZlcnNpb259LCAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGF0YS52YWx1ZSl9LCBgICtcclxuICAgICAgICAgICAgYHtjcmVhdGVUaW1lOiAke3RoaXMuY3JlYXRlVGltZX19KSwgYCArXHJcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRUeXBlOiAke3RoaXMuZG9jdW1lbnRUeXBlfX0pLCBgICtcclxuICAgICAgICAgICAgYHtkb2N1bWVudFN0YXRlOiAke3RoaXMuZG9jdW1lbnRTdGF0ZX19KWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGUgdmFsdWUgZm9yIGZpZWxkIGBmaWVsZGAgaW4gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gVGhyb3dzIGlmXHJcbiAqIHRoZSBmaWVsZCBkb2VzIG5vdCBleGlzdCBpbiBib3RoIGRvY3VtZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudHNCeUZpZWxkKGZpZWxkLCBkMSwgZDIpIHtcclxuICAgIGNvbnN0IHYxID0gZDEuZGF0YS5maWVsZChmaWVsZCk7XHJcbiAgICBjb25zdCB2MiA9IGQyLmRhdGEuZmllbGQoZmllbGQpO1xyXG4gICAgaWYgKHYxICE9PSBudWxsICYmIHYyICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlQ29tcGFyZSh2MSwgdjIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJvdW5kIG9mIGEgcXVlcnkuXHJcbiAqXHJcbiAqIFRoZSBib3VuZCBpcyBzcGVjaWZpZWQgd2l0aCB0aGUgZ2l2ZW4gY29tcG9uZW50cyByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBhbmRcclxuICogd2hldGhlciBpdCdzIGp1c3QgYmVmb3JlIG9yIGp1c3QgYWZ0ZXIgdGhlIHBvc2l0aW9uIChyZWxhdGl2ZSB0byB3aGF0ZXZlciB0aGVcclxuICogcXVlcnkgb3JkZXIgaXMpLlxyXG4gKlxyXG4gKiBUaGUgcG9zaXRpb24gcmVwcmVzZW50cyBhIGxvZ2ljYWwgaW5kZXggcG9zaXRpb24gZm9yIGEgcXVlcnkuIEl0J3MgYSBwcmVmaXhcclxuICogb2YgdmFsdWVzIGZvciB0aGUgKHBvdGVudGlhbGx5IGltcGxpY2l0KSBvcmRlciBieSBjbGF1c2VzIG9mIGEgcXVlcnkuXHJcbiAqXHJcbiAqIEJvdW5kIHByb3ZpZGVzIGEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkb2N1bWVudCBjb21lcyBiZWZvcmUgb3JcclxuICogYWZ0ZXIgYSBib3VuZC4gVGhpcyBpcyBpbmZsdWVuY2VkIGJ5IHdoZXRoZXIgdGhlIHBvc2l0aW9uIGlzIGp1c3QgYmVmb3JlIG9yXHJcbiAqIGp1c3QgYWZ0ZXIgdGhlIHByb3ZpZGVkIHZhbHVlcy5cclxuICovXHJcbmNsYXNzIEJvdW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBpbmNsdXNpdmUpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XHJcbiAgICBsZXQgY29tcGFyaXNvbiA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kLnBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb3JkZXJCeUNvbXBvbmVudCA9IG9yZGVyQnlbaV07XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYm91bmQucG9zaXRpb25baV07XHJcbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKERvY3VtZW50S2V5LmZyb21OYW1lKGNvbXBvbmVudC5yZWZlcmVuY2VWYWx1ZSksIGRvYy5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZG9jVmFsdWUgPSBkb2MuZGF0YS5maWVsZChvcmRlckJ5Q29tcG9uZW50LmZpZWxkKTtcclxuICAgICAgICAgICAgY29tcGFyaXNvbiA9IHZhbHVlQ29tcGFyZShjb21wb25lbnQsIGRvY1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLykge1xyXG4gICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyaXNvbiAqIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcGFyaXNvbjtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYWZ0ZXIgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxyXG4gKiBvcmRlci5cclxuICovXHJcbmZ1bmN0aW9uIGJvdW5kU29ydHNBZnRlckRvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpO1xyXG4gICAgcmV0dXJuIGJvdW5kLmluY2x1c2l2ZSA/IGNvbXBhcmlzb24gPj0gMCA6IGNvbXBhcmlzb24gPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxyXG4gKiBvcmRlci5cclxuICovXHJcbmZ1bmN0aW9uIGJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcclxuICAgIHJldHVybiBib3VuZC5pbmNsdXNpdmUgPyBjb21wYXJpc29uIDw9IDAgOiBjb21wYXJpc29uIDwgMDtcclxufVxyXG5mdW5jdGlvbiBib3VuZEVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmlnaHQgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAhPT0gcmlnaHQuaW5jbHVzaXZlIHx8XHJcbiAgICAgICAgbGVmdC5wb3NpdGlvbi5sZW5ndGggIT09IHJpZ2h0LnBvc2l0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxlZnRQb3NpdGlvbiA9IGxlZnQucG9zaXRpb25baV07XHJcbiAgICAgICAgY29uc3QgcmlnaHRQb3NpdGlvbiA9IHJpZ2h0LnBvc2l0aW9uW2ldO1xyXG4gICAgICAgIGlmICghdmFsdWVFcXVhbHMobGVmdFBvc2l0aW9uLCByaWdodFBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIG9yZGVyaW5nIG9uIGEgZmllbGQsIGluIHNvbWUgRGlyZWN0aW9uLiBEaXJlY3Rpb24gZGVmYXVsdHMgdG8gQVNDRU5ESU5HLlxyXG4gKi9cclxuY2xhc3MgT3JkZXJCeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZGlyID0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5T3JkZXJCeShvcmRlckJ5KSB7XHJcbiAgICAvLyBUT0RPKGIvMjkxODMxNjUpOiBNYWtlIHRoaXMgY29sbGlzaW9uIHJvYnVzdC5cclxuICAgIHJldHVybiBvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpICsgb3JkZXJCeS5kaXI7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5T3JkZXJCeShvcmRlckJ5KSB7XHJcbiAgICByZXR1cm4gYCR7b3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKX0gKCR7b3JkZXJCeS5kaXJ9KWA7XHJcbn1cclxuZnVuY3Rpb24gb3JkZXJCeUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIGxlZnQuZGlyID09PSByaWdodC5kaXIgJiYgbGVmdC5maWVsZC5pc0VxdWFsKHJpZ2h0LmZpZWxkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaWx0ZXIge1xyXG59XHJcbmNsYXNzIEZpZWxkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChmaWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0ZpbHRlcihmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0FueUZpbHRlcihmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi9cclxuICAgICAgICAgICAgPyBuZXcgS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgdmFsdWUpXHJcbiAgICAgICAgICAgIDogbmV3IEtleUZpZWxkTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICAvLyBUeXBlcyBkbyBub3QgaGF2ZSB0byBtYXRjaCBpbiBOT1RfRVFVQUwgZmlsdGVycy5cclxuICAgICAgICBpZiAodGhpcy5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT25seSBjb21wYXJlIHR5cGVzIHdpdGggbWF0Y2hpbmcgYmFja2VuZCBvcmRlciAoc3VjaCBhcyBkb3VibGUgYW5kIGludCkuXHJcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICB0eXBlT3JkZXIodGhpcy52YWx1ZSkgPT09IHR5cGVPcmRlcihvdGhlcikgJiZcclxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ29tcGFyaXNvbih2YWx1ZUNvbXBhcmUob3RoZXIsIHRoaXMudmFsdWUpKSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPCAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA8PSAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiAhPT0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+IDA7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID49IDA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzSW5lcXVhbGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gKFtcclxuICAgICAgICAgICAgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovLFxyXG4gICAgICAgICAgICBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi8sXHJcbiAgICAgICAgICAgIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi8sXHJcbiAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sXHJcbiAgICAgICAgICAgIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXHJcbiAgICAgICAgXS5pbmRleE9mKHRoaXMub3ApID49IDApO1xyXG4gICAgfVxyXG4gICAgZ2V0RmxhdHRlbmVkRmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG4gICAgZ2V0RmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXBvc2l0ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzLCBvcCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoZmlsdGVycywgb3ApIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUZpbHRlcihmaWx0ZXJzLCBvcCk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBjb25qdW5jdGlvbnMsIGFsbCBmaWx0ZXJzIG11c3QgbWF0Y2gsIHNvIHJldHVybiBmYWxzZSBpZiBhbnkgZmlsdGVyIGRvZXNuJ3QgbWF0Y2guXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gIWZpbHRlci5tYXRjaGVzKGRvYykpID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgZGlzanVuY3Rpb25zLCBhdCBsZWFzdCBvbmUgZmlsdGVyIHNob3VsZCBtYXRjaC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5maW5kKGZpbHRlciA9PiBmaWx0ZXIubWF0Y2hlcyhkb2MpKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSB0aGlzLmZpbHRlcnMucmVkdWNlKChyZXN1bHQsIHN1YmZpbHRlcikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChzdWJmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIG11dGFibGUgY29weSBvZiBgdGhpcy5maWx0ZXJzYFxyXG4gICAgZ2V0RmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5maWx0ZXJzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xyXG4gICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlci5vcCA9PT0gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi87XHJcbn1cclxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXIub3AgPT09IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmlsdGVyIGlzIGEgY29uanVuY3Rpb24gb2YgZmllbGQgZmlsdGVycyBvbmx5LiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xyXG4gICAgcmV0dXJuIChjb21wb3NpdGVGaWx0ZXJJc0ZsYXQoY29tcG9zaXRlRmlsdGVyKSAmJlxyXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpbHRlciBkb2VzIG5vdCBjb250YWluIGFueSBjb21wb3NpdGUgZmlsdGVycy4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0ZsYXQoY29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycykge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgLy8gVE9ETyhiLzI5MTgzMTY1KTogVGVjaG5pY2FsbHksIHRoaXMgd29uJ3QgYmUgdW5pcXVlIGlmIHR3byB2YWx1ZXMgaGF2ZVxyXG4gICAgICAgIC8vIHRoZSBzYW1lIGRlc2NyaXB0aW9uLCBzdWNoIGFzIHRoZSBpbnQgMyBhbmQgdGhlIHN0cmluZyBcIjNcIi4gU28gd2Ugc2hvdWxkXHJcbiAgICAgICAgLy8gYWRkIHRoZSB0eXBlcyBpbiBoZXJlIHNvbWVob3csIHRvby5cclxuICAgICAgICByZXR1cm4gKGZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSArXHJcbiAgICAgICAgICAgIGZpbHRlci5vcC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgY2Fub25pY2FsSWQoZmlsdGVyLnZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpKSB7XHJcbiAgICAgICAgLy8gT2xkZXIgU0RLIHZlcnNpb25zIHVzZSBhbiBpbXBsaWNpdCBBTkQgb3BlcmF0aW9uIGJldHdlZW4gdGhlaXIgZmlsdGVycy5cclxuICAgICAgICAvLyBJbiB0aGUgbmV3IFNESyB2ZXJzaW9ucywgdGhlIGRldmVsb3BlciBtYXkgdXNlIGFuIGV4cGxpY2l0IEFORCBmaWx0ZXIuXHJcbiAgICAgICAgLy8gVG8gc3RheSBjb25zaXN0ZW50IHdpdGggdGhlIG9sZCB1c2FnZXMsIHdlIGFkZCBhIHNwZWNpYWwgY2FzZSB0byBlbnN1cmVcclxuICAgICAgICAvLyB0aGUgY2Fub25pY2FsIElEIGZvciB0aGVzZSB0d28gYXJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZTpcclxuICAgICAgICAvLyBgY29sLndoZXJlRXF1YWxzKFwiYVwiLCAxKS53aGVyZUVxdWFscyhcImJcIiwgMilgIHNob3VsZCBoYXZlIHRoZSBzYW1lXHJcbiAgICAgICAgLy8gY2Fub25pY2FsIElEIGFzIGBjb2wud2hlcmUoYW5kKGVxdWFscyhcImFcIiwxKSwgZXF1YWxzKFwiYlwiLDIpKSlgLlxyXG4gICAgICAgIHJldHVybiBmaWx0ZXIuZmlsdGVycy5tYXAoZmlsdGVyID0+IGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikpLmpvaW4oJywnKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlclxyXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbElkc1N0cmluZyA9IGZpbHRlci5maWx0ZXJzXHJcbiAgICAgICAgICAgIC5tYXAoZmlsdGVyID0+IGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikpXHJcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke2ZpbHRlci5vcH0oJHtjYW5vbmljYWxJZHNTdHJpbmd9KWA7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmlsdGVyRXF1YWxzKGYxLCBmMikge1xyXG4gICAgaWYgKGYxIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGYxIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlckVxdWFscyhmMSwgZjIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMikge1xyXG4gICAgcmV0dXJuIChmMiBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyICYmXHJcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXHJcbiAgICAgICAgZjEuZmllbGQuaXNFcXVhbChmMi5maWVsZCkgJiZcclxuICAgICAgICB2YWx1ZUVxdWFscyhmMS52YWx1ZSwgZjIudmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XHJcbiAgICBpZiAoZjIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcclxuICAgICAgICBmMS5vcCA9PT0gZjIub3AgJiZcclxuICAgICAgICBmMS5maWx0ZXJzLmxlbmd0aCA9PT0gZjIuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBzdWJGaWx0ZXJzTWF0Y2ggPSBmMS5maWx0ZXJzLnJlZHVjZSgocmVzdWx0LCBmMUZpbHRlciwgaW5kZXgpID0+IHJlc3VsdCAmJiBmaWx0ZXJFcXVhbHMoZjFGaWx0ZXIsIGYyLmZpbHRlcnNbaW5kZXhdKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN1YkZpbHRlcnNNYXRjaDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBjb21wb3NpdGUgZmlsdGVyIHRoYXQgY29udGFpbnMgYWxsIGZpbHRlciBmcm9tXHJcbiAqIGBjb21wb3NpdGVGaWx0ZXJgIHBsdXMgYWxsIHRoZSBnaXZlbiBmaWx0ZXJzIGluIGBvdGhlckZpbHRlcnNgLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhjb21wb3NpdGVGaWx0ZXIsIG90aGVyRmlsdGVycykge1xyXG4gICAgY29uc3QgbWVyZ2VkRmlsdGVycyA9IGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLmNvbmNhdChvdGhlckZpbHRlcnMpO1xyXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobWVyZ2VkRmlsdGVycywgY29tcG9zaXRlRmlsdGVyLm9wKTtcclxufVxyXG4vKiogUmV0dXJucyBhIGRlYnVnIGRlc2NyaXB0aW9uIGZvciBgZmlsdGVyYC4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5RmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJ0ZpbHRlcic7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIChmaWx0ZXIub3AudG9TdHJpbmcoKSArXHJcbiAgICAgICAgYCB7YCArXHJcbiAgICAgICAgZmlsdGVyLmdldEZpbHRlcnMoKS5tYXAoc3RyaW5naWZ5RmlsdGVyKS5qb2luKCcgLCcpICtcclxuICAgICAgICAnfScpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIGAke2ZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKX0gJHtmaWx0ZXIub3B9ICR7Y2Fub25pY2FsSWQoZmlsdGVyLnZhbHVlKX1gO1xyXG59XHJcbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgKGkuZS4gJ19fbmFtZV9fJykuICovXHJcbmNsYXNzIEtleUZpZWxkRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIG9wLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMua2V5ID0gRG9jdW1lbnRLZXkuZnJvbU5hbWUodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhkb2MpIHtcclxuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkb2Mua2V5LCB0aGlzLmtleSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbik7XHJcbiAgICB9XHJcbn1cclxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyB3aXRoaW4gYW4gYXJyYXkuICovXHJcbmNsYXNzIEtleUZpZWxkSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJpblwiIC8qIE9wZXJhdG9yLklOICovLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5rZXlzID0gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhkb2MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLnNvbWUoa2V5ID0+IGtleS5pc0VxdWFsKGRvYy5rZXkpKTtcclxuICAgIH1cclxufVxyXG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIG5vdCBwcmVzZW50IHdpdGhpbiBhbiBhcnJheS4gKi9cclxuY2xhc3MgS2V5RmllbGROb3RJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGZpZWxkLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLywgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhkb2MpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKG9wLCB2YWx1ZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuICgoKF9hID0gdmFsdWUuYXJyYXlWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcykgfHwgW10pLm1hcCh2ID0+IHtcclxuICAgICAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbU5hbWUodi5yZWZlcmVuY2VWYWx1ZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucyBvcGVyYXRvci4gKi9cclxuY2xhc3MgQXJyYXlDb250YWluc0ZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICByZXR1cm4gaXNBcnJheShvdGhlcikgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKG90aGVyLmFycmF5VmFsdWUsIHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIElOIG9wZXJhdG9yLiAqL1xyXG5jbGFzcyBJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgb3RoZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIG5vdC1pbiBvcGVyYXRvci4gKi9cclxuY2xhc3MgTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgaWYgKGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xyXG4gICAgICAgIHJldHVybiBvdGhlciAhPT0gbnVsbCAmJiAhYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgb3RoZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIGFycmF5LWNvbnRhaW5zLWFueSBvcGVyYXRvci4gKi9cclxuY2xhc3MgQXJyYXlDb250YWluc0FueUZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhkb2MpIHtcclxuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xyXG4gICAgICAgIGlmICghaXNBcnJheShvdGhlcikgfHwgIW90aGVyLmFycmF5VmFsdWUudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG90aGVyLmFycmF5VmFsdWUudmFsdWVzLnNvbWUodmFsID0+IGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHZhbCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcclxuY2xhc3MgVGFyZ2V0SW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBvcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICB0aGlzLm9yZGVyQnkgPSBvcmRlckJ5O1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xyXG4gICAgICAgIHRoaXMuc3RhcnRBdCA9IHN0YXJ0QXQ7XHJcbiAgICAgICAgdGhpcy5lbmRBdCA9IGVuZEF0O1xyXG4gICAgICAgIHRoaXMubWVtb2l6ZWRDYW5vbmljYWxJZCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgVGFyZ2V0IHdpdGggYSBwYXRoIGFuZCBvcHRpb25hbCBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxyXG4gKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxyXG4gKlxyXG4gKiBOT1RFOiB5b3Ugc2hvdWxkIGFsd2F5cyBjb25zdHJ1Y3QgYFRhcmdldGAgZnJvbSBgUXVlcnkudG9UYXJnZXRgIGluc3RlYWQgb2ZcclxuICogdXNpbmcgdGhpcyBmYWN0b3J5IG1ldGhvZCwgYmVjYXVzZSBgUXVlcnlgIHByb3ZpZGVzIGFuIGltcGxpY2l0IGBvcmRlckJ5YFxyXG4gKiBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1RhcmdldChwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBvcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IFRhcmdldEltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgc3RhcnRBdCwgZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgY29uc3QgdGFyZ2V0SW1wbCA9IGRlYnVnQ2FzdCh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZCA9PT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBzdHIgPSB0YXJnZXRJbXBsLnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRhcmdldEltcGwuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnfGNnOicgKyB0YXJnZXRJbXBsLmNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyICs9ICd8ZjonO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmZpbHRlcnMubWFwKGYgPT4gY2Fub25pZnlGaWx0ZXIoZikpLmpvaW4oJywnKTtcclxuICAgICAgICBzdHIgKz0gJ3xvYjonO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLm9yZGVyQnkubWFwKG8gPT4gY2Fub25pZnlPcmRlckJ5KG8pKS5qb2luKCcsJyk7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0YXJnZXRJbXBsLmxpbWl0KSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJ3xsOic7XHJcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmxpbWl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0SW1wbC5zdGFydEF0KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnfGxiOic7XHJcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLnN0YXJ0QXQuaW5jbHVzaXZlID8gJ2I6JyA6ICdhOic7XHJcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLnN0YXJ0QXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldEltcGwuZW5kQXQpIHtcclxuICAgICAgICAgICAgc3RyICs9ICd8dWI6JztcclxuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZW5kQXQuaW5jbHVzaXZlID8gJ2E6JyA6ICdiOic7XHJcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmVuZEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZCA9IHN0cjtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQ7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgbGV0IHN0ciA9IHRhcmdldC5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICBzdHIgKz0gJyBjb2xsZWN0aW9uR3JvdXA9JyArIHRhcmdldC5jb2xsZWN0aW9uR3JvdXA7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHN0ciArPSBgLCBmaWx0ZXJzOiBbJHt0YXJnZXQuZmlsdGVyc1xyXG4gICAgICAgICAgICAubWFwKGYgPT4gc3RyaW5naWZ5RmlsdGVyKGYpKVxyXG4gICAgICAgICAgICAuam9pbignLCAnKX1dYDtcclxuICAgIH1cclxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0LmxpbWl0KSkge1xyXG4gICAgICAgIHN0ciArPSAnLCBsaW1pdDogJyArIHRhcmdldC5saW1pdDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQub3JkZXJCeS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgc3RyICs9IGAsIG9yZGVyQnk6IFske3RhcmdldC5vcmRlckJ5XHJcbiAgICAgICAgICAgIC5tYXAobyA9PiBzdHJpbmdpZnlPcmRlckJ5KG8pKVxyXG4gICAgICAgICAgICAuam9pbignLCAnKX1dYDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuc3RhcnRBdCkge1xyXG4gICAgICAgIHN0ciArPSAnLCBzdGFydEF0OiAnO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXQuc3RhcnRBdC5pbmNsdXNpdmUgPyAnYjonIDogJ2E6JztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0LnN0YXJ0QXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuZW5kQXQpIHtcclxuICAgICAgICBzdHIgKz0gJywgZW5kQXQ6ICc7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldC5lbmRBdC5pbmNsdXNpdmUgPyAnYTonIDogJ2I6JztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFRhcmdldCgke3N0cn0pYDtcclxufVxyXG5mdW5jdGlvbiB0YXJnZXRFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LmxpbWl0ICE9PSByaWdodC5saW1pdCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0Lm9yZGVyQnkubGVuZ3RoICE9PSByaWdodC5vcmRlckJ5Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5vcmRlckJ5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFvcmRlckJ5RXF1YWxzKGxlZnQub3JkZXJCeVtpXSwgcmlnaHQub3JkZXJCeVtpXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmZpbHRlcnMubGVuZ3RoICE9PSByaWdodC5maWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJFcXVhbHMobGVmdC5maWx0ZXJzW2ldLCByaWdodC5maWx0ZXJzW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuY29sbGVjdGlvbkdyb3VwICE9PSByaWdodC5jb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWxlZnQucGF0aC5pc0VxdWFsKHJpZ2h0LnBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFib3VuZEVxdWFscyhsZWZ0LnN0YXJ0QXQsIHJpZ2h0LnN0YXJ0QXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvdW5kRXF1YWxzKGxlZnQuZW5kQXQsIHJpZ2h0LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiB0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHRhcmdldC5wYXRoKSAmJlxyXG4gICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgJiZcclxuICAgICAgICB0YXJnZXQuZmlsdGVycy5sZW5ndGggPT09IDApO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRoZSBmaWVsZCBmaWx0ZXJzIHRoYXQgdGFyZ2V0IHRoZSBnaXZlbiBmaWVsZCBwYXRoLiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHRhcmdldC5maWx0ZXJzLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJiBmLmZpZWxkLmlzRXF1YWwocGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZXMgdGhhdCBhcmUgdXNlZCBpbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTllcclxuICogZmlsdGVycy4gUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggZmlsdGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHRhcmdldEdldEFycmF5VmFsdWVzKHRhcmdldCwgZmllbGRJbmRleCkge1xyXG4gICAgY29uc3Qgc2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCk7XHJcbiAgICBpZiAoc2VnbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXIudmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmaWVsZEZpbHRlci52YWx1ZV07XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGFyZSBub3QgYXJyYXkgZmlsdGVycy5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgdGhhdCBhcmUgdXNlZCBpbiAhPSBvciBOT1RfSU4gZmlsdGVycy4gUmV0dXJuc1xyXG4gKiBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggZmlsdGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHRhcmdldEdldE5vdEluVmFsdWVzKHRhcmdldCwgZmllbGRJbmRleCkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIGVxdWFsaXR5IHByZWZpeCwgd2hpY2ggaXMgZW5jb2RlZCBpbiB0aGUgaW5kZXggdmFsdWUgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluZXF1YWxpdHkgKGUuZy4gYGEgPT0gJ2EnICYmIGIgIT0gJ2InYCBpcyBlbmNvZGVkIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHZhbHVlICE9ICdhYidgKS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KHNlZ21lbnQuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBmaWVsZEZpbHRlci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdEluL05vdEVxdWFsIGlzIGFsd2F5cyBhIHN1ZmZpeC4gVGhlcmUgY2Fubm90IGJlIGFueSByZW1haW5pbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50cyBhbmQgaGVuY2Ugd2UgY2FuIHJldHVybiBlYXJseSBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zZXQoc2VnbWVudC5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCksIGZpZWxkRmlsdGVyLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZXMudmFsdWVzKCkpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgbm90SW4gYm91bmRzLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsb3dlciBib3VuZCBvZiBmaWVsZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN0YXJ0aW5nIHBvaW50IHRvXHJcbiAqIHNjYW4gdGhlIGluZGV4IGRlZmluZWQgYnkgYGZpZWxkSW5kZXhgLiBSZXR1cm5zIGBNSU5fVkFMVUVgIGlmIG5vIGxvd2VyIGJvdW5kXHJcbiAqIGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHRhcmdldEdldExvd2VyQm91bmQodGFyZ2V0LCBmaWVsZEluZGV4KSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xyXG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCwgcmV0cmlldmUgYSBsb3dlciBib3VuZCBpZiB0aGVyZSBpcyBhIHN1aXRhYmxlIGZpbHRlciBvclxyXG4gICAgLy8gc3RhcnRBdC5cclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRCb3VuZCA9IHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXHJcbiAgICAgICAgICAgID8gdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LnN0YXJ0QXQpXHJcbiAgICAgICAgICAgIDogdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5zdGFydEF0KTtcclxuICAgICAgICB2YWx1ZXMucHVzaChzZWdtZW50Qm91bmQudmFsdWUpO1xyXG4gICAgICAgIGluY2x1c2l2ZSAmJiAoaW5jbHVzaXZlID0gc2VnbWVudEJvdW5kLmluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKHZhbHVlcywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiB1cHBlciBib3VuZCBvZiBmaWVsZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRpbmcgcG9pbnRcclxuICogd2hlbiBzY2FubmluZyB0aGUgaW5kZXggZGVmaW5lZCBieSBgZmllbGRJbmRleGAuIFJldHVybnMgYE1BWF9WQUxVRWAgaWYgbm9cclxuICogdXBwZXIgYm91bmQgZXhpc3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gdGFyZ2V0R2V0VXBwZXJCb3VuZCh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XHJcbiAgICAvLyBGb3IgZWFjaCBzZWdtZW50LCByZXRyaWV2ZSBhbiB1cHBlciBib3VuZCBpZiB0aGVyZSBpcyBhIHN1aXRhYmxlIGZpbHRlciBvclxyXG4gICAgLy8gZW5kQXQuXHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50Qm91bmQgPSBzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICA/IHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuZW5kQXQpXHJcbiAgICAgICAgICAgIDogdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LmVuZEF0KTtcclxuICAgICAgICB2YWx1ZXMucHVzaChzZWdtZW50Qm91bmQudmFsdWUpO1xyXG4gICAgICAgIGluY2x1c2l2ZSAmJiAoaW5jbHVzaXZlID0gc2VnbWVudEJvdW5kLmluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKHZhbHVlcywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdmFsdWUgdG8gdXNlIGFzIHRoZSBsb3dlciBib3VuZCBmb3IgYXNjZW5kaW5nIGluZGV4IHNlZ21lbnQgYXRcclxuICogdGhlIHByb3ZpZGVkIGBmaWVsZFBhdGhgIChvciB0aGUgdXBwZXIgYm91bmQgZm9yIGFuIGRlc2NlbmRpbmcgc2VnbWVudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXRBc2NlbmRpbmdCb3VuZCh0YXJnZXQsIGZpZWxkUGF0aCwgYm91bmQpIHtcclxuICAgIGxldCB2YWx1ZSA9IE1JTl9WQUxVRTtcclxuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xyXG4gICAgLy8gUHJvY2VzcyBhbGwgZmlsdGVycyB0byBmaW5kIGEgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGZpZWxkIHNlZ21lbnRcclxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIGZpZWxkUGF0aCkpIHtcclxuICAgICAgICBsZXQgZmlsdGVyVmFsdWUgPSBNSU5fVkFMVUU7XHJcbiAgICAgICAgbGV0IGZpbHRlckluY2x1c2l2ZSA9IHRydWU7XHJcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLzpcclxuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSB2YWx1ZXNHZXRMb3dlckJvdW5kKGZpZWxkRmlsdGVyLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcclxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBNSU5fVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgbG93ZXIgYm91bmRzLlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG93ZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGZpbHRlclZhbHVlLCBpbmNsdXNpdmU6IGZpbHRlckluY2x1c2l2ZSB9KSA8IDApIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcclxuICAgICAgICAgICAgaW5jbHVzaXZlID0gZmlsdGVySW5jbHVzaXZlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgYm91bmQsIGNvbXBhcmUgdGhlIHZhbHVlcyBhZ2FpbnN0IHRoZSBleGlzdGluZ1xyXG4gICAgLy8gcmFuZ2UgdG8gc2VlIGlmIHdlIGNhbiBuYXJyb3cgdGhlIHNjb3BlLlxyXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQub3JkZXJCeS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5ID0gdGFyZ2V0Lm9yZGVyQnlbaV07XHJcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yVmFsdWUgPSBib3VuZC5wb3NpdGlvbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChsb3dlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogY3Vyc29yVmFsdWUsIGluY2x1c2l2ZTogYm91bmQuaW5jbHVzaXZlIH0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlID0gYm91bmQuaW5jbHVzaXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB2YWx1ZSwgaW5jbHVzaXZlIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgdXBwZXIgYm91bmQgZm9yIGFzY2VuZGluZyBpbmRleCBzZWdtZW50IGF0XHJcbiAqIHRoZSBwcm92aWRlZCBgZmllbGRQYXRoYCAob3IgdGhlIGxvd2VyIGJvdW5kIGZvciBhIGRlc2NlbmRpbmcgc2VnbWVudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXREZXNjZW5kaW5nQm91bmQodGFyZ2V0LCBmaWVsZFBhdGgsIGJvdW5kKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBNQVhfVkFMVUU7XHJcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcclxuICAgIC8vIFByb2Nlc3MgYWxsIGZpbHRlcnMgdG8gZmluZCBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmaWVsZCBzZWdtZW50XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBmaWx0ZXJJbmNsdXNpdmUgPSB0cnVlO1xyXG4gICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcclxuICAgICAgICAgICAgY2FzZSBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovOlxyXG4gICAgICAgICAgICBjYXNlIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gdmFsdWVzR2V0VXBwZXJCb3VuZChmaWVsZEZpbHRlci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmNsdXNpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcclxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcclxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBNQVhfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgdXBwZXIgYm91bmRzLlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXBwZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGZpbHRlclZhbHVlLCBpbmNsdXNpdmU6IGZpbHRlckluY2x1c2l2ZSB9KSA+IDApIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcclxuICAgICAgICAgICAgaW5jbHVzaXZlID0gZmlsdGVySW5jbHVzaXZlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgYm91bmQsIGNvbXBhcmUgdGhlIHZhbHVlcyBhZ2FpbnN0IHRoZSBleGlzdGluZ1xyXG4gICAgLy8gcmFuZ2UgdG8gc2VlIGlmIHdlIGNhbiBuYXJyb3cgdGhlIHNjb3BlLlxyXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQub3JkZXJCeS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5ID0gdGFyZ2V0Lm9yZGVyQnlbaV07XHJcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yVmFsdWUgPSBib3VuZC5wb3NpdGlvbltpXTtcclxuICAgICAgICAgICAgICAgIGlmICh1cHBlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogY3Vyc29yVmFsdWUsIGluY2x1c2l2ZTogYm91bmQuaW5jbHVzaXZlIH0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlID0gYm91bmQuaW5jbHVzaXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB2YWx1ZSwgaW5jbHVzaXZlIH07XHJcbn1cclxuLyoqIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cyBvZiBhIHBlcmZlY3QgaW5kZXggZm9yIHRoaXMgdGFyZ2V0LiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRHZXRTZWdtZW50Q291bnQodGFyZ2V0KSB7XHJcbiAgICBsZXQgZmllbGRzID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgIGxldCBoYXNBcnJheVNlZ21lbnQgPSBmYWxzZTtcclxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRhcmdldC5maWx0ZXJzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2YgZmlsdGVyLmdldEZsYXR0ZW5lZEZpbHRlcnMoKSkge1xyXG4gICAgICAgICAgICAvLyBfX25hbWVfXyBpcyBub3QgYW4gZXhwbGljaXQgc2VnbWVudCBvZiBhbnkgaW5kZXgsIHNvIHdlIGRvbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gY291bnQgaXQuXHJcbiAgICAgICAgICAgIGlmIChzdWJGaWx0ZXIuZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTlkgZmlsdGVycyBtdXN0IGJlIGNvdW50ZWQgc2VwYXJhdGVseS5cclxuICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGFuIGluZGV4IGZvciBcImEgQVJSQVkgYSBBU0NcIi4gRXZlblxyXG4gICAgICAgICAgICAvLyB0aG91Z2ggdGhlc2UgYXJlIG9uIHRoZSBzYW1lIGZpZWxkLCB0aGV5IHNob3VsZCBiZSBjb3VudGVkIGFzIHR3b1xyXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBzZWdtZW50cyBpbiBhbiBpbmRleC5cclxuICAgICAgICAgICAgaWYgKHN1YkZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XHJcbiAgICAgICAgICAgICAgICBzdWJGaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNBcnJheVNlZ21lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmllbGRzID0gZmllbGRzLmFkZChzdWJGaWx0ZXIuZmllbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRhcmdldC5vcmRlckJ5KSB7XHJcbiAgICAgICAgLy8gX19uYW1lX18gaXMgbm90IGFuIGV4cGxpY2l0IHNlZ21lbnQgb2YgYW55IGluZGV4LCBzbyB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICAgICAgLy8gY291bnQgaXQuXHJcbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMuYWRkKG9yZGVyQnkuZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmaWVsZHMuc2l6ZSArIChoYXNBcnJheVNlZ21lbnQgPyAxIDogMCk7XHJcbn1cclxuZnVuY3Rpb24gdGFyZ2V0SGFzTGltaXQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0LmxpbWl0ICE9PSBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBRdWVyeSBlbmNhcHN1bGF0ZXMgYWxsIHRoZSBxdWVyeSBhdHRyaWJ1dGVzIHdlIHN1cHBvcnQgaW4gdGhlIFNESy4gSXQgY2FuXHJcbiAqIGJlIHJ1biBhZ2FpbnN0IHRoZSBMb2NhbFN0b3JlLCBhcyB3ZWxsIGFzIGJlIGNvbnZlcnRlZCB0byBhIGBUYXJnZXRgIHRvXHJcbiAqIHF1ZXJ5IHRoZSBSZW1vdGVTdG9yZSByZXN1bHRzLlxyXG4gKlxyXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlJbXBsIHtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgYSBRdWVyeSB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cclxuICAgICAqIFBhdGggbXVzdCBjdXJyZW50bHkgYmUgZW1wdHkgaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIGV4cGxpY2l0T3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgbGltaXRUeXBlID0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICB0aGlzLmV4cGxpY2l0T3JkZXJCeSA9IGV4cGxpY2l0T3JkZXJCeTtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICB0aGlzLmxpbWl0VHlwZSA9IGxpbWl0VHlwZTtcclxuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xyXG4gICAgICAgIHRoaXMuZW5kQXQgPSBlbmRBdDtcclxuICAgICAgICB0aGlzLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBudWxsO1xyXG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSwgZm9yIHVzZSB3aXRoXHJcbiAgICAgICAgLy8gbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLlxyXG4gICAgICAgIHRoaXMubWVtb2l6ZWRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSwgZm9yIHVzZSB3aXRoXHJcbiAgICAgICAgLy8gYWdncmVnYXRlIHF1ZXJpZXMuIFVubGlrZSB0YXJnZXRzIGZvciBub24tYWdncmVnYXRlIHF1ZXJpZXMsXHJcbiAgICAgICAgLy8gYWdncmVnYXRlIHF1ZXJ5IHRhcmdldHMgZG8gbm90IGNvbnRhaW4gbm9ybWFsaXplZCBvcmRlci1ieXMsIHRoZXkgb25seVxyXG4gICAgICAgIC8vIGNvbnRhaW4gZXhwbGljaXQgb3JkZXItYnlzLlxyXG4gICAgICAgIHRoaXMubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QXQpIDtcclxuICAgICAgICBpZiAodGhpcy5lbmRBdCkgO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGluc3RhbmNlIHdpdGggdGhlIG9wdGlvbnMgcHJvdmlkZWQuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgZXhwbGljaXRPcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgbGltaXRUeXBlLCBzdGFydEF0LCBlbmRBdCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBleHBsaWNpdE9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBsaW1pdFR5cGUsIHN0YXJ0QXQsIGVuZEF0KTtcclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBxdWVyeSB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyBhdCBgcGF0aGAgKi9cclxuZnVuY3Rpb24gbmV3UXVlcnlGb3JQYXRoKHBhdGgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gY29udmVydCBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgaW50byBhIGNvbGxlY3Rpb24gcXVlcnkgYXQgYVxyXG4gKiBzcGVjaWZpYyBwYXRoLiBUaGlzIGlzIHVzZWQgd2hlbiBleGVjdXRpbmcgY29sbGVjdGlvbiBncm91cCBxdWVyaWVzLCBzaW5jZVxyXG4gKiB3ZSBoYXZlIHRvIHNwbGl0IHRoZSBxdWVyeSBpbnRvIGEgc2V0IG9mIGNvbGxlY3Rpb24gcXVlcmllcyBhdCBtdWx0aXBsZVxyXG4gKiBwYXRocy5cclxuICovXHJcbmZ1bmN0aW9uIGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoLCBcclxuICAgIC8qY29sbGVjdGlvbkdyb3VwPSovIG51bGwsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcXVlcnkgZG9lcyBub3Qgc3BlY2lmeSBhbnkgcXVlcnkgY29uc3RyYWludHMgdGhhdFxyXG4gKiBjb3VsZCByZW1vdmUgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0FsbERvY3VtZW50cyhxdWVyeSkge1xyXG4gICAgcmV0dXJuIChxdWVyeS5maWx0ZXJzLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgIHF1ZXJ5LmxpbWl0ID09PSBudWxsICYmXHJcbiAgICAgICAgcXVlcnkuc3RhcnRBdCA9PSBudWxsICYmXHJcbiAgICAgICAgcXVlcnkuZW5kQXQgPT0gbnVsbCAmJlxyXG4gICAgICAgIChxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID09PSAwIHx8XHJcbiAgICAgICAgICAgIChxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICBxdWVyeS5leHBsaWNpdE9yZGVyQnlbMF0uZmllbGQuaXNLZXlGaWVsZCgpKSkpO1xyXG59XHJcbi8vIFJldHVybnMgdGhlIHNvcnRlZCBzZXQgb2YgaW5lcXVhbGl0eSBmaWx0ZXIgZmllbGRzIHVzZWQgaW4gdGhpcyBxdWVyeS5cclxuZnVuY3Rpb24gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICBxdWVyeS5maWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xyXG4gICAgICAgIHN1YkZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHNcclxuICogd2l0aGluIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uIGdyb3VwLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UXVlcnlGb3JDb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIGNvbGxlY3Rpb25JZCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBhIHNpbmdsZSBkb2N1bWVudCBieSBwYXRoIChyYXRoZXIgdGhhbiBhXHJcbiAqIGNvbGxlY3Rpb24pLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudFF1ZXJ5JDEocXVlcnkpIHtcclxuICAgIHJldHVybiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShxdWVyeS5wYXRoKSAmJlxyXG4gICAgICAgIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCAmJlxyXG4gICAgICAgIHF1ZXJ5LmZpbHRlcnMubGVuZ3RoID09PSAwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGEgY29sbGVjdGlvbiBncm91cCByYXRoZXIgdGhhbiBhIHNwZWNpZmljXHJcbiAqIGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gcXVlcnkuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG9yZGVyLWJ5IGNvbnN0cmFpbnQgdGhhdCBpcyB1c2VkIHRvIGV4ZWN1dGUgdGhlIFF1ZXJ5LFxyXG4gKiB3aGljaCBjYW4gYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yZGVyLWJ5IGNvbnN0cmFpbnRzIHRoZSB1c2VyIHByb3ZpZGVkIChlLmcuXHJcbiAqIHRoZSBTREsgYW5kIGJhY2tlbmQgYWx3YXlzIG9yZGVycyBieSBgX19uYW1lX19gKS4gVGhlIG5vcm1hbGl6ZWQgb3JkZXItYnlcclxuICogaW5jbHVkZXMgaW1wbGljaXQgb3JkZXItYnlzIGluIGFkZGl0aW9uIHRvIHRoZSBleHBsaWNpdCB1c2VyIHByb3ZpZGVkXHJcbiAqIG9yZGVyLWJ5cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XHJcbiAgICBpZiAocXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPT09IG51bGwpIHtcclxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkc05vcm1hbGl6ZWQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy8gQW55IGV4cGxpY2l0IG9yZGVyIGJ5IGZpZWxkcyBzaG91bGQgYmUgYWRkZWQgYXMgaXMuXHJcbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkpIHtcclxuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChvcmRlckJ5KTtcclxuICAgICAgICAgICAgZmllbGRzTm9ybWFsaXplZC5hZGQob3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgaW1wbGljaXQgb3JkZXJpbmcgYWx3YXlzIG1hdGNoZXMgdGhlIGxhc3QgZXhwbGljaXQgb3JkZXIgYnkuXHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICA/IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnlbcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggLSAxXS5kaXJcclxuICAgICAgICAgICAgOiBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi87XHJcbiAgICAgICAgLy8gQW55IGluZXF1YWxpdHkgZmllbGRzIG5vdCBleHBsaWNpdGx5IG9yZGVyZWQgc2hvdWxkIGJlIGltcGxpY2l0bHkgb3JkZXJlZCBpbiBhIGxleGljb2dyYXBoaWNhbFxyXG4gICAgICAgIC8vIG9yZGVyLiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpbmVxdWFsaXR5IGZpbHRlcnMgb24gdGhlIHNhbWUgZmllbGQsIHRoZSBmaWVsZCBzaG91bGQgYmUgYWRkZWRcclxuICAgICAgICAvLyBvbmx5IG9uY2UuXHJcbiAgICAgICAgLy8gTm90ZTogYFNvcnRlZFNldDxGaWVsZFBhdGg+YCBzb3J0cyB0aGUga2V5IGZpZWxkIGJlZm9yZSBvdGhlciBmaWVsZHMuIEhvd2V2ZXIsIHdlIHdhbnQgdGhlIGtleVxyXG4gICAgICAgIC8vIGZpZWxkIHRvIGJlIHNvcnRlZCBsYXN0LlxyXG4gICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWVsZHMgPSBnZXRJbmVxdWFsaXR5RmlsdGVyRmllbGRzKHF1ZXJ5SW1wbCk7XHJcbiAgICAgICAgaW5lcXVhbGl0eUZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcclxuICAgICAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhmaWVsZC5jYW5vbmljYWxTdHJpbmcoKSkgJiZcclxuICAgICAgICAgICAgICAgICFmaWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gobmV3IE9yZGVyQnkoZmllbGQsIGxhc3REaXJlY3Rpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFkZCB0aGUgZG9jdW1lbnQga2V5IGZpZWxkIHRvIHRoZSBsYXN0IGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IG9yZGVyZWQuXHJcbiAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLmNhbm9uaWNhbFN0cmluZygpKSkge1xyXG4gICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KEZpZWxkUGF0aCQxLmtleUZpZWxkKCksIGxhc3REaXJlY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdHMgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5VG9UYXJnZXQocXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XHJcbiAgICBpZiAoIXF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCkge1xyXG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCA9IF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldDtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBgUXVlcnlgIGluc3RhbmNlIHRvIGl0cyBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIHJlcHJlc2VudGF0aW9uLFxyXG4gKiBmb3IgdXNlIHdpdGhpbiBhbiBhZ2dyZWdhdGUgcXVlcnkuIFVubGlrZSB0YXJnZXRzIGZvciBub24tYWdncmVnYXRlIHF1ZXJpZXMsXHJcbiAqIGFnZ3JlZ2F0ZSBxdWVyeSB0YXJnZXRzIGRvIG5vdCBjb250YWluIG5vcm1hbGl6ZWQgb3JkZXItYnlzLCB0aGV5IG9ubHlcclxuICogY29udGFpbiBleHBsaWNpdCBvcmRlci1ieXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xyXG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQpIHtcclxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBpbXBsaWNpdCBvcmRlci1ieXMgZm9yIGFnZ3JlZ2F0ZSBxdWVyaWVzLlxyXG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCA9IF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBvcmRlckJ5cykge1xyXG4gICAgaWYgKHF1ZXJ5SW1wbC5saW1pdFR5cGUgPT09IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykge1xyXG4gICAgICAgIHJldHVybiBuZXdUYXJnZXQocXVlcnlJbXBsLnBhdGgsIHF1ZXJ5SW1wbC5jb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnlzLCBxdWVyeUltcGwuZmlsdGVycywgcXVlcnlJbXBsLmxpbWl0LCBxdWVyeUltcGwuc3RhcnRBdCwgcXVlcnlJbXBsLmVuZEF0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEZsaXAgdGhlIG9yZGVyQnkgZGlyZWN0aW9ucyBzaW5jZSB3ZSB3YW50IHRoZSBsYXN0IHJlc3VsdHNcclxuICAgICAgICBvcmRlckJ5cyA9IG9yZGVyQnlzLm1hcChvcmRlckJ5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGlyID0gb3JkZXJCeS5kaXIgPT09IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXHJcbiAgICAgICAgICAgICAgICA/IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgOiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRlckJ5KG9yZGVyQnkuZmllbGQsIGRpcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzd2FwIHRoZSBjdXJzb3JzIHRvIG1hdGNoIHRoZSBub3ctZmxpcHBlZCBxdWVyeSBvcmRlcmluZy5cclxuICAgICAgICBjb25zdCBzdGFydEF0ID0gcXVlcnlJbXBsLmVuZEF0XHJcbiAgICAgICAgICAgID8gbmV3IEJvdW5kKHF1ZXJ5SW1wbC5lbmRBdC5wb3NpdGlvbiwgcXVlcnlJbXBsLmVuZEF0LmluY2x1c2l2ZSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGVuZEF0ID0gcXVlcnlJbXBsLnN0YXJ0QXRcclxuICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLnN0YXJ0QXQucG9zaXRpb24sIHF1ZXJ5SW1wbC5zdGFydEF0LmluY2x1c2l2ZSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIC8vIE5vdyByZXR1cm4gYXMgYSBMaW1pdFR5cGUuRmlyc3QgcXVlcnkuXHJcbiAgICAgICAgcmV0dXJuIG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeXMsIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XHJcbiAgICBjb25zdCBuZXdGaWx0ZXJzID0gcXVlcnkuZmlsdGVycy5jb25jYXQoW2ZpbHRlcl0pO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgbmV3RmlsdGVycywgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeSwgb3JkZXJCeSkge1xyXG4gICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0ZSB0aGF0IG9yZGVyQnkgZG9lcyBub3QgbGlzdCB0aGUgc2FtZSBrZXkgdHdpY2UuXHJcbiAgICBjb25zdCBuZXdPcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5LmNvbmNhdChbb3JkZXJCeV0pO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBuZXdPcmRlckJ5LCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhMaW1pdChxdWVyeSwgbGltaXQsIGxpbWl0VHlwZSkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBsaW1pdCwgbGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoU3RhcnRBdChxdWVyeSwgYm91bmQpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgYm91bmQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhFbmRBdChxdWVyeSwgYm91bmQpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgYm91bmQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gKHRhcmdldEVxdWFscyhxdWVyeVRvVGFyZ2V0KGxlZnQpLCBxdWVyeVRvVGFyZ2V0KHJpZ2h0KSkgJiZcclxuICAgICAgICBsZWZ0LmxpbWl0VHlwZSA9PT0gcmlnaHQubGltaXRUeXBlKTtcclxufVxyXG4vLyBUT0RPKGIvMjkxODMxNjUpOiBUaGlzIGlzIHVzZWQgdG8gZ2V0IGEgdW5pcXVlIHN0cmluZyBmcm9tIGEgcXVlcnkgdG8sIGZvclxyXG4vLyBleGFtcGxlLCB1c2UgYXMgYSBkaWN0aW9uYXJ5IGtleSwgYnV0IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBzdWJqZWN0IHRvXHJcbi8vIGNvbGxpc2lvbnMuIE1ha2UgaXQgY29sbGlzaW9uLWZyZWUuXHJcbmZ1bmN0aW9uIGNhbm9uaWZ5UXVlcnkocXVlcnkpIHtcclxuICAgIHJldHVybiBgJHtjYW5vbmlmeVRhcmdldChxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSl9fGx0OiR7cXVlcnkubGltaXRUeXBlfWA7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcclxuICAgIHJldHVybiBgUXVlcnkodGFyZ2V0PSR7c3RyaW5naWZ5VGFyZ2V0KHF1ZXJ5VG9UYXJnZXQocXVlcnkpKX07IGxpbWl0VHlwZT0ke3F1ZXJ5LmxpbWl0VHlwZX0pYDtcclxufVxyXG4vKiogUmV0dXJucyB3aGV0aGVyIGBkb2NgIG1hdGNoZXMgdGhlIGNvbnN0cmFpbnRzIG9mIGBxdWVyeWAuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jKSB7XHJcbiAgICByZXR1cm4gKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSAmJlxyXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc1BhdGhBbmRDb2xsZWN0aW9uR3JvdXAocXVlcnksIGRvYykgJiZcclxuICAgICAgICBxdWVyeU1hdGNoZXNPcmRlckJ5KHF1ZXJ5LCBkb2MpICYmXHJcbiAgICAgICAgcXVlcnlNYXRjaGVzRmlsdGVycyhxdWVyeSwgZG9jKSAmJlxyXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc0JvdW5kcyhxdWVyeSwgZG9jKSk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzUGF0aEFuZENvbGxlY3Rpb25Hcm91cChxdWVyeSwgZG9jKSB7XHJcbiAgICBjb25zdCBkb2NQYXRoID0gZG9jLmtleS5wYXRoO1xyXG4gICAgaWYgKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIE5PVEU6IHRoaXMucGF0aCBpcyBjdXJyZW50bHkgYWx3YXlzIGVtcHR5IHNpbmNlIHdlIGRvbid0IGV4cG9zZSBDb2xsZWN0aW9uXHJcbiAgICAgICAgLy8gR3JvdXAgcXVlcmllcyByb290ZWQgYXQgYSBkb2N1bWVudCBwYXRoIHlldC5cclxuICAgICAgICByZXR1cm4gKGRvYy5rZXkuaGFzQ29sbGVjdGlvbklkKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCkgJiZcclxuICAgICAgICAgICAgcXVlcnkucGF0aC5pc1ByZWZpeE9mKGRvY1BhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocXVlcnkucGF0aCkpIHtcclxuICAgICAgICAvLyBleGFjdCBtYXRjaCBmb3IgZG9jdW1lbnQgcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLmlzRXF1YWwoZG9jUGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzaGFsbG93IGFuY2VzdG9yIHF1ZXJpZXMgYnkgZGVmYXVsdFxyXG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLmlzSW1tZWRpYXRlUGFyZW50T2YoZG9jUGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgZG9jdW1lbnQgbXVzdCBoYXZlIGEgdmFsdWUgZm9yIGV2ZXJ5IG9yZGVyaW5nIGNsYXVzZSBpbiBvcmRlciB0byBzaG93IHVwXHJcbiAqIGluIHRoZSByZXN1bHRzLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzT3JkZXJCeShxdWVyeSwgZG9jKSB7XHJcbiAgICAvLyBXZSBtdXN0IHVzZSBgcXVlcnlOb3JtYWxpemVkT3JkZXJCeSgpYCB0byBnZXQgdGhlIGxpc3Qgb2YgYWxsIG9yZGVyQnlzIChib3RoIGltcGxpY2l0IGFuZCBleHBsaWNpdCkuXHJcbiAgICAvLyBOb3RlIHRoYXQgZm9yIE9SIHF1ZXJpZXMsIG9yZGVyQnkgYXBwbGllcyB0byBhbGwgZGlzanVuY3Rpb24gdGVybXMgYW5kIGltcGxpY2l0IG9yZGVyQnlzIG11c3RcclxuICAgIC8vIGJlIHRha2VuIGludG8gYWNjb3VudC4gRm9yIGV4YW1wbGUsIHRoZSBxdWVyeSBcImEgPiAxIHx8IGI9PTFcIiBoYXMgYW4gaW1wbGljaXQgXCJvcmRlckJ5IGFcIiBkdWVcclxuICAgIC8vIHRvIHRoZSBpbmVxdWFsaXR5LCBhbmQgaXMgZXZhbHVhdGVkIGFzIFwiYSA+IDEgb3JkZXJCeSBhIHx8IGI9PTEgb3JkZXJCeSBhXCIuXHJcbiAgICAvLyBBIGRvY3VtZW50IHdpdGggY29udGVudCBvZiB7YjoxfSBtYXRjaGVzIHRoZSBmaWx0ZXJzLCBidXQgZG9lcyBub3QgbWF0Y2ggdGhlIG9yZGVyQnkgYmVjYXVzZVxyXG4gICAgLy8gaXQncyBtaXNzaW5nIHRoZSBmaWVsZCAnYScuXHJcbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcclxuICAgICAgICAvLyBvcmRlci1ieSBrZXkgYWx3YXlzIG1hdGNoZXNcclxuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpICYmIGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpIHtcclxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHF1ZXJ5LmZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoIWZpbHRlci5tYXRjaGVzKGRvYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKiBNYWtlcyBzdXJlIGEgZG9jdW1lbnQgaXMgd2l0aGluIHRoZSBib3VuZHMsIGlmIHByb3ZpZGVkLiAqL1xyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNCb3VuZHMocXVlcnksIGRvYykge1xyXG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgJiZcclxuICAgICAgICAhYm91bmRTb3J0c0JlZm9yZURvY3VtZW50KHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpLCBkb2MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5LmVuZEF0ICYmXHJcbiAgICAgICAgIWJvdW5kU29ydHNBZnRlckRvY3VtZW50KHF1ZXJ5LmVuZEF0LCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSwgZG9jKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGdyb3VwIHRoYXQgdGhpcyBxdWVyeSB0YXJnZXRzLlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBXZWIgU0RLIHRvIGZhY2lsaXRhdGUgbXVsdGktdGFiXHJcbiAqIHN5bmNocm9uaXphdGlvbiBmb3IgcXVlcnkgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCB8fFxyXG4gICAgICAgIChxdWVyeS5wYXRoLmxlbmd0aCAlIDIgPT09IDFcclxuICAgICAgICAgICAgPyBxdWVyeS5wYXRoLmxhc3RTZWdtZW50KClcclxuICAgICAgICAgICAgOiBxdWVyeS5wYXRoLmdldChxdWVyeS5wYXRoLmxlbmd0aCAtIDIpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgY29tcGFyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBhcmUgdHdvIGRvY3VtZW50c1xyXG4gKiBiYXNlZCBvbiB0aGUgUXVlcnkncyBvcmRlcmluZyBjb25zdHJhaW50LlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gKGQxLCBkMikgPT4ge1xyXG4gICAgICAgIGxldCBjb21wYXJlZE9uS2V5RmllbGQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVEb2NzKG9yZGVyQnksIGQxLCBkMik7XHJcbiAgICAgICAgICAgIGlmIChjb21wICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21wYXJlZE9uS2V5RmllbGQgPSBjb21wYXJlZE9uS2V5RmllbGQgfHwgb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpIHtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKVxyXG4gICAgICAgID8gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSlcclxuICAgICAgICA6IGNvbXBhcmVEb2N1bWVudHNCeUZpZWxkKG9yZGVyQnkuZmllbGQsIGQxLCBkMik7XHJcbiAgICBzd2l0Y2ggKG9yZGVyQnkuZGlyKSB7XHJcbiAgICAgICAgY2FzZSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgICAgIGNhc2UgXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAtMSAqIGNvbXBhcmlzb247XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBtYXAgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIG9iamVjdHMgYXMga2V5cy4gT2JqZWN0cyBtdXN0IGhhdmUgYW5cclxuICogYXNzb2NpYXRlZCBlcXVhbHMgZnVuY3Rpb24gYW5kIG11c3QgYmUgaW1tdXRhYmxlLiBFbnRyaWVzIGluIHRoZSBtYXAgYXJlXHJcbiAqIHN0b3JlZCB0b2dldGhlciB3aXRoIHRoZSBrZXkgYmVpbmcgcHJvZHVjZWQgZnJvbSB0aGUgbWFwS2V5Rm4uIFRoaXMgbWFwXHJcbiAqIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb2xsaXNpb25zIG9mIGtleXMuXHJcbiAqL1xyXG5jbGFzcyBPYmplY3RNYXAge1xyXG4gICAgY29uc3RydWN0b3IobWFwS2V5Rm4sIGVxdWFsc0ZuKSB7XHJcbiAgICAgICAgdGhpcy5tYXBLZXlGbiA9IG1hcEtleUZuO1xyXG4gICAgICAgIHRoaXMuZXF1YWxzRm4gPSBlcXVhbHNGbjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5uZXIgbWFwIGZvciBhIGtleS92YWx1ZSBwYWlyLiBEdWUgdG8gdGhlIHBvc3NpYmlsaXR5IG9mIGNvbGxpc2lvbnMgd2VcclxuICAgICAgICAgKiBrZWVwIGEgbGlzdCBvZiBlbnRyaWVzIHRoYXQgd2UgZG8gYSBsaW5lYXIgc2VhcmNoIHRocm91Z2ggdG8gZmluZCBhbiBhY3R1YWxcclxuICAgICAgICAgKiBtYXRjaC4gTm90ZSB0aGF0IGNvbGxpc2lvbnMgc2hvdWxkIGJlIHJhcmUsIHNvIHdlIHN0aWxsIGV4cGVjdCBuZWFyXHJcbiAgICAgICAgICogY29uc3RhbnQgdGltZSBsb29rdXBzIGluIHByYWN0aWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5uZXIgPSB7fTtcclxuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbnRyaWVzIHN0b3JlZCBpbiB0aGUgbWFwICovXHJcbiAgICAgICAgdGhpcy5pbm5lclNpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqIEdldCBhIHZhbHVlIGZvciB0aGlzIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LiAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgW290aGVyS2V5LCB2YWx1ZV0gb2YgbWF0Y2hlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihvdGhlcktleSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKiBQdXQgdGhpcyBrZXkgYW5kIHZhbHVlIGluIHRoZSBtYXAuICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJbaWRdID0gW1trZXksIHZhbHVlXV07XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJTaXplKys7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdXBkYXRpbmcgYW4gZXhpc3RpbmcgZW50cnkgYW5kIGRvZXMgbm90IGluY3JlYXNlIGBpbm5lclNpemVgLlxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1tpXSA9IFtrZXksIHZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRjaGVzLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICB0aGlzLmlubmVyU2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhpcyBrZXkgZnJvbSB0aGUgbWFwLiBSZXR1cm5zIGEgYm9vbGVhbiBpZiBhbnl0aGluZyB3YXMgZGVsZXRlZC5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lclNpemUtLTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICBmb3JFYWNoKHRoaXMuaW5uZXIsIChfLCBlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGZuKGssIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaW5uZXIpO1xyXG4gICAgfVxyXG4gICAgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclNpemU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRU1QVFlfTVVUQUJMRV9ET0NVTUVOVF9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG5mdW5jdGlvbiBtdXRhYmxlRG9jdW1lbnRNYXAoKSB7XHJcbiAgICByZXR1cm4gRU1QVFlfTVVUQUJMRV9ET0NVTUVOVF9NQVA7XHJcbn1cclxuY29uc3QgRU1QVFlfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gZG9jdW1lbnRNYXAoLi4uZG9jcykge1xyXG4gICAgbGV0IG1hcCA9IEVNUFRZX0RPQ1VNRU5UX01BUDtcclxuICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcclxuICAgICAgICBtYXAgPSBtYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwO1xyXG59XHJcbmZ1bmN0aW9uIG5ld092ZXJsYXllZERvY3VtZW50TWFwKCkge1xyXG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XHJcbn1cclxuZnVuY3Rpb24gY29udmVydE92ZXJsYXllZERvY3VtZW50TWFwVG9Eb2N1bWVudE1hcChjb2xsZWN0aW9uKSB7XHJcbiAgICBsZXQgZG9jdW1lbnRzID0gRU1QVFlfRE9DVU1FTlRfTUFQO1xyXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKChrLCB2KSA9PiAoZG9jdW1lbnRzID0gZG9jdW1lbnRzLmluc2VydChrLCB2Lm92ZXJsYXllZERvY3VtZW50KSkpO1xyXG4gICAgcmV0dXJuIGRvY3VtZW50cztcclxufVxyXG5mdW5jdGlvbiBuZXdPdmVybGF5TWFwKCkge1xyXG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XHJcbn1cclxuZnVuY3Rpb24gbmV3TXV0YXRpb25NYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3RG9jdW1lbnRLZXlNYXAoKTtcclxufVxyXG5mdW5jdGlvbiBuZXdEb2N1bWVudEtleU1hcCgpIHtcclxuICAgIHJldHVybiBuZXcgT2JqZWN0TWFwKGtleSA9PiBrZXkudG9TdHJpbmcoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XHJcbn1cclxuY29uc3QgRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG5mdW5jdGlvbiBkb2N1bWVudFZlcnNpb25NYXAoKSB7XHJcbiAgICByZXR1cm4gRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVA7XHJcbn1cclxuY29uc3QgRU1QVFlfRE9DVU1FTlRfS0VZX1NFVCA9IG5ldyBTb3J0ZWRTZXQoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbmZ1bmN0aW9uIGRvY3VtZW50S2V5U2V0KC4uLmtleXMpIHtcclxuICAgIGxldCBzZXQgPSBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUO1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIHNldCA9IHNldC5hZGQoa2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXQ7XHJcbn1cclxuY29uc3QgRU1QVFlfVEFSR0VUX0lEX1NFVCA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbmZ1bmN0aW9uIHRhcmdldElkU2V0KCkge1xyXG4gICAgcmV0dXJuIEVNUFRZX1RBUkdFVF9JRF9TRVQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRG91YmxlVmFsdWUgZm9yIGB2YWx1ZWAgdGhhdCBpcyBlbmNvZGVkIGJhc2VkIHRoZSBzZXJpYWxpemVyJ3NcclxuICogYHVzZVByb3RvM0pzb25gIHNldHRpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RvdWJsZShzZXJpYWxpemVyLCB2YWx1ZSkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICdOYU4nIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ0luZmluaXR5JyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnLUluZmluaXR5JyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkgPyAnLTAnIDogdmFsdWUgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBJbnRlZ2VyVmFsdWUgZm9yIGB2YWx1ZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB7IGludGVnZXJWYWx1ZTogJycgKyB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXHJcbiAqIG90aGVyd2lzZSBhIERvdWJsZVZhbHVlIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9OdW1iZXIoc2VyaWFsaXplciwgdmFsdWUpIHtcclxuICAgIHJldHVybiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSA/IHRvSW50ZWdlcih2YWx1ZSkgOiB0b0RvdWJsZShzZXJpYWxpemVyLCB2YWx1ZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovXHJcbmNsYXNzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc3RydWN0dXJhbCB0eXBlIG9mIGBUcmFuc2Zvcm1PcGVyYXRpb25gIGlzIHVuaXF1ZS5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy81NDUxXHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHJlc3VsdCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgcHJldmlvdXNWYWx1ZWAsXHJcbiAqIG9wdGlvbmFsbHkgdXNpbmcgdGhlIHByb3ZpZGVkIGxvY2FsV3JpdGVUaW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSB7XHJcbiAgICBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZlclRpbWVzdGFtcCQxKGxvY2FsV3JpdGVUaW1lLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBmaW5hbCB0cmFuc2Zvcm0gcmVzdWx0IGFmdGVyIHRoZSB0cmFuc2Zvcm0gaGFzIGJlZW4gYWNrbm93bGVkZ2VkXHJcbiAqIGJ5IHRoZSBzZXJ2ZXIsIHBvdGVudGlhbGx5IHVzaW5nIHRoZSBzZXJ2ZXItcHJvdmlkZWQgdHJhbnNmb3JtUmVzdWx0LlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgdHJhbnNmb3JtUmVzdWx0KSB7XHJcbiAgICAvLyBUaGUgc2VydmVyIGp1c3Qgc2VuZHMgbnVsbCBhcyB0aGUgdHJhbnNmb3JtIHJlc3VsdCBmb3IgYXJyYXkgb3BlcmF0aW9ucyxcclxuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsY3VsYXRlIGEgcmVzdWx0IHRoZSBzYW1lIGFzIHdlIGRvIGZvciBsb2NhbFxyXG4gICAgLy8gYXBwbGljYXRpb25zLlxyXG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBJZiB0aGlzIHRyYW5zZm9ybSBvcGVyYXRpb24gaXMgbm90IGlkZW1wb3RlbnQsIHJldHVybnMgdGhlIGJhc2UgdmFsdWUgdG9cclxuICogcGVyc2lzdCBmb3IgdGhpcyB0cmFuc2Zvcm0uIElmIGEgYmFzZSB2YWx1ZSBpcyByZXR1cm5lZCwgdGhlIHRyYW5zZm9ybVxyXG4gKiBvcGVyYXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhpcyBiYXNlIHZhbHVlLCBldmVuIGlmIGRvY3VtZW50IGhhc1xyXG4gKiBhbHJlYWR5IGJlZW4gdXBkYXRlZC5cclxuICpcclxuICogQmFzZSB2YWx1ZXMgcHJvdmlkZSBjb25zaXN0ZW50IGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZFxyXG4gKiBhbGxvdyB1cyB0byByZXR1cm4gdGhlIHNhbWUgbGF0ZW5jeS1jb21wZW5zYXRlZCB2YWx1ZSBldmVuIGlmIHRoZSBiYWNrZW5kXHJcbiAqIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlIHRyYW5zZm9ybSBvcGVyYXRpb24uIFRoZSBiYXNlIHZhbHVlIGlzIG51bGwgZm9yXHJcbiAqIGlkZW1wb3RlbnQgdHJhbnNmb3JtcywgYXMgdGhleSBjYW4gYmUgcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzXHJcbiAqIGFscmVhZHkgYXBwbGllZCB0aGVtLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBhIGJhc2UgdmFsdWUgdG8gc3RvcmUgYWxvbmcgd2l0aCB0aGUgbXV0YXRpb24sIG9yIG51bGwgZm9yXHJcbiAqIGlkZW1wb3RlbnQgdHJhbnNmb3Jtcy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBpc051bWJlcihwcmV2aW91c1ZhbHVlKSA/IHByZXZpb3VzVmFsdWUgOiB7IGludGVnZXJWYWx1ZTogMCB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24gJiZcclxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5lbGVtZW50cywgcmlnaHQuZWxlbWVudHMsIHZhbHVlRXF1YWxzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbiAmJlxyXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5lbGVtZW50cywgcmlnaHQuZWxlbWVudHMsIHZhbHVlRXF1YWxzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uICYmXHJcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlRXF1YWxzKGxlZnQub3BlcmFuZCwgcmlnaHQub3BlcmFuZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGxlZnQgaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0gJiZcclxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSk7XHJcbn1cclxuLyoqIFRyYW5zZm9ybXMgYSB2YWx1ZSBpbnRvIGEgc2VydmVyLWdlbmVyYXRlZCB0aW1lc3RhbXAuICovXHJcbmNsYXNzIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbn1cclxuLyoqIFRyYW5zZm9ybXMgYW4gYXJyYXkgdmFsdWUgdmlhIGEgdW5pb24gb3BlcmF0aW9uLiAqL1xyXG5jbGFzcyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XHJcbiAgICBmb3IgKGNvbnN0IHRvVW5pb24gb2YgdHJhbnNmb3JtLmVsZW1lbnRzKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZXMuc29tZShlbGVtZW50ID0+IHZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvVW5pb24pKSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0b1VuaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XHJcbn1cclxuLyoqIFRyYW5zZm9ybXMgYW4gYXJyYXkgdmFsdWUgdmlhIGEgcmVtb3ZlIG9wZXJhdGlvbi4gKi9cclxuY2xhc3MgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xyXG4gICAgbGV0IHZhbHVlcyA9IGNvZXJjZWRGaWVsZFZhbHVlc0FycmF5KHByZXZpb3VzVmFsdWUpO1xyXG4gICAgZm9yIChjb25zdCB0b1JlbW92ZSBvZiB0cmFuc2Zvcm0uZWxlbWVudHMpIHtcclxuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKGVsZW1lbnQgPT4gIXZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvUmVtb3ZlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGJhY2tlbmQgc2VtYW50aWNzIGZvciBsb2NhbGx5IGNvbXB1dGVkIE5VTUVSSUNfQUREIChpbmNyZW1lbnQpXHJcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcclxuICogYmFja2VuZCBkb2VzIG5vdCBjYXAgaW50ZWdlciB2YWx1ZXMgYXQgMl42My4gSW5zdGVhZCwgSmF2YVNjcmlwdCBudW1iZXJcclxuICogYXJpdGhtZXRpYyBpcyB1c2VkIGFuZCBwcmVjaXNpb24gbG9zcyBjYW4gb2NjdXIgZm9yIHZhbHVlcyBncmVhdGVyIHRoYW4gMl41My5cclxuICovXHJcbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgb3BlcmFuZCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5TnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBTaW5jZSBKYXZhU2NyaXB0J3MgaW50ZWdlciBhcml0aG1ldGljIGlzIGxpbWl0ZWQgdG8gNTMgYml0XHJcbiAgICAvLyBwcmVjaXNpb24gYW5kIHJlc29sdmVzIG92ZXJmbG93cyBieSByZWR1Y2luZyBwcmVjaXNpb24sIHdlIGRvIG5vdFxyXG4gICAgLy8gbWFudWFsbHkgY2FwIG92ZXJmbG93cyBhdCAyXjYzLlxyXG4gICAgY29uc3QgYmFzZVZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZSh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgY29uc3Qgc3VtID0gYXNOdW1iZXIoYmFzZVZhbHVlKSArIGFzTnVtYmVyKHRyYW5zZm9ybS5vcGVyYW5kKTtcclxuICAgIGlmIChpc0ludGVnZXIoYmFzZVZhbHVlKSAmJiBpc0ludGVnZXIodHJhbnNmb3JtLm9wZXJhbmQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvSW50ZWdlcihzdW0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRvRG91YmxlKHRyYW5zZm9ybS5zZXJpYWxpemVyLCBzdW0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplTnVtYmVyKHZhbHVlLmludGVnZXJWYWx1ZSB8fCB2YWx1ZS5kb3VibGVWYWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlc1xyXG4gICAgICAgID8gdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMuc2xpY2UoKVxyXG4gICAgICAgIDogW107XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIEEgZmllbGQgcGF0aCBhbmQgdGhlIFRyYW5zZm9ybU9wZXJhdGlvbiB0byBwZXJmb3JtIHVwb24gaXQuICovXHJcbmNsYXNzIEZpZWxkVHJhbnNmb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmllbGRUcmFuc2Zvcm1FcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiAobGVmdC5maWVsZC5pc0VxdWFsKHJpZ2h0LmZpZWxkKSAmJlxyXG4gICAgICAgIHRyYW5zZm9ybU9wZXJhdGlvbkVxdWFscyhsZWZ0LnRyYW5zZm9ybSwgcmlnaHQudHJhbnNmb3JtKSk7XHJcbn1cclxuZnVuY3Rpb24gZmllbGRUcmFuc2Zvcm1zQXJlRXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIChsLCByKSA9PiBmaWVsZFRyYW5zZm9ybUVxdWFscyhsLCByKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqIFRoZSByZXN1bHQgb2Ygc3VjY2Vzc2Z1bGx5IGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gdGhlIGJhY2tlbmQuICovXHJcbmNsYXNzIE11dGF0aW9uUmVzdWx0IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmVyc2lvbiBhdCB3aGljaCB0aGUgbXV0YXRpb24gd2FzIGNvbW1pdHRlZDpcclxuICAgICAqXHJcbiAgICAgKiAtIEZvciBtb3N0IG9wZXJhdGlvbnMsIHRoaXMgaXMgdGhlIHVwZGF0ZVRpbWUgaW4gdGhlIFdyaXRlUmVzdWx0LlxyXG4gICAgICogLSBGb3IgZGVsZXRlcywgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgKGJlY2F1c2UgZGVsZXRlcyBhcmVcclxuICAgICAqICAgbm90IHN0b3JlZCBhbmQgaGF2ZSBubyB1cGRhdGVUaW1lKS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2UgdmVyc2lvbnMgY2FuIGJlIGRpZmZlcmVudDogTm8tb3Agd3JpdGVzIHdpbGwgbm90IGNoYW5nZVxyXG4gICAgICogdGhlIHVwZGF0ZVRpbWUgZXZlbiB0aG91Z2ggdGhlIGNvbW1pdFRpbWUgYWR2YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHZlcnNpb24sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGZpZWxkcyByZXR1cm5lZCBmcm9tIHRoZSBiYWNrZW5kIGFmdGVyIGEgbXV0YXRpb25cclxuICAgICAqIGNvbnRhaW5pbmcgZmllbGQgdHJhbnNmb3JtcyBoYXMgYmVlbiBjb21taXR0ZWQuIENvbnRhaW5zIG9uZSBGaWVsZFZhbHVlXHJcbiAgICAgKiBmb3IgZWFjaCBGaWVsZFRyYW5zZm9ybSB0aGF0IHdhcyBpbiB0aGUgbXV0YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogV2lsbCBiZSBlbXB0eSBpZiB0aGUgbXV0YXRpb24gZGlkIG5vdCBjb250YWluIGFueSBmaWVsZCB0cmFuc2Zvcm1zLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2Zvcm1SZXN1bHRzKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdHMgPSB0cmFuc2Zvcm1SZXN1bHRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgcHJlY29uZGl0aW9uIGZvciBhIG11dGF0aW9uLiBUaGlzIGZvbGxvd3MgdGhlIG1vZGVsIHRoYXQgdGhlXHJcbiAqIGJhY2tlbmQgYWNjZXB0cyB3aXRoIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gZXhwbGljaXQgXCJlbXB0eVwiIHByZWNvbmRpdGlvblxyXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxyXG4gKi9cclxuY2xhc3MgUHJlY29uZGl0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZVRpbWUsIGV4aXN0cykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHVwZGF0ZVRpbWU7XHJcbiAgICAgICAgdGhpcy5leGlzdHMgPSBleGlzdHM7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBlbXB0eSBQcmVjb25kaXRpb24uICovXHJcbiAgICBzdGF0aWMgbm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbigpO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgUHJlY29uZGl0aW9uIHdpdGggYW4gZXhpc3RzIGZsYWcuICovXHJcbiAgICBzdGF0aWMgZXhpc3RzKGV4aXN0cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlY29uZGl0aW9uKHVuZGVmaW5lZCwgZXhpc3RzKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovXHJcbiAgICBzdGF0aWMgdXBkYXRlVGltZSh2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24odmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoaXMgUHJlY29uZGl0aW9uIGlzIGVtcHR5LiAqL1xyXG4gICAgZ2V0IGlzTm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGlzdHMgPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXhpc3RzID09PSBvdGhlci5leGlzdHMgJiZcclxuICAgICAgICAgICAgKHRoaXMudXBkYXRlVGltZVxyXG4gICAgICAgICAgICAgICAgPyAhIW90aGVyLnVwZGF0ZVRpbWUgJiYgdGhpcy51cGRhdGVUaW1lLmlzRXF1YWwob3RoZXIudXBkYXRlVGltZSlcclxuICAgICAgICAgICAgICAgIDogIW90aGVyLnVwZGF0ZVRpbWUpKTtcclxuICAgIH1cclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwcmVjb25kaXRpb25zIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXHJcbmZ1bmN0aW9uIHByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChwcmVjb25kaXRpb24sIGRvY3VtZW50KSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcclxuICAgICAgICAgICAgZG9jdW1lbnQudmVyc2lvbi5pc0VxdWFsKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gcHJlY29uZGl0aW9uLmV4aXN0cyA9PT0gZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiBkZXNjcmliZXMgYSBzZWxmLWNvbnRhaW5lZCBjaGFuZ2UgdG8gYSBkb2N1bWVudC4gTXV0YXRpb25zIGNhblxyXG4gKiBjcmVhdGUsIHJlcGxhY2UsIGRlbGV0ZSwgYW5kIHVwZGF0ZSBzdWJzZXRzIG9mIGRvY3VtZW50cy5cclxuICpcclxuICogTXV0YXRpb25zIG5vdCBvbmx5IGFjdCBvbiB0aGUgdmFsdWUgb2YgdGhlIGRvY3VtZW50IGJ1dCBhbHNvIGl0cyB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBGb3IgbG9jYWwgbXV0YXRpb25zIChtdXRhdGlvbnMgdGhhdCBoYXZlbid0IGJlZW4gY29tbWl0dGVkIHlldCksIHdlIHByZXNlcnZlXHJcbiAqIHRoZSBleGlzdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gRm9yIERlbGV0ZSBtdXRhdGlvbnMsIHdlXHJcbiAqIHJlc2V0IHRoZSB2ZXJzaW9uIHRvIDAuXHJcbiAqXHJcbiAqIEhlcmUncyB0aGUgZXhwZWN0ZWQgdHJhbnNpdGlvbiB0YWJsZS5cclxuICpcclxuICogTVVUQVRJT04gICAgICAgICAgIEFQUExJRUQgVE8gICAgICAgICAgICBSRVNVTFRTIElOXHJcbiAqXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgRG9jdW1lbnQodjApXHJcbiAqIFNldE11dGF0aW9uICAgICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgRG9jdW1lbnQodjApXHJcbiAqIFBhdGNoTXV0YXRpb24gICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXHJcbiAqIFBhdGNoTXV0YXRpb24gICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MylcclxuICogUGF0Y2hNdXRhdGlvbiAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBVbmtub3duRG9jdW1lbnQodjMpXHJcbiAqIERlbGV0ZU11dGF0aW9uICAgICBEb2N1bWVudCh2MykgICAgICAgICAgTm9Eb2N1bWVudCh2MClcclxuICogRGVsZXRlTXV0YXRpb24gICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBOb0RvY3VtZW50KHYwKVxyXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIE5vRG9jdW1lbnQodjApXHJcbiAqXHJcbiAqIEZvciBhY2tub3dsZWRnZWQgbXV0YXRpb25zLCB3ZSB1c2UgdGhlIHVwZGF0ZVRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgYXNcclxuICogdGhlIHJlc3VsdGluZyB2ZXJzaW9uIGZvciBTZXQgYW5kIFBhdGNoIG11dGF0aW9ucy4gQXMgZGVsZXRlcyBoYXZlIG5vXHJcbiAqIGV4cGxpY2l0IHVwZGF0ZSB0aW1lLCB3ZSB1c2UgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgZm9yXHJcbiAqIERlbGV0ZSBtdXRhdGlvbnMuXHJcbiAqXHJcbiAqIElmIGEgbXV0YXRpb24gaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kIGJ1dCBmYWlscyB0aGUgcHJlY29uZGl0aW9uIGNoZWNrXHJcbiAqIGxvY2FsbHksIHdlIHRyYW5zaXRpb24gdG8gYW4gYFVua25vd25Eb2N1bWVudGAgYW5kIHJlbHkgb24gV2F0Y2ggdG8gc2VuZCB1c1xyXG4gKiB0aGUgdXBkYXRlZCB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBGaWVsZCB0cmFuc2Zvcm1zIGFyZSB1c2VkIG9ubHkgd2l0aCBQYXRjaCBhbmQgU2V0IE11dGF0aW9ucy4gV2UgdXNlIHRoZVxyXG4gKiBgdXBkYXRlVHJhbnNmb3Jtc2AgbWVzc2FnZSB0byBzdG9yZSB0cmFuc2Zvcm1zLCByYXRoZXIgdGhhbiB0aGUgYHRyYW5zZm9ybXNgc1xyXG4gKiBtZXNzYWdlcy5cclxuICpcclxuICogIyMgU3ViY2xhc3NpbmcgTm90ZXNcclxuICpcclxuICogRXZlcnkgdHlwZSBvZiBtdXRhdGlvbiBuZWVkcyB0byBpbXBsZW1lbnQgaXRzIG93biBhcHBseVRvUmVtb3RlRG9jdW1lbnQoKSBhbmRcclxuICogYXBwbHlUb0xvY2FsVmlldygpIHRvIGltcGxlbWVudCB0aGUgYWN0dWFsIGJlaGF2aW9yIG9mIGFwcGx5aW5nIHRoZSBtdXRhdGlvblxyXG4gKiB0byBzb21lIHNvdXJjZSBkb2N1bWVudCAoc2VlIGBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudCgpYCBmb3IgYW5cclxuICogZXhhbXBsZSkuXHJcbiAqL1xyXG5jbGFzcyBNdXRhdGlvbiB7XHJcbn1cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBtZXRob2QgdG8gY2FsY3VsYXRlIGEgYE11dGF0aW9uYCByZXByZXNlbnRpbmcgdGhlIG92ZXJsYXkgZnJvbSB0aGVcclxuICogZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50LCBhbmQgYSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgdGhlIGZpZWxkcyB0aGF0XHJcbiAqIGFyZSBtdXRhdGVkIGJ5IHRoZSBsb2NhbCBtdXRhdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVPdmVybGF5TXV0YXRpb24oZG9jLCBtYXNrKSB7XHJcbiAgICBpZiAoIWRvYy5oYXNMb2NhbE11dGF0aW9ucyB8fCAobWFzayAmJiBtYXNrLmZpZWxkcy5sZW5ndGggPT09IDApKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBtYXNrIGlzIG51bGwgd2hlbiBzZXRzIG9yIGRlbGV0ZXMgYXJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAgICBpZiAobWFzayA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWxldGVNdXRhdGlvbihkb2Mua2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oZG9jLmtleSwgZG9jLmRhdGEsIFByZWNvbmRpdGlvbi5ub25lKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGE7XHJcbiAgICAgICAgY29uc3QgcGF0Y2hWYWx1ZSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICAgICAgbGV0IG1hc2tTZXQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgbWFzay5maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKCFtYXNrU2V0LmhhcyhwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZG9jVmFsdWUuZmllbGQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZGVsZXRpbmcgYSBuZXN0ZWQgZmllbGQsIHdlIHRha2UgdGhlIGltbWVkaWF0ZSBwYXJlbnQgYXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBtYXNrIHVzZWQgdG8gY29uc3RydWN0IHRoZSByZXN1bHRpbmcgbXV0YXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBKdXN0aWZpY2F0aW9uOiBOZXN0ZWQgZmllbGRzIGNhbiBjcmVhdGUgcGFyZW50IGZpZWxkcyBpbXBsaWNpdGx5LiBJZlxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBhIGxlYWYgZW50cnkgaXMgZGVsZXRlZCBpbiBsYXRlciBtdXRhdGlvbnMsIHRoZSBwYXJlbnQgZmllbGRcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzdGlsbCByZW1haW4sIGJ1dCB3ZSBtYXkgaGF2ZSBsb3N0IHRoaXMgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBtdXRhdGlvbiAoZm9vLmJhciAxKSwgdGhlbiBtdXRhdGlvbiAoZm9vLmJhciBkZWxldGUoKSkuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxlYXZlcyB0aGUgZmluYWwgcmVzdWx0IChmb28sIHt9KS4gRGVzcGl0ZSB0aGUgZmFjdCB0aGF0IGBkb2NgXHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgdGhlIGNvcnJlY3QgcmVzdWx0LCBgZm9vYCBpcyBub3QgaW4gYG1hc2tgLCBhbmQgdGhlIHJlc3VsdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gbXV0YXRpb24gd291bGQgbWlzcyBgZm9vYC5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkb2NWYWx1ZS5maWVsZChwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoVmFsdWUuZGVsZXRlKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWYWx1ZS5zZXQocGF0aCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFza1NldCA9IG1hc2tTZXQuYWRkKHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihkb2Mua2V5LCBwYXRjaFZhbHVlLCBuZXcgRmllbGRNYXNrKG1hc2tTZXQudG9BcnJheSgpKSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmcgYVxyXG4gKiBuZXcgcmVtb3RlIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgc3RhdGVcclxuICogKGUuZy4gaXQgaXMgaW52YWxpZCBvciBvdXRkYXRlZCksIHRoZSBkb2N1bWVudCB0eXBlIG1heSB0cmFuc2l0aW9uIHRvXHJcbiAqIHVua25vd24uXHJcbiAqXHJcbiAqIEBwYXJhbSBtdXRhdGlvbiAtIFRoZSBtdXRhdGlvbiB0byBhcHBseS5cclxuICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIG11dGF0ZS4gVGhlIGlucHV0IGRvY3VtZW50IGNhbiBiZSBhblxyXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxyXG4gKiAgICAgb2YgdGhlIGRvY3VtZW50LlxyXG4gKiBAcGFyYW0gbXV0YXRpb25SZXN1bHQgLSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBtdXRhdGlvbiBmcm9tIHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gbXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xyXG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcclxuICAgICAgICBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xyXG4gICAgICAgIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGlzIG11dGF0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbXB1dGluZ1xyXG4gKiB0aGUgbmV3IGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gSWYgdGhlIGlucHV0IGRvY3VtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlXHJcbiAqIGV4cGVjdGVkIHN0YXRlLCB0aGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXHJcbiAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBtdXRhdGUuIFRoZSBpbnB1dCBkb2N1bWVudCBjYW4gYmUgYW5cclxuICogICAgIGludmFsaWQgZG9jdW1lbnQgaWYgdGhlIGNsaWVudCBoYXMgbm8ga25vd2xlZGdlIG9mIHRoZSBwcmUtbXV0YXRpb24gc3RhdGVcclxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cclxuICogQHBhcmFtIHByZXZpb3VzTWFzayAtIFRoZSBmaWVsZHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBiZWZvcmUgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cclxuICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gQSB0aW1lc3RhbXAgaW5kaWNhdGluZyB0aGUgbG9jYWwgd3JpdGUgdGltZSBvZiB0aGVcclxuICogICAgIGJhdGNoIHRoaXMgbXV0YXRpb24gaXMgYSBwYXJ0IG9mLlxyXG4gKiBAcmV0dXJucyBBIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyB0aGUgZmllbGRzIHRoYXQgYXJlIGNoYW5nZWQgYnkgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpIHtcclxuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGNoTXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVsZXRlTXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSWYgdGhpcyBtdXRhdGlvbiBpcyBub3QgaWRlbXBvdGVudCwgcmV0dXJucyB0aGUgYmFzZSB2YWx1ZSB0byBwZXJzaXN0IHdpdGhcclxuICogdGhpcyBtdXRhdGlvbi4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgbXV0YXRpb24gaXMgYWx3YXlzIGFwcGxpZWRcclxuICogdG8gdGhpcyBiYXNlIHZhbHVlLCBldmVuIGlmIGRvY3VtZW50IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZC5cclxuICpcclxuICogVGhlIGJhc2UgdmFsdWUgaXMgYSBzcGFyc2Ugb2JqZWN0IHRoYXQgY29uc2lzdHMgb2Ygb25seSB0aGUgZG9jdW1lbnRcclxuICogZmllbGRzIGZvciB3aGljaCB0aGlzIG11dGF0aW9uIGNvbnRhaW5zIGEgbm9uLWlkZW1wb3RlbnQgdHJhbnNmb3JtYXRpb25cclxuICogKGUuZy4gYSBudW1lcmljIGluY3JlbWVudCkuIFRoZSBwcm92aWRlZCB2YWx1ZSBndWFyYW50ZWVzIGNvbnNpc3RlbnRcclxuICogYmVoYXZpb3IgZm9yIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYW5kIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZVxyXG4gKiBsYXRlbmN5LWNvbXBlbnNhdGVkIHZhbHVlIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzIGFscmVhZHkgYXBwbGllZCB0aGVcclxuICogbXV0YXRpb24uIFRoZSBiYXNlIHZhbHVlIGlzIG51bGwgZm9yIGlkZW1wb3RlbnQgbXV0YXRpb25zLCBhcyB0aGV5IGNhbiBiZVxyXG4gKiByZS1wbGF5ZWQgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZW0uXHJcbiAqXHJcbiAqIEByZXR1cm5zIGEgYmFzZSB2YWx1ZSB0byBzdG9yZSBhbG9uZyB3aXRoIHRoZSBtdXRhdGlvbiwgb3IgbnVsbCBmb3JcclxuICogaWRlbXBvdGVudCBtdXRhdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbkV4dHJhY3RCYXNlVmFsdWUobXV0YXRpb24sIGRvY3VtZW50KSB7XHJcbiAgICBsZXQgYmFzZU9iamVjdCA9IG51bGw7XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkVHJhbnNmb3JtIG9mIG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBkb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkVHJhbnNmb3JtLmZpZWxkKTtcclxuICAgICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybSwgZXhpc3RpbmdWYWx1ZSB8fCBudWxsKTtcclxuICAgICAgICBpZiAoY29lcmNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2VPYmplY3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VPYmplY3QgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhc2VPYmplY3Quc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBjb2VyY2VkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlT2JqZWN0ID8gYmFzZU9iamVjdCA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gbXV0YXRpb25FcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWxlZnQua2V5LmlzRXF1YWwocmlnaHQua2V5KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghbGVmdC5wcmVjb25kaXRpb24uaXNFcXVhbChyaWdodC5wcmVjb25kaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFmaWVsZFRyYW5zZm9ybXNBcmVFcXVhbChsZWZ0LmZpZWxkVHJhbnNmb3JtcywgcmlnaHQuZmllbGRUcmFuc2Zvcm1zKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLykge1xyXG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlLmlzRXF1YWwocmlnaHQudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMSAvKiBNdXRhdGlvblR5cGUuUGF0Y2ggKi8pIHtcclxuICAgICAgICByZXR1cm4gKGxlZnQuZGF0YS5pc0VxdWFsKHJpZ2h0LmRhdGEpICYmXHJcbiAgICAgICAgICAgIGxlZnQuZmllbGRNYXNrLmlzRXF1YWwocmlnaHQuZmllbGRNYXNrKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IGNyZWF0ZXMgb3IgcmVwbGFjZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcclxuICogb2JqZWN0IHZhbHVlIGNvbnRlbnRzLlxyXG4gKi9cclxuY2xhc3MgU2V0TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3JtcyA9IFtdKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICAgICAgdGhpcy50eXBlID0gMCAvKiBNdXRhdGlvblR5cGUuU2V0ICovO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRNYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcclxuICAgIC8vIFVubGlrZSBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYVxyXG4gICAgLy8gcmVtb3RlIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uXHJcbiAgICAvLyBtdXN0IGhhdmUgaGVsZC5cclxuICAgIGNvbnN0IG5ld0RhdGEgPSBtdXRhdGlvbi52YWx1ZS5jbG9uZSgpO1xyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcclxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xyXG4gICAgaWYgKCFwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcclxuICAgICAgICAvLyBUaGUgbXV0YXRpb24gZmFpbGVkIHRvIGFwcGx5IChlLmcuIGEgZG9jdW1lbnQgSUQgY3JlYXRlZCB3aXRoIGFkZCgpXHJcbiAgICAgICAgLy8gY2F1c2VkIGEgbmFtZSBjb2xsaXNpb24pLlxyXG4gICAgICAgIHJldHVybiBwcmV2aW91c01hc2s7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdEYXRhID0gbXV0YXRpb24udmFsdWUuY2xvbmUoKTtcclxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBsb2NhbFRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgZG9jdW1lbnQpO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KGRvY3VtZW50LnZlcnNpb24sIG5ld0RhdGEpXHJcbiAgICAgICAgLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XHJcbiAgICByZXR1cm4gbnVsbDsgLy8gU2V0TXV0YXRpb24gb3ZlcndyaXRlcyBhbGwgZmllbGRzLlxyXG59XHJcbi8qKlxyXG4gKiBBIG11dGF0aW9uIHRoYXQgbW9kaWZpZXMgZmllbGRzIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXHJcbiAqIGdpdmVuIHZhbHVlcy4gVGhlIHZhbHVlcyBhcmUgYXBwbGllZCB0aHJvdWdoIGEgZmllbGQgbWFzazpcclxuICpcclxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIGJvdGggdGhlIG1hc2sgYW5kIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXHJcbiAqICAgIGlzIHVwZGF0ZWQuXHJcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiBuZWl0aGVyIHRoZSBtYXNrIG5vciB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiAgICBmaWVsZCBpcyB1bm1vZGlmaWVkLlxyXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgaW4gdGhlIG1hc2sgYnV0IG5vdCBpbiB0aGUgdmFsdWVzLCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZFxyXG4gKiAgICBpcyBkZWxldGVkLlxyXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgbm90IGluIHRoZSBtYXNrIGJ1dCBpcyBpbiB0aGUgdmFsdWVzLCB0aGUgdmFsdWVzIG1hcCBpc1xyXG4gKiAgICBpZ25vcmVkLlxyXG4gKi9cclxuY2xhc3MgUGF0Y2hNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgZGF0YSwgZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3JtcyA9IFtdKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xyXG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDEgLyogTXV0YXRpb25UeXBlLlBhdGNoICovO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRNYXNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkTWFzaztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcclxuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlIG11dGF0aW9uIHdhcyBub3QgcmVqZWN0ZWQsIHdlIGtub3cgdGhhdCB0aGUgcHJlY29uZGl0aW9uXHJcbiAgICAgICAgLy8gbWF0Y2hlZCBvbiB0aGUgYmFja2VuZC4gV2UgdGhlcmVmb3JlIG11c3Qgbm90IGhhdmUgdGhlIGV4cGVjdGVkIHZlcnNpb25cclxuICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgaW4gb3VyIGNhY2hlIGFuZCBjb252ZXJ0IHRvIGFuIFVua25vd25Eb2N1bWVudCB3aXRoIGFcclxuICAgICAgICAvLyBrbm93biB1cGRhdGVUaW1lLlxyXG4gICAgICAgIGRvY3VtZW50LmNvbnZlcnRUb1Vua25vd25Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpIHtcclxuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTWFzaztcclxuICAgIH1cclxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBsb2NhbFRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgZG9jdW1lbnQpO1xyXG4gICAgY29uc3QgbmV3RGF0YSA9IGRvY3VtZW50LmRhdGE7XHJcbiAgICBuZXdEYXRhLnNldEFsbChnZXRQYXRjaChtdXRhdGlvbikpO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KGRvY3VtZW50LnZlcnNpb24sIG5ld0RhdGEpXHJcbiAgICAgICAgLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XHJcbiAgICBpZiAocHJldmlvdXNNYXNrID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldmlvdXNNYXNrXHJcbiAgICAgICAgLnVuaW9uV2l0aChtdXRhdGlvbi5maWVsZE1hc2suZmllbGRzKVxyXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdHJhbnNmb3JtLmZpZWxkKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBGaWVsZFBhdGgvVmFsdWUgbWFwIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIFBhdGNoTXV0YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXRjaChtdXRhdGlvbikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gICAgbXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XHJcbiAgICAgICAgaWYgKCFmaWVsZFBhdGguaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbXV0YXRpb24uZGF0YS5maWVsZChmaWVsZFBhdGgpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGZpZWxkUGF0aCwgbmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxyXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhIHRyYW5zZm9ybSkgZm9yIHVzZSBhZnRlciBhIG11dGF0aW9uXHJcbiAqIGNvbnRhaW5pbmcgdHJhbnNmb3JtcyBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgdGhlIHNlcnZlci5cclxuICpcclxuICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIFRoZSBmaWVsZCB0cmFuc2Zvcm1zIHRvIGFwcGx5IHRoZSByZXN1bHQgdG8uXHJcbiAqIEBwYXJhbSBtdXRhYmxlRG9jdW1lbnQgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgYXBwbHlpbmcgYWxsXHJcbiAqIHByZXZpb3VzIG11dGF0aW9ucy5cclxuICogQHBhcmFtIHNlcnZlclRyYW5zZm9ybVJlc3VsdHMgLSBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci5cclxuICogQHJldHVybnMgVGhlIHRyYW5zZm9ybSByZXN1bHRzIGxpc3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKGZpZWxkVHJhbnNmb3JtcywgbXV0YWJsZURvY3VtZW50LCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKSB7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbmV3IE1hcCgpO1xyXG4gICAgaGFyZEFzc2VydChmaWVsZFRyYW5zZm9ybXMubGVuZ3RoID09PSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3Jtc1tpXTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IG11dGFibGVEb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkVHJhbnNmb3JtLmZpZWxkKTtcclxuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgc2VydmVyVHJhbnNmb3JtUmVzdWx0c1tpXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdHM7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIFwidHJhbnNmb3JtIHJlc3VsdHNcIiAoYSB0cmFuc2Zvcm0gcmVzdWx0IGlzIGEgZmllbGQgdmFsdWVcclxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2Ugd2hlbiBhcHBseWluZyBhXHJcbiAqIHRyYW5zZm9ybSBsb2NhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gVGhlIGZpZWxkIHRyYW5zZm9ybXMgdG8gYXBwbHkgdGhlIHJlc3VsdCB0by5cclxuICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIGxvY2FsIHRpbWUgb2YgdGhlIG11dGF0aW9uICh1c2VkIHRvXHJcbiAqICAgICBnZW5lcmF0ZSBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZXMpLlxyXG4gKiBAcGFyYW0gbXV0YWJsZURvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IHRyYW5zZm9ybXMgb24uXHJcbiAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyBsaXN0LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKGZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIG11dGFibGVEb2N1bWVudCkge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAoY29uc3QgZmllbGRUcmFuc2Zvcm0gb2YgZmllbGRUcmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XHJcbiAgICAgICAgdHJhbnNmb3JtUmVzdWx0cy5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCBsb2NhbFdyaXRlVGltZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdHM7XHJcbn1cclxuLyoqIEEgbXV0YXRpb24gdGhhdCBkZWxldGVzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5LiAqL1xyXG5jbGFzcyBEZWxldGVNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE11dGF0aW9uVHlwZS5EZWxldGUgKi87XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBbXTtcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XHJcbiAgICAvLyBVbmxpa2UgYXBwbHlUb0xvY2FsVmlldywgaWYgd2UncmUgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byBhIHJlbW90ZVxyXG4gICAgLy8gZG9jdW1lbnQgdGhlIHNlcnZlciBoYXMgYWNjZXB0ZWQgdGhlIG11dGF0aW9uIHNvIHRoZSBwcmVjb25kaXRpb24gbXVzdFxyXG4gICAgLy8gaGF2ZSBoZWxkLlxyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvTm9Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKVxyXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2spIHtcclxuICAgIGlmIChwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcclxuICAgICAgICBkb2N1bWVudC5jb252ZXJ0VG9Ob0RvY3VtZW50KGRvY3VtZW50LnZlcnNpb24pLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldmlvdXNNYXNrO1xyXG59XHJcbi8qKlxyXG4gKiBBIG11dGF0aW9uIHRoYXQgdmVyaWZpZXMgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoXHJcbiAqIHRoZSBwcm92aWRlZCBwcmVjb25kaXRpb24uXHJcbiAqXHJcbiAqIFRoZSBgdmVyaWZ5YCBvcGVyYXRpb24gaXMgb25seSB1c2VkIGluIFRyYW5zYWN0aW9ucywgYW5kIHRoaXMgY2xhc3Mgc2VydmVzXHJcbiAqIHByaW1hcmlseSB0byBmYWNpbGl0YXRlIHNlcmlhbGl6YXRpb24gaW50byBwcm90b3MuXHJcbiAqL1xyXG5jbGFzcyBWZXJpZnlNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnR5cGUgPSAzIC8qIE11dGF0aW9uVHlwZS5WZXJpZnkgKi87XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBbXTtcclxuICAgIH1cclxuICAgIGdldEZpZWxkTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBiYXRjaCBvZiBtdXRhdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgYXMgb25lIHVuaXQgdG8gdGhlIGJhY2tlbmQuXHJcbiAqL1xyXG5jbGFzcyBNdXRhdGlvbkJhdGNoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgdW5pcXVlIElEIG9mIHRoaXMgbXV0YXRpb24gYmF0Y2guXHJcbiAgICAgKiBAcGFyYW0gbG9jYWxXcml0ZVRpbWUgLSBUaGUgb3JpZ2luYWwgd3JpdGUgdGltZSBvZiB0aGlzIG11dGF0aW9uLlxyXG4gICAgICogQHBhcmFtIGJhc2VNdXRhdGlvbnMgLSBNdXRhdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBwb3B1bGF0ZSB0aGUgYmFzZVxyXG4gICAgICogdmFsdWVzIHdoZW4gdGhpcyBtdXRhdGlvbiBpcyBhcHBsaWVkIGxvY2FsbHkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9jYWxseVxyXG4gICAgICogb3ZlcndyaXRlIHZhbHVlcyB0aGF0IGFyZSBwZXJzaXN0ZWQgaW4gdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZS4gQmFzZVxyXG4gICAgICogbXV0YXRpb25zIGFyZSBuZXZlciBzZW50IHRvIHRoZSBiYWNrZW5kLlxyXG4gICAgICogQHBhcmFtIG11dGF0aW9ucyAtIFRoZSB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucyBpbiB0aGlzIG11dGF0aW9uIGJhdGNoLlxyXG4gICAgICogVXNlci1wcm92aWRlZCBtdXRhdGlvbnMgYXJlIGFwcGxpZWQgYm90aCBsb2NhbGx5IGFuZCByZW1vdGVseSBvbiB0aGVcclxuICAgICAqIGJhY2tlbmQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJhdGNoSWQsIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmJhdGNoSWQgPSBiYXRjaElkO1xyXG4gICAgICAgIHRoaXMubG9jYWxXcml0ZVRpbWUgPSBsb2NhbFdyaXRlVGltZTtcclxuICAgICAgICB0aGlzLmJhc2VNdXRhdGlvbnMgPSBiYXNlTXV0YXRpb25zO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zID0gbXV0YXRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGFsbCB0aGUgbXV0YXRpb25zIGluIHRoaXMgTXV0YXRpb25CYXRjaCB0byB0aGUgc3BlY2lmaWVkIGRvY3VtZW50XHJcbiAgICAgKiB0byBjb21wdXRlIHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGRvY3VtZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cclxuICAgICAqIEBwYXJhbSBiYXRjaFJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIE11dGF0aW9uQmF0Y2ggdG8gdGhlXHJcbiAgICAgKiBiYWNrZW5kLlxyXG4gICAgICovXHJcbiAgICBhcHBseVRvUmVtb3RlRG9jdW1lbnQoZG9jdW1lbnQsIGJhdGNoUmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHRzID0gYmF0Y2hSZXN1bHQubXV0YXRpb25SZXN1bHRzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb24gPSB0aGlzLm11dGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gbXV0YXRpb25SZXN1bHRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQgZ2l2ZW4gYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpc1xyXG4gICAgICogYmF0Y2guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cclxuICAgICAqIEBwYXJhbSBtdXRhdGVkRmllbGRzIC0gRmllbGRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlIGFwcGx5aW5nIHRoaXMgbXV0YXRpb24gYmF0Y2guXHJcbiAgICAgKiBAcmV0dXJucyBBIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyBhbGwgdGhlIGZpZWxkcyB0aGF0IGFyZSBtdXRhdGVkLlxyXG4gICAgICovXHJcbiAgICBhcHBseVRvTG9jYWxWaWV3KGRvY3VtZW50LCBtdXRhdGVkRmllbGRzKSB7XHJcbiAgICAgICAgLy8gRmlyc3QsIGFwcGx5IHRoZSBiYXNlIHN0YXRlLiBUaGlzIGFsbG93cyB1cyB0byBhcHBseSBub24taWRlbXBvdGVudFxyXG4gICAgICAgIC8vIHRyYW5zZm9ybSBhZ2FpbnN0IGEgY29uc2lzdGVudCBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5iYXNlTXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRlZEZpZWxkcywgdGhpcy5sb2NhbFdyaXRlVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2Vjb25kLCBhcHBseSBhbGwgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMuXHJcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiB0aGlzLm11dGF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMsIHRoaXMubG9jYWxXcml0ZVRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtdXRhdGVkRmllbGRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9jYWwgdmlldyBmb3IgYWxsIHByb3ZpZGVkIGRvY3VtZW50cyBnaXZlbiB0aGUgbXV0YXRpb25zIGluXHJcbiAgICAgKiB0aGlzIGJhdGNoLiBSZXR1cm5zIGEgYERvY3VtZW50S2V5YCB0byBgTXV0YXRpb25gIG1hcCB3aGljaCBjYW4gYmUgdXNlZCB0b1xyXG4gICAgICogcmVwbGFjZSBhbGwgdGhlIG11dGF0aW9uIGFwcGxpY2F0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYXBwbHlUb0xvY2FsRG9jdW1lbnRTZXQoZG9jdW1lbnRNYXAsIGRvY3VtZW50c1dpdGhvdXRSZW1vdGVWZXJzaW9uKSB7XHJcbiAgICAgICAgLy8gVE9ETyhtcnNjaG1pZHQpOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIE8obl4yKS4gSWYgd2UgYXBwbHkgdGhlIG11dGF0aW9uc1xyXG4gICAgICAgIC8vIGRpcmVjdGx5IChhcyBkb25lIGluIGBhcHBseVRvTG9jYWxWaWV3KClgKSwgd2UgY2FuIHJlZHVjZSB0aGUgY29tcGxleGl0eVxyXG4gICAgICAgIC8vIHRvIE8obikuXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdNdXRhdGlvbk1hcCgpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXllZERvY3VtZW50ID0gZG9jdW1lbnRNYXAuZ2V0KG0ua2V5KTtcclxuICAgICAgICAgICAgLy8gVE9ETyhtdXRhYmxlZG9jdW1lbnRzKTogVGhpcyBtZXRob2Qgc2hvdWxkIHRha2UgYSBNdXRhYmxlRG9jdW1lbnRNYXBcclxuICAgICAgICAgICAgLy8gYW5kIHdlIHNob3VsZCByZW1vdmUgdGhpcyBjYXN0LlxyXG4gICAgICAgICAgICBjb25zdCBtdXRhYmxlRG9jdW1lbnQgPSBvdmVybGF5ZWREb2N1bWVudC5vdmVybGF5ZWREb2N1bWVudDtcclxuICAgICAgICAgICAgbGV0IG11dGF0ZWRGaWVsZHMgPSB0aGlzLmFwcGx5VG9Mb2NhbFZpZXcobXV0YWJsZURvY3VtZW50LCBvdmVybGF5ZWREb2N1bWVudC5tdXRhdGVkRmllbGRzKTtcclxuICAgICAgICAgICAgLy8gU2V0IG11dGF0ZWRGaWVsZHMgdG8gbnVsbCBpZiB0aGUgZG9jdW1lbnQgaXMgb25seSBmcm9tIGxvY2FsIG11dGF0aW9ucy5cclxuICAgICAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgU2V0IG9yIERlbGV0ZSBtdXRhdGlvbiwgaW5zdGVhZCBvZiB0cnlpbmcgdG8gY3JlYXRlIGFcclxuICAgICAgICAgICAgLy8gcGF0Y2ggbXV0YXRpb24gYXMgdGhlIG92ZXJsYXkuXHJcbiAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbi5oYXMobS5rZXkpXHJcbiAgICAgICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgICAgIDogbXV0YXRlZEZpZWxkcztcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihtdXRhYmxlRG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KG0ua2V5LCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW11dGFibGVEb2N1bWVudC5pc1ZhbGlkRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgbXV0YWJsZURvY3VtZW50LmNvbnZlcnRUb05vRG9jdW1lbnQoU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvdmVybGF5cztcclxuICAgIH1cclxuICAgIGtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25zLnJlZHVjZSgoa2V5cywgbSkgPT4ga2V5cy5hZGQobS5rZXkpLCBkb2N1bWVudEtleVNldCgpKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hJZCA9PT0gb3RoZXIuYmF0Y2hJZCAmJlxyXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLm11dGF0aW9ucywgb3RoZXIubXV0YXRpb25zLCAobCwgcikgPT4gbXV0YXRpb25FcXVhbHMobCwgcikpICYmXHJcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKHRoaXMuYmFzZU11dGF0aW9ucywgb3RoZXIuYmFzZU11dGF0aW9ucywgKGwsIHIpID0+IG11dGF0aW9uRXF1YWxzKGwsIHIpKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSBtdXRhdGlvbiBiYXRjaCB0byB0aGUgYmFja2VuZC4gKi9cclxuY2xhc3MgTXV0YXRpb25CYXRjaFJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihiYXRjaCwgY29tbWl0VmVyc2lvbiwgbXV0YXRpb25SZXN1bHRzLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBwcmUtY29tcHV0ZWQgbWFwcGluZyBmcm9tIGVhY2ggbXV0YXRlZCBkb2N1bWVudCB0byB0aGUgcmVzdWx0aW5nXHJcbiAgICAgKiB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBkb2NWZXJzaW9ucykge1xyXG4gICAgICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcclxuICAgICAgICB0aGlzLmNvbW1pdFZlcnNpb24gPSBjb21taXRWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25SZXN1bHRzID0gbXV0YXRpb25SZXN1bHRzO1xyXG4gICAgICAgIHRoaXMuZG9jVmVyc2lvbnMgPSBkb2NWZXJzaW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNdXRhdGlvbkJhdGNoUmVzdWx0IGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHJlc3VsdHMuIFRoZXJlXHJcbiAgICAgKiBtdXN0IGJlIG9uZSByZXN1bHQgZm9yIGVhY2ggbXV0YXRpb24gaW4gdGhlIGJhdGNoLiBUaGlzIHN0YXRpYyBmYWN0b3J5XHJcbiAgICAgKiBjYWNoZXMgYSBkb2N1bWVudD0mZ3Q7dmVyc2lvbiBtYXBwaW5nIChkb2NWZXJzaW9ucykuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChiYXRjaC5tdXRhdGlvbnMubGVuZ3RoID09PSByZXN1bHRzLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IHZlcnNpb25NYXAgPSBkb2N1bWVudFZlcnNpb25NYXAoKTtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmVyc2lvbk1hcCA9IHZlcnNpb25NYXAuaW5zZXJ0KG11dGF0aW9uc1tpXS5rZXksIHJlc3VsdHNbaV0udmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YXRpb25CYXRjaFJlc3VsdChiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cywgdmVyc2lvbk1hcCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGFuIG92ZXJsYXkgY29tcHV0ZWQgYnkgRmlyZXN0b3JlLlxyXG4gKlxyXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBhIG11dGF0aW9uIGFuZCB0aGUgbGFyZ2VzdCBiYXRjaCBpZCBpbiBGaXJlc3RvcmUgd2hlblxyXG4gKiB0aGUgbXV0YXRpb24gd2FzIGNyZWF0ZWQuXHJcbiAqL1xyXG5jbGFzcyBPdmVybGF5IHtcclxuICAgIGNvbnN0cnVjdG9yKGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikge1xyXG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uID0gbXV0YXRpb247XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb24ua2V5O1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciAhPT0gbnVsbCAmJiB0aGlzLm11dGF0aW9uID09PSBvdGhlci5tdXRhdGlvbjtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgT3ZlcmxheXtcbiAgICAgIGxhcmdlc3RCYXRjaElkOiAke3RoaXMubGFyZ2VzdEJhdGNoSWR9LFxuICAgICAgbXV0YXRpb246ICR7dGhpcy5tdXRhdGlvbi50b1N0cmluZygpfVxuICAgIH1gO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4aXN0ZW5jZUZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb3VudCwgdW5jaGFuZ2VkTmFtZXMpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XHJcbiAgICAgICAgdGhpcy51bmNoYW5nZWROYW1lcyA9IHVuY2hhbmdlZE5hbWVzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFcnJvciBDb2RlcyBkZXNjcmliaW5nIHRoZSBkaWZmZXJlbnQgd2F5cyBHUlBDIGNhbiBmYWlsLiBUaGVzZSBhcmUgY29waWVkXHJcbiAqIGRpcmVjdGx5IGZyb20gR1JQQydzIHNvdXJjZXMgaGVyZTpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcclxuICpcclxuICogSW1wb3J0YW50ISBUaGUgbmFtZXMgb2YgdGhlc2UgaWRlbnRpZmllcnMgbWF0dGVyIGJlY2F1c2UgdGhlIHN0cmluZyBmb3Jtc1xyXG4gKiBhcmUgdXNlZCBmb3IgcmV2ZXJzZSBsb29rdXBzIGZyb20gdGhlIHdlYmNoYW5uZWwgc3RyZWFtLiBEbyBOT1QgY2hhbmdlIHRoZVxyXG4gKiBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBvciBjaGFuZ2UgdGhpcyBpbnRvIGEgY29uc3QgZW51bS5cclxuICovXHJcbnZhciBScGNDb2RlO1xyXG4oZnVuY3Rpb24gKFJwY0NvZGUpIHtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9LXCJdID0gMF0gPSBcIk9LXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xyXG59KShScGNDb2RlIHx8IChScGNDb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBlcnJvciBjb2RlIHJlcHJlc2VudHMgYSBwZXJtYW5lbnQgZXJyb3Igd2hlbiByZWNlaXZlZFxyXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIFNlZSBpc1Blcm1hbmVudFdyaXRlRXJyb3IgZm9yIGNsYXNzaWZ5aW5nIHdyaXRlIGVycm9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGVybWFuZW50RXJyb3IoY29kZSkge1xyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgY2FzZSBDb2RlLk9LOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIGNhc2UgQ29kZS5DQU5DRUxMRUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLlVOS05PV046XHJcbiAgICAgICAgY2FzZSBDb2RlLkRFQURMSU5FX0VYQ0VFREVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLklOVEVSTkFMOlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTkFWQUlMQUJMRTpcclxuICAgICAgICAvLyBVbmF1dGhlbnRpY2F0ZWQgbWVhbnMgc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBvdXIgdG9rZW4gYW5kIHdlIG5lZWRcclxuICAgICAgICAvLyB0byByZXRyeSB3aXRoIG5ldyBjcmVkZW50aWFscyB3aGljaCB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTkFVVEhFTlRJQ0FURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjYXNlIENvZGUuSU5WQUxJRF9BUkdVTUVOVDpcclxuICAgICAgICBjYXNlIENvZGUuTk9UX0ZPVU5EOlxyXG4gICAgICAgIGNhc2UgQ29kZS5BTFJFQURZX0VYSVNUUzpcclxuICAgICAgICBjYXNlIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XHJcbiAgICAgICAgLy8gQWJvcnRlZCBtaWdodCBiZSByZXRyaWVkIGluIHNvbWUgc2NlbmFyaW9zLCBidXQgdGhhdCBpcyBkZXBlbmRhbnQgb25cclxuICAgICAgICAvLyB0aGUgY29udGV4dCBhbmQgc2hvdWxkIGhhbmRsZWQgaW5kaXZpZHVhbGx5IGJ5IHRoZSBjYWxsaW5nIGNvZGUuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9hcGlzL2Rlc2lnbi9lcnJvcnMuXHJcbiAgICAgICAgY2FzZSBDb2RlLkFCT1JURUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLk9VVF9PRl9SQU5HRTpcclxuICAgICAgICBjYXNlIENvZGUuVU5JTVBMRU1FTlRFRDpcclxuICAgICAgICBjYXNlIENvZGUuREFUQV9MT1NTOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXJyb3IgY29kZSByZXByZXNlbnRzIGEgcGVybWFuZW50IGVycm9yIHdoZW4gcmVjZWl2ZWRcclxuICogaW4gcmVzcG9uc2UgdG8gYSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIFdyaXRlIG9wZXJhdGlvbnMgbXVzdCBiZSBoYW5kbGVkIHNwZWNpYWxseSBiZWNhdXNlIGFzIG9mIGIvMTE5NDM3NzY0LCBBQk9SVEVEXHJcbiAqIGVycm9ycyBvbiB0aGUgd3JpdGUgc3RyZWFtIHNob3VsZCBiZSByZXRyaWVkIHRvbyAoZXZlbiB0aG91Z2ggQUJPUlRFRCBlcnJvcnNcclxuICogYXJlIG5vdCBnZW5lcmFsbHkgcmV0cnlhYmxlKS5cclxuICpcclxuICogTm90ZSB0aGF0IGR1cmluZyB0aGUgaW5pdGlhbCBoYW5kc2hha2Ugb24gdGhlIHdyaXRlIHN0cmVhbSBhbiBBQk9SVEVEIGVycm9yXHJcbiAqIHNpZ25hbHMgdGhhdCB3ZSBzaG91bGQgZGlzY2FyZCBvdXIgc3RyZWFtIHRva2VuIChpLmUuIGl0IGlzIHBlcm1hbmVudCkuIFRoaXNcclxuICogbWVhbnMgYSBoYW5kc2hha2UgZXJyb3Igc2hvdWxkIGJlIGNsYXNzaWZpZWQgd2l0aCBpc1Blcm1hbmVudEVycm9yLCBhYm92ZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGVybWFuZW50V3JpdGVFcnJvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSAmJiBjb2RlICE9PSBDb2RlLkFCT1JURUQ7XHJcbn1cclxuLyoqXHJcbiAqIE1hcHMgYW4gZXJyb3IgQ29kZSBmcm9tIEdSUEMgc3RhdHVzIGNvZGUgbnVtYmVyLCBsaWtlIDAsIDEsIG9yIDE0LiBUaGVzZVxyXG4gKiBhcmUgbm90IHRoZSBzYW1lIGFzIEhUVFAgc3RhdHVzIGNvZGVzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgQ29kZSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBHUlBDIHN0YXR1cyBjb2RlLiBGYWlscyBpZiB0aGVyZVxyXG4gKiAgICAgaXMgbm8gbWF0Y2guXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDb2RlRnJvbVJwY0NvZGUoY29kZSkge1xyXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGluIGNlcnRhaW4gZXJyb3IgY2FzZXMgKGxpa2UgdHJ5aW5nXHJcbiAgICAgICAgLy8gdG8gc2VuZCBpbnZhbGlkIHByb3RvIG1lc3NhZ2VzKSB3ZSBtYXkgZ2V0IGFuIGVycm9yIHdpdGggbm8gR1JQQyBjb2RlLlxyXG4gICAgICAgIGxvZ0Vycm9yKCdHUlBDIGVycm9yIGhhcyBubyAuY29kZScpO1xyXG4gICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuT0s6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9LO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5DQU5DRUxMRUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkNBTkNFTExFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuVU5LTk9XTjpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5LTk9XTjtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuREVBRExJTkVfRVhDRUVERUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRFQURMSU5FX0VYQ0VFREVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuSU5URVJOQUw6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLklOVEVSTkFMO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFWQUlMQUJMRTpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOQVVUSEVOVElDQVRFRDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5JTlZBTElEX0FSR1VNRU5UOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JTlZBTElEX0FSR1VNRU5UO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5OT1RfRk9VTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk5PVF9GT1VORDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuQUxSRUFEWV9FWElTVFM6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFMUkVBRFlfRVhJU1RTO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5QRVJNSVNTSU9OX0RFTklFRDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT047XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkFCT1JURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFCT1JURUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLk9VVF9PRl9SQU5HRTpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuT1VUX09GX1JBTkdFO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTklNUExFTUVOVEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTklNUExFTUVOVEVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5EQVRBX0xPU1M6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRBVEFfTE9TUztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxyXG4gKi9cclxuY2xhc3MgQmFzZTY0RGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdCYXNlNjREZWNvZGVFcnJvcic7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBnbG9iYWwsIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBUZXN0aW5nSG9va3NTcGkuXHJcbiAqXHJcbiAqIFRoaXMgdmFyaWFibGUgd2lsbCBiZSBgbnVsbGAgaW4gYWxsIGNhc2VzIF9leGNlcHRfIHdoZW4gcnVubmluZyBmcm9tXHJcbiAqIGludGVncmF0aW9uIHRlc3RzIHRoYXQgaGF2ZSByZWdpc3RlcmVkIGNhbGxiYWNrcyB0byBiZSBub3RpZmllZCBvZiBldmVudHNcclxuICogdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSB0ZXN0IGV4ZWN1dGlvbi5cclxuICovXHJcbmxldCB0ZXN0aW5nSG9va3NTcGkgPSBudWxsO1xyXG4vKipcclxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGB0ZXN0aW5nSG9va3NTcGlgIG9iamVjdC5cclxuICogQHBhcmFtIGluc3RhbmNlIHRoZSBpbnN0YW5jZSB0byBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUZXN0aW5nSG9va3NTcGkoaW5zdGFuY2UpIHtcclxuICAgIGlmICh0ZXN0aW5nSG9va3NTcGkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgVGVzdGluZ0hvb2tzU3BpIGluc3RhbmNlIGlzIGFscmVhZHkgc2V0Jyk7XHJcbiAgICB9XHJcbiAgICB0ZXN0aW5nSG9va3NTcGkgPSBpbnN0YW5jZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFBsYXRmb3JtJ3MgJ1RleHRFbmNvZGVyJyBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1RleHRFbmNvZGVyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dERlY29kZXInIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3VGV4dERlY29kZXIoKSB7XHJcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE1BWF82NF9CSVRfVU5TSUdORURfSU5URUdFUiA9IG5ldyBJbnRlZ2VyKFsweGZmZmZmZmZmLCAweGZmZmZmZmZmXSwgMCk7XHJcbi8vIEhhc2ggYSBzdHJpbmcgdXNpbmcgbWQ1IGhhc2hpbmcgYWxnb3JpdGhtLlxyXG5mdW5jdGlvbiBnZXRNZDVIYXNoVmFsdWUodmFsdWUpIHtcclxuICAgIGNvbnN0IGVuY29kZWRWYWx1ZSA9IG5ld1RleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcclxuICAgIGNvbnN0IG1kNSA9IG5ldyBNZDUoKTtcclxuICAgIG1kNS51cGRhdGUoZW5jb2RlZFZhbHVlKTtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShtZDUuZGlnZXN0KCkpO1xyXG59XHJcbi8vIEludGVycHJldCB0aGUgMTYgYnl0ZXMgYXJyYXkgYXMgdHdvIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VycywgZW5jb2RlZCB1c2luZ1xyXG4vLyAy4oCZcyBjb21wbGVtZW50IHVzaW5nIGxpdHRsZSBlbmRpYW4uXHJcbmZ1bmN0aW9uIGdldDY0Qml0VWludHMoQnl0ZXMpIHtcclxuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KEJ5dGVzLmJ1ZmZlcik7XHJcbiAgICBjb25zdCBjaHVuazEgPSBkYXRhVmlldy5nZXRVaW50MzIoMCwgLyogbGl0dGxlRW5kaWFuPSAqLyB0cnVlKTtcclxuICAgIGNvbnN0IGNodW5rMiA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xyXG4gICAgY29uc3QgY2h1bmszID0gZGF0YVZpZXcuZ2V0VWludDMyKDgsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCBjaHVuazQgPSBkYXRhVmlldy5nZXRVaW50MzIoMTIsIC8qIGxpdHRsZUVuZGlhbj0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCBpbnRlZ2VyMSA9IG5ldyBJbnRlZ2VyKFtjaHVuazEsIGNodW5rMl0sIDApO1xyXG4gICAgY29uc3QgaW50ZWdlcjIgPSBuZXcgSW50ZWdlcihbY2h1bmszLCBjaHVuazRdLCAwKTtcclxuICAgIHJldHVybiBbaW50ZWdlcjEsIGludGVnZXIyXTtcclxufVxyXG5jbGFzcyBCbG9vbUZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihiaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCkge1xyXG4gICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNoQ291bnQgPSBoYXNoQ291bnQ7XHJcbiAgICAgICAgaWYgKHBhZGRpbmcgPCAwIHx8IHBhZGRpbmcgPj0gOCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nOiAke3BhZGRpbmd9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoQ291bnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIGhhc2ggY291bnQ6ICR7aGFzaENvdW50fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYml0bWFwLmxlbmd0aCA+IDAgJiYgdGhpcy5oYXNoQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gT25seSBlbXB0eSBibG9vbSBmaWx0ZXIgY2FuIGhhdmUgMCBoYXNoIGNvdW50LlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBoYXNoIGNvdW50OiAke2hhc2hDb3VudH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJpdG1hcC5sZW5ndGggPT09IDAgJiYgcGFkZGluZyAhPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBFbXB0eSBibG9vbSBmaWx0ZXIgc2hvdWxkIGhhdmUgMCBwYWRkaW5nLlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nIHdoZW4gYml0bWFwIGxlbmd0aCBpcyAwOiAke3BhZGRpbmd9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRtYXAubGVuZ3RoICogOCAtIHBhZGRpbmc7XHJcbiAgICAgICAgLy8gU2V0IHRoZSBiaXQgY291bnQgaW4gSW50ZWdlciB0byBhdm9pZCByZXBldGl0aW9uIGluIG1pZ2h0Q29udGFpbigpLlxyXG4gICAgICAgIHRoaXMuYml0Q291bnRJbkludGVnZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIodGhpcy5iaXRDb3VudCk7XHJcbiAgICB9XHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGl0aCBoYXNoIHZhbHVlIGJhc2VkIG9uIHRoZSBoYXNoZWQgNjRiaXQgaW50ZWdlcnMsXHJcbiAgICAvLyBhbmQgY2FsY3VsYXRlIGl0cyBjb3JyZXNwb25kaW5nIGJpdCBpbmRleCBpbiB0aGUgYml0bWFwIHRvIGJlIGNoZWNrZWQuXHJcbiAgICBnZXRCaXRJbmRleChudW0xLCBudW0yLCBoYXNoSW5kZXgpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFzaGVkIHZhbHVlIGgoaSkgPSBoMSArIChpICogaDIpLlxyXG4gICAgICAgIGxldCBoYXNoVmFsdWUgPSBudW0xLmFkZChudW0yLm11bHRpcGx5KEludGVnZXIuZnJvbU51bWJlcihoYXNoSW5kZXgpKSk7XHJcbiAgICAgICAgLy8gV3JhcCBpZiBoYXNoIHZhbHVlIG92ZXJmbG93IDY0Yml0LlxyXG4gICAgICAgIGlmIChoYXNoVmFsdWUuY29tcGFyZShNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIpID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhhc2hWYWx1ZSA9IG5ldyBJbnRlZ2VyKFtoYXNoVmFsdWUuZ2V0Qml0cygwKSwgaGFzaFZhbHVlLmdldEJpdHMoMSldLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZS5tb2R1bG8odGhpcy5iaXRDb3VudEluSW50ZWdlcikudG9OdW1iZXIoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybiB3aGV0aGVyIHRoZSBiaXQgb24gdGhlIGdpdmVuIGluZGV4IGluIHRoZSBiaXRtYXAgaXMgc2V0IHRvIDEuXHJcbiAgICBpc0JpdFNldChpbmRleCkge1xyXG4gICAgICAgIC8vIFRvIHJldHJpZXZlIGJpdCBuLCBjYWxjdWxhdGU6IChiaXRtYXBbbiAvIDhdICYgKDB4MDEgPDwgKG4gJSA4KSkpLlxyXG4gICAgICAgIGNvbnN0IGJ5dGUgPSB0aGlzLmJpdG1hcFtNYXRoLmZsb29yKGluZGV4IC8gOCldO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICUgODtcclxuICAgICAgICByZXR1cm4gKGJ5dGUgJiAoMHgwMSA8PCBvZmZzZXQpKSAhPT0gMDtcclxuICAgIH1cclxuICAgIG1pZ2h0Q29udGFpbih2YWx1ZSkge1xyXG4gICAgICAgIC8vIEVtcHR5IGJpdG1hcCBzaG91bGQgYWx3YXlzIHJldHVybiBmYWxzZSBvbiBtZW1iZXJzaGlwIGNoZWNrLlxyXG4gICAgICAgIGlmICh0aGlzLmJpdENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWQ1SGFzaGVkVmFsdWUgPSBnZXRNZDVIYXNoVmFsdWUodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRCaXRJbmRleChoYXNoMSwgaGFzaDIsIGkpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNCaXRTZXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlIGJsb29tIGZpbHRlciBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LiAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShiaXRDb3VudCwgaGFzaENvdW50LCBjb250YWlucykge1xyXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBiaXRDb3VudCAlIDggPT09IDAgPyAwIDogOCAtIChiaXRDb3VudCAlIDgpO1xyXG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRDb3VudCAvIDgpKTtcclxuICAgICAgICBjb25zdCBibG9vbUZpbHRlciA9IG5ldyBCbG9vbUZpbHRlcihiaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCk7XHJcbiAgICAgICAgY29udGFpbnMuZm9yRWFjaChpdGVtID0+IGJsb29tRmlsdGVyLmluc2VydChpdGVtKSk7XHJcbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgW2hhc2gxLCBoYXNoMl0gPSBnZXQ2NEJpdFVpbnRzKG1kNUhhc2hlZFZhbHVlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGFzaENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Qml0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRCaXQoaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpbmRleE9mQnl0ZSA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAlIDg7XHJcbiAgICAgICAgdGhpcy5iaXRtYXBbaW5kZXhPZkJ5dGVdIHw9IDB4MDEgPDwgb2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEJsb29tRmlsdGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdCbG9vbUZpbHRlckVycm9yJztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gZXZlbnQgZnJvbSB0aGUgUmVtb3RlU3RvcmUuIEl0IGlzIHNwbGl0IGludG8gdGFyZ2V0Q2hhbmdlcyAoY2hhbmdlcyB0byB0aGVcclxuICogc3RhdGUgb3IgdGhlIHNldCBvZiBkb2N1bWVudHMgaW4gb3VyIHdhdGNoZWQgdGFyZ2V0cykgYW5kIGRvY3VtZW50VXBkYXRlc1xyXG4gKiAoY2hhbmdlcyB0byB0aGUgYWN0dWFsIGRvY3VtZW50cykuXHJcbiAqL1xyXG5jbGFzcyBSZW1vdGVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNuYXBzaG90IHZlcnNpb24gdGhpcyBldmVudCBicmluZ3MgdXMgdXAgdG8sIG9yIE1JTiBpZiBub3Qgc2V0LlxyXG4gICAgICovXHJcbiAgICBzbmFwc2hvdFZlcnNpb24sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1hcCBmcm9tIHRhcmdldCB0byBjaGFuZ2VzIHRvIHRoZSB0YXJnZXQuIFNlZSBUYXJnZXRDaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENoYW5nZXMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1hcCBvZiB0YXJnZXRzIHRoYXQgaXMga25vd24gdG8gYmUgaW5jb25zaXN0ZW50LCBhbmQgdGhlIHB1cnBvc2UgZm9yXHJcbiAgICAgKiByZS1saXN0ZW5pbmcuIExpc3RlbnMgZm9yIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHJlLWVzdGFibGlzaGVkIHdpdGhvdXRcclxuICAgICAqIHJlc3VtZSB0b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldE1pc21hdGNoZXMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNldCBvZiB3aGljaCBkb2N1bWVudHMgaGF2ZSBjaGFuZ2VkIG9yIGJlZW4gZGVsZXRlZCwgYWxvbmcgd2l0aCB0aGVcclxuICAgICAqIGRvYydzIG5ldyB2YWx1ZXMgKGlmIG5vdCBkZWxldGVkKS5cclxuICAgICAqL1xyXG4gICAgZG9jdW1lbnRVcGRhdGVzLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2Ygd2hpY2ggZG9jdW1lbnQgdXBkYXRlcyBhcmUgZHVlIG9ubHkgdG8gbGltYm8gcmVzb2x1dGlvbiB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlZExpbWJvRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdFZlcnNpb24gPSBzbmFwc2hvdFZlcnNpb247XHJcbiAgICAgICAgdGhpcy50YXJnZXRDaGFuZ2VzID0gdGFyZ2V0Q2hhbmdlcztcclxuICAgICAgICB0aGlzLnRhcmdldE1pc21hdGNoZXMgPSB0YXJnZXRNaXNtYXRjaGVzO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRVcGRhdGVzID0gZG9jdW1lbnRVcGRhdGVzO1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IHJlc29sdmVkTGltYm9Eb2N1bWVudHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhBQ0s6IFZpZXdzIHJlcXVpcmUgUmVtb3RlRXZlbnRzIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSB2aWV3IGlzXHJcbiAgICAgKiBDVVJSRU5ULCBidXQgc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgcmVjZWl2ZSByZW1vdGUgZXZlbnRzLiBTbyB0aGlzIG1ldGhvZCBpc1xyXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBSZW1vdGVFdmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IGFcclxuICAgICAqIENVUlJFTlQgc3RhdHVzIGNoYW5nZSB0byBhIFZpZXcsIGZvciBxdWVyaWVzIGV4ZWN1dGVkIGluIGEgZGlmZmVyZW50IHRhYi5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seVxyXG4gICAgc3RhdGljIGNyZWF0ZVN5bnRoZXNpemVkUmVtb3RlRXZlbnRGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGFyZ2V0Q2hhbmdlcy5zZXQodGFyZ2V0SWQsIFRhcmdldENoYW5nZS5jcmVhdGVTeW50aGVzaXplZFRhcmdldENoYW5nZUZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVFdmVudChTbmFwc2hvdFZlcnNpb24ubWluKCksIHRhcmdldENoYW5nZXMsIG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvciksIG11dGFibGVEb2N1bWVudE1hcCgpLCBkb2N1bWVudEtleVNldCgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBUYXJnZXRDaGFuZ2Ugc3BlY2lmaWVzIHRoZSBzZXQgb2YgY2hhbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXJnZXQgYXMgcGFydCBvZlxyXG4gKiBhIFJlbW90ZUV2ZW50LiBUaGVzZSBjaGFuZ2VzIHRyYWNrIHdoaWNoIGRvY3VtZW50cyBhcmUgYWRkZWQsIG1vZGlmaWVkIG9yXHJcbiAqIHJlbW92ZWQsIGFzIHdlbGwgYXMgdGhlIHRhcmdldCdzIHJlc3VtZSB0b2tlbiBhbmQgd2hldGhlciB0aGUgdGFyZ2V0IGlzXHJcbiAqIG1hcmtlZCBDVVJSRU5ULlxyXG4gKiBUaGUgYWN0dWFsIGNoYW5nZXMgKnRvKiBkb2N1bWVudHMgYXJlIG5vdCBwYXJ0IG9mIHRoZSBUYXJnZXRDaGFuZ2Ugc2luY2VcclxuICogZG9jdW1lbnRzIG1heSBiZSBwYXJ0IG9mIG11bHRpcGxlIHRhcmdldHMuXHJcbiAqL1xyXG5jbGFzcyBUYXJnZXRDaGFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgcXVlcnkgdG8gYmUgcmVzdW1lZFxyXG4gICAgICogYWZ0ZXIgZGlzY29ubmVjdGluZyB3aXRob3V0IHJldHJhbnNtaXR0aW5nIGFsbCB0aGUgZGF0YSB0aGF0IG1hdGNoZXMgdGhlXHJcbiAgICAgKiBxdWVyeS4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW4gdGltZSBmcm9tIHdoaWNoXHJcbiAgICAgKiB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICByZXN1bWVUb2tlbiwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBcImN1cnJlbnRcIiAoc3luY2VkKSBzdGF0dXMgb2YgdGhpcyB0YXJnZXQuIE5vdGUgdGhhdCBcImN1cnJlbnRcIlxyXG4gICAgICogaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sIHRoYXQgaW1wbGllcyB0aGF0IGEgdGFyZ2V0IGlzXHJcbiAgICAgKiBib3RoIHVwLXRvLWRhdGUgYW5kIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2ggc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICBjdXJyZW50LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIG5ld2x5IGFzc2lnbmVkIHRvIHRoaXMgdGFyZ2V0IGFzIHBhcnQgb2ZcclxuICAgICAqIHRoaXMgcmVtb3RlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBhZGRlZERvY3VtZW50cywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBhbHJlYWR5IGFzc2lnbmVkIHRvIHRoaXMgdGFyZ2V0IGJ1dCByZWNlaXZlZFxyXG4gICAgICogYW4gdXBkYXRlIGR1cmluZyB0aGlzIHJlbW90ZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgbW9kaWZpZWREb2N1bWVudHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgdGFyZ2V0IGFzIHBhcnQgb2YgdGhpc1xyXG4gICAgICogcmVtb3RlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgdGhpcy5hZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWREb2N1bWVudHMgPSBtb2RpZmllZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLnJlbW92ZWREb2N1bWVudHMgPSByZW1vdmVkRG9jdW1lbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHN5bnRoZXNpemVkIFRhcmdldENoYW5nZXMgdGhhdCBjYW4gYmUgdXNlZCB0b1xyXG4gICAgICogYXBwbHkgYSBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3IChmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudFxyXG4gICAgICogdGFiKSBvciBmb3IgbmV3IHF1ZXJpZXMgKHRvIHJhaXNlIHNuYXBzaG90cyB3aXRoIGNvcnJlY3QgQ1VSUkVOVCBzdGF0dXMpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0Q2hhbmdlKHJlc3VtZVRva2VuLCBjdXJyZW50LCBkb2N1bWVudEtleVNldCgpLCBkb2N1bWVudEtleVNldCgpLCBkb2N1bWVudEtleVNldCgpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNoYW5nZWQgZG9jdW1lbnQgYW5kIGEgbGlzdCBvZiB0YXJnZXQgaWRzIHRvIHdoaWNoIHRoaXMgY2hhbmdlXHJcbiAqIGFwcGxpZXMuXHJcbiAqXHJcbiAqIElmIGRvY3VtZW50IGhhcyBiZWVuIGRlbGV0ZWQgTm9Eb2N1bWVudCB3aWxsIGJlIHByb3ZpZGVkLlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRXYXRjaENoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgbmV3IGRvY3VtZW50IGFwcGxpZXMgdG8gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXHJcbiAgICB1cGRhdGVkVGFyZ2V0SWRzLCBcclxuICAgIC8qKiBUaGUgbmV3IGRvY3VtZW50IGlzIHJlbW92ZWQgZnJvbSBhbGwgb2YgdGhlc2UgdGFyZ2V0cy4gKi9cclxuICAgIHJlbW92ZWRUYXJnZXRJZHMsIFxyXG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGRvY3VtZW50IGZvciB0aGlzIGNoYW5nZS4gKi9cclxuICAgIGtleSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuZXcgZG9jdW1lbnQgb3IgTm9Eb2N1bWVudCBpZiBpdCB3YXMgZGVsZXRlZC4gSXMgbnVsbCBpZiB0aGVcclxuICAgICAqIGRvY3VtZW50IHdlbnQgb3V0IG9mIHZpZXcgd2l0aG91dCB0aGUgc2VydmVyIHNlbmRpbmcgYSBuZXcgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIG5ld0RvYykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlZFRhcmdldElkcyA9IHVwZGF0ZWRUYXJnZXRJZHM7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVkVGFyZ2V0SWRzID0gcmVtb3ZlZFRhcmdldElkcztcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLm5ld0RvYyA9IG5ld0RvYztcclxuICAgIH1cclxufVxyXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXJDaGFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLmV4aXN0ZW5jZUZpbHRlciA9IGV4aXN0ZW5jZUZpbHRlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBXYXRjaFRhcmdldENoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBXaGF0IGtpbmQgb2YgY2hhbmdlIG9jY3VycmVkIHRvIHRoZSB3YXRjaCB0YXJnZXQuICovXHJcbiAgICBzdGF0ZSwgXHJcbiAgICAvKiogVGhlIHRhcmdldCBJRHMgdGhhdCB3ZXJlIGFkZGVkL3JlbW92ZWQvc2V0LiAqL1xyXG4gICAgdGFyZ2V0SWRzLCBcclxuICAgIC8qKlxyXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcclxuICAgICAqIHJlc3VtZWQgYWZ0ZXIgZGlzY29ubmVjdGluZyB3aXRob3V0IHJldHJhbnNtaXR0aW5nIGFsbCB0aGUgZGF0YSB0aGF0XHJcbiAgICAgKiBtYXRjaGVzIHRoZSB0YXJnZXQuIFRoZSByZXN1bWUgdG9rZW4gZXNzZW50aWFsbHkgaWRlbnRpZmllcyBhIHBvaW50IGluXHJcbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBcclxuICAgIC8qKiBBbiBSUEMgZXJyb3IgaW5kaWNhdGluZyB3aHkgdGhlIHdhdGNoIGZhaWxlZC4gKi9cclxuICAgIGNhdXNlID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLnRhcmdldElkcyA9IHRhcmdldElkcztcclxuICAgICAgICB0aGlzLnJlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XHJcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUcmFja3MgdGhlIGludGVybmFsIHN0YXRlIG9mIGEgV2F0Y2ggdGFyZ2V0LiAqL1xyXG5jbGFzcyBUYXJnZXRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIChhZGRzIG9yIHJlbW92ZXMpIHRoYXQgd2UgYXJlIHdhaXRpbmcgb24uXHJcbiAgICAgICAgICogV2Ugb25seSBjb25zaWRlciB0YXJnZXRzIGFjdGl2ZSB0aGF0IGhhdmUgbm8gcGVuZGluZyByZXNwb25zZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgZG9jdW1lbnQgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCByYWlzZWQgc25hcHNob3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGVzZSBjaGFuZ2VzIGFyZSBjb250aW51b3VzbHkgdXBkYXRlZCBhcyB3ZSByZWNlaXZlIGRvY3VtZW50IHVwZGF0ZXMgYW5kXHJcbiAgICAgICAgICogYWx3YXlzIHJlZmxlY3QgdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMgYWdhaW5zdCB0aGUgbGFzdCBpc3N1ZWQgc25hcHNob3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSBzbmFwc2hvdENoYW5nZXNNYXAoKTtcclxuICAgICAgICAvKiogU2VlIHB1YmxpYyBnZXR0ZXJzIGZvciBleHBsYW5hdGlvbnMgb2YgdGhlc2UgZmllbGRzLiAqL1xyXG4gICAgICAgIHRoaXMuX3Jlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGlzIHRhcmdldCBzdGF0ZSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIG5leHQgc25hcHNob3QuIFdlXHJcbiAgICAgICAgICogaW5pdGlhbGl6ZSB0byB0cnVlIHNvIHRoYXQgbmV3bHktYWRkZWQgdGFyZ2V0cyBhcmUgaW5jbHVkZWQgaW4gdGhlIG5leHRcclxuICAgICAgICAgKiBSZW1vdGVFdmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyB0YXJnZXQgaGFzIGJlZW4gbWFya2VkICdjdXJyZW50Jy5cclxuICAgICAqXHJcbiAgICAgKiAnQ3VycmVudCcgaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sOiBJdCBpbXBsaWVzIHRoYXQgdGhlXHJcbiAgICAgKiBXYXRjaCBiYWNrZW5kIGhhcyBzZW50IHVzIGFsbCBjaGFuZ2VzIHVwIHRvIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgdGFyZ2V0XHJcbiAgICAgKiB3YXMgYWRkZWQgYW5kIHRoYXQgdGhlIHRhcmdldCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoXHJcbiAgICAgKiBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBsYXN0IHJlc3VtZSB0b2tlbiBzZW50IHRvIHVzIGZvciB0aGlzIHRhcmdldC4gKi9cclxuICAgIGdldCByZXN1bWVUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdW1lVG9rZW47XHJcbiAgICB9XHJcbiAgICAvKiogV2hldGhlciB0aGlzIHRhcmdldCBoYXMgcGVuZGluZyB0YXJnZXQgYWRkcyBvciB0YXJnZXQgcmVtb3Zlcy4gKi9cclxuICAgIGdldCBpc1BlbmRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKiBXaGV0aGVyIHdlIGhhdmUgbW9kaWZpZWQgYW55IHN0YXRlIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSBzbmFwc2hvdC4gKi9cclxuICAgIGdldCBoYXNQZW5kaW5nQ2hhbmdlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzUGVuZGluZ0NoYW5nZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIHJlc3VtZSB0b2tlbiB0byB0aGUgVGFyZ2V0Q2hhbmdlLCBidXQgb25seSB3aGVuIGl0IGhhcyBhIG5ld1xyXG4gICAgICogdmFsdWUuIEVtcHR5IHJlc3VtZVRva2VucyBhcmUgZGlzY2FyZGVkLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVSZXN1bWVUb2tlbihyZXN1bWVUb2tlbikge1xyXG4gICAgICAgIGlmIChyZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB0YXJnZXQgY2hhbmdlIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogVG8gcmVzZXQgdGhlIGRvY3VtZW50IGNoYW5nZXMgYWZ0ZXIgcmFpc2luZyB0aGlzIHNuYXBzaG90LCBjYWxsXHJcbiAgICAgKiBgY2xlYXJQZW5kaW5nQ2hhbmdlcygpYC5cclxuICAgICAqL1xyXG4gICAgdG9UYXJnZXRDaGFuZ2UoKSB7XHJcbiAgICAgICAgbGV0IGFkZGVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBsZXQgbW9kaWZpZWREb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGxldCByZW1vdmVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChrZXksIGNoYW5nZVR5cGUpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWREb2N1bWVudHMgPSBtb2RpZmllZERvY3VtZW50cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZERvY3VtZW50cyA9IHJlbW92ZWREb2N1bWVudHMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0Q2hhbmdlKHRoaXMuX3Jlc3VtZVRva2VuLCB0aGlzLl9jdXJyZW50LCBhZGRlZERvY3VtZW50cywgbW9kaWZpZWREb2N1bWVudHMsIHJlbW92ZWREb2N1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGRvY3VtZW50IGNoYW5nZXMgYW5kIHNldHMgYGhhc1BlbmRpbmdDaGFuZ2VzYCB0byBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgY2xlYXJQZW5kaW5nQ2hhbmdlcygpIHtcclxuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XHJcbiAgICB9XHJcbiAgICBhZGREb2N1bWVudENoYW5nZShrZXksIGNoYW5nZVR5cGUpIHtcclxuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5pbnNlcnQoa2V5LCBjaGFuZ2VUeXBlKTtcclxuICAgIH1cclxuICAgIHJlbW92ZURvY3VtZW50Q2hhbmdlKGtleSkge1xyXG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHRoaXMuZG9jdW1lbnRDaGFuZ2VzLnJlbW92ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QoKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzICs9IDE7XHJcbiAgICB9XHJcbiAgICByZWNvcmRUYXJnZXRSZXNwb25zZSgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgLT0gMTtcclxuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA+PSAwKTtcclxuICAgIH1cclxuICAgIG1hcmtDdXJyZW50KCkge1xyXG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBMT0dfVEFHJGcgPSAnV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yJztcclxuLyoqXHJcbiAqIEEgaGVscGVyIGNsYXNzIHRvIGFjY3VtdWxhdGUgd2F0Y2ggY2hhbmdlcyBpbnRvIGEgUmVtb3RlRXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBXYXRjaENoYW5nZUFnZ3JlZ2F0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGFQcm92aWRlciA9IG1ldGFkYXRhUHJvdmlkZXI7XHJcbiAgICAgICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbGwgdHJhY2tlZCB0YXJnZXRzLiAqL1xyXG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZG9jdW1lbnRzIHRvIHVwZGF0ZSBzaW5jZSB0aGUgbGFzdCByYWlzZWQgc25hcHNob3QuICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgLyoqIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXlzIHRvIHRoZWlyIHNldCBvZiB0YXJnZXQgSURzLiAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgb2YgdGFyZ2V0cyB3aXRoIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hlcy4gVGhlc2UgdGFyZ2V0cyBhcmVcclxuICAgICAgICAgKiBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQgYW5kIHRoZWlyIGxpc3RlbnMgbmVlZHMgdG8gYmUgcmUtZXN0YWJsaXNoZWQgYnlcclxuICAgICAgICAgKiBSZW1vdGVTdG9yZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgYW5kIGFkZHMgdGhlIERvY3VtZW50V2F0Y2hDaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZURvY3VtZW50Q2hhbmdlKGRvY0NoYW5nZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgZG9jQ2hhbmdlLnVwZGF0ZWRUYXJnZXRJZHMpIHtcclxuICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS5uZXdEb2MgJiYgZG9jQ2hhbmdlLm5ld0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2Uua2V5LCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGRvY0NoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2Uua2V5LCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogUHJvY2Vzc2VzIGFuZCBhZGRzIHRoZSBXYXRjaFRhcmdldENoYW5nZSB0byB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy4gKi9cclxuICAgIGhhbmRsZVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0Q2hhbmdlLnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5Ob0NoYW5nZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlY3JlbWVudCB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYWNrcyBuZWVkZWQgZnJvbSB3YXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIHRhcmdldElkLlxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS5pc1BlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGZyZXNobHkgYWRkZWQgdGFyZ2V0LCBzbyB3ZSBuZWVkIHRvIHJlc2V0IGFueSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIGhhZCBwcmV2aW91c2x5LiBUaGlzIGNhbiBoYXBwZW4gZS5nLiB3aGVuIHJlbW92ZSBhbmQgYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2sgYSB0YXJnZXQgZm9yIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUuY2xlYXJQZW5kaW5nQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgcmVtb3ZlZCB0YXJnZXRzIHRvIHdlIGNhbiBwb3N0LWZpbHRlciBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYW55IHRhcmdldCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVjb3JkVGFyZ2V0UmVzcG9uc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQ3VycmVudCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUubWFya0N1cnJlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZXNldCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRhcmdldCBhbmQgc3ludGhlc2l6ZXMgcmVtb3ZlcyBmb3IgYWxsIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cy4gVGhlIGJhY2tlbmQgd2lsbCByZS1hZGQgYW55IGRvY3VtZW50cyB0aGF0IHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoIHRoZSB0YXJnZXQgYmVmb3JlIGl0IHNlbmRzIHRoZSBuZXh0IGdsb2JhbCBzbmFwc2hvdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdGFyZ2V0SWRzIHRoYXQgdGhlIHdhdGNoIGNoYW5nZSBhcHBsaWVzIHRvOiBlaXRoZXIgdGhlXHJcbiAgICAgKiB0YXJnZXRJZHMgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGNoYW5nZSBvciB0aGUgdGFyZ2V0SWRzIG9mIGFsbCBjdXJyZW50bHlcclxuICAgICAqIGFjdGl2ZSB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoVGFyZ2V0KHRhcmdldENoYW5nZSwgZm4pIHtcclxuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS50YXJnZXRJZHMuZm9yRWFjaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4odGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgZXhpc3RlbmNlIGZpbHRlcnMgYW5kIHN5bnRoZXNpemVzIGRlbGV0ZXMgZm9yIGZpbHRlciBtaXNtYXRjaGVzLlxyXG4gICAgICogVGFyZ2V0cyB0aGF0IGFyZSBpbnZhbGlkYXRlZCBieSBmaWx0ZXIgbWlzbWF0Y2hlcyBhcmUgYWRkZWQgdG9cclxuICAgICAqIGBwZW5kaW5nVGFyZ2V0UmVzZXRzYC5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB3YXRjaENoYW5nZS50YXJnZXRJZDtcclxuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLmNvdW50O1xyXG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldERhdGEudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleGlzdGVuY2UgZmlsdGVyIHRvbGQgdXMgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0LiBXZSBkZWR1Y2VcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QgYW5kIGFwcGx5IGEgZGVsZXRlZCBkb2N1bWVudCB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG91ciB1cGRhdGVzLiBXaXRob3V0IGFwcGx5aW5nIHRoaXMgZGVsZXRlZCBkb2N1bWVudCB0aGVyZSBtaWdodCBiZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgcXVlcnkgdGhhdCB3aWxsIHJhaXNlIHRoaXMgZG9jdW1lbnQgYXMgcGFydCBvZiBhIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgaXQgaXMgcmVzb2x2ZWQsIGVzc2VudGlhbGx5IGV4cG9zaW5nIGluY29uc2lzdGVuY3kgYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldC5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChleHBlY3RlZENvdW50ID09PSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gdGhpcy5nZXRDdXJyZW50RG9jdW1lbnRDb3VudEZvclRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLiBNYXJrIHRoZSBkb2N1bWVudHMgYXMgYmVpbmcgaW4gbGltYm8sIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gcmFpc2UgYSBzbmFwc2hvdCB3aXRoIGBpc0Zyb21DYWNoZTp0cnVlYC5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2l6ZSAhPT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGJsb29tIGZpbHRlciB0byBpZGVudGlmeSBhbmQgbWFyayByZW1vdmVkIGRvY3VtZW50cy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9vbUZpbHRlciA9IHRoaXMucGFyc2VCbG9vbUZpbHRlcih3YXRjaENoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gYmxvb21GaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50U2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU2tpcHBlZCAqLztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBibG9vbSBmaWx0ZXIgYXBwbGljYXRpb24gZmFpbHMsIHdlIHJlc2V0IHRoZSBtYXBwaW5nIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlLXJ1biBvZiB0aGUgcXVlcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXJwb3NlID0gc3RhdHVzID09PSAyIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuRmFsc2VQb3NpdGl2ZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLmluc2VydCh0YXJnZXRJZCwgcHVycG9zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RpbmdIb29rc1NwaSA9PT0gbnVsbCB8fCB0ZXN0aW5nSG9va3NTcGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRlc3RpbmdIb29rc1NwaS5ub3RpZnlPbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNyZWF0ZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoSW5mb0ZvclRlc3RpbmdIb29rcyhjdXJyZW50U2l6ZSwgd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLCB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0RGF0YWJhc2VJZCgpLCBibG9vbUZpbHRlciwgc3RhdHVzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBibG9vbSBmaWx0ZXIgZnJvbSB0aGUgXCJ1bmNoYW5nZWRfbmFtZXNcIiBmaWVsZCBvZiBhbiBleGlzdGVuY2VcclxuICAgICAqIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgcGFyc2VCbG9vbUZpbHRlcih3YXRjaENoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZE5hbWVzID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLnVuY2hhbmdlZE5hbWVzO1xyXG4gICAgICAgIGlmICghdW5jaGFuZ2VkTmFtZXMgfHwgIXVuY2hhbmdlZE5hbWVzLmJpdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgYml0czogeyBiaXRtYXAgPSAnJywgcGFkZGluZyA9IDAgfSwgaGFzaENvdW50ID0gMCB9ID0gdW5jaGFuZ2VkTmFtZXM7XHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRCaXRtYXA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEJpdG1hcCA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYml0bWFwKS50b1VpbnQ4QXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQmFzZTY0RGVjb2RlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0RlY29kaW5nIHRoZSBiYXNlNjQgYmxvb20gZmlsdGVyIGluIGV4aXN0ZW5jZSBmaWx0ZXIgZmFpbGVkICgnICtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyk7IGlnbm9yaW5nIHRoZSBibG9vbSBmaWx0ZXIgYW5kIGZhbGxpbmcgYmFjayB0byBmdWxsIHJlLXF1ZXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGJsb29tRmlsdGVyO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEJsb29tRmlsdGVyIHRocm93cyBlcnJvciBpZiB0aGUgaW5wdXRzIGFyZSBpbnZhbGlkLlxyXG4gICAgICAgICAgICBibG9vbUZpbHRlciA9IG5ldyBCbG9vbUZpbHRlcihub3JtYWxpemVkQml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBCbG9vbUZpbHRlckVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdCbG9vbUZpbHRlciBlcnJvcjogJywgZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0FwcGx5aW5nIGJsb29tIGZpbHRlciBmYWlsZWQ6ICcsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibG9vbUZpbHRlci5iaXRDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBibG9vbSBmaWx0ZXIgdG8gcmVtb3ZlIHRoZSBkZWxldGVkIGRvY3VtZW50cywgYW5kIHJldHVybiB0aGVcclxuICAgICAqIGFwcGxpY2F0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgYXBwbHlCbG9vbUZpbHRlcihibG9vbUZpbHRlciwgd2F0Y2hDaGFuZ2UsIGN1cnJlbnRDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIuY291bnQ7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZERvY3VtZW50Q291bnQgPSB0aGlzLmZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLnRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRDb3VudCA9PT0gY3VycmVudENvdW50IC0gcmVtb3ZlZERvY3VtZW50Q291bnRcclxuICAgICAgICAgICAgPyAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqL1xyXG4gICAgICAgICAgICA6IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgb3V0IHJlbW92ZWQgZG9jdW1lbnRzIGJhc2VkIG9uIGJsb29tIGZpbHRlciBtZW1iZXJzaGlwIHJlc3VsdCBhbmRcclxuICAgICAqIHJldHVybiBudW1iZXIgb2YgZG9jdW1lbnRzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIGZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGxldCByZW1vdmFsQ291bnQgPSAwO1xyXG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0RGF0YWJhc2VJZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudFBhdGggPSBgcHJvamVjdHMvJHtkYXRhYmFzZUlkLnByb2plY3RJZH1gICtcclxuICAgICAgICAgICAgICAgIGAvZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX1gICtcclxuICAgICAgICAgICAgICAgIGAvZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YDtcclxuICAgICAgICAgICAgaWYgKCFibG9vbUZpbHRlci5taWdodENvbnRhaW4oZG9jdW1lbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgLyp1cGRhdGVkRG9jdW1lbnQ9Ki8gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmFsQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZW1vdmFsQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50bHkgYWNjdW11bGF0ZWQgc3RhdGUgaW50byBhIHJlbW90ZSBldmVudCBhdCB0aGVcclxuICAgICAqIHByb3ZpZGVkIHNuYXBzaG90IHZlcnNpb24uIFJlc2V0cyB0aGUgYWNjdW11bGF0ZWQgY2hhbmdlcyBiZWZvcmUgcmV0dXJuaW5nLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmZvckVhY2goKHRhcmdldFN0YXRlLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTdGF0ZS5jdXJyZW50ICYmIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgcXVlcmllcyBmb3IgZG9jdW1lbnQgdGhhdCBkb24ndCBleGlzdCBjYW4gcHJvZHVjZSBhbiBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBzZXQuIFRvIHVwZGF0ZSBvdXIgbG9jYWwgY2FjaGUsIHdlIHN5bnRoZXNpemUgYSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBpZiB3ZSBoYXZlIG5vdCBwcmV2aW91c2x5IHJlY2VpdmVkIHRoZSBkb2N1bWVudC4gVGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmVzIHRoZSBsaW1ibyBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQsIHJlbW92aW5nIGl0IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAvLyBsaW1ib0RvY3VtZW50UmVmcy5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oZGltb25kKTogSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGFuIGV4cGxpY2l0IGxvb2t1cCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHJlc3VsdGluZyBpbiBhbiBleHBsaWNpdCBkZWxldGUgbWVzc2FnZSBhbmQgd2UgY291bGRcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBzcGVjaWFsIGxvZ2ljLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleSh0YXJnZXREYXRhLnRhcmdldC5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmdldChrZXkpID09PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCBzbmFwc2hvdFZlcnNpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U3RhdGUuaGFzUGVuZGluZ0NoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFuZ2VzLnNldCh0YXJnZXRJZCwgdGFyZ2V0U3RhdGUudG9UYXJnZXRDaGFuZ2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUuY2xlYXJQZW5kaW5nQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIC8vIFdlIGV4dHJhY3QgdGhlIHNldCBvZiBsaW1iby1vbmx5IGRvY3VtZW50IHVwZGF0ZXMgYXMgdGhlIEdDIGxvZ2ljXHJcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlcyBkb2N1bWVudHMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSB0YXJnZXQgY2FjaGUuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUT0RPKGdzb2x0aXMpOiBFeHBhbmQgb24gdGhpcyBjb21tZW50IG9uY2UgR0MgaXMgYXZhaWxhYmxlIGluIHRoZSBKU1xyXG4gICAgICAgIC8vIGNsaWVudC5cclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZm9yRWFjaCgoa2V5LCB0YXJnZXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpc09ubHlMaW1ib1RhcmdldCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaFdoaWxlKHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldERhdGEgJiZcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhLnB1cnBvc2UgIT09IFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbmx5TGltYm9UYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc09ubHlMaW1ib1RhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IHJlc29sdmVkTGltYm9Eb2N1bWVudHMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuZm9yRWFjaCgoXywgZG9jKSA9PiBkb2Muc2V0UmVhZFRpbWUoc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlRXZlbnQgPSBuZXcgUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uLCB0YXJnZXRDaGFuZ2VzLCB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMsIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcywgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVFdmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgZG9jdW1lbnQgdXBkYXRlcyBhbmRcclxuICAgICAqIGl0cyBkb2N1bWVudCBrZXkgdG8gdGhlIGdpdmVuIHRhcmdldCdzIG1hcHBpbmcuXHJcbiAgICAgKi9cclxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAgICBhZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2N1bWVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGFuZ2VUeXBlID0gdGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBkb2N1bWVudC5rZXkpXHJcbiAgICAgICAgICAgID8gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovXHJcbiAgICAgICAgICAgIDogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGUuYWRkRG9jdW1lbnRDaGFuZ2UoZG9jdW1lbnQua2V5LCBjaGFuZ2VUeXBlKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBkb2N1bWVudCBmcm9tIHRoZSB0YXJnZXQgbWFwcGluZy4gSWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBubyBsb25nZXIgbWF0Y2hlcyB0aGUgdGFyZ2V0LCBidXQgdGhlIGRvY3VtZW50J3Mgc3RhdGUgaXMgc3RpbGxcclxuICAgICAqIGtub3duIChlLmcuIHdlIGtub3cgdGhhdCB0aGUgZG9jdW1lbnQgd2FzIGRlbGV0ZWQgb3Igd2UgcmVjZWl2ZWQgdGhlIGNoYW5nZVxyXG4gICAgICogdGhhdCBjYXVzZWQgdGhlIGZpbHRlciBtaXNtYXRjaCksIHRoZSBuZXcgZG9jdW1lbnQgY2FuIGJlIHByb3ZpZGVkXHJcbiAgICAgKiB0byB1cGRhdGUgdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICAgIHJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCB1cGRhdGVkRG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLmVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKTtcclxuICAgICAgICBpZiAodGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFN0YXRlLmFkZERvY3VtZW50Q2hhbmdlKGtleSwgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IG1heSBoYXZlIGVudGVyZWQgYW5kIGxlZnQgdGhlIHRhcmdldCBiZWZvcmUgd2UgcmFpc2VkIGFcclxuICAgICAgICAgICAgLy8gc25hcHNob3QsIHNvIHdlIGNhbiBqdXN0IGlnbm9yZSB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZW1vdmVEb2N1bWVudENoYW5nZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGtleSwgdGhpcy5lbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KS5kZWxldGUodGFyZ2V0SWQpKTtcclxuICAgICAgICBpZiAodXBkYXRlZERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcy5pbnNlcnQoa2V5LCB1cGRhdGVkRG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmRlbGV0ZSh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY291bnQgb2YgZG9jdW1lbnRzIGluIHRoZSB0YXJnZXQuIFRoaXMgaW5jbHVkZXMgYm90aFxyXG4gICAgICogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdG8gYmUgcGFydCBvZiB0aGVcclxuICAgICAqIHRhcmdldCBhcyB3ZWxsIGFzIGFueSBhY2N1bXVsYXRlZCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50RG9jdW1lbnRDb3VudEZvclRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gdGFyZ2V0U3RhdGUudG9UYXJnZXRDaGFuZ2UoKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKS5zaXplICtcclxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgLVxyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgYWNrcyBuZWVkZWQgZnJvbSB3YXRjaCBiZWZvcmUgd2UgY2FuIGNvbnNpZGVyIHRoZVxyXG4gICAgICogc2VydmVyIHRvIGJlICdpbi1zeW5jJyB3aXRoIHRoZSBjbGllbnQncyBhY3RpdmUgdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgcmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0SWQpIHtcclxuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0IHdlIGdldCB3ZSBuZWVkIHRvIHJlY29yZCB3ZSBuZWVkIGEgcmVzcG9uc2UgZm9yIGl0LlxyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGUucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QoKTtcclxuICAgIH1cclxuICAgIGVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudGFyZ2V0U3RhdGVzLmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRhcmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLnNldCh0YXJnZXRJZCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0TWFwcGluZyA9IHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIXRhcmdldE1hcHBpbmcpIHtcclxuICAgICAgICAgICAgdGFyZ2V0TWFwcGluZyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGtleSwgdGFyZ2V0TWFwcGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRNYXBwaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSB1c2VyIGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhpcyB0YXJnZXQgKGJ5IGNhbGxpbmdcclxuICAgICAqIGBnZXRUYXJnZXREYXRhRm9yVGFyZ2V0KClgKSBhbmQgdGhhdCB3ZSBhcmUgbm90IHdhaXRpbmcgZm9yIHBlbmRpbmcgQUREc1xyXG4gICAgICogZnJvbSB3YXRjaC5cclxuICAgICAqL1xyXG4gICAgaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRBY3RpdmUgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpICE9PSBudWxsO1xyXG4gICAgICAgIGlmICghdGFyZ2V0QWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZywgJ0RldGVjdGVkIGluYWN0aXZlIHRhcmdldCcsIHRhcmdldElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldEFjdGl2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVGFyZ2V0RGF0YSBmb3IgYW4gYWN0aXZlIHRhcmdldCAoaS5lLiBhIHRhcmdldCB0aGF0IHRoZSB1c2VyXHJcbiAgICAgKiBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoYXQgaGFzIG5vIG91dHN0YW5kaW5nIHRhcmdldCBjaGFuZ2UgcmVxdWVzdHMpLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLnRhcmdldFN0YXRlcy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZSAmJiB0YXJnZXRTdGF0ZS5pc1BlbmRpbmdcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFRhcmdldERhdGFGb3JUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHN0YXRlIG9mIGEgV2F0Y2ggdGFyZ2V0IHRvIGl0cyBpbml0aWFsIHN0YXRlIChlLmcuIHNldHNcclxuICAgICAqICdjdXJyZW50JyB0byBmYWxzZSwgY2xlYXJzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHJlbW92ZXMgaXRzIHRhcmdldCBtYXBwaW5nXHJcbiAgICAgKiBmcm9tIGFsbCBkb2N1bWVudHMpLlxyXG4gICAgICovXHJcbiAgICByZXNldFRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLnNldCh0YXJnZXRJZCwgbmV3IFRhcmdldFN0YXRlKCkpO1xyXG4gICAgICAgIC8vIFRyaWdnZXIgcmVtb3ZhbCBmb3IgYW55IGRvY3VtZW50cyBjdXJyZW50bHkgbWFwcGVkIHRvIHRoaXMgdGFyZ2V0LlxyXG4gICAgICAgIC8vIFRoZXNlIHJlbW92YWxzIHdpbGwgYmUgcGFydCBvZiB0aGUgaW5pdGlhbCBzbmFwc2hvdCBpZiBXYXRjaCBkb2VzIG5vdFxyXG4gICAgICAgIC8vIHJlc2VuZCB0aGVzZSBkb2N1bWVudHMuXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIC8qdXBkYXRlZERvY3VtZW50PSovIG51bGwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIExvY2FsU3RvcmUgY29uc2lkZXJzIHRoZSBkb2N1bWVudCB0byBiZSBwYXJ0IG9mIHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0tleXMuaGFzKGtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZG9jdW1lbnRUYXJnZXRNYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxufVxyXG5mdW5jdGlvbiBzbmFwc2hvdENoYW5nZXNNYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEluZm9Gb3JUZXN0aW5nSG9va3MobG9jYWxDYWNoZUNvdW50LCBleGlzdGVuY2VGaWx0ZXIsIGRhdGFiYXNlSWQsIGJsb29tRmlsdGVyLCBibG9vbUZpbHRlclN0YXR1cykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgbG9jYWxDYWNoZUNvdW50LFxyXG4gICAgICAgIGV4aXN0ZW5jZUZpbHRlckNvdW50OiBleGlzdGVuY2VGaWx0ZXIuY291bnQsXHJcbiAgICAgICAgZGF0YWJhc2VJZDogZGF0YWJhc2VJZC5kYXRhYmFzZSxcclxuICAgICAgICBwcm9qZWN0SWQ6IGRhdGFiYXNlSWQucHJvamVjdElkXHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5jaGFuZ2VkTmFtZXMgPSBleGlzdGVuY2VGaWx0ZXIudW5jaGFuZ2VkTmFtZXM7XHJcbiAgICBpZiAodW5jaGFuZ2VkTmFtZXMpIHtcclxuICAgICAgICByZXN1bHQuYmxvb21GaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIGFwcGxpZWQ6IGJsb29tRmlsdGVyU3RhdHVzID09PSAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqLyxcclxuICAgICAgICAgICAgaGFzaENvdW50OiAoX2EgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuaGFzaENvdW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxyXG4gICAgICAgICAgICBiaXRtYXBMZW5ndGg6IChfZCA9IChfYyA9IChfYiA9IHVuY2hhbmdlZE5hbWVzID09PSBudWxsIHx8IHVuY2hhbmdlZE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmNoYW5nZWROYW1lcy5iaXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYml0bWFwKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAoX2YgPSAoX2UgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuYml0cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhZGRpbmcpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDAsXHJcbiAgICAgICAgICAgIG1pZ2h0Q29udGFpbjogKHZhbHVlKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGJsb29tRmlsdGVyID09PSBudWxsIHx8IGJsb29tRmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9vbUZpbHRlci5taWdodENvbnRhaW4odmFsdWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTsgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERJUkVDVElPTlMgPSAoKCkgPT4ge1xyXG4gICAgY29uc3QgZGlycyA9IHt9O1xyXG4gICAgZGlyc1tcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9dID0gJ0FTQ0VORElORyc7XHJcbiAgICBkaXJzW1wiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXSA9ICdERVNDRU5ESU5HJztcclxuICAgIHJldHVybiBkaXJzO1xyXG59KSgpO1xyXG5jb25zdCBPUEVSQVRPUlMgPSAoKCkgPT4ge1xyXG4gICAgY29uc3Qgb3BzID0ge307XHJcbiAgICBvcHNbXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovXSA9ICdMRVNTX1RIQU4nO1xyXG4gICAgb3BzW1wiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0xFU1NfVEhBTl9PUl9FUVVBTCc7XHJcbiAgICBvcHNbXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovXSA9ICdHUkVBVEVSX1RIQU4nO1xyXG4gICAgb3BzW1wiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0dSRUFURVJfVEhBTl9PUl9FUVVBTCc7XHJcbiAgICBvcHNbXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovXSA9ICdFUVVBTCc7XHJcbiAgICBvcHNbXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqL10gPSAnTk9UX0VRVUFMJztcclxuICAgIG9wc1tcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi9dID0gJ0FSUkFZX0NPTlRBSU5TJztcclxuICAgIG9wc1tcImluXCIgLyogT3BlcmF0b3IuSU4gKi9dID0gJ0lOJztcclxuICAgIG9wc1tcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL10gPSAnTk9UX0lOJztcclxuICAgIG9wc1tcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqL10gPSAnQVJSQVlfQ09OVEFJTlNfQU5ZJztcclxuICAgIHJldHVybiBvcHM7XHJcbn0pKCk7XHJcbmNvbnN0IENPTVBPU0lURV9PUEVSQVRPUlMgPSAoKCkgPT4ge1xyXG4gICAgY29uc3Qgb3BzID0ge307XHJcbiAgICBvcHNbXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi9dID0gJ0FORCc7XHJcbiAgICBvcHNbXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovXSA9ICdPUic7XHJcbiAgICByZXR1cm4gb3BzO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBhc3NlcnRQcmVzZW50KHZhbHVlLCBkZXNjcmlwdGlvbikge1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGdlbmVyYXRlcyBKc29uT2JqZWN0IHZhbHVlcyBmb3IgdGhlIERhdGFzdG9yZSBBUEkgc3VpdGFibGUgZm9yXHJcbiAqIHNlbmRpbmcgdG8gZWl0aGVyIEdSUEMgc3R1YiBtZXRob2RzIG9yIHZpYSB0aGUgSlNPTi9IVFRQIFJFU1QgQVBJLlxyXG4gKlxyXG4gKiBUaGUgc2VyaWFsaXplciBzdXBwb3J0cyBib3RoIFByb3RvYnVmLmpzIGFuZCBQcm90bzMgSlNPTiBmb3JtYXRzLiBCeVxyXG4gKiBzZXR0aW5nIGB1c2VQcm90bzNKc29uYCB0byB0cnVlLCB0aGUgc2VyaWFsaXplciB3aWxsIHVzZSB0aGUgUHJvdG8zIEpTT05cclxuICogZm9ybWF0LlxyXG4gKlxyXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgUHJvdG8zIEpTT04gZm9ybWF0IGNoZWNrXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzMjanNvblxyXG4gKlxyXG4gKiBUT0RPKGtsaW10KTogV2UgY2FuIHJlbW92ZSB0aGUgZGF0YWJhc2VJZCBhcmd1bWVudCBpZiB3ZSBrZWVwIHRoZSBmdWxsXHJcbiAqIHJlc291cmNlIG5hbWUgaW4gZG9jdW1lbnRzLlxyXG4gKi9cclxuY2xhc3MgSnNvblByb3RvU2VyaWFsaXplciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCB1c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLnVzZVByb3RvM0pzb24gPSB1c2VQcm90bzNKc29uO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21ScGNTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICBjb25zdCBjb2RlID0gc3RhdHVzLmNvZGUgPT09IHVuZGVmaW5lZCA/IENvZGUuVU5LTk9XTiA6IG1hcENvZGVGcm9tUnBjQ29kZShzdGF0dXMuY29kZSk7XHJcbiAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIHN0YXR1cy5tZXNzYWdlIHx8ICcnKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGZvciBhIG51bWJlciAob3IgbnVsbCkgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvXHJcbiAqIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgcHJvdG8uXHJcbiAqIERPIE5PVCBVU0UgVEhJUyBGT1IgQU5ZVEhJTkcgRUxTRS5cclxuICogVGhpcyBtZXRob2QgY2hlYXRzLiBJdCdzIHR5cGVkIGFzIHJldHVybmluZyBcIm51bWJlclwiIGJlY2F1c2UgdGhhdCdzIHdoYXRcclxuICogb3VyIGdlbmVyYXRlZCBwcm90byBpbnRlcmZhY2VzIHNheSBJbnQzMlZhbHVlIG11c3QgYmUuIEJ1dCBHUlBDIGFjdHVhbGx5XHJcbiAqIGV4cGVjdHMgYSB7IHZhbHVlOiA8bnVtYmVyPiB9IHN0cnVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB2YWwpIHtcclxuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24gfHwgaXNOdWxsT3JVbmRlZmluZWQodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBudW1iZXIgKG9yIG51bGwpIGZyb20gYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQzMlByb3RvKHZhbCkge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJlc3VsdCA9IHZhbC52YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHZhbDtcclxuICAgIH1cclxuICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGZvciBhIERhdGUgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB0aW1lc3RhbXApIHtcclxuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICAvLyBTZXJpYWxpemUgdG8gSVNPLTg2MDEgZGF0ZSBmb3JtYXQsIGJ1dCB3aXRoIGZ1bGwgbmFubyByZXNvbHV0aW9uLlxyXG4gICAgICAgIC8vIFNpbmNlIEpTIERhdGUgaGFzIG9ubHkgbWlsbGlzLCBsZXQncyBvbmx5IHVzZSBpdCBmb3IgdGhlIHNlY29uZHMgYW5kXHJcbiAgICAgICAgLy8gdGhlbiBtYW51YWxseSBhZGQgdGhlIGZyYWN0aW9ucyB0byB0aGUgZW5kLlxyXG4gICAgICAgIGNvbnN0IGpzRGF0ZVN0ciA9IG5ldyBEYXRlKHRpbWVzdGFtcC5zZWNvbmRzICogMTAwMCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAvLyBSZW1vdmUgLnh4eCBmcmFjIHBhcnQgYW5kIFogaW4gdGhlIGVuZC5cclxuICAgICAgICBjb25zdCBzdHJVbnRpbFNlY29uZHMgPSBqc0RhdGVTdHIucmVwbGFjZSgvXFwuXFxkKi8sICcnKS5yZXBsYWNlKCdaJywgJycpO1xyXG4gICAgICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gb3V0IHRvIDkgZGlnaXRzIChuYW5vcykuXHJcbiAgICAgICAgY29uc3QgbmFub1N0ciA9ICgnMDAwMDAwMDAwJyArIHRpbWVzdGFtcC5uYW5vc2Vjb25kcykuc2xpY2UoLTkpO1xyXG4gICAgICAgIHJldHVybiBgJHtzdHJVbnRpbFNlY29uZHN9LiR7bmFub1N0cn1aYDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlY29uZHM6ICcnICsgdGltZXN0YW1wLnNlY29uZHMsXHJcbiAgICAgICAgICAgIG5hbm9zOiB0aW1lc3RhbXAubmFub3NlY29uZHNcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21UaW1lc3RhbXAoZGF0ZSkge1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGRhdGUpO1xyXG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAodGltZXN0YW1wLnNlY29uZHMsIHRpbWVzdGFtcC5uYW5vcyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYnl0ZXMgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbiBhIHByb3RvLlxyXG4gKlxyXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9CeXRlcyhzZXJpYWxpemVyLCBieXRlcykge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIHJldHVybiBieXRlcy50b0Jhc2U2NCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvVWludDhBcnJheSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgQnl0ZVN0cmluZyBiYXNlZCBvbiB0aGUgcHJvdG8gc3RyaW5nIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJ5dGVzKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xyXG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcodmFsdWUgPyB2YWx1ZSA6ICcnKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGhhcmRBc3NlcnQodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYm90aCBCdWZmZXIgYW5kIFVpbnQ4QXJyYXksXHJcbiAgICAgICAgICAgIC8vIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCBCdWZmZXIgZXh0ZW5kcyBVaW50OEFycmF5LiBJbiBzb21lXHJcbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50cywgc3VjaCBhcyBqc2RvbSwgdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBCdWZmZXJcclxuICAgICAgICAgICAgLy8gZG9lcyBub3QgaW5kaWNhdGUgdGhhdCBpdCBleHRlbmRzIFVpbnQ4QXJyYXkuXHJcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyIHx8XHJcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkodmFsdWUgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvVmVyc2lvbihzZXJpYWxpemVyLCB2ZXJzaW9uKSB7XHJcbiAgICByZXR1cm4gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdmVyc2lvbi50b1RpbWVzdGFtcCgpKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tVmVyc2lvbih2ZXJzaW9uKSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhdmVyc2lvbik7XHJcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAoZnJvbVRpbWVzdGFtcCh2ZXJzaW9uKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZXNvdXJjZU5hbWUoZGF0YWJhc2VJZCwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHBhdGgpLmNhbm9uaWNhbFN0cmluZygpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHBhdGgpIHtcclxuICAgIGNvbnN0IHJlc291cmNlUGF0aCA9IGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKS5jaGlsZCgnZG9jdW1lbnRzJyk7XHJcbiAgICByZXR1cm4gcGF0aCA9PT0gdW5kZWZpbmVkID8gcmVzb3VyY2VQYXRoIDogcmVzb3VyY2VQYXRoLmNoaWxkKHBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21SZXNvdXJjZU5hbWUobmFtZSkge1xyXG4gICAgY29uc3QgcmVzb3VyY2UgPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcclxuICAgIGhhcmRBc3NlcnQoaXNWYWxpZFJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xyXG4gICAgcmV0dXJuIHJlc291cmNlO1xyXG59XHJcbmZ1bmN0aW9uIHRvTmFtZShzZXJpYWxpemVyLCBrZXkpIHtcclxuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIGtleS5wYXRoKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tTmFtZShzZXJpYWxpemVyLCBuYW1lKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IGZyb21SZXNvdXJjZU5hbWUobmFtZSk7XHJcbiAgICBpZiAocmVzb3VyY2UuZ2V0KDEpICE9PSBzZXJpYWxpemVyLmRhdGFiYXNlSWQucHJvamVjdElkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBwcm9qZWN0OiAnICtcclxuICAgICAgICAgICAgcmVzb3VyY2UuZ2V0KDEpICtcclxuICAgICAgICAgICAgJyB2cyAnICtcclxuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzb3VyY2UuZ2V0KDMpICE9PSBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IGRhdGFiYXNlOiAnICtcclxuICAgICAgICAgICAgcmVzb3VyY2UuZ2V0KDMpICtcclxuICAgICAgICAgICAgJyB2cyAnICtcclxuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2UpKTtcclxufVxyXG5mdW5jdGlvbiB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gdG9SZXNvdXJjZU5hbWUoc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXRoKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tUXVlcnlQYXRoKG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IGZyb21SZXNvdXJjZU5hbWUobmFtZSk7XHJcbiAgICAvLyBJbiB2MWJldGExIHF1ZXJpZXMgZm9yIGNvbGxlY3Rpb25zIGF0IHRoZSByb290IGRpZCBub3QgaGF2ZSBhIHRyYWlsaW5nXHJcbiAgICAvLyBcIi9kb2N1bWVudHNcIi4gSW4gdjEgYWxsIHJlc291cmNlIHBhdGhzIGNvbnRhaW4gXCIvZG9jdW1lbnRzXCIuIFByZXNlcnZlIHRoZVxyXG4gICAgLy8gYWJpbGl0eSB0byByZWFkIHRoZSB2MWJldGExIGZvcm0gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBxdWVyaWVzIHBlcnNpc3RlZFxyXG4gICAgLy8gaW4gdGhlIGxvY2FsIHRhcmdldCBjYWNoZS5cclxuICAgIGlmIChyZXNvdXJjZU5hbWUubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZU5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVuY29kZWREYXRhYmFzZUlkKHNlcmlhbGl6ZXIpIHtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKFtcclxuICAgICAgICAncHJvamVjdHMnLFxyXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQsXHJcbiAgICAgICAgJ2RhdGFiYXNlcycsXHJcbiAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlXHJcbiAgICBdKTtcclxuICAgIHJldHVybiBwYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG59XHJcbmZ1bmN0aW9uIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXHJcbiAgICAgICAgJ3Byb2plY3RzJyxcclxuICAgICAgICBkYXRhYmFzZUlkLnByb2plY3RJZCxcclxuICAgICAgICAnZGF0YWJhc2VzJyxcclxuICAgICAgICBkYXRhYmFzZUlkLmRhdGFiYXNlXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZU5hbWUpIHtcclxuICAgIGhhcmRBc3NlcnQocmVzb3VyY2VOYW1lLmxlbmd0aCA+IDQgJiYgcmVzb3VyY2VOYW1lLmdldCg0KSA9PT0gJ2RvY3VtZW50cycpO1xyXG4gICAgcmV0dXJuIHJlc291cmNlTmFtZS5wb3BGaXJzdCg1KTtcclxufVxyXG4vKiogQ3JlYXRlcyBhIERvY3VtZW50IHByb3RvIGZyb20ga2V5IGFuZCBmaWVsZHMgKGJ1dCBubyBjcmVhdGUvdXBkYXRlIHRpbWUpICovXHJcbmZ1bmN0aW9uIHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBrZXksIGZpZWxkcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwga2V5KSxcclxuICAgICAgICBmaWVsZHM6IGZpZWxkcy52YWx1ZS5tYXBWYWx1ZS5maWVsZHNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdG9Eb2N1bWVudChzZXJpYWxpemVyLCBkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQua2V5KSxcclxuICAgICAgICBmaWVsZHM6IGRvY3VtZW50LmRhdGEudmFsdWUubWFwVmFsdWUuZmllbGRzLFxyXG4gICAgICAgIHVwZGF0ZVRpbWU6IHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIGRvY3VtZW50LnZlcnNpb24udG9UaW1lc3RhbXAoKSksXHJcbiAgICAgICAgY3JlYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQuY3JlYXRlVGltZS50b1RpbWVzdGFtcCgpKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQsIGhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xyXG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQubmFtZSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZG9jdW1lbnQudXBkYXRlVGltZSk7XHJcbiAgICAvLyBJZiB3ZSByZWFkIGEgZG9jdW1lbnQgZnJvbSBwZXJzaXN0ZW5jZSB0aGF0IGlzIG1pc3NpbmcgY3JlYXRlVGltZSwgaXQncyBkdWVcclxuICAgIC8vIHRvIG9sZGVyIFNESyB2ZXJzaW9ucyBub3Qgc3RvcmluZyB0aGlzIGluZm9ybWF0aW9uLiBJbiBzdWNoIGNhc2VzLCB3ZSdsbFxyXG4gICAgLy8gc2V0IHRoZSBjcmVhdGVUaW1lIHRvIHplcm8uIFRoaXMgY2FuIGJlIHJlbW92ZWQgaW4gdGhlIGxvbmcgdGVybS5cclxuICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVUaW1lXHJcbiAgICAgICAgPyBmcm9tVmVyc2lvbihkb2N1bWVudC5jcmVhdGVUaW1lKVxyXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jdW1lbnQuZmllbGRzIH0gfSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xyXG4gICAgaWYgKGhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xyXG4gICAgICAgIHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNDb21taXR0ZWRNdXRhdGlvbnMgPyByZXN1bHQuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCkgOiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIGRvYykge1xyXG4gICAgaGFyZEFzc2VydCghIWRvYy5mb3VuZCk7XHJcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC5uYW1lKTtcclxuICAgIGFzc2VydFByZXNlbnQoZG9jLmZvdW5kLnVwZGF0ZVRpbWUpO1xyXG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jLmZvdW5kLm5hbWUpO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcclxuICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBkb2MuZm91bmQuY3JlYXRlVGltZVxyXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jLmZvdW5kLmNyZWF0ZVRpbWUpXHJcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2MuZm91bmQuZmllbGRzIH0gfSk7XHJcbiAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpIHtcclxuICAgIGhhcmRBc3NlcnQoISFyZXN1bHQubWlzc2luZyk7XHJcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0LnJlYWRUaW1lKTtcclxuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHJlc3VsdC5taXNzaW5nKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihyZXN1bHQucmVhZFRpbWUpO1xyXG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2Uoc2VyaWFsaXplciwgcmVzdWx0KSB7XHJcbiAgICBpZiAoJ2ZvdW5kJyBpbiByZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnbWlzc2luZycgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21NaXNzaW5nKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFpbCgpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21XYXRjaENoYW5nZShzZXJpYWxpemVyLCBjaGFuZ2UpIHtcclxuICAgIGxldCB3YXRjaENoYW5nZTtcclxuICAgIGlmICgndGFyZ2V0Q2hhbmdlJyBpbiBjaGFuZ2UpIHtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS50YXJnZXRDaGFuZ2UpO1xyXG4gICAgICAgIC8vIHByb3RvMyBkZWZhdWx0IHZhbHVlIGlzIHVuc2V0IGluIEpTT04gKHVuZGVmaW5lZCksIHNvIHVzZSAnTk9fQ0hBTkdFJ1xyXG4gICAgICAgIC8vIGlmIHVuc2V0XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBmcm9tV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZShjaGFuZ2UudGFyZ2V0Q2hhbmdlLnRhcmdldENoYW5nZVR5cGUgfHwgJ05PX0NIQU5HRScpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGNoYW5nZS50YXJnZXRDaGFuZ2UudGFyZ2V0SWRzIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VtZVRva2VuID0gZnJvbUJ5dGVzKHNlcmlhbGl6ZXIsIGNoYW5nZS50YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgIGNvbnN0IGNhdXNlUHJvdG8gPSBjaGFuZ2UudGFyZ2V0Q2hhbmdlLmNhdXNlO1xyXG4gICAgICAgIGNvbnN0IGNhdXNlID0gY2F1c2VQcm90byAmJiBmcm9tUnBjU3RhdHVzKGNhdXNlUHJvdG8pO1xyXG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IFdhdGNoVGFyZ2V0Q2hhbmdlKHN0YXRlLCB0YXJnZXRJZHMsIHJlc3VtZVRva2VuLCBjYXVzZSB8fCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb2N1bWVudENoYW5nZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRDaGFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IGVudGl0eUNoYW5nZSA9IGNoYW5nZS5kb2N1bWVudENoYW5nZTtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGVudGl0eUNoYW5nZS5kb2N1bWVudCk7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQubmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQudXBkYXRlVGltZSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihlbnRpdHlDaGFuZ2UuZG9jdW1lbnQudXBkYXRlVGltZSk7XHJcbiAgICAgICAgY29uc3QgY3JlYXRlVGltZSA9IGVudGl0eUNoYW5nZS5kb2N1bWVudC5jcmVhdGVUaW1lXHJcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LmNyZWF0ZVRpbWUpXHJcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgT2JqZWN0VmFsdWUoe1xyXG4gICAgICAgICAgICBtYXBWYWx1ZTogeyBmaWVsZHM6IGVudGl0eUNoYW5nZS5kb2N1bWVudC5maWVsZHMgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS50YXJnZXRJZHMgfHwgW107XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xyXG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IERvY3VtZW50V2F0Y2hDaGFuZ2UodXBkYXRlZFRhcmdldElkcywgcmVtb3ZlZFRhcmdldElkcywgZG9jLmtleSwgZG9jKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb2N1bWVudERlbGV0ZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnREZWxldGUpO1xyXG4gICAgICAgIGNvbnN0IGRvY0RlbGV0ZSA9IGNoYW5nZS5kb2N1bWVudERlbGV0ZTtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY0RlbGV0ZS5kb2N1bWVudCk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jRGVsZXRlLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZG9jRGVsZXRlLnJlYWRUaW1lXHJcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZG9jRGVsZXRlLnJlYWRUaW1lKVxyXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NEZWxldGUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBkb2Mua2V5LCBkb2MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50UmVtb3ZlJyBpbiBjaGFuZ2UpIHtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5kb2N1bWVudFJlbW92ZSk7XHJcbiAgICAgICAgY29uc3QgZG9jUmVtb3ZlID0gY2hhbmdlLmRvY3VtZW50UmVtb3ZlO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZG9jUmVtb3ZlLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2NSZW1vdmUuZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NSZW1vdmUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBrZXksIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2ZpbHRlcicgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBpbXBsZW1lbnQgZXhpc3RlbmNlIGZpbHRlciBwYXJzaW5nIHdpdGggc3RyYXRlZ3kuXHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZmlsdGVyKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjaGFuZ2UuZmlsdGVyO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZmlsdGVyLnRhcmdldElkKTtcclxuICAgICAgICBjb25zdCB7IGNvdW50ID0gMCwgdW5jaGFuZ2VkTmFtZXMgfSA9IGZpbHRlcjtcclxuICAgICAgICBjb25zdCBleGlzdGVuY2VGaWx0ZXIgPSBuZXcgRXhpc3RlbmNlRmlsdGVyKGNvdW50LCB1bmNoYW5nZWROYW1lcyk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBmaWx0ZXIudGFyZ2V0SWQ7XHJcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKHRhcmdldElkLCBleGlzdGVuY2VGaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3YXRjaENoYW5nZTtcclxufVxyXG5mdW5jdGlvbiBmcm9tV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgaWYgKHN0YXRlID09PSAnTk9fQ0hBTkdFJykge1xyXG4gICAgICAgIHJldHVybiAwIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuTm9DaGFuZ2UgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ0FERCcpIHtcclxuICAgICAgICByZXR1cm4gMSAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkFkZGVkICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdSRU1PVkUnKSB7XHJcbiAgICAgICAgcmV0dXJuIDIgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZW1vdmVkICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdDVVJSRU5UJykge1xyXG4gICAgICAgIHJldHVybiAzIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQ3VycmVudCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVTRVQnKSB7XHJcbiAgICAgICAgcmV0dXJuIDQgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZXNldCAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmVyc2lvbkZyb21MaXN0ZW5SZXNwb25zZShjaGFuZ2UpIHtcclxuICAgIC8vIFdlIGhhdmUgb25seSByZWFjaGVkIGEgY29uc2lzdGVudCBzbmFwc2hvdCBmb3IgdGhlIGVudGlyZSBzdHJlYW0gaWYgdGhlcmVcclxuICAgIC8vIGlzIGEgcmVhZF90aW1lIHNldCBhbmQgaXQgYXBwbGllcyB0byBhbGwgdGFyZ2V0cyAoaS5lLiB0aGUgbGlzdCBvZlxyXG4gICAgLy8gdGFyZ2V0cyBpcyBlbXB0eSkuIFRoZSBiYWNrZW5kIGlzIGd1YXJhbnRlZWQgdG8gc2VuZCBzdWNoIHJlc3BvbnNlcy5cclxuICAgIGlmICghKCd0YXJnZXRDaGFuZ2UnIGluIGNoYW5nZSkpIHtcclxuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gY2hhbmdlLnRhcmdldENoYW5nZTtcclxuICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzICYmIHRhcmdldENoYW5nZS50YXJnZXRJZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIH1cclxuICAgIGlmICghdGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tVmVyc2lvbih0YXJnZXRDaGFuZ2UucmVhZFRpbWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvTXV0YXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24pIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi52YWx1ZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBEZWxldGVNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHsgZGVsZXRlOiB0b05hbWUoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5KSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB1cGRhdGU6IHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXksIG11dGF0aW9uLmRhdGEpLFxyXG4gICAgICAgICAgICB1cGRhdGVNYXNrOiB0b0RvY3VtZW50TWFzayhtdXRhdGlvbi5maWVsZE1hc2spXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgVmVyaWZ5TXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHZlcmlmeTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIGlmIChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJlc3VsdC51cGRhdGVUcmFuc2Zvcm1zID0gbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKTtcclxuICAgIH1cclxuICAgIGlmICghbXV0YXRpb24ucHJlY29uZGl0aW9uLmlzTm9uZSkge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50RG9jdW1lbnQgPSB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBtdXRhdGlvbi5wcmVjb25kaXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBmcm9tTXV0YXRpb24oc2VyaWFsaXplciwgcHJvdG8pIHtcclxuICAgIGNvbnN0IHByZWNvbmRpdGlvbiA9IHByb3RvLmN1cnJlbnREb2N1bWVudFxyXG4gICAgICAgID8gZnJvbVByZWNvbmRpdGlvbihwcm90by5jdXJyZW50RG9jdW1lbnQpXHJcbiAgICAgICAgOiBQcmVjb25kaXRpb24ubm9uZSgpO1xyXG4gICAgY29uc3QgZmllbGRUcmFuc2Zvcm1zID0gcHJvdG8udXBkYXRlVHJhbnNmb3Jtc1xyXG4gICAgICAgID8gcHJvdG8udXBkYXRlVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKVxyXG4gICAgICAgIDogW107XHJcbiAgICBpZiAocHJvdG8udXBkYXRlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChwcm90by51cGRhdGUubmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udXBkYXRlLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IE9iamVjdFZhbHVlKHtcclxuICAgICAgICAgICAgbWFwVmFsdWU6IHsgZmllbGRzOiBwcm90by51cGRhdGUuZmllbGRzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJvdG8udXBkYXRlTWFzaykge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZE1hc2sgPSBmcm9tRG9jdW1lbnRNYXNrKHByb3RvLnVwZGF0ZU1hc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB2YWx1ZSwgZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldE11dGF0aW9uKGtleSwgdmFsdWUsIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm90by5kZWxldGUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by5kZWxldGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdG8udmVyaWZ5KSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udmVyaWZ5KTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlcmlmeU11dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWU6IHRvVmVyc2lvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24udXBkYXRlVGltZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZXhpc3RzOiBwcmVjb25kaXRpb24uZXhpc3RzIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21QcmVjb25kaXRpb24ocHJlY29uZGl0aW9uKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZShmcm9tVmVyc2lvbihwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMocHJlY29uZGl0aW9uLmV4aXN0cyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLm5vbmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpIHtcclxuICAgIC8vIE5PVEU6IERlbGV0ZXMgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVUaW1lLlxyXG4gICAgbGV0IHZlcnNpb24gPSBwcm90by51cGRhdGVUaW1lXHJcbiAgICAgICAgPyBmcm9tVmVyc2lvbihwcm90by51cGRhdGVUaW1lKVxyXG4gICAgICAgIDogZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XHJcbiAgICBpZiAodmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAvLyBUaGUgRmlyZXN0b3JlIEVtdWxhdG9yIGN1cnJlbnRseSByZXR1cm5zIGFuIHVwZGF0ZSB0aW1lIG9mIDAgZm9yXHJcbiAgICAgICAgLy8gZGVsZXRlcyBvZiBub24tZXhpc3RpbmcgZG9jdW1lbnRzIChyYXRoZXIgdGhhbiBudWxsKS4gVGhpcyBicmVha3MgdGhlXHJcbiAgICAgICAgLy8gdGVzdCBcImdldCBkZWxldGVkIGRvYyB3aGlsZSBvZmZsaW5lIHdpdGggc291cmNlPWNhY2hlXCIgYXMgTm9Eb2N1bWVudHNcclxuICAgICAgICAvLyB3aXRoIHZlcnNpb24gMCBhcmUgZmlsdGVyZWQgYnkgSW5kZXhlZERiJ3MgUmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICAgICAgICAvLyBUT0RPKCMyMTQ5KTogUmVtb3ZlIHRoaXMgd2hlbiBFbXVsYXRvciBpcyBmaXhlZFxyXG4gICAgICAgIHZlcnNpb24gPSBmcm9tVmVyc2lvbihjb21taXRUaW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTXV0YXRpb25SZXN1bHQodmVyc2lvbiwgcHJvdG8udHJhbnNmb3JtUmVzdWx0cyB8fCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdyaXRlUmVzdWx0cyhwcm90b3MsIGNvbW1pdFRpbWUpIHtcclxuICAgIGlmIChwcm90b3MgJiYgcHJvdG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBoYXJkQXNzZXJ0KGNvbW1pdFRpbWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcmV0dXJuIHByb3Rvcy5tYXAocHJvdG8gPT4gZnJvbVdyaXRlUmVzdWx0KHByb3RvLCBjb21taXRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBmaWVsZFRyYW5zZm9ybSkge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xyXG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHNldFRvU2VydmVyVmFsdWU6ICdSRVFVRVNUX1RJTUUnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogdHJhbnNmb3JtLmVsZW1lbnRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogdHJhbnNmb3JtLmVsZW1lbnRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGluY3JlbWVudDogdHJhbnNmb3JtLm9wZXJhbmRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBwcm90bykge1xyXG4gICAgbGV0IHRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICBpZiAoJ3NldFRvU2VydmVyVmFsdWUnIGluIHByb3RvKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChwcm90by5zZXRUb1NlcnZlclZhbHVlID09PSAnUkVRVUVTVF9USU1FJyk7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2FwcGVuZE1pc3NpbmdFbGVtZW50cycgaW4gcHJvdG8pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm90by5hcHBlbmRNaXNzaW5nRWxlbWVudHMudmFsdWVzIHx8IFtdO1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVtb3ZlQWxsRnJvbUFycmF5JyBpbiBwcm90bykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByb3RvLnJlbW92ZUFsbEZyb21BcnJheS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnaW5jcmVtZW50JyBpbiBwcm90bykge1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvLmluY3JlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWVsZFBhdGggPSBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHByb3RvLmZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGZpZWxkUGF0aCwgdHJhbnNmb3JtKTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50c1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIHtcclxuICAgIHJldHVybiB7IGRvY3VtZW50czogW3RvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHRhcmdldC5wYXRoKV0gfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRzVGFyZ2V0KGRvY3VtZW50c1RhcmdldCkge1xyXG4gICAgY29uc3QgY291bnQgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzLmxlbmd0aDtcclxuICAgIGhhcmRBc3NlcnQoY291bnQgPT09IDEpO1xyXG4gICAgY29uc3QgbmFtZSA9IGRvY3VtZW50c1RhcmdldC5kb2N1bWVudHNbMF07XHJcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoZnJvbVF1ZXJ5UGF0aChuYW1lKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KSB7XHJcbiAgICAvLyBEaXNzZWN0IHRoZSBwYXRoIGludG8gcGFyZW50LCBjb2xsZWN0aW9uSWQsIGFuZCBvcHRpb25hbCBrZXkgZmlsdGVyLlxyXG4gICAgY29uc3QgcXVlcnlUYXJnZXQgPSB7IHN0cnVjdHVyZWRRdWVyeToge30gfTtcclxuICAgIGNvbnN0IHBhdGggPSB0YXJnZXQucGF0aDtcclxuICAgIGxldCBwYXJlbnQ7XHJcbiAgICBpZiAodGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHBhcmVudCA9IHBhdGg7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCxcclxuICAgICAgICAgICAgICAgIGFsbERlc2NlbmRhbnRzOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFyZW50ID0gcGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbeyBjb2xsZWN0aW9uSWQ6IHBhdGgubGFzdFNlZ21lbnQoKSB9XTtcclxuICAgIH1cclxuICAgIHF1ZXJ5VGFyZ2V0LnBhcmVudCA9IHRvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHBhcmVudCk7XHJcbiAgICBjb25zdCB3aGVyZSA9IHRvRmlsdGVycyh0YXJnZXQuZmlsdGVycyk7XHJcbiAgICBpZiAod2hlcmUpIHtcclxuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkud2hlcmUgPSB3aGVyZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yZGVyQnkgPSB0b09yZGVyKHRhcmdldC5vcmRlckJ5KTtcclxuICAgIGlmIChvcmRlckJ5KSB7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5Lm9yZGVyQnkgPSBvcmRlckJ5O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGltaXQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0LmxpbWl0KTtcclxuICAgIGlmIChsaW1pdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5saW1pdCA9IGxpbWl0O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XHJcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LnN0YXJ0QXQgPSB0b1N0YXJ0QXRDdXJzb3IodGFyZ2V0LnN0YXJ0QXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xyXG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5lbmRBdCA9IHRvRW5kQXRDdXJzb3IodGFyZ2V0LmVuZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfTtcclxufVxyXG5mdW5jdGlvbiB0b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHNlcmlhbGl6ZXIsIHRhcmdldCwgYWdncmVnYXRlcykge1xyXG4gICAgY29uc3QgeyBxdWVyeVRhcmdldCwgcGFyZW50IH0gPSB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCk7XHJcbiAgICBjb25zdCBhbGlhc01hcCA9IHt9O1xyXG4gICAgY29uc3QgYWdncmVnYXRpb25zID0gW107XHJcbiAgICBsZXQgYWdncmVnYXRpb25OdW0gPSAwO1xyXG4gICAgYWdncmVnYXRlcy5mb3JFYWNoKGFnZ3JlZ2F0ZSA9PiB7XHJcbiAgICAgICAgLy8gTWFwIGFsbCBjbGllbnQtc2lkZSBhbGlhc2VzIHRvIGEgdW5pcXVlIHNob3J0LWZvcm1cclxuICAgICAgICAvLyBhbGlhcy4gVGhpcyBhdm9pZHMgaXNzdWVzIHdpdGggY2xpZW50LXNpZGUgYWxpYXNlcyB0aGF0XHJcbiAgICAgICAgLy8gZXhjZWVkIHRoZSAxNTAwLWJ5dGUgc3RyaW5nIHNpemUgbGltaXQuXHJcbiAgICAgICAgY29uc3Qgc2VydmVyQWxpYXMgPSBgYWdncmVnYXRlXyR7YWdncmVnYXRpb25OdW0rK31gO1xyXG4gICAgICAgIGFsaWFzTWFwW3NlcnZlckFsaWFzXSA9IGFnZ3JlZ2F0ZS5hbGlhcztcclxuICAgICAgICBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdjb3VudCcpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgY291bnQ6IHt9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ2F2ZycpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgYXZnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ3N1bScpIHtcclxuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxyXG4gICAgICAgICAgICAgICAgc3VtOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXF1ZXN0OiB7XHJcbiAgICAgICAgICAgIHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHF1ZXJ5VGFyZ2V0LnBhcmVudFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWxpYXNNYXAsXHJcbiAgICAgICAgcGFyZW50XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XHJcbiAgICBsZXQgcGF0aCA9IGZyb21RdWVyeVBhdGgodGFyZ2V0LnBhcmVudCk7XHJcbiAgICBjb25zdCBxdWVyeSA9IHRhcmdldC5zdHJ1Y3R1cmVkUXVlcnk7XHJcbiAgICBjb25zdCBmcm9tQ291bnQgPSBxdWVyeS5mcm9tID8gcXVlcnkuZnJvbS5sZW5ndGggOiAwO1xyXG4gICAgbGV0IGNvbGxlY3Rpb25Hcm91cCA9IG51bGw7XHJcbiAgICBpZiAoZnJvbUNvdW50ID4gMCkge1xyXG4gICAgICAgIGhhcmRBc3NlcnQoZnJvbUNvdW50ID09PSAxKTtcclxuICAgICAgICBjb25zdCBmcm9tID0gcXVlcnkuZnJvbVswXTtcclxuICAgICAgICBpZiAoZnJvbS5hbGxEZXNjZW5kYW50cykge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uR3JvdXAgPSBmcm9tLmNvbGxlY3Rpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkKGZyb20uY29sbGVjdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgZmlsdGVyQnkgPSBbXTtcclxuICAgIGlmIChxdWVyeS53aGVyZSkge1xyXG4gICAgICAgIGZpbHRlckJ5ID0gZnJvbUZpbHRlcnMocXVlcnkud2hlcmUpO1xyXG4gICAgfVxyXG4gICAgbGV0IG9yZGVyQnkgPSBbXTtcclxuICAgIGlmIChxdWVyeS5vcmRlckJ5KSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IGZyb21PcmRlcihxdWVyeS5vcmRlckJ5KTtcclxuICAgIH1cclxuICAgIGxldCBsaW1pdCA9IG51bGw7XHJcbiAgICBpZiAocXVlcnkubGltaXQpIHtcclxuICAgICAgICBsaW1pdCA9IGZyb21JbnQzMlByb3RvKHF1ZXJ5LmxpbWl0KTtcclxuICAgIH1cclxuICAgIGxldCBzdGFydEF0ID0gbnVsbDtcclxuICAgIGlmIChxdWVyeS5zdGFydEF0KSB7XHJcbiAgICAgICAgc3RhcnRBdCA9IGZyb21TdGFydEF0Q3Vyc29yKHF1ZXJ5LnN0YXJ0QXQpO1xyXG4gICAgfVxyXG4gICAgbGV0IGVuZEF0ID0gbnVsbDtcclxuICAgIGlmIChxdWVyeS5lbmRBdCkge1xyXG4gICAgICAgIGVuZEF0ID0gZnJvbUVuZEF0Q3Vyc29yKHF1ZXJ5LmVuZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlckJ5LCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVF1ZXJ5VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQoY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpKTtcclxufVxyXG5mdW5jdGlvbiB0b0xpc3RlblJlcXVlc3RMYWJlbHMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSB0b0xhYmVsKHRhcmdldERhdGEucHVycG9zZSk7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2dvb2ctbGlzdGVuLXRhZ3MnOiB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9MYWJlbChwdXJwb3NlKSB7XHJcbiAgICBzd2l0Y2ggKHB1cnBvc2UpIHtcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoJztcclxuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb21cIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb20gKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnZXhpc3RlbmNlLWZpbHRlci1taXNtYXRjaC1ibG9vbSc7XHJcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdsaW1iby1kb2N1bWVudCc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0geyBkb2N1bWVudHM6IHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHsgcXVlcnk6IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KS5xdWVyeVRhcmdldCB9O1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgIGlmICh0YXJnZXREYXRhLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcclxuICAgICAgICByZXN1bHQucmVzdW1lVG9rZW4gPSB0b0J5dGVzKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcclxuICAgICAgICBpZiAoZXhwZWN0ZWRDb3VudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZXhwZWN0ZWRDb3VudCA9IGV4cGVjdGVkQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgPiAwKSB7XHJcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXHJcbiAgICAgICAgLy8gUmlnaHQgbm93LCBtYW55IHRlc3RzIGRlcGVuZCBvbiB0aGlzIGJlaGF2aW91ciB0aG91Z2ggKGxlYXZpbmcgbWluKCkgb3V0XHJcbiAgICAgICAgLy8gb2Ygc2VyaWFsaXphdGlvbikuXHJcbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXREYXRhLmV4cGVjdGVkQ291bnQpO1xyXG4gICAgICAgIGlmIChleHBlY3RlZENvdW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHRvRmlsdGVycyhmaWx0ZXJzKSB7XHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9GaWx0ZXIoQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWx0ZXJzKGZpbHRlcikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gZnJvbUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciAmJlxyXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbcmVzdWx0XTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlci51bmFyeUZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyLmZpZWxkRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIuY29tcG9zaXRlRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XHJcbiAgICBpZiAob3JkZXJCeXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yZGVyQnlzLm1hcChvcmRlciA9PiB0b1Byb3BlcnR5T3JkZXIob3JkZXIpKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tT3JkZXIob3JkZXJCeXMpIHtcclxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gZnJvbVByb3BlcnR5T3JkZXIob3JkZXIpKTtcclxufVxyXG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJlZm9yZTogY3Vyc29yLmluY2x1c2l2ZSxcclxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiZWZvcmU6ICFjdXJzb3IuaW5jbHVzaXZlLFxyXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgY29uc3QgaW5jbHVzaXZlID0gISFjdXJzb3IuYmVmb3JlO1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IudmFsdWVzIHx8IFtdO1xyXG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRW5kQXRDdXJzb3IoY3Vyc29yKSB7XHJcbiAgICBjb25zdCBpbmNsdXNpdmUgPSAhY3Vyc29yLmJlZm9yZTtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnZhbHVlcyB8fCBbXTtcclxuICAgIHJldHVybiBuZXcgQm91bmQocG9zaXRpb24sIGluY2x1c2l2ZSk7XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b0RpcmVjdGlvbihkaXIpIHtcclxuICAgIHJldHVybiBESVJFQ1RJT05TW2Rpcl07XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcikge1xyXG4gICAgc3dpdGNoIChkaXIpIHtcclxuICAgICAgICBjYXNlICdBU0NFTkRJTkcnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xyXG4gICAgICAgIGNhc2UgJ0RFU0NFTkRJTkcnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIHRvT3BlcmF0b3JOYW1lKG9wKSB7XHJcbiAgICByZXR1cm4gT1BFUkFUT1JTW29wXTtcclxufVxyXG5mdW5jdGlvbiB0b0NvbXBvc2l0ZU9wZXJhdG9yTmFtZShvcCkge1xyXG4gICAgcmV0dXJuIENPTVBPU0lURV9PUEVSQVRPUlNbb3BdO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21PcGVyYXRvck5hbWUob3ApIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlICdFUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLztcclxuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLztcclxuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovO1xyXG4gICAgICAgIGNhc2UgJ0xFU1NfVEhBTl9PUl9FUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLztcclxuICAgICAgICBjYXNlICdJTic6XHJcbiAgICAgICAgICAgIHJldHVybiBcImluXCIgLyogT3BlcmF0b3IuSU4gKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0lOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TX0FOWSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLztcclxuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSAnQU5EJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xyXG4gICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvRmllbGRQYXRoUmVmZXJlbmNlKHBhdGgpIHtcclxuICAgIHJldHVybiB7IGZpZWxkUGF0aDogcGF0aC5jYW5vbmljYWxTdHJpbmcoKSB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmllbGRSZWZlcmVuY2UpIHtcclxuICAgIHJldHVybiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KGZpZWxkUmVmZXJlbmNlLmZpZWxkUGF0aCk7XHJcbn1cclxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiB0b1Byb3BlcnR5T3JkZXIob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiB0b0RpcmVjdGlvbihvcmRlckJ5LmRpcilcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbVByb3BlcnR5T3JkZXIob3JkZXJCeSkge1xyXG4gICAgcmV0dXJuIG5ldyBPcmRlckJ5KGZyb21GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksIGZyb21EaXJlY3Rpb24ob3JkZXJCeS5kaXJlY3Rpb24pKTtcclxufVxyXG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gdG9Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICBjb25zdCBwcm90b3MgPSBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChmaWx0ZXIgPT4gdG9GaWx0ZXIoZmlsdGVyKSk7XHJcbiAgICBpZiAocHJvdG9zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBwcm90b3NbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcjoge1xyXG4gICAgICAgICAgICBvcDogdG9Db21wb3NpdGVPcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcclxuICAgICAgICAgICAgZmlsdGVyczogcHJvdG9zXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b1VuYXJ5T3JGaWVsZEZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIub3AgPT09IFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLykge1xyXG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OQU4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OVUxMJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpbHRlci5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xyXG4gICAgICAgIGlmIChpc05hblZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OT1RfTkFOJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bmFyeUZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTk9UX05VTEwnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZEZpbHRlcjoge1xyXG4gICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgb3A6IHRvT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXHJcbiAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXIudmFsdWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHN3aXRjaCAoZmlsdGVyLnVuYXJ5RmlsdGVyLm9wKSB7XHJcbiAgICAgICAgY2FzZSAnSVNfTkFOJzpcclxuICAgICAgICAgICAgY29uc3QgbmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobmFuRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdJU19OVUxMJzpcclxuICAgICAgICAgICAgY29uc3QgbnVsbEZpZWxkID0gZnJvbUZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIudW5hcnlGaWx0ZXIuZmllbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKG51bGxGaWVsZCwgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovLCB7XHJcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdJU19OT1RfTkFOJzpcclxuICAgICAgICAgICAgY29uc3Qgbm90TmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TmFuRmllbGQsIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIHtcclxuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBOYU5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSAnSVNfTk9UX05VTEwnOlxyXG4gICAgICAgICAgICBjb25zdCBub3ROdWxsRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TnVsbEZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XHJcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkRmlsdGVyLmZpZWxkKSwgZnJvbU9wZXJhdG9yTmFtZShmaWx0ZXIuZmllbGRGaWx0ZXIub3ApLCBmaWx0ZXIuZmllbGRGaWx0ZXIudmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBmcm9tRmlsdGVyKGZpbHRlcikpLCBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIub3ApKTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcclxuICAgIGNvbnN0IGNhbm9uaWNhbEZpZWxkcyA9IFtdO1xyXG4gICAgZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNhbm9uaWNhbEZpZWxkcy5wdXNoKGZpZWxkLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpZWxkUGF0aHM6IGNhbm9uaWNhbEZpZWxkc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRNYXNrKHByb3RvKSB7XHJcbiAgICBjb25zdCBwYXRocyA9IHByb3RvLmZpZWxkUGF0aHMgfHwgW107XHJcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhwYXRocy5tYXAocGF0aCA9PiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHBhdGgpKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZFJlc291cmNlTmFtZShwYXRoKSB7XHJcbiAgICAvLyBSZXNvdXJjZSBuYW1lcyBoYXZlIGF0IGxlYXN0IDQgY29tcG9uZW50cyAocHJvamVjdCBJRCwgZGF0YWJhc2UgSUQpXHJcbiAgICByZXR1cm4gKHBhdGgubGVuZ3RoID49IDQgJiZcclxuICAgICAgICBwYXRoLmdldCgwKSA9PT0gJ3Byb2plY3RzJyAmJlxyXG4gICAgICAgIHBhdGguZ2V0KDIpID09PSAnZGF0YWJhc2VzJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzZXQgb2YgbWV0YWRhdGEgdGhhdCB0aGUgbG9jYWwgc3RvcmUgdHJhY2tzIGZvciBlYWNoIHRhcmdldC5cclxuICovXHJcbmNsYXNzIFRhcmdldERhdGEge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHRhcmdldCBiZWluZyBsaXN0ZW5lZCB0by4gKi9cclxuICAgIHRhcmdldCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgSUQgdG8gd2hpY2ggdGhlIHRhcmdldCBjb3JyZXNwb25kczsgQXNzaWduZWQgYnkgdGhlXHJcbiAgICAgKiBMb2NhbFN0b3JlIGZvciB1c2VyIGxpc3RlbnMgYW5kIGJ5IHRoZSBTeW5jRW5naW5lIGZvciBsaW1ibyB3YXRjaGVzLlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRJZCwgXHJcbiAgICAvKiogVGhlIHB1cnBvc2Ugb2YgdGhlIHRhcmdldC4gKi9cclxuICAgIHB1cnBvc2UsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBsYXN0IHRyYW5zYWN0aW9uIGR1cmluZyB3aGljaCB0aGlzIHRhcmdldCBkYXRhXHJcbiAgICAgKiB3YXMgbW9kaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIHNlcXVlbmNlTnVtYmVyLCBcclxuICAgIC8qKiBUaGUgbGF0ZXN0IHNuYXBzaG90IHZlcnNpb24gc2VlbiBmb3IgdGhpcyB0YXJnZXQuICovXHJcbiAgICBzbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBzbmFwc2hvdCB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBhc3NvY2lhdGVkIHZpZXdcclxuICAgICAqIGNvbnRhaW5lZCBubyBsaW1ibyBkb2N1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHRhcmdldCB0byBiZVxyXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXRcclxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cclxuICAgICAqIHRpbWUgZnJvbSB3aGljaCB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IGxhc3QgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIHJlc3VtZSB0b2tlbiBvclxyXG4gICAgICogcmVhZCB0aW1lLiBEb2N1bWVudHMgYXJlIGNvdW50ZWQgb25seSB3aGVuIG1ha2luZyBhIGxpc3RlbiByZXF1ZXN0IHdpdGhcclxuICAgICAqIHJlc3VtZSB0b2tlbiBvciByZWFkIHRpbWUsIG90aGVyd2lzZSwga2VlcCBpdCBudWxsLlxyXG4gICAgICovXHJcbiAgICBleHBlY3RlZENvdW50ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnB1cnBvc2UgPSBwdXJwb3NlO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90VmVyc2lvbiA9IHNuYXBzaG90VmVyc2lvbjtcclxuICAgICAgICB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB0aGlzLmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIHNlcXVlbmNlIG51bWJlci4gKi9cclxuICAgIHdpdGhTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCBzZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgdGhpcy5leHBlY3RlZENvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgcmVzdW1lIHRva2VuIGFuZFxyXG4gICAgICogc25hcHNob3QgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgd2l0aFJlc3VtZVRva2VuKHJlc3VtZVRva2VuLCBzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgc25hcHNob3RWZXJzaW9uLCB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlc3VtZVRva2VuLCBcclxuICAgICAgICAvKiBleHBlY3RlZENvdW50PSAqLyBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgZXhwZWN0ZWQgY291bnQuXHJcbiAgICAgKi9cclxuICAgIHdpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgZXhwZWN0ZWRDb3VudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIGxhc3QgbGltYm8gZnJlZVxyXG4gICAgICogc25hcHNob3QgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHdpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFNlcmlhbGl6ZXIgZm9yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIExvY2FsU3RvcmUuICovXHJcbmNsYXNzIExvY2FsU2VyaWFsaXplciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVTZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTZXJpYWxpemVyID0gcmVtb3RlU2VyaWFsaXplcjtcclxuICAgIH1cclxufVxyXG4vKiogRGVjb2RlcyBhIHJlbW90ZSBkb2N1bWVudCBmcm9tIHN0b3JhZ2UgbG9jYWxseSB0byBhIERvY3VtZW50LiAqL1xyXG5mdW5jdGlvbiBmcm9tRGJSZW1vdGVEb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIsIHJlbW90ZURvYykge1xyXG4gICAgbGV0IGRvYztcclxuICAgIGlmIChyZW1vdGVEb2MuZG9jdW1lbnQpIHtcclxuICAgICAgICBkb2MgPSBmcm9tRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHJlbW90ZURvYy5kb2N1bWVudCwgISFyZW1vdGVEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy5ub0RvY3VtZW50LnBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLm5vRG9jdW1lbnQucmVhZFRpbWUpO1xyXG4gICAgICAgIGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XHJcbiAgICAgICAgaWYgKHJlbW90ZURvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgZG9jLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC5wYXRoKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbURiVGltZXN0YW1wKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQudmVyc2lvbik7XHJcbiAgICAgICAgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld1Vua25vd25Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIGlmIChyZW1vdGVEb2MucmVhZFRpbWUpIHtcclxuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoZnJvbURiVGltZXN0YW1wS2V5KHJlbW90ZURvYy5yZWFkVGltZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvYztcclxufVxyXG4vKiogRW5jb2RlcyBhIGRvY3VtZW50IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXHJcbmZ1bmN0aW9uIHRvRGJSZW1vdGVEb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIsIGRvY3VtZW50KSB7XHJcbiAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5rZXk7XHJcbiAgICBjb25zdCByZW1vdGVEb2MgPSB7XHJcbiAgICAgICAgcHJlZml4UGF0aDoga2V5LmdldENvbGxlY3Rpb25QYXRoKCkucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IGtleS5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgZG9jdW1lbnRJZDoga2V5LnBhdGgubGFzdFNlZ21lbnQoKSxcclxuICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcEtleShkb2N1bWVudC5yZWFkVGltZSksXHJcbiAgICAgICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zOiBkb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcclxuICAgIH07XHJcbiAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSB0b0RvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgIHJlbW90ZURvYy5ub0RvY3VtZW50ID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wKGRvY3VtZW50LnZlcnNpb24pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzVW5rbm93bkRvY3VtZW50KCkpIHtcclxuICAgICAgICByZW1vdGVEb2MudW5rbm93bkRvY3VtZW50ID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHZlcnNpb246IHRvRGJUaW1lc3RhbXAoZG9jdW1lbnQudmVyc2lvbilcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVEb2M7XHJcbn1cclxuZnVuY3Rpb24gdG9EYlRpbWVzdGFtcEtleShzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpO1xyXG4gICAgcmV0dXJuIFt0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zZWNvbmRzXTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRGJUaW1lc3RhbXBLZXkoZGJUaW1lc3RhbXBLZXkpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXBLZXlbMF0sIGRiVGltZXN0YW1wS2V5WzFdKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXAoc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcclxuICAgIHJldHVybiB7IHNlY29uZHM6IHRpbWVzdGFtcC5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGltZXN0YW1wLm5hbm9zZWNvbmRzIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURiVGltZXN0YW1wKGRiVGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKGRiVGltZXN0YW1wLnNlY29uZHMsIGRiVGltZXN0YW1wLm5hbm9zZWNvbmRzKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgYmF0Y2ggb2YgbXV0YXRpb25zIGludG8gYSBEYk11dGF0aW9uQmF0Y2ggZm9yIGxvY2FsIHN0b3JhZ2UuICovXHJcbmZ1bmN0aW9uIHRvRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBiYXRjaCkge1xyXG4gICAgY29uc3Qgc2VyaWFsaXplZEJhc2VNdXRhdGlvbnMgPSBiYXRjaC5iYXNlTXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWRNdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VySWQsXHJcbiAgICAgICAgYmF0Y2hJZDogYmF0Y2guYmF0Y2hJZCxcclxuICAgICAgICBsb2NhbFdyaXRlVGltZU1zOiBiYXRjaC5sb2NhbFdyaXRlVGltZS50b01pbGxpcygpLFxyXG4gICAgICAgIGJhc2VNdXRhdGlvbnM6IHNlcmlhbGl6ZWRCYXNlTXV0YXRpb25zLFxyXG4gICAgICAgIG11dGF0aW9uczogc2VyaWFsaXplZE11dGF0aW9uc1xyXG4gICAgfTtcclxufVxyXG4vKiogRGVjb2RlcyBhIERiTXV0YXRpb25CYXRjaCBpbnRvIGEgTXV0YXRpb25CYXRjaCAqL1xyXG5mdW5jdGlvbiBmcm9tRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgZGJCYXRjaCkge1xyXG4gICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IChkYkJhdGNoLmJhc2VNdXRhdGlvbnMgfHwgW10pLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgLy8gU3F1YXNoIG9sZCB0cmFuc2Zvcm0gbXV0YXRpb25zIGludG8gZXhpc3RpbmcgcGF0Y2ggb3Igc2V0IG11dGF0aW9ucy5cclxuICAgIC8vIFRoZSByZXBsYWNlbWVudCBvZiByZXByZXNlbnRpbmcgYHRyYW5zZm9ybXNgIHdpdGggYHVwZGF0ZV90cmFuc2Zvcm1zYFxyXG4gICAgLy8gb24gdGhlIFNESyBtZWFucyB0aGF0IG9sZCBgdHJhbnNmb3JtYCBtdXRhdGlvbnMgc3RvcmVkIGluIEluZGV4ZWREQiBuZWVkXHJcbiAgICAvLyB0byBiZSB1cGRhdGVkIHRvIGB1cGRhdGVfdHJhbnNmb3Jtc2AuXHJcbiAgICAvLyBUT0RPKGIvMTc0NjA4Mzc0KTogUmVtb3ZlIHRoaXMgY29kZSBvbmNlIHdlIHBlcmZvcm0gYSBzY2hlbWEgbWlncmF0aW9uLlxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYkJhdGNoLm11dGF0aW9ucy5sZW5ndGggLSAxOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50TXV0YXRpb24gPSBkYkJhdGNoLm11dGF0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSBpICsgMSA8IGRiQmF0Y2gubXV0YXRpb25zLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICBkYkJhdGNoLm11dGF0aW9uc1tpICsgMV0udHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1NdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2kgKyAxXTtcclxuICAgICAgICAgICAgY3VycmVudE11dGF0aW9uLnVwZGF0ZVRyYW5zZm9ybXMgPVxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTXV0YXRpb24udHJhbnNmb3JtLmZpZWxkVHJhbnNmb3JtcztcclxuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnMuc3BsaWNlKGkgKyAxLCAxKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG11dGF0aW9ucyA9IGRiQmF0Y2gubXV0YXRpb25zLm1hcChtID0+IGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21NaWxsaXMoZGJCYXRjaC5sb2NhbFdyaXRlVGltZU1zKTtcclxuICAgIHJldHVybiBuZXcgTXV0YXRpb25CYXRjaChkYkJhdGNoLmJhdGNoSWQsIHRpbWVzdGFtcCwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxufVxyXG4vKiogRGVjb2RlcyBhIERiVGFyZ2V0IGludG8gVGFyZ2V0RGF0YSAqL1xyXG5mdW5jdGlvbiBmcm9tRGJUYXJnZXQoZGJUYXJnZXQpIHtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAoZGJUYXJnZXQucmVhZFRpbWUpO1xyXG4gICAgY29uc3QgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pXHJcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICBsZXQgdGFyZ2V0O1xyXG4gICAgaWYgKGlzRG9jdW1lbnRRdWVyeShkYlRhcmdldC5xdWVyeSkpIHtcclxuICAgICAgICB0YXJnZXQgPSBmcm9tRG9jdW1lbnRzVGFyZ2V0KGRiVGFyZ2V0LnF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldCA9IGZyb21RdWVyeVRhcmdldChkYlRhcmdldC5xdWVyeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGFyZ2V0LCBkYlRhcmdldC50YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIGRiVGFyZ2V0Lmxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgdmVyc2lvbiwgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGRiVGFyZ2V0LnJlc3VtZVRva2VuKSk7XHJcbn1cclxuLyoqIEVuY29kZXMgVGFyZ2V0RGF0YSBpbnRvIGEgRGJUYXJnZXQgZm9yIHN0b3JhZ2UgbG9jYWxseS4gKi9cclxuZnVuY3Rpb24gdG9EYlRhcmdldChsb2NhbFNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcclxuICAgIGNvbnN0IGRiVGltZXN0YW1wID0gdG9EYlRpbWVzdGFtcCh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbik7XHJcbiAgICBjb25zdCBkYkxhc3RMaW1ib0ZyZWVUaW1lc3RhbXAgPSB0b0RiVGltZXN0YW1wKHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbik7XHJcbiAgICBsZXQgcXVlcnlQcm90bztcclxuICAgIGlmICh0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSkge1xyXG4gICAgICAgIHF1ZXJ5UHJvdG8gPSB0b0RvY3VtZW50c1RhcmdldChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgdGFyZ2V0RGF0YS50YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVlcnlQcm90byA9IHRvUXVlcnlUYXJnZXQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHRhcmdldERhdGEudGFyZ2V0KS5xdWVyeVRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIFdlIGNhbid0IHN0b3JlIHRoZSByZXN1bWVUb2tlbiBhcyBhIEJ5dGVTdHJpbmcgaW4gSW5kZXhlZERiLCBzbyB3ZVxyXG4gICAgLy8gY29udmVydCBpdCB0byBhIGJhc2U2NCBzdHJpbmcgZm9yIHN0b3JhZ2UuXHJcbiAgICBjb25zdCByZXN1bWVUb2tlbiA9IHRhcmdldERhdGEucmVzdW1lVG9rZW4udG9CYXNlNjQoKTtcclxuICAgIC8vIGxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciBpcyBhbHdheXMgMCB1bnRpbCB3ZSBkbyByZWFsIEdDLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXJnZXRJZDogdGFyZ2V0RGF0YS50YXJnZXRJZCxcclxuICAgICAgICBjYW5vbmljYWxJZDogY2Fub25pZnlUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpLFxyXG4gICAgICAgIHJlYWRUaW1lOiBkYlRpbWVzdGFtcCxcclxuICAgICAgICByZXN1bWVUb2tlbixcclxuICAgICAgICBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI6IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIsXHJcbiAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjogZGJMYXN0TGltYm9GcmVlVGltZXN0YW1wLFxyXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVByb3RvXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZmlndXJpbmcgb3V0IHdoYXQga2luZCBvZiBxdWVyeSBoYXMgYmVlbiBzdG9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkoZGJRdWVyeSkge1xyXG4gICAgcmV0dXJuIGRiUXVlcnkuZG9jdW1lbnRzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqIEVuY29kZXMgYSBEYkJ1bmRsZSB0byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cclxuZnVuY3Rpb24gZnJvbURiQnVuZGxlKGRiQnVuZGxlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBkYkJ1bmRsZS5idW5kbGVJZCxcclxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tRGJUaW1lc3RhbXAoZGJCdW5kbGUuY3JlYXRlVGltZSksXHJcbiAgICAgICAgdmVyc2lvbjogZGJCdW5kbGUudmVyc2lvblxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHRvIGEgRGJCdW5kbGUuICovXHJcbmZ1bmN0aW9uIHRvRGJCdW5kbGUobWV0YWRhdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYnVuZGxlSWQ6IG1ldGFkYXRhLmlkLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSkpLFxyXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb25cclxuICAgIH07XHJcbn1cclxuLyoqIEVuY29kZXMgYSBEYk5hbWVkUXVlcnkgdG8gYSBOYW1lZFF1ZXJ5LiAqL1xyXG5mdW5jdGlvbiBmcm9tRGJOYW1lZFF1ZXJ5KGRiTmFtZWRRdWVyeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBkYk5hbWVkUXVlcnkubmFtZSxcclxuICAgICAgICBxdWVyeTogZnJvbUJ1bmRsZWRRdWVyeShkYk5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcclxuICAgICAgICByZWFkVGltZTogZnJvbURiVGltZXN0YW1wKGRiTmFtZWRRdWVyeS5yZWFkVGltZSlcclxuICAgIH07XHJcbn1cclxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IGZyb20gYSBidW5kbGUgcHJvdG8gdG8gYSBEYk5hbWVkUXVlcnkuICovXHJcbmZ1bmN0aW9uIHRvRGJOYW1lZFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHF1ZXJ5Lm5hbWUsXHJcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24ocXVlcnkucmVhZFRpbWUpKSxcclxuICAgICAgICBidW5kbGVkUXVlcnk6IHF1ZXJ5LmJ1bmRsZWRRdWVyeVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogRW5jb2RlcyBhIGBCdW5kbGVkUXVlcnlgIGZyb20gYnVuZGxlIHByb3RvIHRvIGEgUXVlcnkgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGlzIHJlY29uc3RydWN0cyB0aGUgb3JpZ2luYWwgcXVlcnkgdXNlZCB0byBidWlsZCB0aGUgYnVuZGxlIGJlaW5nIGxvYWRlZCxcclxuICogaW5jbHVkaW5nIGZlYXR1cmVzIGV4aXN0cyBvbmx5IGluIFNES3MgKGZvciBleGFtcGxlOiBsaW1pdC10by1sYXN0KS5cclxuICovXHJcbmZ1bmN0aW9uIGZyb21CdW5kbGVkUXVlcnkoYnVuZGxlZFF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkoe1xyXG4gICAgICAgIHBhcmVudDogYnVuZGxlZFF1ZXJ5LnBhcmVudCxcclxuICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IGJ1bmRsZWRRdWVyeS5zdHJ1Y3R1cmVkUXVlcnlcclxuICAgIH0pO1xyXG4gICAgaWYgKGJ1bmRsZWRRdWVyeS5saW1pdFR5cGUgPT09ICdMQVNUJykge1xyXG4gICAgICAgIHJldHVybiBxdWVyeVdpdGhMaW1pdChxdWVyeSwgcXVlcnkubGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeTtcclxufVxyXG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgcHJvdG8gb2JqZWN0IHRvIGEgTmFtZWRRdWVyeSBtb2RlbCBvYmplY3QuICovXHJcbmZ1bmN0aW9uIGZyb21Qcm90b05hbWVkUXVlcnkobmFtZWRRdWVyeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBuYW1lZFF1ZXJ5Lm5hbWUsXHJcbiAgICAgICAgcXVlcnk6IGZyb21CdW5kbGVkUXVlcnkobmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxyXG4gICAgICAgIHJlYWRUaW1lOiBmcm9tVmVyc2lvbihuYW1lZFF1ZXJ5LnJlYWRUaW1lKVxyXG4gICAgfTtcclxufVxyXG4vKiogRGVjb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHByb3RvIGludG8gYSBCdW5kbGVNZXRhZGF0YSBvYmplY3QuICovXHJcbmZ1bmN0aW9uIGZyb21CdW5kbGVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogbWV0YWRhdGEuaWQsXHJcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcclxuICAgICAgICBjcmVhdGVUaW1lOiBmcm9tVmVyc2lvbihtZXRhZGF0YS5jcmVhdGVUaW1lKVxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIERiRG9jdW1lbnRPdmVybGF5IG9iamVjdCB0byBhbiBPdmVybGF5IG1vZGVsIG9iamVjdC4gKi9cclxuZnVuY3Rpb24gZnJvbURiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgZGJEb2N1bWVudE92ZXJsYXkpIHtcclxuICAgIHJldHVybiBuZXcgT3ZlcmxheShkYkRvY3VtZW50T3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCwgZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheS5vdmVybGF5TXV0YXRpb24pKTtcclxufVxyXG4vKiogRGVjb2RlcyBhbiBPdmVybGF5IG1vZGVsIG9iamVjdCBpbnRvIGEgRGJEb2N1bWVudE92ZXJsYXkgb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBvdmVybGF5KSB7XHJcbiAgICBjb25zdCBbXywgY29sbGVjdGlvblBhdGgsIGRvY3VtZW50SWRdID0gdG9EYkRvY3VtZW50T3ZlcmxheUtleSh1c2VySWQsIG92ZXJsYXkubXV0YXRpb24ua2V5KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlcklkLFxyXG4gICAgICAgIGNvbGxlY3Rpb25QYXRoLFxyXG4gICAgICAgIGRvY3VtZW50SWQsXHJcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBvdmVybGF5Lm11dGF0aW9uLmtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSxcclxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCxcclxuICAgICAgICBvdmVybGF5TXV0YXRpb246IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG92ZXJsYXkubXV0YXRpb24pXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBEYkRvY3VtZW50T3ZlcmxheUtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB1c2VyIGFuZFxyXG4gKiBkb2N1bWVudCBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHVzZXJJZCwgZG9jS2V5KSB7XHJcbiAgICBjb25zdCBkb2NJZCA9IGRvY0tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChkb2NLZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgcmV0dXJuIFt1c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBkb2NJZF07XHJcbn1cclxuZnVuY3Rpb24gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbmRleElkOiBpbmRleC5pbmRleElkLFxyXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDogaW5kZXguY29sbGVjdGlvbkdyb3VwLFxyXG4gICAgICAgIGZpZWxkczogaW5kZXguZmllbGRzLm1hcChzID0+IFtzLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgcy5raW5kXSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4LCBzdGF0ZSkge1xyXG4gICAgY29uc3QgZGVjb2RlZFN0YXRlID0gc3RhdGVcclxuICAgICAgICA/IG5ldyBJbmRleFN0YXRlKHN0YXRlLnNlcXVlbmNlTnVtYmVyLCBuZXcgSW5kZXhPZmZzZXQoZnJvbURiVGltZXN0YW1wKHN0YXRlLnJlYWRUaW1lKSwgbmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChzdGF0ZS5kb2N1bWVudEtleSkpLCBzdGF0ZS5sYXJnZXN0QmF0Y2hJZCkpXHJcbiAgICAgICAgOiBJbmRleFN0YXRlLmVtcHR5KCk7XHJcbiAgICBjb25zdCBkZWNvZGVkU2VnbWVudHMgPSBpbmRleC5maWVsZHMubWFwKChbZmllbGRQYXRoLCBraW5kXSkgPT4gbmV3IEluZGV4U2VnbWVudChGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KGZpZWxkUGF0aCksIGtpbmQpKTtcclxuICAgIHJldHVybiBuZXcgRmllbGRJbmRleChpbmRleC5pbmRleElkLCBpbmRleC5jb2xsZWN0aW9uR3JvdXAsIGRlY29kZWRTZWdtZW50cywgZGVjb2RlZFN0YXRlKTtcclxufVxyXG5mdW5jdGlvbiB0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB1aWQsIHNlcXVlbmNlTnVtYmVyLCBvZmZzZXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXhJZCxcclxuICAgICAgICB1aWQsXHJcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIsXHJcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAob2Zmc2V0LnJlYWRUaW1lKSxcclxuICAgICAgICBkb2N1bWVudEtleTogZW5jb2RlUmVzb3VyY2VQYXRoKG9mZnNldC5kb2N1bWVudEtleS5wYXRoKSxcclxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb2Zmc2V0Lmxhcmdlc3RCYXRjaElkXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYkJ1bmRsZUNhY2hlIHtcclxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQoYnVuZGxlSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGJ1bmRsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJCdW5kbGUoYnVuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiQnVuZGxlKGJ1bmRsZU1ldGFkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQocXVlcnlOYW1lKVxyXG4gICAgICAgICAgICAubmV4dChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk5hbWVkUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiTmFtZWRRdWVyeShxdWVyeSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGJ1bmRsZXMgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVuZGxlc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJCdW5kbGVTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbmFtZWRRdWVyaWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG5hbWVkUXVlcmllc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJOYW1lZFF1ZXJ5U3RvcmUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBEb2N1bWVudE92ZXJsYXlDYWNoZSB1c2luZyBJbmRleGVkRGIuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIGRvY3VtZW50IHNlcmlhbGl6ZXIuXHJcbiAgICAgKiBAcGFyYW0gdXNlcklkIC0gVGhlIHVzZXJJZCBmb3Igd2hpY2ggd2UgYXJlIGFjY2Vzc2luZyBvdmVybGF5cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgdXNlcklkKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmb3JVc2VyKHNlcmlhbGl6ZXIsIHVzZXIpIHtcclxuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLnVpZCB8fCAnJztcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlKHNlcmlhbGl6ZXIsIHVzZXJJZCk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQodG9EYkRvY3VtZW50T3ZlcmxheUtleSh0aGlzLnVzZXJJZCwga2V5KSlcclxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5ID0+IHtcclxuICAgICAgICAgICAgaWYgKGRiT3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goKF8sIG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBzZXQgb2YgdW5pcXVlIGNvbGxlY3Rpb24gcGF0aHMuXHJcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goa2V5ID0+IGNvbGxlY3Rpb25QYXRocy5hZGQoZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5nZXRDb2xsZWN0aW9uUGF0aCgpKSkpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY29sbGVjdGlvblBhdGhzLmZvckVhY2goY29sbGVjdGlvblBhdGggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBiYXRjaElkICsgMV0sIFxyXG4gICAgICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKS5kZWxldGVBbGwoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgcmFuZ2UpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoY29sbGVjdGlvbik7XHJcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcclxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgc2luY2VCYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAubG9hZEFsbChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSlcclxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5cyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJPdmVybGF5IG9mIGRiT3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkLCBjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICBsZXQgY3VycmVudEJhdGNoSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcclxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LFxyXG4gICAgICAgICAgICByYW5nZVxyXG4gICAgICAgIH0sIChfLCBkYk92ZXJsYXksIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmV0dXJuIHBhcnRpYWwgYmF0Y2ggb3ZlcmxheXMsIGV2ZW4gaWYgdGhlIHNpemVcclxuICAgICAgICAgICAgLy8gb2YgdGhlIHJlc3VsdCBzZXQgZXhjZWVkcyB0aGUgZ2l2ZW4gYGNvdW50YCBhcmd1bWVudC4gVGhlcmVmb3JlLCB3ZVxyXG4gICAgICAgICAgICAvLyBjb250aW51ZSB0byBhZ2dyZWdhdGUgcmVzdWx0cyBldmVuIGFmdGVyIHRoZSByZXN1bHQgc2l6ZSBleGNlZWRzXHJcbiAgICAgICAgICAgIC8vIGBjb3VudGAgaWYgdGhlcmUgYXJlIG1vcmUgb3ZlcmxheXMgZnJvbSB0aGUgYGN1cnJlbnRCYXRjaElkYC5cclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSgpIDwgY291bnQgfHxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQgPT09IGN1cnJlbnRCYXRjaElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJhdGNoSWQgPSBvdmVybGF5Lmxhcmdlc3RCYXRjaElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiRG9jdW1lbnRPdmVybGF5KHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIG92ZXJsYXkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCBvdmVybGF5IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGRvY3VtZW50T3ZlcmxheVN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE92ZXJsYXlTdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTm90ZTogVGhpcyBjb2RlIGlzIGNvcGllZCBmcm9tIHRoZSBiYWNrZW5kLiBDb2RlIHRoYXQgaXMgbm90IHVzZWQgYnlcclxuLy8gRmlyZXN0b3JlIHdhcyByZW1vdmVkLlxyXG5jb25zdCBJTkRFWF9UWVBFX05VTEwgPSA1O1xyXG5jb25zdCBJTkRFWF9UWVBFX0JPT0xFQU4gPSAxMDtcclxuY29uc3QgSU5ERVhfVFlQRV9OQU4gPSAxMztcclxuY29uc3QgSU5ERVhfVFlQRV9OVU1CRVIgPSAxNTtcclxuY29uc3QgSU5ERVhfVFlQRV9USU1FU1RBTVAgPSAyMDtcclxuY29uc3QgSU5ERVhfVFlQRV9TVFJJTkcgPSAyNTtcclxuY29uc3QgSU5ERVhfVFlQRV9CTE9CID0gMzA7XHJcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFID0gMzc7XHJcbmNvbnN0IElOREVYX1RZUEVfR0VPUE9JTlQgPSA0NTtcclxuY29uc3QgSU5ERVhfVFlQRV9BUlJBWSA9IDUwO1xyXG5jb25zdCBJTkRFWF9UWVBFX01BUCA9IDU1O1xyXG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UID0gNjA7XHJcbi8vIEEgdGVybWluYXRvciB0aGF0IGluZGljYXRlcyB0aGF0IGEgdHJ1bmNhdGFibGUgdmFsdWUgd2FzIG5vdCB0cnVuY2F0ZWQuXHJcbi8vIFRoaXMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYWxsIG90aGVyIHR5cGUgbGFiZWxzLlxyXG5jb25zdCBOT1RfVFJVTkNBVEVEID0gMjtcclxuLyoqIEZpcmVzdG9yZSBpbmRleCB2YWx1ZSB3cml0ZXIuICAqL1xyXG5jbGFzcyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcbiAgICAvLyBUaGUgd3JpdGUgbWV0aG9kcyBiZWxvdyBzaG9ydC1jaXJjdWl0IHdyaXRpbmcgdGVybWluYXRvcnMgZm9yIHZhbHVlc1xyXG4gICAgLy8gY29udGFpbmluZyBhICh0ZXJtaW5hdGluZykgdHJ1bmNhdGVkIHZhbHVlLlxyXG4gICAgLy9cclxuICAgIC8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSByZXN1bHRpbmcgZW5jb2RpbmcgZm9yOlxyXG4gICAgLy9cclxuICAgIC8vIFtcImJhclwiLCBbMiwgXCJmb29cIl1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVEVSTSwgVEVSTSwgVEVSTSlcclxuICAgIC8vIFtcImJhclwiLCBbMiwgdHJ1bmNhdGVkKFwiZm9vXCIpXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBUUlVOQylcclxuICAgIC8vIFtcImJhclwiLCB0cnVuY2F0ZWQoW1wiZm9vXCJdKV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVkuIFNUUklORywgXCJmb29cIiwgVEVSTSwgVFJVTkMpXHJcbiAgICAvKiogV3JpdGVzIGFuIGluZGV4IHZhbHVlLiAgKi9cclxuICAgIHdyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KHZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAvLyBXcml0ZSBzZXBhcmF0b3IgdG8gc3BsaXQgaW5kZXggdmFsdWVzXHJcbiAgICAgICAgLy8gKHNlZSBnby9maXJlc3RvcmUtc3RvcmFnZS1mb3JtYXQjZW5jb2RpbmdzKS5cclxuICAgICAgICBlbmNvZGVyLndyaXRlSW5maW5pdHkoKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5kZXhWYWx1ZUF1eChpbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgaWYgKCdudWxsVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVMTCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQk9PTEVBTik7XHJcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoaW5kZXhWYWx1ZS5ib29sZWFuVmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5pbnRlZ2VyVmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTkFOKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZVplcm8obikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAtMC4wLCAwIGFuZCAwLjAgYXJlIGFsbCBjb25zaWRlcmVkIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcigwLjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IGluZGV4VmFsdWUudGltZXN0YW1wVmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1RJTUVTVEFNUCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhgJHt0aW1lc3RhbXAuc2Vjb25kcyB8fCAnJ31gKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0aW1lc3RhbXAubmFub3MgfHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoaW5kZXhWYWx1ZS5zdHJpbmdWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CTE9CKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZUJ5dGVzKG5vcm1hbGl6ZUJ5dGVTdHJpbmcoaW5kZXhWYWx1ZS5ieXRlc1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4RW50aXR5UmVmKGluZGV4VmFsdWUucmVmZXJlbmNlVmFsdWUsIGVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBnZW9Qb2ludCA9IGluZGV4VmFsdWUuZ2VvUG9pbnRWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfR0VPUE9JTlQpO1xyXG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxhdGl0dWRlIHx8IDApO1xyXG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxvbmdpdHVkZSB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc01heFZhbHVlKGluZGV4VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4TWFwKGluZGV4VmFsdWUubWFwVmFsdWUsIGVuY29kZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4QXJyYXkoaW5kZXhWYWx1ZS5hcnJheVZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleFN0cmluZyhzdHJpbmdJbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfU1RSSU5HKTtcclxuICAgICAgICB0aGlzLndyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICB9XHJcbiAgICB3cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcclxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHN0cmluZ0luZGV4VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleE1hcChtYXBJbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTUFQKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhrZXksIGVuY29kZXIpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChtYXBba2V5XSwgZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleEFycmF5KGFycmF5SW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGFycmF5SW5kZXhWYWx1ZS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQVJSQVkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgoZWxlbWVudCwgZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbmRleEVudGl0eVJlZihyZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRSk7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IERvY3VtZW50S2V5LmZyb21OYW1lKHJlZmVyZW5jZVZhbHVlKS5wYXRoO1xyXG4gICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc2VnbWVudCwgZW5jb2Rlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIHR5cGVPcmRlcikge1xyXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIodHlwZU9yZGVyKTtcclxuICAgIH1cclxuICAgIHdyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKSB7XHJcbiAgICAgICAgLy8gV2hpbGUgdGhlIFNESyBkb2VzIG5vdCBpbXBsZW1lbnQgdHJ1bmNhdGlvbiwgdGhlIHRydW5jYXRpb24gbWFya2VyIGlzXHJcbiAgICAgICAgLy8gdXNlZCB0byB0ZXJtaW5hdGUgYWxsIHZhcmlhYmxlIGxlbmd0aCB2YWx1ZXMgKHdoaWNoIGFyZSBzdHJpbmdzLCBieXRlcyxcclxuICAgICAgICAvLyByZWZlcmVuY2VzLCBhcnJheXMgYW5kIG1hcHMpLlxyXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoTk9UX1RSVU5DQVRFRCk7XHJcbiAgICB9XHJcbn1cclxuRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRSA9IG5ldyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyB8IGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyB8IENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIHwgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBUaGVzZSBjb25zdGFudHMgYXJlIHRha2VuIGZyb20gdGhlIGJhY2tlbmQuICovXHJcbmNvbnN0IE1JTl9TVVJST0dBVEUgPSAnXFx1RDgwMCc7XHJcbmNvbnN0IE1BWF9TVVJST0dBVEUgPSAnXFx1REJGRic7XHJcbmNvbnN0IEVTQ0FQRTEgPSAweDAwO1xyXG5jb25zdCBOVUxMX0JZVEUgPSAweGZmOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTFcclxuY29uc3QgU0VQQVJBVE9SID0gMHgwMTsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXHJcbmNvbnN0IEVTQ0FQRTIgPSAweGZmO1xyXG5jb25zdCBJTkZJTklUWSA9IDB4ZmY7IC8vIENvbWJpbmVkIHdpdGggRVNDQVBFMlxyXG5jb25zdCBGRl9CWVRFID0gMHgwMDsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXHJcbmNvbnN0IExPTkdfU0laRSA9IDY0O1xyXG5jb25zdCBCWVRFX1NJWkUgPSA4O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgYnVmZmVyLiBUaGlzIGlzIGFyYml0cmFyeSwgYnV0IGxpa2VseSBsYXJnZXIgdGhhblxyXG4gKiBtb3N0IGluZGV4IHZhbHVlcyBzbyB0aGF0IGxlc3MgY29waWVzIG9mIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB3aWxsIGJlIG1hZGUuXHJcbiAqIEZvciBsYXJnZSB2YWx1ZXMsIGEgc2luZ2xlIGNvcHkgd2lsbCBtYWRlIHRvIGRvdWJsZSB0aGUgYnVmZmVyIGxlbmd0aC5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQlVGRkVSX1NJWkUgPSAxMDI0O1xyXG4vKiogQ29udmVydHMgYSBKYXZhU2NyaXB0IG51bWJlciB0byBhIGJ5dGUgYXJyYXkgKHVzaW5nIGJpZyBlbmRpYW4gZW5jb2RpbmcpLiAqL1xyXG5mdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xyXG4gICAgZHYuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgLyogbGl0dGxlRW5kaWFuPSAqLyBmYWxzZSk7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHYuYnVmZmVyKTtcclxufVxyXG4vKipcclxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgemVyb3MgaW4gYSBieXRlLlxyXG4gKlxyXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3NJbkJ5dGUoeCkge1xyXG4gICAgaWYgKHggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gODtcclxuICAgIH1cclxuICAgIGxldCB6ZXJvcyA9IDA7XHJcbiAgICBpZiAoeCA+PiA0ID09PSAwKSB7XHJcbiAgICAgICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgZm91ciBiaXRzIGFyZSB6ZXJvLlxyXG4gICAgICAgIHplcm9zICs9IDQ7XHJcbiAgICAgICAgeCA9IHggPDwgNDtcclxuICAgIH1cclxuICAgIGlmICh4ID4+IDYgPT09IDApIHtcclxuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCB0d28gKG9yIG5leHQgdHdvKSBiaXRzIGFyZSB6ZXJvLlxyXG4gICAgICAgIHplcm9zICs9IDI7XHJcbiAgICAgICAgeCA9IHggPDwgMjtcclxuICAgIH1cclxuICAgIGlmICh4ID4+IDcgPT09IDApIHtcclxuICAgICAgICAvLyBUZXN0IGlmIHRoZSByZW1haW5pbmcgYml0IGlzIHplcm8uXHJcbiAgICAgICAgemVyb3MgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB6ZXJvcztcclxufVxyXG4vKiogQ291bnRzIHRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBpbiB0aGUgZ2l2ZW4gYnl0ZSBhcnJheS4gKi9cclxuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3MoYnl0ZXMpIHtcclxuICAgIGxldCBsZWFkaW5nWmVyb3MgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyArK2kpIHtcclxuICAgICAgICBjb25zdCB6ZXJvcyA9IG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKGJ5dGVzW2ldICYgMHhmZik7XHJcbiAgICAgICAgbGVhZGluZ1plcm9zICs9IHplcm9zO1xyXG4gICAgICAgIGlmICh6ZXJvcyAhPT0gOCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVhZGluZ1plcm9zO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJ2YWx1ZVwiLiBMZWFkaW5nIHplcm8gYnl0ZXNcclxuICogYXJlIHNraXBwZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSkge1xyXG4gICAgLy8gVGhpcyBpcyBqdXN0IHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxyXG4gICAgY29uc3QgbnVtQml0cyA9IExPTkdfU0laRSAtIG51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwobnVtQml0cyAvIEJZVEVfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIE9yZGVyZWRDb2RlV3JpdGVyIGlzIGEgbWluaW1hbC1hbGxvY2F0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB3cml0aW5nXHJcbiAqIGJlaGF2aW9yIGRlZmluZWQgYnkgdGhlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIFRoZSBjb2RlIGlzIHBvcnRlZCBmcm9tIGl0cyBKYXZhIGNvdW50ZXJwYXJ0LlxyXG4gKi9cclxuY2xhc3MgT3JkZXJlZENvZGVXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShERUZBVUxUX0JVRkZFUl9TSVpFKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIH1cclxuICAgIHdyaXRlQnl0ZXNBc2NlbmRpbmcodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBpdCA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZyhieXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVCeXRlc0Rlc2NlbmRpbmcodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBpdCA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoYnl0ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIGJ5dGUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JEZXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGFzY2VuZGluZy4gKi9cclxuICAgIHdyaXRlVXRmOEFzY2VuZGluZyhzZXF1ZW5jZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoY2hhckNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjaGFyQ29kZSA+Pj4gNikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gMTIpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBkZXNjZW5kaW5nICovXHJcbiAgICB3cml0ZVV0ZjhEZXNjZW5kaW5nKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoY2hhckNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA2KSB8IChjaGFyQ29kZSA+Pj4gNikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IE1JTl9TVVJST0dBVEUgfHwgTUFYX1NVUlJPR0FURSA8IGMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDYpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcclxuICAgIH1cclxuICAgIHdyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbCkge1xyXG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXHJcbiAgICAgICAgLy8gYWN0dWFsIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvT3JkZXJlZEJpdHModmFsKTtcclxuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGxlbiAmIDB4ZmY7IC8vIFdyaXRlIHRoZSBsZW5ndGhcclxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IHZhbHVlW2ldICYgMHhmZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZU51bWJlckRlc2NlbmRpbmcodmFsKSB7XHJcbiAgICAgICAgLy8gVmFsdWVzIGFyZSBlbmNvZGVkIHdpdGggYSBzaW5nbGUgYnl0ZSBsZW5ndGggcHJlZml4LCBmb2xsb3dlZCBieSB0aGVcclxuICAgICAgICAvLyBpbnZlcnRlZCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdW5zaWduZWROdW1MZW5ndGgodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KGxlbiAmIDB4ZmYpOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHZhbHVlLmxlbmd0aCAtIGxlbjsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KHZhbHVlW2ldICYgMHhmZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYWZ0ZXIgYWxsIG90aGVyIGJ5dGVcclxuICAgICAqIHNlcXVlbmNlcyB3cml0dGVuIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmZpbml0eUFzY2VuZGluZygpIHtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMik7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKElORklOSVRZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgb3RoZXIgYnl0ZVxyXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gZGVzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmZpbml0eURlc2NlbmRpbmcoKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKElORklOSVRZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBidWZmZXIgc3VjaCB0aGF0IGl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gaXQgd2FzIG5ld2x5XHJcbiAgICAgKiBjb25zdHJ1Y3RlZC5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICB9XHJcbiAgICBzZWVkKGVuY29kZWRCeXRlcykge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKGVuY29kZWRCeXRlcy5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyLnNldChlbmNvZGVkQnl0ZXMsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gZW5jb2RlZEJ5dGVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGVuY29kZWQgYnl0ZXMgaW4gdGhpcyBidWZmZXIuICAqL1xyXG4gICAgZW5jb2RlZEJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBgdmFsYCBpbnRvIGFuIGVuY29kaW5nIHNvIHRoYXQgdGhlIG9yZGVyIG1hdGNoZXMgdGhlIElFRUUgNzU0XHJcbiAgICAgKiBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIHJlc3VsdHMgd2l0aCB0aGUgZm9sbG93aW5nIGV4Y2VwdGlvbnM6XHJcbiAgICAgKiAgIC0wLjAgPCAwLjBcclxuICAgICAqICAgYWxsIG5vbi1OYU4gPCBOYU5cclxuICAgICAqICAgTmFOID0gTmFOXHJcbiAgICAgKi9cclxuICAgIHRvT3JkZXJlZEJpdHModmFsKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb3VibGVUb0xvbmdCaXRzKHZhbCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGJpdCBpcyBzZXQuIFdlIHVzZSBhIGJpdCBtYXNrIHNpbmNlIHZhbHVlWzBdIGlzXHJcbiAgICAgICAgLy8gZW5jb2RlZCBhcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1LlxyXG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodmFsdWVbMF0gJiAweDgwKSAhPT0gMDtcclxuICAgICAgICAvLyBSZXZlcnQgdGhlIHR3byBjb21wbGVtZW50IHRvIGdldCBuYXR1cmFsIG9yZGVyaW5nXHJcbiAgICAgICAgdmFsdWVbMF0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDgwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFsdWVbaV0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgYXNjZW5kaW5nIHRvIHRoZSBidWZmZXIuICovXHJcbiAgICB3cml0ZUJ5dGVBc2NlbmRpbmcoYikge1xyXG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGIgJiAweGZmO1xyXG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTEpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoTlVMTF9CWVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEZGX0JZVEUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKG1hc2tlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlcyBhIHNpbmdsZSBieXRlIGRlc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gICovXHJcbiAgICB3cml0ZUJ5dGVEZXNjZW5kaW5nKGIpIHtcclxuICAgICAgICBjb25zdCBtYXNrZWQgPSBiICYgMHhmZjtcclxuICAgICAgICBpZiAobWFza2VkID09PSBFU0NBUEUxKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoTlVMTF9CWVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRkZfQllURSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCkge1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoU0VQQVJBVE9SKTtcclxuICAgIH1cclxuICAgIHdyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpIHtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTEpO1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoU0VQQVJBVE9SKTtcclxuICAgIH1cclxuICAgIHdyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoYikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBiO1xyXG4gICAgfVxyXG4gICAgd3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+YjtcclxuICAgIH1cclxuICAgIGVuc3VyZUF2YWlsYWJsZShieXRlcykge1xyXG4gICAgICAgIGNvbnN0IG1pbkNhcGFjaXR5ID0gYnl0ZXMgKyB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgZG91YmxpbmcuXHJcbiAgICAgICAgbGV0IG5ld0xlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAqIDI7XHJcbiAgICAgICAgLy8gU3RpbGwgbm90IGJpZyBlbm91Z2g/IEp1c3QgYWxsb2NhdGUgdGhlIHJpZ2h0IHNpemUuXHJcbiAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkNhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkNhcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBidWZmZXIuXHJcbiAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgICAgICBuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTsgLy8gY29weSBvbGQgZGF0YVxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhBc2NlbmRpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5maW5pdHkoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5QXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzRGVzY2VuZGluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4RGVzY2VuZGluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZU51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5maW5pdHkoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5RGVzY2VuZGluZygpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBEaXJlY3Rpb25hbEluZGV4Qnl0ZUVuY29kZXJgIHVzaW5nIGBPcmRlcmVkQ29kZVdyaXRlcmAgZm9yIHRoZVxyXG4gKiBhY3R1YWwgZW5jb2RpbmcuXHJcbiAqL1xyXG5jbGFzcyBJbmRleEJ5dGVFbmNvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBuZXcgT3JkZXJlZENvZGVXcml0ZXIoKTtcclxuICAgICAgICB0aGlzLmFzY2VuZGluZyA9IG5ldyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xyXG4gICAgICAgIHRoaXMuZGVzY2VuZGluZyA9IG5ldyBEZXNjZW5kaW5nSW5kZXhCeXRlRW5jb2Rlcih0aGlzLm9yZGVyZWRDb2RlKTtcclxuICAgIH1cclxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS5zZWVkKGVuY29kZWRCeXRlcyk7XHJcbiAgICB9XHJcbiAgICBmb3JLaW5kKGtpbmQpIHtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovID8gdGhpcy5hc2NlbmRpbmcgOiB0aGlzLmRlc2NlbmRpbmc7XHJcbiAgICB9XHJcbiAgICBlbmNvZGVkQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZENvZGUuZW5jb2RlZEJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLnJlc2V0KCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFJlcHJlc2VudHMgYW4gaW5kZXggZW50cnkgc2F2ZWQgYnkgdGhlIFNESyBpbiBwZXJzaXN0ZWQgc3RvcmFnZS4gKi9cclxuY2xhc3MgSW5kZXhFbnRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleElkLCBkb2N1bWVudEtleSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhJZCA9IGluZGV4SWQ7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xyXG4gICAgICAgIHRoaXMuYXJyYXlWYWx1ZSA9IGFycmF5VmFsdWU7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25hbFZhbHVlID0gZGlyZWN0aW9uYWxWYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBJbmRleEVudHJ5IGVudHJ5IHRoYXQgc29ydHMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGN1cnJlbnRcclxuICAgICAqIGRpcmVjdGlvbmFsIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzdWNjZXNzb3IoKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExlbmd0aCA9IHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gY3VycmVudExlbmd0aCA9PT0gMCB8fCB0aGlzLmRpcmVjdGlvbmFsVmFsdWVbY3VycmVudExlbmd0aCAtIDFdID09PSAyNTVcclxuICAgICAgICAgICAgPyBjdXJyZW50TGVuZ3RoICsgMVxyXG4gICAgICAgICAgICA6IGN1cnJlbnRMZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc29yID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgICAgICBzdWNjZXNzb3Iuc2V0KHRoaXMuZGlyZWN0aW9uYWxWYWx1ZSwgMCk7XHJcbiAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gY3VycmVudExlbmd0aCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzb3Iuc2V0KFswXSwgdGhpcy5kaXJlY3Rpb25hbFZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICArK3N1Y2Nlc3NvcltzdWNjZXNzb3IubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhFbnRyeSh0aGlzLmluZGV4SWQsIHRoaXMuZG9jdW1lbnRLZXksIHRoaXMuYXJyYXlWYWx1ZSwgc3VjY2Vzc29yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmRleEVudHJ5Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xyXG4gICAgbGV0IGNtcCA9IGxlZnQuaW5kZXhJZCAtIHJpZ2h0LmluZGV4SWQ7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuYXJyYXlWYWx1ZSwgcmlnaHQuYXJyYXlWYWx1ZSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuZGlyZWN0aW9uYWxWYWx1ZSwgcmlnaHQuZGlyZWN0aW9uYWxWYWx1ZSk7XHJcbiAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlQnl0ZUFycmF5cyhsZWZ0LCByaWdodCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aCAmJiBpIDwgcmlnaHQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjb21wYXJlID0gbGVmdFtpXSAtIHJpZ2h0W2ldO1xyXG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0Lmxlbmd0aCAtIHJpZ2h0Lmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBsaWdodCBxdWVyeSBwbGFubmVyIGZvciBGaXJlc3RvcmUuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgbWF0Y2hlcyBhIGBGaWVsZEluZGV4YCBhZ2FpbnN0IGEgRmlyZXN0b3JlIFF1ZXJ5IGBUYXJnZXRgLiBJdFxyXG4gKiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgc3BlY2lmaWVkIHRhcmdldC5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93Y2FzZXMgc29tZSBwb3NzaWJsZSBpbmRleCBjb25maWd1cmF0aW9uczpcclxuICpcclxuICogUXVlcnkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSW5kZXhcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0MsIGIgREVTQ1xyXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBhIEFTQ1xyXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBiIERFU0NcclxuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKSAgICAgICAgICAgICAgICAgIHwgYSBBU0NcclxuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnLCAnZGVzYycpICAgICAgICAgIHwgYSBERVNDXHJcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykub3JkZXJCeSgnYicpICAgICB8IGEgQVNDLCBiIEFTQ1xyXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScpLm9yZGVyQnkoJ2InKSAgICAgfCBhIEFTQ1xyXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TLCBiIEFTQ0VORElOR1xyXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TXHJcbiAqL1xyXG5jbGFzcyBUYXJnZXRJbmRleE1hdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gVGhlIGluZXF1YWxpdHkgZmlsdGVycyBvZiB0aGUgdGFyZ2V0IChpZiBpdCBleGlzdHMpLlxyXG4gICAgICAgIC8vIE5vdGU6IFRoZSBzb3J0IG9uIEZpZWxkRmlsdGVycyBpcyBub3QgcmVxdWlyZWQuIFVzaW5nIFNvcnRlZFNldCBoZXJlIGp1c3QgdG8gdXRpbGl6ZSB0aGUgY3VzdG9tXHJcbiAgICAgICAgLy8gY29tcGFyYXRvci5cclxuICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gbmV3IFNvcnRlZFNldCgobGhzLCByaHMpID0+IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGhzLmZpZWxkLCByaHMuZmllbGQpKTtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25JZCA9XHJcbiAgICAgICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXHJcbiAgICAgICAgICAgICAgICA6IHRhcmdldC5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICAgICAgdGhpcy5vcmRlckJ5cyA9IHRhcmdldC5vcmRlckJ5O1xyXG4gICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGFyZ2V0LmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRGaWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZEZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVxdWFsaXR5RmlsdGVycyA9IHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuYWRkKGZpZWxkRmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzLnB1c2goZmllbGRGaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGhhc011bHRpcGxlSW5lcXVhbGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgVGFyZ2V0SW5kZXhNYXRjaGVyJ3NcclxuICAgICAqIHRhcmdldC5cclxuICAgICAqXHJcbiAgICAgKiBBbiBpbmRleCBpcyBjb25zaWRlcmVkIGNhcGFibGUgb2Ygc2VydmluZyB0aGUgdGFyZ2V0IHdoZW46XHJcbiAgICAgKiAtIFRoZSB0YXJnZXQgdXNlcyBhbGwgaW5kZXggc2VnbWVudHMgZm9yIGl0cyBmaWx0ZXJzIGFuZCBvcmRlckJ5IGNsYXVzZXMuXHJcbiAgICAgKiAgIFRoZSB0YXJnZXQgY2FuIGhhdmUgYWRkaXRpb25hbCBmaWx0ZXIgYW5kIG9yZGVyQnkgY2xhdXNlcywgYnV0IG5vdFxyXG4gICAgICogICBmZXdlci5cclxuICAgICAqIC0gSWYgYW4gQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55ZmlsdGVyIGlzIHVzZWQsIHRoZSBpbmRleCBtdXN0IGFsc29cclxuICAgICAqICAgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYENPTlRBSU5TYCBzZWdtZW50LlxyXG4gICAgICogLSBBbGwgZGlyZWN0aW9uYWwgaW5kZXggc2VnbWVudHMgY2FuIGJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0IGFzIGEgc2VyaWVzIG9mXHJcbiAgICAgKiAgIGVxdWFsaXR5IGZpbHRlcnMsIGEgc2luZ2xlIGluZXF1YWxpdHkgZmlsdGVyIGFuZCBhIHNlcmllcyBvZiBvcmRlckJ5XHJcbiAgICAgKiAgIGNsYXVzZXMuXHJcbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGUgZXF1YWxpdHkgZmlsdGVycyBtYXkgYXBwZWFyIG91dCBvZiBvcmRlci5cclxuICAgICAqIC0gVGhlIG9wdGlvbmFsIHNlZ21lbnQgZm9yIHRoZSBpbmVxdWFsaXR5IGZpbHRlciBtdXN0IGFwcGVhciBhZnRlciBhbGxcclxuICAgICAqICAgZXF1YWxpdHkgc2VnbWVudHMuXHJcbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGF0IG9yZGVyQnkgY2xhdXNlIG9mIHRoZSB0YXJnZXQgbXVzdCBhcHBlYXJcclxuICAgICAqICAgaW4gb3JkZXIgYWZ0ZXIgYWxsIGVxdWFsaXR5IGFuZCBpbmVxdWFsaXR5IHNlZ21lbnRzLiBTaW5nbGUgb3JkZXJCeVxyXG4gICAgICogICBjbGF1c2VzIGNhbm5vdCBiZSBza2lwcGVkLCBidXQgYSBjb250aW51b3VzIG9yZGVyQnkgc3VmZml4IG1heSBiZVxyXG4gICAgICogICBvbWl0dGVkLlxyXG4gICAgICovXHJcbiAgICBzZXJ2ZWRCeUluZGV4KGluZGV4KSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChpbmRleC5jb2xsZWN0aW9uR3JvdXAgPT09IHRoaXMuY29sbGVjdGlvbklkKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcclxuICAgICAgICAgICAgLy8gT25seSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBzdXBwb3J0ZWQgZm9yIG5vdy5cclxuICAgICAgICAgICAgLy8gVE9ETyhBZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgaW5lcXVhbGl0eSBxdWVyeSk6IGIvMjk4NDQxMDQzXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYXJyYXkgZWxlbWVudCwgZmluZCBhIG1hdGNoaW5nIGZpbHRlci5cclxuICAgICAgICBjb25zdCBhcnJheVNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGluZGV4KTtcclxuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgIXRoaXMuaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihhcnJheVNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhpbmRleCk7XHJcbiAgICAgICAgbGV0IGVxdWFsaXR5U2VnbWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IHNlZ21lbnRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IG9yZGVyQnlzSW5kZXggPSAwO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIGVxdWFsaXRpZXMgZmlyc3QuIEVxdWFsaXRpZXMgY2FuIGFwcGVhciBvdXQgb2Ygb3JkZXIuXHJcbiAgICAgICAgZm9yICg7IHNlZ21lbnRJbmRleCA8IHNlZ21lbnRzLmxlbmd0aDsgKytzZWdtZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gV2UgYXR0ZW1wdCB0byBncmVlZGlseSBtYXRjaCBhbGwgc2VnbWVudHMgdG8gZXF1YWxpdHkgZmlsdGVycy4gSWYgYVxyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgbWF0Y2hlcyBhbiBpbmRleCBzZWdtZW50LCB3ZSBjYW4gbWFyayB0aGUgc2VnbWVudCBhcyB1c2VkLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhbGl0eVNlZ21lbnRzID0gZXF1YWxpdHlTZWdtZW50cy5hZGQoc2VnbWVudHNbc2VnbWVudEluZGV4XS5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgYSBtYXRjaGluZyBmaWx0ZXIsIHdlIG5lZWQgdG8gdmVyaWZ5IHdoZXRoZXIgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgc2VnbWVudHMgbWFwIHRvIHRoZSB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBpdHMgb3JkZXJCeVxyXG4gICAgICAgICAgICAgICAgLy8gY2xhdXNlcy5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBwcm9jZXNzZWQgYWxsIHNlZ21lbnRzLCBhbGwgc2VnbWVudHMgYXJlIHVzZWQgdG8gc2VydmVcclxuICAgICAgICAvLyB0aGUgZXF1YWxpdHkgZmlsdGVycyBhbmQgd2UgZG8gbm90IG5lZWQgdG8gbWFwIGFueSBzZWdtZW50cyB0byB0aGVcclxuICAgICAgICAvLyB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBvcmRlckJ5IGNsYXVzZXMuXHJcbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIGluZXF1YWxpdHkgaXMgY3VycmVudGx5IHN1cHBvcnRlZC4gR2V0IHRoZSBvbmx5IGVudHJ5IGluIHRoZSBzZXQuXHJcbiAgICAgICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWx0ZXIgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmdldEl0ZXJhdG9yKCkuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbmVxdWFsaXR5IGZpbHRlciBhbmQgdGhlIGZpZWxkIHdhcyBub3QgaW4gb25lIG9mIHRoZVxyXG4gICAgICAgICAgICAvLyBlcXVhbGl0eSBmaWx0ZXJzIGFib3ZlLCB0aGUgbmV4dCBzZWdtZW50IG11c3QgbWF0Y2ggYm90aCB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZmlyc3Qgb3JkZXJCeSBjbGF1c2UuXHJcbiAgICAgICAgICAgIGlmICghZXF1YWxpdHlTZWdtZW50cy5oYXMoaW5lcXVhbGl0eUZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXNGaWx0ZXIoaW5lcXVhbGl0eUZpbHRlciwgc2VnbWVudCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzT3JkZXJCeSh0aGlzLm9yZGVyQnlzW29yZGVyQnlzSW5kZXgrK10sIHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsrc2VnbWVudEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbGwgcmVtYWluaW5nIHNlZ21lbnRzIG5lZWQgdG8gcmVwcmVzZW50IHRoZSBwcmVmaXggb2YgdGhlIHRhcmdldCdzXHJcbiAgICAgICAgLy8gb3JkZXJCeS5cclxuICAgICAgICBmb3IgKDsgc2VnbWVudEluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyArK3NlZ21lbnRJbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKG9yZGVyQnlzSW5kZXggPj0gdGhpcy5vcmRlckJ5cy5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNPcmRlckJ5KHRoaXMub3JkZXJCeXNbb3JkZXJCeXNJbmRleCsrXSwgc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZ1bGwgbWF0Y2hlZCBmaWVsZCBpbmRleCBmb3IgdGhpcyB0YXJnZXQuIEN1cnJlbnRseSBtdWx0aXBsZVxyXG4gICAgICogaW5lcXVhbGl0eSBxdWVyeSBpcyBub3Qgc3VwcG9ydGVkIHNvIGZ1bmN0aW9uIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYnVpbGRUYXJnZXRJbmRleCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIG9ubHkgb25lIHNlZ21lbnQgY3JlYXRlZCBmb3Igb25lIGZpZWxkLiBGb3IgZXhhbXBsZSxcclxuICAgICAgICAvLyBpbiBjYXNlIGxpa2UgYSA9PSAzIGFuZCBhID4gMiwgSW5kZXgge2EgQVNDRU5ESU5HfSB3aWxsIG9ubHkgYmUgY3JlYXRlZFxyXG4gICAgICAgIC8vIG9uY2UuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUZpZWxkcyA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLmVxdWFsaXR5RmlsdGVycykge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyLmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXNBcnJheU9wZXJhdG9yID0gZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcclxuICAgICAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5T3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWx0ZXIuZmllbGQsIDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlRmllbGRzLmhhcyhmaWx0ZXIuZmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bmlxdWVGaWVsZHMgPSB1bmlxdWVGaWVsZHMuYWRkKGZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmlsdGVyLmZpZWxkLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3RlOiBXZSBkbyBub3QgZXhwbGljaXRseSBjaGVjayBgdGhpcy5pbmVxdWFsaXR5RmlsdGVyYCBidXQgcmF0aGVyIHJlbHlcclxuICAgICAgICAvLyBvbiB0aGUgdGFyZ2V0IGRlZmluaW5nIGFuIGFwcHJvcHJpYXRlIFwib3JkZXIgYnlcIiB0byBlbnN1cmUgdGhhdCB0aGVcclxuICAgICAgICAvLyByZXF1aXJlZCBpbmRleCBzZWdtZW50IGlzIGFkZGVkLiBUaGUgcXVlcnkgZW5naW5lIHdvdWxkIHJlamVjdCBhIHF1ZXJ5XHJcbiAgICAgICAgLy8gd2l0aCBhbiBpbmVxdWFsaXR5IGZpbHRlciB0aGF0IGxhY2tzIHRoZSByZXF1aXJlZCBvcmRlci1ieSBjbGF1c2UuXHJcbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRoaXMub3JkZXJCeXMpIHtcclxuICAgICAgICAgICAgLy8gU3RvcCBhZGRpbmcgbW9yZSBzZWdtZW50cyBpZiB3ZSBzZWUgYSBvcmRlci1ieSBvbiBrZXkuIFR5cGljYWxseSB0aGlzXHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBkZWZhdWx0IGltcGxpY2l0IG9yZGVyLWJ5IHdoaWNoIGlzIGNvdmVyZWQgaW4gdGhlIGluZGV4X2VudHJ5XHJcbiAgICAgICAgICAgIC8vIHRhYmxlIGFzIGEgc2VwYXJhdGUgY29sdW1uLiBJZiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgb3JkZXItYnksIHRoZVxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgaW5kZXggd2lsbCBiZSBtaXNzaW5nIHNvbWUgc2VnbWVudHMgb3B0aW1pemVkIGZvciBvcmRlci1ieXMsXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHByb2JhYmx5IGZpbmUuXHJcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVuaXF1ZUZpZWxkcy5oYXMob3JkZXJCeS5maWVsZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaXF1ZUZpZWxkcyA9IHVuaXF1ZUZpZWxkcy5hZGQob3JkZXJCeS5maWVsZCk7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChvcmRlckJ5LmZpZWxkLCBvcmRlckJ5LmRpciA9PT0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXHJcbiAgICAgICAgICAgICAgICA/IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgOiAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIHRoaXMuY29sbGVjdGlvbklkLCBzZWdtZW50cywgSW5kZXhTdGF0ZS5lbXB0eSgpKTtcclxuICAgIH1cclxuICAgIGhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoc2VnbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZXF1YWxpdHlGaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoZXNGaWx0ZXIoZmlsdGVyLCBzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc0ZpbHRlcihmaWx0ZXIsIHNlZ21lbnQpIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQgfHwgIWZpbHRlci5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzQXJyYXlPcGVyYXRvciA9IGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XHJcbiAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XHJcbiAgICAgICAgcmV0dXJuIChzZWdtZW50LmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSA9PT0gaXNBcnJheU9wZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc09yZGVyQnkob3JkZXJCeSwgc2VnbWVudCkge1xyXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovICYmXHJcbiAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pIHx8XHJcbiAgICAgICAgICAgIChzZWdtZW50LmtpbmQgPT09IDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLykpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGhlbHAgd2l0aCBib29sZWFuIGxvZ2ljIHRyYW5zZm9ybWF0aW9ucyBuZWVkZWQgZm9yIGhhbmRsaW5nXHJcbiAqIGNvbXBsZXggZmlsdGVycyB1c2VkIGluIHF1ZXJpZXMuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGBpbmAgZmlsdGVyIGlzIG9ubHkgYSBzeW50YWN0aWMgc3VnYXIgb3ZlciBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXRpZXMuIEZvciBpbnN0YW5jZTogYGEgaW5cclxuICogWzEsMiwzXWAgaXMgaW4gZmFjdCBgYT09MSB8fCBhPT0yIHx8IGE9PTNgLiBUaGlzIG1ldGhvZCBleHBhbmRzIGFueSBgaW5gIGZpbHRlciBpbiB0aGUgZ2l2ZW5cclxuICogaW5wdXQgaW50byBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXR5IGZpbHRlcnMgYW5kIHJldHVybnMgdGhlIGV4cGFuZGVkIGZpbHRlci5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XHJcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgSW5GaWx0ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gKChfYiA9IChfYSA9IGZpbHRlci52YWx1ZS5hcnJheVZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKHZhbHVlID0+IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWx0ZXIuZmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywgdmFsdWUpKSkgfHwgW107XHJcbiAgICAgICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKGV4cGFuZGVkRmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCBvdGhlciBraW5kcyBvZiBmaWVsZCBmaWx0ZXJzLlxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdlIGhhdmUgYSBjb21wb3NpdGUgZmlsdGVyLlxyXG4gICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlSW5FeHBhbnNpb24oc3ViZmlsdGVyKSk7XHJcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIGZpbHRlci5vcCk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgY29tcG9zaXRlIGZpbHRlciwgcmV0dXJucyB0aGUgbGlzdCBvZiB0ZXJtcyBpbiBpdHMgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0uXHJcbiAqXHJcbiAqIDxwPkVhY2ggZWxlbWVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIGlzIG9uZSB0ZXJtIG9mIHRoZSByZXN1bHRpbmcgRE5GLiBGb3IgaW5zdGFuY2U6IEZvciB0aGVcclxuICogaW5wdXQ6IChBIHx8IEIpICYmIEMsIHRoZSBETkYgZm9ybSBpczogKEEgJiYgQykgfHwgKEIgJiYgQyksIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIGEgbGlzdFxyXG4gKiB3aXRoIHR3byBlbGVtZW50czogYSBjb21wb3NpdGUgZmlsdGVyIHRoYXQgcGVyZm9ybXMgKEEgJiYgQyksIGFuZCBhIGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdFxyXG4gKiBwZXJmb3JtcyAoQiAmJiBDKS5cclxuICpcclxuICogQHBhcmFtIGZpbHRlciB0aGUgY29tcG9zaXRlIGZpbHRlciB0byBjYWxjdWxhdGUgRE5GIHRyYW5zZm9ybSBmb3IuXHJcbiAqIEByZXR1cm4gdGhlIHRlcm1zIGluIHRoZSBETkYgdHJhbnNmb3JtLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG5mVGVybXMoZmlsdGVyKSB7XHJcbiAgICBpZiAoZmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpKTtcclxuICAgIGhhcmRBc3NlcnQoaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0ocmVzdWx0KSk7XHJcbiAgICBpZiAoaXNTaW5nbGVGaWVsZEZpbHRlcihyZXN1bHQpIHx8IGlzRmxhdENvbmp1bmN0aW9uKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgYSBzaW5nbGUgZmllbGQgZmlsdGVyLiBlLmcuIChhID09IDEwKS4gKi9cclxuZnVuY3Rpb24gaXNTaW5nbGVGaWVsZEZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHJldHVybiBmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcjtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIG9uZSBvciBtb3JlIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTBcclxuICogJiYgYiA9PSAyMClcclxuICovXHJcbmZ1bmN0aW9uIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcclxuICAgICAgICBjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gZmlsdGVyIGlzIGluIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpLlxyXG4gKlxyXG4gKiA8cD5JbiBib29sZWFuIGxvZ2ljLCBhIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpIGlzIGEgY2Fub25pY2FsIG5vcm1hbCBmb3JtIG9mIGEgbG9naWNhbFxyXG4gKiBmb3JtdWxhIGNvbnNpc3Rpbmcgb2YgYSBkaXNqdW5jdGlvbiBvZiBjb25qdW5jdGlvbnM7IGl0IGNhbiBhbHNvIGJlIGRlc2NyaWJlZCBhcyBhbiBPUiBvZiBBTkRzLlxyXG4gKlxyXG4gKiA8cD5Gb3IgbW9yZSBpbmZvLCB2aXNpdDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzanVuY3RpdmVfbm9ybWFsX2Zvcm1cclxuICovXHJcbmZ1bmN0aW9uIGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIChpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikgfHxcclxuICAgICAgICBpc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpIHx8XHJcbiAgICAgICAgaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGRpc2p1bmN0aW9uIG9mIG9uZSBvciBtb3JlIFwiZmxhdCBjb25qdW5jdGlvbnNcIiBhbmRcclxuICogZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMCkgfHwgKGI9PTIwICYmIGM9PTMwKVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGaWx0ZXJzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTaW5nbGVGaWVsZEZpbHRlcihzdWJGaWx0ZXIpICYmICFpc0ZsYXRDb25qdW5jdGlvbihzdWJGaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGZpbHRlcikge1xyXG4gICAgaGFyZEFzc2VydChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXIuZmlsdGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShmaWx0ZXIuZmlsdGVyc1swXSk7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlIERORiBmb3IgZWFjaCBvZiB0aGUgc3ViZmlsdGVycyBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKHN1YmZpbHRlcikpO1xyXG4gICAgbGV0IG5ld0ZpbHRlciA9IENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0LCBmaWx0ZXIub3ApO1xyXG4gICAgbmV3RmlsdGVyID0gYXBwbHlBc3NvY2lhdGlvbihuZXdGaWx0ZXIpO1xyXG4gICAgaWYgKGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKG5ld0ZpbHRlcikpIHtcclxuICAgICAgICByZXR1cm4gbmV3RmlsdGVyO1xyXG4gICAgfVxyXG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaGFyZEFzc2VydChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKG5ld0ZpbHRlcikpO1xyXG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIuZmlsdGVycy5sZW5ndGggPiAxKTtcclxuICAgIHJldHVybiBuZXdGaWx0ZXIuZmlsdGVycy5yZWR1Y2UoKHJ1bm5pbmdSZXN1bHQsIGZpbHRlcikgPT4gYXBwbHlEaXN0cmlidXRpb24ocnVubmluZ1Jlc3VsdCwgZmlsdGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb24obGhzLCByaHMpIHtcclxuICAgIGhhcmRBc3NlcnQobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgbGhzIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcclxuICAgIGhhcmRBc3NlcnQocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgcmhzIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgRmllbGRGaWx0ZXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRBbmRDb21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIEZpZWxkRmlsdGVyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRBbmRDb21wb3NpdGVGaWx0ZXJzKHJocywgbGhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBvc2l0ZUZpbHRlciBDb21wb3NpdGVGaWx0ZXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwbHlBc3NvY2lhdGlvbihyZXN1bHQpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uRmllbGRGaWx0ZXJzKGxocywgcmhzKSB7XHJcbiAgICAvLyBDb25qdW5jdGlvbiBkaXN0cmlidXRpb24gZm9yIHR3byBmaWVsZCBmaWx0ZXJzIGlzIHRoZSBjb25qdW5jdGlvbiBvZiB0aGVtLlxyXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoW2xocywgcmhzXSwgXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocykge1xyXG4gICAgaGFyZEFzc2VydChsaHMuZmlsdGVycy5sZW5ndGggPiAwICYmIHJocy5maWx0ZXJzLmxlbmd0aCA+IDApO1xyXG4gICAgLy8gVGhlcmUgYXJlIGZvdXIgY2FzZXM6XHJcbiAgICAvLyAoQSAmIEIpICYgKEMgJiBEKSAtLT4gKEEgJiBCICYgQyAmIEQpXHJcbiAgICAvLyAoQSAmIEIpICYgKEMgfCBEKSAtLT4gKEEgJiBCICYgQykgfCAoQSAmIEIgJiBEKVxyXG4gICAgLy8gKEEgfCBCKSAmIChDICYgRCkgLS0+IChDICYgRCAmIEEpIHwgKEMgJiBEICYgQilcclxuICAgIC8vIChBIHwgQikgJiAoQyB8IEQpIC0tPiAoQSAmIEMpIHwgKEEgJiBEKSB8IChCICYgQykgfCAoQiAmIEQpXHJcbiAgICAvLyBDYXNlIDEgaXMgYSBtZXJnZS5cclxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGxocykgJiYgY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMobGhzLCByaHMuZ2V0RmlsdGVycygpKTtcclxuICAgIH1cclxuICAgIC8vIENhc2UgMiwzLDQgYWxsIGhhdmUgYXQgbGVhc3Qgb25lIHNpZGUgKGxocyBvciByaHMpIHRoYXQgaXMgYSBkaXNqdW5jdGlvbi4gSW4gYWxsIHRocmVlIGNhc2VzXHJcbiAgICAvLyB3ZSBzaG91bGQgdGFrZSBlYWNoIGVsZW1lbnQgb2YgdGhlIGRpc2p1bmN0aW9uIGFuZCBkaXN0cmlidXRlIGl0IG92ZXIgdGhlIG90aGVyIHNpZGUsIGFuZFxyXG4gICAgLy8gcmV0dXJuIHRoZSBkaXNqdW5jdGlvbiBvZiB0aGUgZGlzdHJpYnV0aW9uIHJlc3VsdHMuXHJcbiAgICBjb25zdCBkaXNqdW5jdGlvblNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyBsaHMgOiByaHM7XHJcbiAgICBjb25zdCBvdGhlclNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyByaHMgOiBsaHM7XHJcbiAgICBjb25zdCByZXN1bHRzID0gZGlzanVuY3Rpb25TaWRlLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihzdWJmaWx0ZXIsIG90aGVyU2lkZSkpO1xyXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0cywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhmaWVsZEZpbHRlciwgY29tcG9zaXRlRmlsdGVyKSB7XHJcbiAgICAvLyBUaGVyZSBhcmUgdHdvIGNhc2VzOlxyXG4gICAgLy8gQSAmIChCICYgQykgLS0+IChBICYgQiAmIEMpXHJcbiAgICAvLyBBICYgKEIgfCBDKSAtLT4gKEEgJiBCKSB8IChBICYgQylcclxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikpIHtcclxuICAgICAgICAvLyBDYXNlIDFcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyV2l0aEFkZGVkRmlsdGVycyhjb21wb3NpdGVGaWx0ZXIsIGZpZWxkRmlsdGVyLmdldEZpbHRlcnMoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBDYXNlIDJcclxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJzID0gY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihmaWVsZEZpbHRlciwgc3ViZmlsdGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobmV3RmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgYXNzb2NpYXRpdml0eSBwcm9wZXJ0eSB0byB0aGUgZ2l2ZW4gZmlsdGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZmlsdGVyLlxyXG4gKlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPkEgfCAoQiB8IEMpID09IChBIHwgQikgfCBDID09IChBIHwgQiB8IEMpXHJcbiAqICAgPGxpPkEgJiAoQiAmIEMpID09IChBICYgQikgJiBDID09IChBICYgQiAmIEMpXHJcbiAqIDwvdWw+XHJcbiAqXHJcbiAqIDxwPkZvciBtb3JlIGluZm8sIHZpc2l0OiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc3NvY2lhdGl2ZV9wcm9wZXJ0eSNQcm9wb3NpdGlvbmFsX2xvZ2ljXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcikge1xyXG4gICAgaGFyZEFzc2VydChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xyXG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmlsdGVycygpO1xyXG4gICAgLy8gSWYgdGhlIGNvbXBvc2l0ZSBmaWx0ZXIgb25seSBjb250YWlucyAxIGZpbHRlciwgYXBwbHkgYXNzb2NpYXRpdml0eSB0byBpdC5cclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcnNbMF0pO1xyXG4gICAgfVxyXG4gICAgLy8gQXNzb2NpYXRpdml0eSBhcHBsaWVkIHRvIGEgZmxhdCBjb21wb3NpdGUgZmlsdGVyIHJlc3VsdHMgaXMgaXRzZWxmLlxyXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChmaWx0ZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIC8vIEZpcnN0IGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gYWxsIHN1YmZpbHRlcnMuIFRoaXMgd2lsbCBpbiB0dXJuIHJlY3Vyc2l2ZWx5IGFwcGx5XHJcbiAgICAvLyBhc3NvY2lhdGl2aXR5IHRvIGFsbCBuZXN0ZWQgY29tcG9zaXRlIGZpbHRlcnMgYW5kIGZpZWxkIGZpbHRlcnMuXHJcbiAgICBjb25zdCB1cGRhdGVkRmlsdGVycyA9IGZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseUFzc29jaWF0aW9uKHN1YmZpbHRlcikpO1xyXG4gICAgLy8gRm9yIGNvbXBvc2l0ZSBzdWJmaWx0ZXJzIHRoYXQgcGVyZm9ybSB0aGUgc2FtZSBraW5kIG9mIGxvZ2ljYWwgb3BlcmF0aW9uIGFzIGBjb21wb3NpdGVGaWx0ZXJgXHJcbiAgICAvLyB0YWtlIG91dCB0aGVpciBmaWx0ZXJzIGFuZCBhZGQgdGhlbSB0byBgY29tcG9zaXRlRmlsdGVyYC4gRm9yIGV4YW1wbGU6XHJcbiAgICAvLyBjb21wb3NpdGVGaWx0ZXIgPSAoQSB8IChCIHwgQyB8IEQpKVxyXG4gICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyID0gKEIgfCBDIHwgRClcclxuICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQyB8IEQpXHJcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGBjb21wb3NpdGVTdWJmaWx0ZXJgIGhhcyBiZWVuIGVsaW1pbmF0ZWQsIGFuZCBpdHMgZmlsdGVycyAoQiwgQywgRCkgaGF2ZSBiZWVuXHJcbiAgICAvLyBhZGRlZCB0byB0aGUgdG9wLWxldmVsIFwiY29tcG9zaXRlRmlsdGVyXCIuXHJcbiAgICBjb25zdCBuZXdTdWJmaWx0ZXJzID0gW107XHJcbiAgICB1cGRhdGVkRmlsdGVycy5mb3JFYWNoKHN1YmZpbHRlciA9PiB7XHJcbiAgICAgICAgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaChzdWJmaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdWJmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHN1YmZpbHRlci5vcCA9PT0gZmlsdGVyLm9wKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGVGaWx0ZXI6IChBIHwgKEIgfCBDKSlcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZVN1YmZpbHRlcjogKEIgfCBDKVxyXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IEIgfCBDKVxyXG4gICAgICAgICAgICAgICAgbmV3U3ViZmlsdGVycy5wdXNoKC4uLnN1YmZpbHRlci5maWx0ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZUZpbHRlcjogKEEgfCAoQiAmIEMpKVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiAmIEMpXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQ6IChBIHwgKEIgJiBDKSlcclxuICAgICAgICAgICAgICAgIG5ld1N1YmZpbHRlcnMucHVzaChzdWJmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAobmV3U3ViZmlsdGVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gbmV3U3ViZmlsdGVyc1swXTtcclxuICAgIH1cclxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld1N1YmZpbHRlcnMsIGZpbHRlci5vcCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlJbmRleE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXggPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XHJcbiAgICB9XHJcbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5nZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkpO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlQWxsRmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1RhcmdldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKDAgLyogSW5kZXhUeXBlLk5PTkUgKi8pO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKEluZGV4T2Zmc2V0Lm1pbigpKTtcclxuICAgIH1cclxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGV4cG9zZWQgYnkgTWVtb3J5SW5kZXhNYW5hZ2VyLlxyXG4gKiBBbHNvIHVzZWQgZm9yIGluLW1lbW9yeSBjYWNoaW5nIGJ5IEluZGV4ZWREYkluZGV4TWFuYWdlciBhbmQgaW5pdGlhbCBpbmRleCBwb3B1bGF0aW9uXHJcbiAqIGluIGluZGV4ZWRkYl9zY2hlbWEudHNcclxuICovXHJcbmNsYXNzIE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0ge307XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbnRyeSBhbHJlYWR5IGV4aXN0ZWQuXHJcbiAgICBhZGQoY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdIHx8XHJcbiAgICAgICAgICAgIG5ldyBTb3J0ZWRTZXQoUmVzb3VyY2VQYXRoLmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGNvbnN0IGFkZGVkID0gIWV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XHJcbiAgICAgICAgdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdID0gZXhpc3RpbmdQYXJlbnRzLmFkZChwYXJlbnRQYXRoKTtcclxuICAgICAgICByZXR1cm4gYWRkZWQ7XHJcbiAgICB9XHJcbiAgICBoYXMoY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJlbnRzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1BhcmVudHMgJiYgZXhpc3RpbmdQYXJlbnRzLmhhcyhwYXJlbnRQYXRoKTtcclxuICAgIH1cclxuICAgIGdldEVudHJpZXMoY29sbGVjdGlvbklkKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aHMgPSB0aGlzLmluZGV4W2NvbGxlY3Rpb25JZF0gfHxcclxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzLnRvQXJyYXkoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJGYgPSAnSW5kZXhlZERiSW5kZXhNYW5hZ2VyJztcclxuY29uc3QgRU1QVFlfVkFMVUUgPSBuZXcgVWludDhBcnJheSgwKTtcclxuLyoqXHJcbiAqIEEgcGVyc2lzdGVkIGltcGxlbWVudGF0aW9uIG9mIEluZGV4TWFuYWdlci5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBVbmxpa2UgaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2ViIFNESyBkb2VzIG5vdCBtZW1vaXplIGluZGV4XHJcbiAqIGRhdGEgYXMgaXQgc3VwcG9ydHMgbXVsdGktdGFiIGFjY2Vzcy5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYkluZGV4TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1c2VyLCBkYXRhYmFzZUlkKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBpbi1tZW1vcnkgY29weSBvZiB0aGUgaW5kZXggZW50cmllcyB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc2luY2UgdGhlIFNES1xyXG4gICAgICAgICAqIGxhdW5jaGVkLiBVc2VkIHRvIGF2b2lkIHJlLXdyaXRpbmcgdGhlIHNhbWUgZW50cnkgcmVwZWF0ZWRseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgKk5PVCogYSBjb21wbGV0ZSBjYWNoZSBvZiB3aGF0J3MgaW4gcGVyc2lzdGVuY2UgYW5kIHNvIGNhbiBuZXZlciBiZVxyXG4gICAgICAgICAqIHVzZWQgdG8gc2F0aXNmeSByZWFkcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUgPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFwcyBmcm9tIGEgdGFyZ2V0IHRvIGl0cyBlcXVpdmFsZW50IGxpc3Qgb2Ygc3ViLXRhcmdldHMuIEVhY2ggc3ViLXRhcmdldFxyXG4gICAgICAgICAqIGNvbnRhaW5zIG9ubHkgb25lIHRlcm0gZnJvbSB0aGUgdGFyZ2V0J3MgZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0gKERORikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIChsLCByKSA9PiB0YXJnZXRFcXVhbHMobCwgcikpO1xyXG4gICAgICAgIHRoaXMudWlkID0gdXNlci51aWQgfHwgJyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGNvbGxlY3Rpb24gcGFyZW50IGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxyXG4gICAgICogdHJhbnNhY3Rpb24gYXMgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIG9ubHkgY2FjaGVzIHdyaXRlcyBvbmNlIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIGhhcyBiZWVuIGNvbW1pdHRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25QYXRoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUuaGFzKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRPbkNvbW1pdHRlZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xyXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQoY29sbGVjdGlvblBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gW107XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY29sbGVjdGlvbklkLCAnJ10sIFtpbW1lZGlhdGVTdWNjZXNzb3IoY29sbGVjdGlvbklkKSwgJyddLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxyXG4gICAgICAgICAgICAubmV4dChlbnRyaWVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgcnVubmluZyBpbiBhIHJlYWwgYnJvd3NlciksIGJ1dCB0aGVyZSdzIGEgYnVnIGluXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRleGVkZGJzaGltIHRoYXQgYnJlYWtzIG91ciByYW5nZSBpbiBvdXIgdGVzdHMgcnVubmluZyBpbiBub2RlOlxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jb2xsZWN0aW9uSWQgIT09IGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50UGF0aHMucHVzaChkZWNvZGVSZXNvdXJjZVBhdGgoZW50cnkucGFyZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogVmVyaWZ5IHRoYXQgdGhlIGF1dG8taW5jcmVtZW50aW5nIGluZGV4IElEIHdvcmtzIGluXHJcbiAgICAgICAgLy8gU2FmYXJpICYgRmlyZWZveC5cclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGRiSW5kZXggPSB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KTtcclxuICAgICAgICBkZWxldGUgZGJJbmRleC5pbmRleElkOyAvLyBgaW5kZXhJZGAgaXMgYXV0by1wb3B1bGF0ZWQgYnkgSW5kZXhlZERiXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhlcy5hZGQoZGJJbmRleCk7XHJcbiAgICAgICAgaWYgKGluZGV4LmluZGV4U3RhdGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KGluZGV4SWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShpbmRleElkLCB0aGlzLnVpZCwgaW5kZXguaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlciwgaW5kZXguaW5kZXhTdGF0ZS5vZmZzZXQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBlbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBpbmRleGVzXHJcbiAgICAgICAgICAgIC5kZWxldGUoaW5kZXguaW5kZXhJZClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gc3RhdGVzLmRlbGV0ZShJREJLZXlSYW5nZS5ib3VuZChbaW5kZXguaW5kZXhJZF0sIFtpbmRleC5pbmRleElkICsgMV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVudHJpZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxyXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpKSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gaW5kZXhlc1xyXG4gICAgICAgICAgICAuZGVsZXRlQWxsKClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGVBbGwoKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gc3RhdGVzLmRlbGV0ZUFsbCgpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dCh0eXBlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovIHx8IHR5cGUgPT09IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleE1hdGNoZXIgPSBuZXcgVGFyZ2V0SW5kZXhNYXRjaGVyKHN1YlRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IHRhcmdldEluZGV4TWF0Y2hlci5idWlsZFRhcmdldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBsZXQgY2FuU2VydmVUYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMuZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpLCAoc3ViVGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYW5TZXJ2ZVRhcmdldCAmJiAoY2FuU2VydmVUYXJnZXQgPSAhIWluZGV4KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ZXMuc2V0KHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjYW5TZXJ2ZVRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleGVzLCAoaW5kZXgsIHN1YlRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgYFVzaW5nIGluZGV4ICR7ZmllbGRJbmRleFRvU3RyaW5nKGluZGV4KX0gdG8gZXhlY3V0ZSAke2Nhbm9uaWZ5VGFyZ2V0KHRhcmdldCl9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZXMgPSB0YXJnZXRHZXRBcnJheVZhbHVlcyhzdWJUYXJnZXQsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RJblZhbHVlcyA9IHRhcmdldEdldE5vdEluVmFsdWVzKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0YXJnZXRHZXRMb3dlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0YXJnZXRHZXRVcHBlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmRFbmNvZGVkID0gdGhpcy5lbmNvZGVCb3VuZChpbmRleCwgc3ViVGFyZ2V0LCBsb3dlckJvdW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgdXBwZXJCb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90SW5FbmNvZGVkID0gdGhpcy5lbmNvZGVWYWx1ZXMoaW5kZXgsIHN1YlRhcmdldCwgbm90SW5WYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gdGhpcy5nZW5lcmF0ZUluZGV4UmFuZ2VzKGluZGV4LmluZGV4SWQsIGFycmF5VmFsdWVzLCBsb3dlckJvdW5kRW5jb2RlZCwgbG93ZXJCb3VuZC5pbmNsdXNpdmUsIHVwcGVyQm91bmRFbmNvZGVkLCB1cHBlckJvdW5kLmluY2x1c2l2ZSwgbm90SW5FbmNvZGVkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhSYW5nZXMsIChpbmRleFJhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5sb2FkRmlyc3QoaW5kZXhSYW5nZSwgdGFyZ2V0LmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50S2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGVudHJ5LmRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5cy5oYXMoZG9jdW1lbnRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5cyA9IGV4aXN0aW5nS2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTdWJUYXJnZXRzKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBzdWJUYXJnZXRzID0gdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHN1YlRhcmdldHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YlRhcmdldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQuZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc3ViVGFyZ2V0cyA9IFt0YXJnZXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYW4gaW1wbGljaXQgQU5EIG9wZXJhdGlvbiBiZXR3ZWVuIGFsbCB0aGUgZmlsdGVycyBzdG9yZWQgaW4gdGhlIHRhcmdldFxyXG4gICAgICAgICAgICBjb25zdCBkbmYgPSBnZXREbmZUZXJtcyhDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHRhcmdldC5maWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xyXG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gZG5mLm1hcCh0ZXJtID0+IG5ld1RhcmdldCh0YXJnZXQucGF0aCwgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCwgdGFyZ2V0Lm9yZGVyQnksIHRlcm0uZ2V0RmlsdGVycygpLCB0YXJnZXQubGltaXQsIHRhcmdldC5zdGFydEF0LCB0YXJnZXQuZW5kQXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuc2V0KHRhcmdldCwgc3ViVGFyZ2V0cyk7XHJcbiAgICAgICAgcmV0dXJuIHN1YlRhcmdldHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBrZXkgcmFuZ2UgcXVlcnkgb24gYERiSW5kZXhFbnRyeVN0b3JlYCB0aGF0IHVuaW9ucyBhbGxcclxuICAgICAqIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVJbmRleFJhbmdlcyhpbmRleElkLCBhcnJheVZhbHVlcywgbG93ZXJCb3VuZHMsIGxvd2VyQm91bmRJbmNsdXNpdmUsIHVwcGVyQm91bmRzLCB1cHBlckJvdW5kSW5jbHVzaXZlLCBub3RJblZhbHVlcykge1xyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgdG90YWwgaW5kZXggc2NhbnMgd2UgdW5pb24gdG9nZXRoZXIuIFRoaXMgaXMgc2ltaWxhciB0byBhXHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgbm9ybWFsIGZvcm0sIGJ1dCBhZGFwdGVkIGZvciBhcnJheSB2YWx1ZXMuIFdlIGNyZWF0ZSBhIHNpbmdsZVxyXG4gICAgICAgIC8vIGluZGV4IHJhbmdlIHBlciB2YWx1ZSBpbiBhbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTlkgZmlsdGVyXHJcbiAgICAgICAgLy8gY29tYmluZWQgd2l0aCB0aGUgdmFsdWVzIGZyb20gdGhlIHF1ZXJ5IGJvdW5kcy5cclxuICAgICAgICBjb25zdCB0b3RhbFNjYW5zID0gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKSAqXHJcbiAgICAgICAgICAgIE1hdGgubWF4KGxvd2VyQm91bmRzLmxlbmd0aCwgdXBwZXJCb3VuZHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzY2Fuc1BlckFycmF5RWxlbWVudCA9IHRvdGFsU2NhbnMgLyAoYXJyYXlWYWx1ZXMgIT0gbnVsbCA/IGFycmF5VmFsdWVzLmxlbmd0aCA6IDEpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNjYW5zOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IGFycmF5VmFsdWVzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlc1tpIC8gc2NhbnNQZXJBcnJheUVsZW1lbnRdKVxyXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9WQUxVRTtcclxuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHRoaXMuZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGxvd2VyQm91bmRzW2kgJSBzY2Fuc1BlckFycmF5RWxlbWVudF0sIGxvd2VyQm91bmRJbmNsdXNpdmUpO1xyXG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5nZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgdXBwZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgdXBwZXJCb3VuZEluY2x1c2l2ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdEluQm91bmQgPSBub3RJblZhbHVlcy5tYXAobm90SW4gPT4gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbm90SW4sIFxyXG4gICAgICAgICAgICAvKiBpbmNsdXNpdmU9ICovIHRydWUpKTtcclxuICAgICAgICAgICAgaW5kZXhSYW5nZXMucHVzaCguLi50aGlzLmNyZWF0ZVJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG5vdEluQm91bmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZGV4UmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLyoqIEdlbmVyYXRlcyB0aGUgbG93ZXIgYm91bmQgZm9yIGBhcnJheVZhbHVlYCBhbmQgYGRpcmVjdGlvbmFsVmFsdWVgLiAqL1xyXG4gICAgZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUsIGluY2x1c2l2ZSkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGluY2x1c2l2ZSA/IGVudHJ5IDogZW50cnkuc3VjY2Vzc29yKCk7XHJcbiAgICB9XHJcbiAgICAvKiogR2VuZXJhdGVzIHRoZSB1cHBlciBib3VuZCBmb3IgYGFycmF5VmFsdWVgIGFuZCBgZGlyZWN0aW9uYWxWYWx1ZWAuICovXHJcbiAgICBnZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgSW5kZXhFbnRyeShpbmRleElkLCBEb2N1bWVudEtleS5lbXB0eSgpLCBhcnJheVZhbHVlLCBkaXJlY3Rpb25hbFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gaW5jbHVzaXZlID8gZW50cnkuc3VjY2Vzc29yKCkgOiBlbnRyeTtcclxuICAgIH1cclxuICAgIGdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4TWF0Y2hlciA9IG5ldyBUYXJnZXRJbmRleE1hdGNoZXIodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0YXJnZXQuY29sbGVjdGlvbkdyb3VwICE9IG51bGxcclxuICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkubmV4dChpbmRleGVzID0+IHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBpbmRleCB3aXRoIHRoZSBtb3N0IG51bWJlciBvZiBzZWdtZW50cy5cclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaW5kZXhlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRhcmdldEluZGV4TWF0Y2hlci5zZXJ2ZWRCeUluZGV4KGNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghaW5kZXggfHwgY2FuZGlkYXRlLmZpZWxkcy5sZW5ndGggPiBpbmRleC5maWVsZHMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IGluZGV4VHlwZSA9IDIgLyogSW5kZXhUeXBlLkZVTEwgKi87XHJcbiAgICAgICAgY29uc3Qgc3ViVGFyZ2V0cyA9IHRoaXMuZ2V0U3ViVGFyZ2V0cyh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChzdWJUYXJnZXRzLCAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkubmV4dChpbmRleCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUeXBlID0gMCAvKiBJbmRleFR5cGUuTk9ORSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4VHlwZSAhPT0gMCAvKiBJbmRleFR5cGUuTk9ORSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmZpZWxkcy5sZW5ndGggPCB0YXJnZXRHZXRTZWdtZW50Q291bnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIGhhdmUgbW9yZSB0aGFuIG9uZSBzdWItdGFyZ2V0IChvbmUgc3ViLXRhcmdldCBwZXIgRE5GIHRlcm0pLiBXZSBjdXJyZW50bHkgY29uc2lkZXJcclxuICAgICAgICAgICAgLy8gT1IgcXVlcmllcyB0aGF0IGhhdmUgYSBgbGltaXRgIHRvIGhhdmUgYSBwYXJ0aWFsIGluZGV4LiBGb3Igc3VjaCBxdWVyaWVzIHdlIHBlcmZvcm0gc29ydGluZ1xyXG4gICAgICAgICAgICAvLyBhbmQgYXBwbHkgdGhlIGxpbWl0IGluIG1lbW9yeSBhcyBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwLlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SGFzTGltaXQodGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVGFyZ2V0cy5sZW5ndGggPiAxICYmXHJcbiAgICAgICAgICAgICAgICBpbmRleFR5cGUgPT09IDIgLyogSW5kZXhUeXBlLkZVTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleFR5cGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJ5dGUgZW5jb2RlZCBmb3JtIG9mIHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgaW4gdGhlIGZpZWxkIGluZGV4LlxyXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgYWxsIGZpZWxkcyBzcGVjaWZpZWQgaW4gdGhlXHJcbiAgICAgKiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlRGlyZWN0aW9uYWxFbGVtZW50cyhmaWVsZEluZGV4LCBkb2N1bWVudCkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGRvY3VtZW50LmRhdGEuZmllbGQoc2VnbWVudC5maWVsZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XHJcbiAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKGZpZWxkLCBkaXJlY3Rpb25hbEVuY29kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKiBFbmNvZGVzIGEgc2luZ2xlIHZhbHVlIHRvIHRoZSBhc2NlbmRpbmcgaW5kZXggZm9ybWF0LiAqL1xyXG4gICAgZW5jb2RlU2luZ2xlRWxlbWVudCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xyXG4gICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKHZhbHVlLCBlbmNvZGVyLmZvcktpbmQoMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlZEJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZW5jb2RlZCBmb3JtIG9mIHRoZSBkb2N1bWVudCBrZXkgdGhhdCBzb3J0cyBiYXNlZCBvbiB0aGUga2V5XHJcbiAgICAgKiBvcmRlcmluZyBvZiB0aGUgZmllbGQgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIGVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUocmVmVmFsdWUodGhpcy5kYXRhYmFzZUlkLCBkb2N1bWVudEtleSksIGVuY29kZXIuZm9yS2luZChmaWVsZEluZGV4R2V0S2V5T3JkZXIoZmllbGRJbmRleCkpKTtcclxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gZmllbGQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC5cclxuICAgICAqIEZvciBJTiBxdWVyaWVzLCBhIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzIGlzIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuY29kZXJzID0gW107XHJcbiAgICAgICAgZW5jb2RlcnMucHVzaChuZXcgSW5kZXhCeXRlRW5jb2RlcigpKTtcclxuICAgICAgICBsZXQgdmFsdWVJZHggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeCsrXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luRmlsdGVyKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpICYmIGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlcnMgPSB0aGlzLmV4cGFuZEluZGV4VmFsdWVzKGVuY29kZXJzLCBzZWdtZW50LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25hbEVuY29kZXIgPSBlbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBib3VuZHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGluIGB0YXJnZXRgLiBGb3IgSU5cclxuICAgICAqIHF1ZXJpZXMsIGEgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJvdW5kKGZpZWxkSW5kZXgsIHRhcmdldCwgYm91bmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCBib3VuZC5wb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgYnl0ZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGVuY29kZXJzLiAqL1xyXG4gICAgZ2V0RW5jb2RlZEJ5dGVzKGVuY29kZXJzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBlbmNvZGVyc1tpXS5lbmNvZGVkQnl0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNlcGFyYXRlIGVuY29kZXIgZm9yIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIGFwcGVuZHMgZWFjaCB2YWx1ZSB0byBhbGwgZXhpc3RpbmcgZW5jb2RlcnMgKGUuZy4gZmlsdGVyKFwiYVwiLFxyXG4gICAgICogXCI9PVwiLCBcImExXCIpLmZpbHRlcihcImJcIiwgXCJpblwiLCBbXCJiMVwiLCBcImIyXCJdKSBiZWNvbWVzIFtcImExLGIxXCIsIFwiYTEsYjJcIl0pLiBBXHJcbiAgICAgKiBsaXN0IG9mIG5ldyBlbmNvZGVycyBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ZXMgPSBbLi4uZW5jb2RlcnNdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFycmF5RWxlbWVudCBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkRW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRFbmNvZGVyLnNlZWQocHJlZml4LmVuY29kZWRCeXRlcygpKTtcclxuICAgICAgICAgICAgICAgIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIuSU5TVEFOQ0Uud3JpdGVJbmRleFZhbHVlKGFycmF5RWxlbWVudCwgY2xvbmVkRW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNsb25lZEVuY29kZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgaXNJbkZpbHRlcih0YXJnZXQsIGZpZWxkUGF0aCkge1xyXG4gICAgICAgIHJldHVybiAhIXRhcmdldC5maWx0ZXJzLmZpbmQoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcclxuICAgICAgICAgICAgZi5maWVsZC5pc0VxdWFsKGZpZWxkUGF0aCkgJiZcclxuICAgICAgICAgICAgKGYub3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBmLm9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uR3JvdXBcclxuICAgICAgICAgICAgPyBpbmRleGVzLmxvYWRBbGwoRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleCwgSURCS2V5UmFuZ2UuYm91bmQoY29sbGVjdGlvbkdyb3VwLCBjb2xsZWN0aW9uR3JvdXApKVxyXG4gICAgICAgICAgICA6IGluZGV4ZXMubG9hZEFsbCgpKS5uZXh0KGluZGV4Q29uZmlncyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhDb25maWdzLCAoaW5kZXhDb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0KFtpbmRleENvbmZpZy5pbmRleElkLCB0aGlzLnVpZF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaW5kZXhTdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4Q29uZmlnLCBpbmRleFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TmV4dENvbGxlY3Rpb25Hcm91cFRvVXBkYXRlKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKS5uZXh0KGluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4ZXMuc29ydCgobCwgcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY21wID0gbC5pbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVyIC0gci5pbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcCAhPT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gY21wXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcmltaXRpdmVDb21wYXJhdG9yKGwuY29sbGVjdGlvbkdyb3VwLCByLmNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlc1swXS5jb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikubmV4dChuZXh0U2VxdWVuY2VOdW1iZXIgPT4gaW5kZXhlc1xyXG4gICAgICAgICAgICAubG9hZEFsbChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXHJcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51aWQsIG5leHRTZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSkpKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xyXG4gICAgICAgIC8vIFBvcnRpbmcgTm90ZTogYGdldEZpZWxkSW5kZXhlcygpYCBvbiBXZWIgZG9lcyBub3QgY2FjaGUgaW5kZXggbG9va3VwcyBhc1xyXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHVzZWQgYWNyb3NzIGRpZmZlcmVudCBJbmRleGVkREIgdHJhbnNhY3Rpb25zLiBBcyBhbnkgY2FjaGVkXHJcbiAgICAgICAgLy8gZGF0YSBtaWdodCBiZSBpbnZhbGlkYXRlZCBieSBvdGhlciBtdWx0aS10YWIgY2xpZW50cywgd2UgY2FuIG9ubHkgdHJ1c3RcclxuICAgICAgICAvLyBkYXRhIHdpdGhpbiBhIHNpbmdsZSBJbmRleGVkREIgdHJhbnNhY3Rpb24uIFdlIHRoZXJlZm9yZSBhZGQgYSBjYWNoZVxyXG4gICAgICAgIC8vIGhlcmUuXHJcbiAgICAgICAgY29uc3QgbWVtb2l6ZWRJbmRleGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkb2N1bWVudHMsIChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzID0gbWVtb2l6ZWRJbmRleGVzLmdldChrZXkuY29sbGVjdGlvbkdyb3VwKTtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleGVzID0gbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgPyBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwga2V5LmNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZEluZGV4ZXMubmV4dChmaWVsZEluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRJbmRleGVzLnNldChrZXkuY29sbGVjdGlvbkdyb3VwLCBmaWVsZEluZGV4ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGZpZWxkSW5kZXhlcywgKGZpZWxkSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFeGlzdGluZ0luZGV4RW50cmllcyh0cmFuc2FjdGlvbiwga2V5LCBmaWVsZEluZGV4KS5uZXh0KGV4aXN0aW5nRW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB0aGlzLmNvbXB1dGVJbmRleEVudHJpZXMoZG9jLCBmaWVsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0VudHJpZXMuaXNFcXVhbChuZXdFbnRyaWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jLCBmaWVsZEluZGV4LCBleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5wdXQoe1xyXG4gICAgICAgICAgICBpbmRleElkOiBpbmRleEVudHJ5LmluZGV4SWQsXHJcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXHJcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uYWxWYWx1ZTogaW5kZXhFbnRyeS5kaXJlY3Rpb25hbFZhbHVlLFxyXG4gICAgICAgICAgICBvcmRlcmVkRG9jdW1lbnRLZXk6IHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSxcclxuICAgICAgICAgICAgZG9jdW1lbnRLZXk6IGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5kZWxldGUoW1xyXG4gICAgICAgICAgICBpbmRleEVudHJ5LmluZGV4SWQsXHJcbiAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICBpbmRleEVudHJ5LmFycmF5VmFsdWUsXHJcbiAgICAgICAgICAgIGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcclxuICAgICAgICAgICAgdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudC5rZXkpLFxyXG4gICAgICAgICAgICBkb2N1bWVudC5rZXkucGF0aC50b0FycmF5KClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSwgZmllbGRJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCxcclxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoW1xyXG4gICAgICAgICAgICAgICAgZmllbGRJbmRleC5pbmRleElkLFxyXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KVxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgIH0sIChfLCBlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudEtleSwgZW50cnkuYXJyYXlWYWx1ZSwgZW50cnkuZGlyZWN0aW9uYWxWYWx1ZSkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgdGhlIGluZGV4IGVudHJpZXMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC4gKi9cclxuICAgIGNvbXB1dGVJbmRleEVudHJpZXMoZG9jdW1lbnQsIGZpZWxkSW5kZXgpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsVmFsdWUgPSB0aGlzLmVuY29kZURpcmVjdGlvbmFsRWxlbWVudHMoZmllbGRJbmRleCwgZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25hbFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFycmF5U2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCk7XHJcbiAgICAgICAgaWYgKGFycmF5U2VnbWVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuZGF0YS5maWVsZChhcnJheVNlZ21lbnQuZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlKSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIEVNUFRZX1ZBTFVFLCBkaXJlY3Rpb25hbFZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbmRleCBlbnRyaWVzIGZvciB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgYnkgZGVsZXRpbmcgZW50cmllc1xyXG4gICAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlZmVyZW5jZWQgaW4gYG5ld0VudHJpZXNgIGFuZCBhZGRpbmcgYWxsIG5ld2x5IGFkZGVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRmLCBcIlVwZGF0aW5nIGluZGV4IGVudHJpZXMgZm9yIGRvY3VtZW50ICclcydcIiwgZG9jdW1lbnQua2V5KTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGRpZmZTb3J0ZWRTZXRzKGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcywgaW5kZXhFbnRyeUNvbXBhcmF0b3IsIFxyXG4gICAgICAgIC8qIG9uQWRkPSAqLyBlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5hZGRJbmRleEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZW50cnkpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvKiBvblJlbW92ZT0gKi8gZW50cnkgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGVudHJ5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGxldCBuZXh0U2VxdWVuY2VOdW1iZXIgPSAxO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlc1xyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XHJcbiAgICAgICAgICAgIGluZGV4OiBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LFxyXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbdGhpcy51aWQsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSlcclxuICAgICAgICB9LCAoXywgc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5kb25lKCk7XHJcbiAgICAgICAgICAgIG5leHRTZXF1ZW5jZU51bWJlciA9IHN0YXRlLnNlcXVlbmNlTnVtYmVyICsgMTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBuZXh0U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNldCBvZiBJREIgcmFuZ2VzIHRoYXQgc3BsaXRzIHRoZSBleGlzdGluZyByYW5nZSBhbmQgZXhjbHVkZXNcclxuICAgICAqIGFueSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgYG5vdEluVmFsdWVgIGZyb20gdGhlc2UgcmFuZ2VzLiBBcyBhbiBleGFtcGxlLFxyXG4gICAgICogJ1tmb28gPiAyICYmIGZvbyAhPSAzXWAgYmVjb21lcyAgYFtmb28gPiAyICYmIDwgMywgZm9vID4gM11gLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIG5vdEluVmFsdWVzKSB7XHJcbiAgICAgICAgLy8gVGhlIG5vdEluIHZhbHVlcyBuZWVkIHRvIGJlIHNvcnRlZCBhbmQgdW5pcXVlIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhXHJcbiAgICAgICAgLy8gc29ydGVkIHNldCBvZiBub24tb3ZlcmxhcHBpbmcgcmFuZ2VzLlxyXG4gICAgICAgIG5vdEluVmFsdWVzID0gbm90SW5WYWx1ZXNcclxuICAgICAgICAgICAgLnNvcnQoKGwsIHIpID0+IGluZGV4RW50cnlDb21wYXJhdG9yKGwsIHIpKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChlbCwgaSwgdmFsdWVzKSA9PiAhaSB8fCBpbmRleEVudHJ5Q29tcGFyYXRvcihlbCwgdmFsdWVzW2kgLSAxXSkgIT09IDApO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFtdO1xyXG4gICAgICAgIGJvdW5kcy5wdXNoKGxvd2VyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vdEluVmFsdWUgb2Ygbm90SW5WYWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wVG9Mb3dlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIGxvd2VyKTtcclxuICAgICAgICAgICAgY29uc3QgY21wVG9VcHBlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIHVwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGNtcFRvTG93ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCBpcyB0aGUgbG93ZXIgYm91bmQuIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJhaXNlIHRoZSBib3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG5leHQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbMF0gPSBsb3dlci5zdWNjZXNzb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXBUb0xvd2VyID4gMCAmJiBjbXBUb1VwcGVyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5wdXNoKG5vdEluVmFsdWUuc3VjY2Vzc29yKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFRvVXBwZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgKGFuZCBhbGwgZm9sbG93aW5nIHZhbHVlcykgYXJlIG91dCBvZiB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvdW5kcy5wdXNoKHVwcGVyKTtcclxuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgdHdvIGJvdW5kcyB0aGF0IHdpbGwgY3JlYXRlIGFuIHVubWF0Y2hhYmxlIGtleSByYW5nZSxcclxuICAgICAgICAgICAgLy8gdGhlbiB3ZSByZXR1cm4gYW4gZW1wdHkgc2V0IG9mIGtleSByYW5nZXMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2VNYXRjaGFibGUoYm91bmRzW2ldLCBib3VuZHNbaSArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSBbXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbaV0uaW5kZXhJZCxcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2ldLmFycmF5VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBib3VuZHNbaV0uZGlyZWN0aW9uYWxWYWx1ZSxcclxuICAgICAgICAgICAgICAgIEVNUFRZX1ZBTFVFLFxyXG4gICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IFtcclxuICAgICAgICAgICAgICAgIGJvdW5kc1tpICsgMV0uaW5kZXhJZCxcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5hcnJheVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5kaXJlY3Rpb25hbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgRU1QVFlfVkFMVUUsXHJcbiAgICAgICAgICAgICAgICBbXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaChJREJLZXlSYW5nZS5ib3VuZChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcbiAgICBpc1JhbmdlTWF0Y2hhYmxlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcclxuICAgICAgICAvLyBJZiBsb3dlciBib3VuZCBpcyBncmVhdGVyIHRoYW4gdGhlIHVwcGVyIGJvdW5kLCB0aGVuIHRoZSBrZXlcclxuICAgICAgICAvLyByYW5nZSBjYW4gbmV2ZXIgYmUgbWF0Y2hlZC5cclxuICAgICAgICByZXR1cm4gaW5kZXhFbnRyeUNvbXBhcmF0b3IobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPiAwO1xyXG4gICAgfVxyXG4gICAgZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XHJcbiAgICB9XHJcbiAgICBnZXRNaW5PZmZzZXQodHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UubWFwQXJyYXkodGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KGluZGV4ID0+IGluZGV4ID8gaW5kZXggOiBmYWlsKCkpKS5uZXh0KGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNvbGxlY3Rpb25QYXJlbnRzXHJcbiAqIGRvY3VtZW50IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ29sbGVjdGlvblBhcmVudFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBlbnRyeSBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleEVudHJpZXNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhFbnRyeVN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBjb25maWd1cmF0aW9uIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggc3RhdGUgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXhTdGF0ZVN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleFN0YXRlU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMoZmllbGRJbmRleGVzKSB7XHJcbiAgICBoYXJkQXNzZXJ0KGZpZWxkSW5kZXhlcy5sZW5ndGggIT09IDApO1xyXG4gICAgbGV0IG1pbk9mZnNldCA9IGZpZWxkSW5kZXhlc1swXS5pbmRleFN0YXRlLm9mZnNldDtcclxuICAgIGxldCBtYXhCYXRjaElkID0gbWluT2Zmc2V0Lmxhcmdlc3RCYXRjaElkO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWVsZEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmaWVsZEluZGV4ZXNbaV0uaW5kZXhTdGF0ZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdPZmZzZXQsIG1pbk9mZnNldCkgPCAwKSB7XHJcbiAgICAgICAgICAgIG1pbk9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heEJhdGNoSWQgPCBuZXdPZmZzZXQubGFyZ2VzdEJhdGNoSWQpIHtcclxuICAgICAgICAgICAgbWF4QmF0Y2hJZCA9IG5ld09mZnNldC5sYXJnZXN0QmF0Y2hJZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KG1pbk9mZnNldC5yZWFkVGltZSwgbWluT2Zmc2V0LmRvY3VtZW50S2V5LCBtYXhCYXRjaElkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVsZXRlIGEgbXV0YXRpb24gYmF0Y2ggYW5kIHRoZSBhc3NvY2lhdGVkIGRvY3VtZW50IG11dGF0aW9ucy5cclxuICogQHJldHVybnMgQSBQZXJzaXN0ZW5jZVByb21pc2Ugb2YgdGhlIGRvY3VtZW50IG11dGF0aW9ucyB0aGF0IHdlcmUgcmVtb3ZlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCB1c2VySWQsIGJhdGNoKSB7XHJcbiAgICBjb25zdCBtdXRhdGlvblN0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgIGNvbnN0IGluZGV4VHhuID0gdHhuLnN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcclxuICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICBsZXQgbnVtRGVsZXRlZCA9IDA7XHJcbiAgICBjb25zdCByZW1vdmVQcm9taXNlID0gbXV0YXRpb25TdG9yZS5pdGVyYXRlKHsgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICBudW1EZWxldGVkKys7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XHJcbiAgICB9KTtcclxuICAgIHByb21pc2VzLnB1c2gocmVtb3ZlUHJvbWlzZS5uZXh0KCgpID0+IHtcclxuICAgICAgICBoYXJkQXNzZXJ0KG51bURlbGV0ZWQgPT09IDEpO1xyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgcmVtb3ZlZERvY3VtZW50cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBiYXRjaC5tdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh1c2VySWQsIG11dGF0aW9uLmtleS5wYXRoLCBiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4VHhuLmRlbGV0ZShpbmRleEtleSkpO1xyXG4gICAgICAgIHJlbW92ZWREb2N1bWVudHMucHVzaChtdXRhdGlvbi5rZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlbW92ZWREb2N1bWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIHNpemUgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGRiRG9jdW1lbnRTaXplKGRvYykge1xyXG4gICAgaWYgKCFkb2MpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZTtcclxuICAgIGlmIChkb2MuZG9jdW1lbnQpIHtcclxuICAgICAgICB2YWx1ZSA9IGRvYy5kb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICB2YWx1ZSA9IGRvYy51bmtub3duRG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2Mubm9Eb2N1bWVudCkge1xyXG4gICAgICAgIHZhbHVlID0gZG9jLm5vRG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQSBtdXRhdGlvbiBxdWV1ZSBmb3IgYSBzcGVjaWZpYyB1c2VyLCBiYWNrZWQgYnkgSW5kZXhlZERCLiAqL1xyXG5jbGFzcyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFsaXplZCB1c2VySWQgKGUuZy4gbnVsbCBVSUQgPT4gXCJcIiB1c2VySWQpIHVzZWQgdG8gc3RvcmUgL1xyXG4gICAgICogcmV0cmlldmUgbXV0YXRpb25zLlxyXG4gICAgICovXHJcbiAgICB1c2VySWQsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZXMgdGhlIGRvY3VtZW50IGtleXMgZm9yIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcy4gSWYgdGhlIG11dGF0aW9uXHJcbiAgICAgICAgICogaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIEluZGV4ZWREYiwgdGhlIGNhY2hlZCB2YWx1ZSBtYXkgY29udGludWUgdG9cclxuICAgICAgICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBiYXRjaCdzIGRvY3VtZW50IGtleXMuIFRvIHJlbW92ZSBhIGNhY2hlZCB2YWx1ZVxyXG4gICAgICAgICAqIGxvY2FsbHksIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgc2hvdWxkIGJlIGludm9rZWQgZWl0aGVyIGRpcmVjdGx5XHJcbiAgICAgICAgICogb3IgdGhyb3VnaCBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2l0aCBtdWx0aS10YWIsIHdoZW4gdGhlIHByaW1hcnkgY2xpZW50IGFja25vd2xlZGdlcyBvciByZWplY3RzIGEgbXV0YXRpb24sXHJcbiAgICAgICAgICogdGhpcyBjYWNoZSBpcyB1c2VkIGJ5IHNlY29uZGFyeSBjbGllbnRzIHRvIGludmFsaWRhdGUgdGhlIGxvY2FsXHJcbiAgICAgICAgICogdmlldyBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFmZmVjdGVkIGJ5IHRoZSBtdXRhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyLlxyXG4gICAgICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlciBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgbXV0YXRpb24gcXVldWUuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBzZXJpYWxpemVyIHRvIHVzZSB3aGVuIHBlcnNpc3RpbmcgdG8gSW5kZXhlZERiLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yVXNlcih1c2VyLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XHJcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBGaWd1cmUgb3V0IHdoYXQgY29uc3RyYWludHMgdGhlcmUgYXJlIG9uIHVzZXJJRHNcclxuICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBhcmUgdGhlcmUgYW55IHJlc2VydmVkIGNoYXJhY3RlcnM/IGFyZSBlbXB0eSBpZHMgYWxsb3dlZD9cclxuICAgICAgICAvLyBGb3IgdGhlIG1vbWVudCBzdG9yZSB0aGVzZSB0b2dldGhlciBpbiB0aGUgc2FtZSBtdXRhdGlvbnMgdGFibGUgYXNzdW1pbmdcclxuICAgICAgICAvLyB0aGF0IGVtcHR5IHVzZXJJRHMgYXJlbid0IGFsbG93ZWQuXHJcbiAgICAgICAgaGFyZEFzc2VydCh1c2VyLnVpZCAhPT0gJycpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHVzZXIuaXNBdXRoZW50aWNhdGVkKCkgPyB1c2VyLnVpZCA6ICcnO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiTXV0YXRpb25RdWV1ZSh1c2VySWQsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGxldCBlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcclxuICAgIH1cclxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdG9yZSA9IG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAvLyBUaGUgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uIGluIENocm9tZSAoYW5kIEZpcmVmb3gpIGRvZXMgbm90IGhhbmRsZVxyXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcclxuICAgICAgICAvLyB0aGF0IHRoZSBpbmRleCBlbnRyeSBpcyBhZGRlZCBjb3JyZWN0bHkgaW4gYWxsIGJyb3dzZXJzLCB3ZSBwZXJmb3JtIHR3b1xyXG4gICAgICAgIC8vIHdyaXRlczogVGhlIGZpcnN0IHdyaXRlIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIG5leHQgYXV0by1nZW5lcmF0ZWQgQmF0Y2hcclxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcclxuICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaC5cclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTcwMTk3MlxyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25TdG9yZS5hZGQoe30pLm5leHQoYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGJCYXRjaCA9IHRvRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIGJhdGNoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh0aGlzLnVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQobXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXV0YXRpb25TdG9yZS5wdXQoZGJCYXRjaCkpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFN0b3JlLnB1dChpbmRleEtleSwgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uUGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBiYXRjaC5rZXlzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gYmF0Y2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldChiYXRjaElkKVxyXG4gICAgICAgICAgICAubmV4dChkYkJhdGNoID0+IHtcclxuICAgICAgICAgICAgaWYgKGRiQmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRvY3VtZW50IGtleXMgZm9yIHRoZSBtdXRhdGlvbiBiYXRjaCB3aXRoIHRoZSBnaXZlbiBiYXRjaElkLlxyXG4gICAgICogRm9yIHByaW1hcnkgY2xpZW50cywgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAgYWZ0ZXJcclxuICAgICAqIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAgaGFzIGJlZW4gY2FsbGVkLiBTZWNvbmRhcnkgY2xpZW50cyByZXR1cm4gYVxyXG4gICAgICogY2FjaGVkIHJlc3VsdCB1bnRpbCBgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKClgIGlzIGludm9rZWQuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBsb29rdXBNdXRhdGlvbktleXModHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcclxuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpLm5leHQoYmF0Y2ggPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGJhdGNoLmtleXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGtleXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBuZXh0QmF0Y2hJZCA9IGJhdGNoSWQgKyAxO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChbdGhpcy51c2VySWQsIG5leHRCYXRjaElkXSk7XHJcbiAgICAgICAgbGV0IGZvdW5kQmF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYkJhdGNoLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC5iYXRjaElkID49IG5leHRCYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvdW5kQmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZm91bmRCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKFtcclxuICAgICAgICAgICAgdGhpcy51c2VySWQsXHJcbiAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxldCBiYXRjaElkID0gQkFUQ0hJRF9VTktOT1dOO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSwgcmV2ZXJzZTogdHJ1ZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGJhdGNoSWQgPSBkYkJhdGNoLmJhdGNoSWQ7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGJhdGNoSWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIEJBVENISURfVU5LTk9XTl0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAubG9hZEFsbChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlKVxyXG4gICAgICAgICAgICAubmV4dChkYkJhdGNoZXMgPT4gZGJCYXRjaGVzLm1hcChkYkJhdGNoID0+IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgLy8gU2NhbiB0aGUgZG9jdW1lbnQtbXV0YXRpb24gaW5kZXggc3RhcnRpbmcgd2l0aCBhIHByZWZpeCBzdGFydGluZyB3aXRoXHJcbiAgICAgICAgLy8gdGhlIGdpdmVuIGRvY3VtZW50S2V5LlxyXG4gICAgICAgIGNvbnN0IGluZGV4UHJlZml4ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgcm93cyBtYXRjaGluZyBleGFjdGx5IHRoZSBzcGVjaWZpYyBrZXkgb2ZcclxuICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxyXG4gICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXHJcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleCByb3dzIGZvciBkb2N1bWVudEtleSBjb250aWd1b3VzbHkuIEluIHBhcnRpY3VsYXIsIGFsbFxyXG4gICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXHJcbiAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcclxuICAgICAgICAgICAgLy8gY2FuIHN0b3AgYXMgc29vbiBhcyB3ZSBoaXQgYW55IHN1Y2ggcm93LlxyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcclxuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgbXV0YXRpb24gYmF0Y2ggaW4gdGhlIHN0b3JlLlxyXG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBkb2N1bWVudEtleS5wYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4U3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbikuaXRlcmF0ZSh7IHJhbmdlIH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHJvd3MgbWF0Y2hpbmcgZXhhY3RseSB0aGUgc3BlY2lmaWMga2V5IG9mXHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmVzdC4gTm90ZSB0aGF0IGJlY2F1c2Ugd2Ugb3JkZXIgYnkgcGF0aCBmaXJzdCwgYW5kIHdlXHJcbiAgICAgICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggcm93cyBmb3IgZG9jdW1lbnRLZXkgY29udGlndW91c2x5LiBJbiBwYXJ0aWN1bGFyLCBhbGxcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByb3dzIGZvciBkb2N1bWVudEtleSB3aWxsIG9jY3VyIGJlZm9yZSBhbnkgcm93cyBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBzdG9wIGFzIHNvb24gYXMgd2UgaGl0IGFueSBzdWNoIHJvdy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIHVuaXF1ZUJhdGNoSURzKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSBxdWVyeS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoID0gcXVlcnlQYXRoLmxlbmd0aCArIDE7XHJcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBBY3R1YWxseSBpbXBsZW1lbnQgYSBzaW5nbGUtY29sbGVjdGlvbiBxdWVyeVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhpcyBpcyBhY3R1YWxseSBleGVjdXRpbmcgYW4gYW5jZXN0b3IgcXVlcnksIHRyYXZlcnNpbmcgdGhlIHdob2xlXHJcbiAgICAgICAgLy8gc3VidHJlZSBiZWxvdyB0aGUgY29sbGVjdGlvbiB3aGljaCBjYW4gYmUgaG9ycmlmaWNhbGx5IGluZWZmaWNpZW50IGZvclxyXG4gICAgICAgIC8vIHNvbWUgc3RydWN0dXJlcy4gVGhlIHJpZ2h0IHdheSB0byBzb2x2ZSB0aGlzIGlzIHRvIGltcGxlbWVudCB0aGUgZnVsbFxyXG4gICAgICAgIC8vIHZhbHVlIGluZGV4LCBidXQgdGhhdCdzIG5vdCBpbiB0aGUgY2FyZHMgaW4gdGhlIG5lYXIgZnV0dXJlIHNvIHRoaXMgaXNcclxuICAgICAgICAvLyB0aGUgYmVzdCB3ZSBjYW4gZG8gZm9yIHRoZSBtb21lbnQuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCB5ZXQgaW5kZXggdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIGluIHRoZSBtdXRhdGlvbnMsIG91clxyXG4gICAgICAgIC8vIGN1cnJlbnQgYXBwcm9hY2ggaXMgdG8ganVzdCByZXR1cm4gYWxsIG11dGF0aW9uIGJhdGNoZXMgdGhhdCBhZmZlY3RcclxuICAgICAgICAvLyBkb2N1bWVudHMgaW4gdGhlIGNvbGxlY3Rpb24gYmVpbmcgcXVlcmllZC5cclxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIHF1ZXJ5UGF0aCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xyXG4gICAgICAgIC8vIENvbGxlY3QgdXAgdW5pcXVlIGJhdGNoSURzIGVuY291bnRlcmVkIGR1cmluZyBhIHNjYW4gb2YgdGhlIGluZGV4LiBVc2UgYVxyXG4gICAgICAgIC8vIFNvcnRlZFNldCB0byBhY2N1bXVsYXRlIGJhdGNoIElEcyBzbyB0aGV5IGNhbiBiZSB0cmF2ZXJzZWQgaW4gb3JkZXIgaW4gYVxyXG4gICAgICAgIC8vIHNjYW4gb2YgdGhlIG1haW4gdGFibGUuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCB8fCAhcXVlcnlQYXRoLmlzUHJlZml4T2YocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJvd3Mgd2l0aCBkb2N1bWVudCBrZXlzIG1vcmUgdGhhbiBvbmUgc2VnbWVudCBsb25nZXIgdGhhbiB0aGVcclxuICAgICAgICAgICAgLy8gcXVlcnkgcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnXHJcbiAgICAgICAgICAgIC8vIGNhbid0IG1hdGNoIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cclxuICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiB3ZSdsbCBuZWVkIGEgZGlmZmVyZW50IHNjYW5uZXIgd2hlbiB3ZSBpbXBsZW1lbnRcclxuICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSBpbW1lZGlhdGVDaGlsZHJlbkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKGJhdGNoSUQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCBiYXRjaElEcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIC8vIFRPRE8ocm9ja3dvb2QpOiBJbXBsZW1lbnQgdGhpcyB1c2luZyBpdGVyYXRlLlxyXG4gICAgICAgIGJhdGNoSURzLmZvckVhY2goYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KG11dGF0aW9uLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBtdXRhdGlvbikpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbi5zaW1wbGVEYlRyYW5zYWN0aW9uLCB0aGlzLnVzZXJJZCwgYmF0Y2gpLm5leHQocmVtb3ZlZERvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocmVtb3ZlZERvY3VtZW50cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHJhbnNhY3Rpb24sIGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBrZXlzIGZvciBhIG11dGF0aW9uIGJhdGNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcclxuICAgICAqIGNhbGxlZCBieSBzZWNvbmRhcnkgY2xpZW50cyBhZnRlciB0aGV5IHByb2Nlc3MgbXV0YXRpb24gdXBkYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSB0byBiZSBjYWxsZWQgZnJvbSBwcmltYXJ5IGNsaWVudHMgYXNcclxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIGVudHJpZXMgYXJlIGNsZWFyZWQgd2hlbiBhbiBhY2tub3dsZWRnZWQgb3JcclxuICAgICAqIHJlamVjdGVkIGJhdGNoIGlzIHJlbW92ZWQgZnJvbSB0aGUgbXV0YXRpb24gcXVldWUuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcclxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdO1xyXG4gICAgfVxyXG4gICAgcGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbXB0eSh0eG4pLm5leHQoZW1wdHkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBhcmUgbm8gZW50cmllcyBpbiB0aGUgZG9jdW1lbnRNdXRhdGlvbnMgaW5kZXggaWZcclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXVlIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhbmdsaW5nTXV0YXRpb25SZWZlcmVuY2VzID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklEID0ga2V5WzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB0aGlzLnVzZXJJZCwga2V5KTtcclxuICAgIH1cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkgKHN0YXRlIGlzIGhlbGQgaW4gbWVtb3J5IGluIG90aGVyIGNsaWVudHMpLlxyXG4gICAgLyoqIFJldHVybnMgdGhlIG11dGF0aW9uIHF1ZXVlJ3MgbWV0YWRhdGEgZnJvbSBJbmRleGVkRGIuICovXHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldCh0aGlzLnVzZXJJZClcclxuICAgICAgICAgICAgLm5leHQoKG1ldGFkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEgfHwge1xyXG4gICAgICAgICAgICAgICAgdXNlcklkOiB0aGlzLnVzZXJJZCxcclxuICAgICAgICAgICAgICAgIGxhc3RBY2tub3dsZWRnZWRCYXRjaElkOiBCQVRDSElEX1VOS05PV04sXHJcbiAgICAgICAgICAgICAgICBsYXN0U3RyZWFtVG9rZW46ICcnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIgY29udGFpbnMgYSBwZW5kaW5nXHJcbiAqICAgICAgICAgbXV0YXRpb24gZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGtleSkge1xyXG4gICAgY29uc3QgaW5kZXhLZXkgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHVzZXJJZCwga2V5LnBhdGgpO1xyXG4gICAgY29uc3QgZW5jb2RlZFBhdGggPSBpbmRleEtleVsxXTtcclxuICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4S2V5KTtcclxuICAgIGxldCBjb250YWluc0tleSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxyXG4gICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3VzZXJJRCwga2V5UGF0aCwgLypiYXRjaElEKi8gX10gPSBrZXk7XHJcbiAgICAgICAgaWYgKHVzZXJJRCA9PT0gdXNlcklkICYmIGtleVBhdGggPT09IGVuY29kZWRQYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5zS2V5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICB9KVxyXG4gICAgICAgIC5uZXh0KCgpID0+IGNvbnRhaW5zS2V5KTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGFueSBtdXRhdGlvbiBxdWV1ZSBjb250YWlucyB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGRvY0tleSkge1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pXHJcbiAgICAgICAgLml0ZXJhdGVTZXJpYWwodXNlcklkID0+IHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBkb2NLZXkpLm5leHQoY29udGFpbnNLZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnNLZXkpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoIWNvbnRhaW5zS2V5KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcbiAgICAgICAgLm5leHQoKCkgPT4gZm91bmQpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9ucyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbnNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uUXVldWVTdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE9mZnNldCB0byBlbnN1cmUgbm9uLW92ZXJsYXBwaW5nIHRhcmdldCBpZHMuICovXHJcbmNvbnN0IE9GRlNFVCA9IDI7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHRhcmdldCBJRHMgZm9yIHNlbmRpbmcgdGFyZ2V0cyB0byB0aGVcclxuICogd2F0Y2ggc3RyZWFtLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGNvbnN0cnVjdHMgdHdvIGdlbmVyYXRvcnMsIG9uZSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgYW5kIG9uZSBmb3JcclxuICogZm9yIHRoZSBzeW5jIGVuZ2luZSAodG8gZ2VuZXJhdGUgbGltYm8gZG9jdW1lbnRzIHRhcmdldHMpLiBUaGVzZVxyXG4gKiBnZW5lcmF0b3JzIHByb2R1Y2Ugbm9uLW92ZXJsYXBwaW5nIElEcyAoYnkgdXNpbmcgZXZlbiBhbmQgb2RkIElEc1xyXG4gKiByZXNwZWN0aXZlbHkpLlxyXG4gKlxyXG4gKiBCeSBzZXBhcmF0aW5nIHRoZSB0YXJnZXQgSUQgc3BhY2UsIHRoZSBxdWVyeSBjYWNoZSBjYW4gZ2VuZXJhdGUgdGFyZ2V0IElEc1xyXG4gKiB0aGF0IHBlcnNpc3QgYWNyb3NzIGNsaWVudCByZXN0YXJ0cywgd2hpbGUgc3luYyBlbmdpbmUgY2FuIGluZGVwZW5kZW50bHlcclxuICogZ2VuZXJhdGUgaW4tbWVtb3J5IHRhcmdldCBJRHMgdGhhdCBhcmUgdHJhbnNpZW50IGFuZCBjYW4gYmUgcmV1c2VkIGFmdGVyIGFcclxuICogcmVzdGFydC5cclxuICovXHJcbmNsYXNzIFRhcmdldElkR2VuZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGxhc3RJZCkge1xyXG4gICAgICAgIHRoaXMubGFzdElkID0gbGFzdElkO1xyXG4gICAgfVxyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICB0aGlzLmxhc3RJZCArPSBPRkZTRVQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZvclRhcmdldENhY2hlKCkge1xyXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgY2FjaGUgZ2VuZXJhdG9yIG11c3QgcmV0dXJuICcyJyBpbiBpdHMgZmlyc3QgY2FsbCB0byBgbmV4dCgpYFxyXG4gICAgICAgIC8vIGFzIHRoZXJlIGlzIG5vIGRpZmZlcmVudGlhdGlvbiBpbiB0aGUgcHJvdG9jb2wgbGF5ZXIgYmV0d2VlbiBhbiB1bnNldFxyXG4gICAgICAgIC8vIG51bWJlciBhbmQgdGhlIG51bWJlciAnMCcuIElmIHdlIHdlcmUgdG8gc2VudCBhIHRhcmdldCB3aXRoIHRhcmdldCBJRFxyXG4gICAgICAgIC8vICcwJywgdGhlIGJhY2tlbmQgd291bGQgY29uc2lkZXIgaXQgdW5zZXQgYW5kIHJlcGxhY2UgaXQgd2l0aCBpdHMgb3duIElELlxyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IoMiAtIE9GRlNFVCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZm9yU3luY0VuZ2luZSgpIHtcclxuICAgICAgICAvLyBTeW5jIGVuZ2luZSBhc3NpZ25zIHRhcmdldCBJRHMgZm9yIGxpbWJvIGRvY3VtZW50IGRldGVjdGlvbi5cclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDEgLSBPRkZTRVQpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYlRhcmdldENhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICB9XHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFdlIGRvbid0IGNhY2hlIGdsb2JhbCBtZXRhZGF0YSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgc2luY2VcclxuICAgIC8vIHNvbWUgb2YgaXQgKGluIHBhcnRpY3VsYXIgYGhpZ2hlc3RUYXJnZXRJZGApIGNhbiBiZSBtb2RpZmllZCBieSBzZWNvbmRhcnlcclxuICAgIC8vIHRhYnMuIFdlIGNvdWxkIHBlcmhhcHMgYmUgbW9yZSBncmFudWxhciAoYW5kIGUuZy4gc3RpbGwgY2FjaGVcclxuICAgIC8vIGBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uYCBpbiBtZW1vcnkpIGJ1dCBmb3Igc2ltcGxpY2l0eSB3ZSBjdXJyZW50bHkgZ29cclxuICAgIC8vIHRvIEluZGV4ZWREYiB3aGVuZXZlciB3ZSBuZWVkIHRvIHJlYWQgbWV0YWRhdGEuIFdlIGNhbiByZXZpc2l0IGlmIGl0IHR1cm5zXHJcbiAgICAvLyBvdXQgdG8gaGF2ZSBhIG1lYW5pbmdmdWwgcGVyZm9ybWFuY2UgaW1wYWN0LlxyXG4gICAgYWxsb2NhdGVUYXJnZXRJZCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcihtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpLm5leHQoKCkgPT4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKG5ldyBUaW1lc3RhbXAobWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbi5zZWNvbmRzLCBtZXRhZGF0YS5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLm5hbm9zZWNvbmRzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KHRhcmdldEdsb2JhbCA9PiB0YXJnZXRHbG9iYWwuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKTtcclxuICAgIH1cclxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICAgICAgaWYgKGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnRhcmdldENvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKS5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXRJZCkpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydChtZXRhZGF0YS50YXJnZXRDb3VudCA+IDApO1xyXG4gICAgICAgICAgICBtZXRhZGF0YS50YXJnZXRDb3VudCAtPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJvcHMgYW55IHRhcmdldHMgd2l0aCBzZXF1ZW5jZSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB1cHBlciBib3VuZCwgZXhjZXB0aW5nIHRob3NlXHJcbiAgICAgKiBwcmVzZW50IGluIGBhY3RpdmVUYXJnZXRJZHNgLiBEb2N1bWVudCBhc3NvY2lhdGlvbnMgZm9yIHRoZSByZW1vdmVkIHRhcmdldHMgYXJlIGFsc28gcmVtb3ZlZC5cclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXJnZXRzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBmcm9tRGJUYXJnZXQodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHMuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBwcm92aWRlZCBmdW5jdGlvbiB3aXRoIGVhY2ggYFRhcmdldERhdGFgIHRoYXQgd2UgaGF2ZSBjYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pLml0ZXJhdGUoKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGYodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KVxyXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEgIT09IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIHNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cclxuICAgICAqIFRhcmdldERhdGEuIFNhdmluZyBpcyBkb25lIHNlcGFyYXRlbHkuIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSB3ZXJlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgbWV0YWRhdGEuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpIHtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXRDb3VudCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEudGFyZ2V0Q291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gSXRlcmF0aW5nIGJ5IHRoZSBjYW5vbmljYWxJZCBtYXkgeWllbGQgbW9yZSB0aGFuIG9uZSByZXN1bHQgYmVjYXVzZVxyXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XHJcbiAgICAgICAgLy8gZGVwZW5kcyBvbiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4IHRvIGJlIGVmZmljaWVudC5cclxuICAgICAgICBjb25zdCBjYW5vbmljYWxJZCA9IGNhbm9uaWZ5VGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcclxuICAgICAgICAgICAgLy8gQWZ0ZXIgZmluZGluZyBhIHBvdGVudGlhbCBtYXRjaCwgY2hlY2sgdGhhdCB0aGUgdGFyZ2V0IGlzXHJcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGVxdWFsIHRvIHRoZSByZXF1ZXN0ZWQgdGFyZ2V0LlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RXF1YWxzKHRhcmdldCwgZm91bmQudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm91bmQ7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBhZGRNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcclxuICAgICAgICAvLyBJbmRleGVkRGIuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcclxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3RvcmUucHV0KHsgdGFyZ2V0SWQsIHBhdGggfSkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcclxuICAgICAgICAvLyBJbmRleGVkRGIuXHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihbXHJcbiAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoW3RhcmdldElkLCBwYXRoXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RhcmdldElkXSwgW3RhcmdldElkICsgMV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKHJhbmdlKTtcclxuICAgIH1cclxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChrZXlbMV0pO1xyXG4gICAgICAgICAgICBjb25zdCBkb2NLZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZG9jS2V5KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtwYXRoXSwgW2ltbWVkaWF0ZVN1Y2Nlc3NvcihwYXRoKV0sIFxyXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcclxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4LFxyXG4gICAgICAgICAgICBrZXlzT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2VcclxuICAgICAgICB9LCAoW3RhcmdldElkLCBwYXRoXSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBIYXZpbmcgYSBzZW50aW5lbCByb3cgZm9yIGEgZG9jdW1lbnQgZG9lcyBub3QgY291bnQgYXMgY29udGFpbmluZyB0aGF0IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAvLyBGb3IgdGhlIHRhcmdldCBjYWNoZSwgY29udGFpbmluZyB0aGUgZG9jdW1lbnQgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHBhcnQgb2Ygc29tZVxyXG4gICAgICAgICAgICAvLyB0YXJnZXQuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY291bnQgPiAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgYSBUYXJnZXREYXRhIGVudHJ5IGJ5IHRhcmdldCBJRC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SWQgLSBUaGUgdGFyZ2V0IElEIG9mIHRoZSBUYXJnZXREYXRhIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIFRhcmdldERhdGEgZW50cnksIG9yIG51bGwgaWYgdGhlIGNhY2hlIGhhcyBubyBlbnRyeSBmb3JcclxuICAgICAqIHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBnZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5nZXQodGFyZ2V0SWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGZvdW5kID0+IHtcclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiVGFyZ2V0KGZvdW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcXVlcmllcyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0YXJnZXRzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSB0YXJnZXQgZ2xvYmFscyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IHRhcmdldCBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBHQ19ESURfTk9UX1JVTiA9IHtcclxuICAgIGRpZFJ1bjogZmFsc2UsXHJcbiAgICBzZXF1ZW5jZU51bWJlcnNDb2xsZWN0ZWQ6IDAsXHJcbiAgICB0YXJnZXRzUmVtb3ZlZDogMCxcclxuICAgIGRvY3VtZW50c1JlbW92ZWQ6IDBcclxufTtcclxuY29uc3QgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgPSAtMTtcclxuY29uc3QgTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUyA9IDQwICogMTAyNCAqIDEwMjQ7XHJcbmNsYXNzIExydVBhcmFtcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vIFdoZW4gd2UgYXR0ZW1wdCB0byBjb2xsZWN0LCB3ZSB3aWxsIG9ubHkgZG8gc28gaWYgdGhlIGNhY2hlIHNpemUgaXMgZ3JlYXRlciB0aGFuIHRoaXNcclxuICAgIC8vIHRocmVzaG9sZC4gUGFzc2luZyBgQ09MTEVDVElPTl9ESVNBQkxFRGAgaGVyZSB3aWxsIGNhdXNlIGNvbGxlY3Rpb24gdG8gYWx3YXlzIGJlIHNraXBwZWQuXHJcbiAgICBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkLCBcclxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3ZSB3aWxsIGF0dGVtcHQgdG8gY29sbGVjdFxyXG4gICAgcGVyY2VudGlsZVRvQ29sbGVjdCwgXHJcbiAgICAvLyBBIGNhcCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3aWxsIGJlIGNvbGxlY3RlZC4gVGhpcyBwcmV2ZW50c1xyXG4gICAgLy8gdXMgZnJvbSBjb2xsZWN0aW5nIGEgaHVnZSBudW1iZXIgb2Ygc2VxdWVuY2UgbnVtYmVycyBpZiB0aGUgY2FjaGUgaGFzIGdyb3duIHZlcnkgbGFyZ2UuXHJcbiAgICBtYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID0gY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLnBlcmNlbnRpbGVUb0NvbGxlY3QgPSBwZXJjZW50aWxlVG9Db2xsZWN0O1xyXG4gICAgICAgIHRoaXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9IG1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2l0aENhY2hlU2l6ZShjYWNoZVNpemUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExydVBhcmFtcyhjYWNoZVNpemUsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XHJcbiAgICB9XHJcbn1cclxuTHJ1UGFyYW1zLkRFRkFVTFRfQ09MTEVDVElPTl9QRVJDRU5USUxFID0gMTA7XHJcbkxydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QgPSAxMDAwO1xyXG5McnVQYXJhbXMuREVGQVVMVCA9IG5ldyBMcnVQYXJhbXMoTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUywgTHJ1UGFyYW1zLkRFRkFVTFRfQ09MTEVDVElPTl9QRVJDRU5USUxFLCBMcnVQYXJhbXMuREVGQVVMVF9NQVhfU0VRVUVOQ0VfTlVNQkVSU19UT19DT0xMRUNUKTtcclxuTHJ1UGFyYW1zLkRJU0FCTEVEID0gbmV3IExydVBhcmFtcyhMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCwgMCwgMCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckZSA9ICdMcnVHYXJiYWdlQ29sbGVjdG9yJztcclxuY29uc3QgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUyA9IDEgKiAxMDI0ICogMTAyNDtcclxuLyoqIEhvdyBsb25nIHdlIHdhaXQgdG8gdHJ5IHJ1bm5pbmcgTFJVIEdDIGFmdGVyIFNESyBpbml0aWFsaXphdGlvbi4gKi9cclxuY29uc3QgSU5JVElBTF9HQ19ERUxBWV9NUyA9IDEgKiA2MCAqIDEwMDA7XHJcbi8qKiBNaW5pbXVtIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gR0MgY2hlY2tzLCBhZnRlciB0aGUgZmlyc3Qgb25lLiAqL1xyXG5jb25zdCBSRUdVTEFSX0dDX0RFTEFZX01TID0gNSAqIDYwICogMTAwMDtcclxuZnVuY3Rpb24gYnVmZmVyRW50cnlDb21wYXJhdG9yKFthU2VxdWVuY2UsIGFJbmRleF0sIFtiU2VxdWVuY2UsIGJJbmRleF0pIHtcclxuICAgIGNvbnN0IHNlcUNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IoYVNlcXVlbmNlLCBiU2VxdWVuY2UpO1xyXG4gICAgaWYgKHNlcUNtcCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoaXMgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGJ1dCB3ZSBjYW4gYmlhcyBhZ2FpbnN0IGNodXJuIGJ5IHNvcnRpbmdcclxuICAgICAgICAvLyBlbnRyaWVzIGNyZWF0ZWQgZWFybGllciBhcyBsZXNzIHRoYW4gbmV3ZXIgZW50cmllcy5cclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihhSW5kZXgsIGJJbmRleCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VxQ21wO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHNlcXVlbmNlIG51bWJlci4gS2VlcHMgYSByb2xsaW5nIGJ1ZmZlciBvZiB0aGVcclxuICogbG93ZXN0IG4gdmFsdWVzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAsIGFuZCBmaW5hbGx5IHJlcG9ydHMgdGhlIGxhcmdlc3Qgb2ZcclxuICogdGhlbSBpbiBgbWF4VmFsdWVgLlxyXG4gKi9cclxuY2xhc3MgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5tYXhFbGVtZW50cyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFNvcnRlZFNldChidWZmZXJFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICBuZXh0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuICsrdGhpcy5wcmV2aW91c0luZGV4O1xyXG4gICAgfVxyXG4gICAgYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gW3NlcXVlbmNlTnVtYmVyLCB0aGlzLm5leHRJbmRleCgpXTtcclxuICAgICAgICBpZiAodGhpcy5idWZmZXIuc2l6ZSA8IHRoaXMubWF4RWxlbWVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5hZGQoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaGVzdFZhbHVlID0gdGhpcy5idWZmZXIubGFzdCgpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnlDb21wYXJhdG9yKGVudHJ5LCBoaWdoZXN0VmFsdWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5kZWxldGUoaGlnaGVzdFZhbHVlKS5hZGQoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdG8gYmUgbm9uLWVtcHR5LiBJZiB3ZSBkZWNpZGUgd2UgYXJlIG5vdCBjb2xsZWN0aW5nIGFueVxyXG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlcnMsIG50aFNlcXVlbmNlTnVtYmVyIGJlbG93IHNob3J0LWNpcmN1aXRzLiBJZiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gZGVjaWRlZCB0aGF0IHdlIGFyZSBjb2xsZWN0aW5nIG4gc2VxdWVuY2UgbnVtYmVycywgaXQncyBiZWNhdXNlIG4gaXMgc29tZVxyXG4gICAgICAgIC8vIHBlcmNlbnRhZ2Ugb2YgdGhlIGV4aXN0aW5nIHNlcXVlbmNlIG51bWJlcnMuIFRoYXQgbWVhbnMgd2Ugc2hvdWxkIG5ldmVyXHJcbiAgICAgICAgLy8gYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIGNvbGxlY3Rpbmcgc2VxdWVuY2UgbnVtYmVycyBidXQgZG9uJ3RcclxuICAgICAgICAvLyBhY3R1YWxseSBoYXZlIGFueS5cclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGFzdCgpWzBdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiBJdCBoYW5kbGVzIGNoZWNraW5nXHJcbiAqIHdoZXRoZXIgb3Igbm90IEdDIGlzIGVuYWJsZWQsIGFzIHdlbGwgYXMgd2hpY2ggZGVsYXkgdG8gdXNlIGJlZm9yZSB0aGUgbmV4dCBydW4uXHJcbiAqL1xyXG5jbGFzcyBMcnVTY2hlZHVsZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2FyYmFnZUNvbGxlY3RvciwgYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSkge1xyXG4gICAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3RvciA9IGdhcmJhZ2VDb2xsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuZ2NUYXNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdhcmJhZ2VDb2xsZWN0b3IucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgIT09XHJcbiAgICAgICAgICAgIExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVHQyhJTklUSUFMX0dDX0RFTEFZX01TKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdjVGFzaykge1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzay5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzdGFydGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdjVGFzayAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIHNjaGVkdWxlR0MoZGVsYXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGUsIGBHYXJiYWdlIGNvbGxlY3Rpb24gc2NoZWR1bGVkIGluICR7ZGVsYXl9bXNgKTtcclxuICAgICAgICB0aGlzLmdjVGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImxydV9nYXJiYWdlX2NvbGxlY3Rpb25cIiAvKiBUaW1lcklkLkxydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlR0MoUkVHVUxBUl9HQ19ERUxBWV9NUyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gKi9cclxuY2xhc3MgTHJ1R2FyYmFnZUNvbGxlY3RvckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZVRhcmdldENvdW50KHR4biwgcGVyY2VudGlsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmdldFNlcXVlbmNlTnVtYmVyQ291bnQodHhuKS5uZXh0KHRhcmdldENvdW50ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHBlcmNlbnRpbGUgLyAxMDAuMCkgKiB0YXJnZXRDb3VudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBudGhTZXF1ZW5jZU51bWJlcih0eG4sIG4pIHtcclxuICAgICAgICBpZiAobiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBSb2xsaW5nU2VxdWVuY2VOdW1iZXJCdWZmZXIobik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVcclxuICAgICAgICAgICAgLmZvckVhY2hUYXJnZXQodHhuLCB0YXJnZXQgPT4gYnVmZmVyLmFkZEVsZW1lbnQodGFyZ2V0LnNlcXVlbmNlTnVtYmVyKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXIgPT4gYnVmZmVyLmFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBidWZmZXIubWF4VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKTtcclxuICAgIH1cclxuICAgIGNvbGxlY3QodHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCA9PT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnR2FyYmFnZSBjb2xsZWN0aW9uIHNraXBwZWQ7IGRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShHQ19ESURfTk9UX1JVTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENhY2hlU2l6ZSh0eG4pLm5leHQoY2FjaGVTaXplID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhY2hlU2l6ZSA8IHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgYEdhcmJhZ2UgY29sbGVjdGlvbiBza2lwcGVkOyBDYWNoZSBzaXplICR7Y2FjaGVTaXplfSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaXMgbG93ZXIgdGhhbiB0aHJlc2hvbGQgJHt0aGlzLnBhcmFtcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkfWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdDX0RJRF9OT1RfUlVOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0Q2FjaGVTaXplKHR4bik7XHJcbiAgICB9XHJcbiAgICBydW5HYXJiYWdlQ29sbGVjdGlvbih0eG4sIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIGxldCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgbGV0IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCwgdGFyZ2V0c1JlbW92ZWQ7XHJcbiAgICAgICAgLy8gVGltZXN0YW1wcyBmb3IgdmFyaW91cyBwaWVjZXMgb2YgdGhlIHByb2Nlc3NcclxuICAgICAgICBsZXQgY291bnRlZFRhcmdldHNUcywgZm91bmRVcHBlckJvdW5kVHMsIHJlbW92ZWRUYXJnZXRzVHMsIHJlbW92ZWREb2N1bWVudHNUcztcclxuICAgICAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHRoaXMucGFyYW1zLnBlcmNlbnRpbGVUb0NvbGxlY3QpXHJcbiAgICAgICAgICAgIC5uZXh0KHNlcXVlbmNlTnVtYmVycyA9PiB7XHJcbiAgICAgICAgICAgIC8vIENhcCBhdCB0aGUgY29uZmlndXJlZCBtYXhcclxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVycyA+IHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgJ0NhcHBpbmcgc2VxdWVuY2UgbnVtYmVycyB0byBjb2xsZWN0IGRvd24gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRvIHRoZSBtYXhpbXVtIG9mICR7dGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGZyb20gJHtzZXF1ZW5jZU51bWJlcnN9YCk7XHJcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBzZXF1ZW5jZU51bWJlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY291bnRlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm50aFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCh1cHBlckJvdW5kID0+IHtcclxuICAgICAgICAgICAgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyID0gdXBwZXJCb3VuZDtcclxuICAgICAgICAgICAgZm91bmRVcHBlckJvdW5kVHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KG51bVRhcmdldHNSZW1vdmVkID0+IHtcclxuICAgICAgICAgICAgdGFyZ2V0c1JlbW92ZWQgPSBudW1UYXJnZXRzUmVtb3ZlZDtcclxuICAgICAgICAgICAgcmVtb3ZlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHNSZW1vdmVkID0+IHtcclxuICAgICAgICAgICAgcmVtb3ZlZERvY3VtZW50c1RzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSAnTFJVIEdhcmJhZ2UgQ29sbGVjdGlvblxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHRDb3VudGVkIHRhcmdldHMgaW4gJHtjb3VudGVkVGFyZ2V0c1RzIC0gc3RhcnRUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHREZXRlcm1pbmVkIGxlYXN0IHJlY2VudGx5IHVzZWQgJHtzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3R9IGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAke2ZvdW5kVXBwZXJCb3VuZFRzIC0gY291bnRlZFRhcmdldHNUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXHRSZW1vdmVkICR7dGFyZ2V0c1JlbW92ZWR9IHRhcmdldHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7cmVtb3ZlZFRhcmdldHNUcyAtIGZvdW5kVXBwZXJCb3VuZFRzfW1zXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHtkb2N1bWVudHNSZW1vdmVkfSBkb2N1bWVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7cmVtb3ZlZERvY3VtZW50c1RzIC0gcmVtb3ZlZFRhcmdldHNUc31tc1xcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBUb3RhbCBEdXJhdGlvbjogJHtyZW1vdmVkRG9jdW1lbnRzVHMgLSBzdGFydFRzfW1zYDtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgZGVzYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIGRpZFJ1bjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0c1JlbW92ZWQsXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1vdmVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0xydUdhcmJhZ2VDb2xsZWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIG5ldyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChkZWxlZ2F0ZSwgcGFyYW1zKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogUHJvdmlkZXMgTFJVIGZ1bmN0aW9uYWxpdHkgZm9yIEluZGV4ZWREQiBwZXJzaXN0ZW5jZS4gKi9cclxuY2xhc3MgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGRiLCBwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmRiID0gZGI7XHJcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pIHtcclxuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENvdW50UHJvbWlzZSA9IHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5nZXRUYXJnZXRDb3VudCh0eG4pO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRDb3VudFByb21pc2UubmV4dCh0YXJnZXRDb3VudCA9PiBkb2NDb3VudFByb21pc2UubmV4dChkb2NDb3VudCA9PiB0YXJnZXRDb3VudCArIGRvY0NvdW50KSk7XHJcbiAgICB9XHJcbiAgICBvcnBoYW5lZERvY3VtZW50Q291bnQodHhuKSB7XHJcbiAgICAgICAgbGV0IG9ycGhhbmVkQ291bnQgPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcclxuICAgICAgICAgICAgb3JwaGFuZWRDb3VudCsrO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gb3JwaGFuZWRDb3VudCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkuZm9yRWFjaFRhcmdldCh0eG4sIGYpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudCh0eG4sIChkb2NLZXksIHNlcXVlbmNlTnVtYmVyKSA9PiBmKHNlcXVlbmNlTnVtYmVyKSk7XHJcbiAgICB9XHJcbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRUYXJnZXRDYWNoZSgpLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpO1xyXG4gICAgfVxyXG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyB3b3VsZCBwcmV2ZW50IHRoaXMgZG9jdW1lbnQgZnJvbSBiZWluZyBnYXJiYWdlXHJcbiAgICAgKiBjb2xsZWN0ZWQsIGdpdmVuIHRoYXQgdGhlIGRvY3VtZW50IGluIHF1ZXN0aW9uIGlzIG5vdCBwcmVzZW50IGluIGFueVxyXG4gICAgICogdGFyZ2V0cyBhbmQgaGFzIGEgc2VxdWVuY2UgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdXBwZXIgYm91bmQgZm9yXHJcbiAgICAgKiB0aGUgY29sbGVjdGlvbiBydW4uXHJcbiAgICAgKi9cclxuICAgIGlzUGlubmVkKHR4biwgZG9jS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGRvY0tleSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudENhY2hlID0gdGhpcy5kYi5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gZG9jdW1lbnRDYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGxldCBkb2N1bWVudENvdW50ID0gMDtcclxuICAgICAgICBjb25zdCBpdGVyYXRpb24gPSB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyIDw9IHVwcGVyQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmlzUGlubmVkKHR4biwgZG9jS2V5KS5uZXh0KGlzUGlubmVkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Q291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3VyIHNpemUgYWNjb3VudGluZyByZXF1aXJlcyB1cyB0byByZWFkIGFsbCBkb2N1bWVudHMgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQnVmZmVyLnJlbW92ZUVudHJ5KGRvY0tleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikuZGVsZXRlKHNlbnRpbmVsS2V5JDEoZG9jS2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRpb25cclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRDb3VudCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHRhcmdldERhdGEud2l0aFNlcXVlbmNlTnVtYmVyKHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkudXBkYXRlVGFyZ2V0RGF0YSh0eG4sIHVwZGF0ZWQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBwcm92aWRlZCBmdW5jdGlvbiBmb3IgZWFjaCBkb2N1bWVudCBpbiB0aGUgY2FjaGUgdGhhdCBpcyAnb3JwaGFuZWQnLiBPcnBoYW5lZFxyXG4gICAgICogbWVhbnMgbm90IGEgcGFydCBvZiBhbnkgdGFyZ2V0LCBzbyB0aGUgb25seSBlbnRyeSBpbiB0aGUgdGFyZ2V0LWRvY3VtZW50IGluZGV4IGZvclxyXG4gICAgICogdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSBzZW50aW5lbCByb3cgKHRhcmdldElkIDApLCB3aGljaCB3aWxsIGFsc28gaGF2ZSB0aGUgc2VxdWVuY2VcclxuICAgICAqIG51bWJlciBmb3IgdGhlIGxhc3QgdGltZSB0aGUgZG9jdW1lbnQgd2FzIGFjY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoT3JwaGFuZWREb2N1bWVudCh0eG4sIGYpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcclxuICAgICAgICBsZXQgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcclxuICAgICAgICBsZXQgbmV4dFBhdGg7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleFxyXG4gICAgICAgIH0sIChbdGFyZ2V0SWQsIGRvY0tleV0sIHsgcGF0aCwgc2VxdWVuY2VOdW1iZXIgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5leHRUb1JlcG9ydCBpcyB2YWxpZCwgcmVwb3J0IGl0LCB0aGlzIGlzIGEgbmV3IGtleSBzbyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lIG11c3Qgbm90IGJlIGEgbWVtYmVyIG9mIGFueSB0YXJnZXRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYobmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChuZXh0UGF0aCkpLCBuZXh0VG9SZXBvcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcclxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHJlcG9ydCwgaWYgd2UgZG9uJ3QgZmluZCBhbnkgdGFyZ2V0cyBmb3IgdGhpcyBkb2N1bWVudC5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VxdWVuY2UgbnVtYmVyIG11c3QgYmUgZGVmaW5lZCB3aGVuIHRoZSB0YXJnZXRJZFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cclxuICAgICAgICAgICAgICAgIG5leHRUb1JlcG9ydCA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgbmV4dFBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSBpbnZhbGlkLCB3ZSBrbm93IHdlIGRvbid0IG5lZWQgdG8gcmVwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXHJcbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByZXBvcnQgc2VxdWVuY2UgbnVtYmVycyBhZnRlciBnZXR0aW5nIHRvIHRoZSBuZXh0IGtleSwgd2VcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcclxuICAgICAgICAgICAgLy8gZG9jdW1lbnQgYW5kIHJlcG9ydCBpdC5cclxuICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCkuZ2V0U2l6ZSh0eG4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlbnRpbmVsS2V5JDEoa2V5KSB7XHJcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcclxuICogc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICByZXR1cm4geyB0YXJnZXRJZDogMCwgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKSwgc2VxdWVuY2VOdW1iZXIgfTtcclxufVxyXG5mdW5jdGlvbiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pLnB1dChzZW50aW5lbFJvdyhrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGJ1ZmZlciBvZiBlbnRyaWVzIHRvIGJlIHdyaXR0ZW4gdG8gYSBSZW1vdGVEb2N1bWVudENhY2hlLlxyXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cCBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIGNhY2hlLCBidXRcclxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXHJcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgdW5kZXJseWluZyBSZW1vdGVEb2N1bWVudENhY2hlIGlmIG5vIGVudHJ5IGlzXHJcbiAqIGJ1ZmZlcmVkLlxyXG4gKlxyXG4gKiBFbnRyaWVzIGFkZGVkIHRvIHRoZSBjYWNoZSAqbXVzdCogYmUgcmVhZCBmaXJzdC4gVGhpcyBpcyB0byBmYWNpbGl0YXRlXHJcbiAqIGNhbGN1bGF0aW5nIHRoZSBzaXplIGRlbHRhIG9mIHRoZSBwZW5kaW5nIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBjbGFzcyB3YXMgaW1wbGVtZW50ZWQgdGhlbiByZW1vdmVkIGZyb20gb3RoZXIgcGxhdGZvcm1zLlxyXG4gKiBJZiBieXRlLWNvdW50aW5nIGVuZHMgdXAgYmVpbmcgbmVlZGVkIG9uIHRoZSBvdGhlciBwbGF0Zm9ybXMsIGNvbnNpZGVyXHJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cclxuICovXHJcbmNsYXNzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXkgdG8gdGhlIG5ldyBjYWNoZSBlbnRyeSB0aGF0IHNob3VsZCBiZSB3cml0dGVuLlxyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gb25seSBtb2RpZnkgZG9jdW1lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIHZpYVxyXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkoZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXJzIGEgYFJlbW90ZURvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoKWAgY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcclxuICAgICAqIGBnZXRFbnRyeSgpL2dldEVudHJpZXMoKWAgKGVuZm9yY2VkIHZpYSBJbmRleGVkRGJzIGBhcHBseSgpYCkuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpLnNldFJlYWRUaW1lKHJlYWRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS4gVGhlIGJ1ZmZlcmVkIGNoYW5nZXMgd2lsbCBmaXJzdCBiZSBjaGVja2VkLFxyXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXHJcbiAgICAgKiBjYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90QXBwbGllZCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkRW50cnkgPSB0aGlzLmNoYW5nZXMuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShidWZmZXJlZEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgc2V2ZXJhbCBlbnRyaWVzIGluIHRoZSBjYWNoZSwgZm9yd2FyZGluZyB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleXMgLSBUaGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBsb29rIHVwLlxyXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgY2FjaGVkIGRvY3VtZW50cywgaW5kZXhlZCBieSBrZXkuIElmIGFuIGVudHJ5IGNhbm5vdCBiZVxyXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcclxuICAgICAqIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIEhlbHBlciB0byBhc3NlcnQgdGhpcy5jaGFuZ2VzIGlzIG5vdCBudWxsICAqL1xyXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcclxuICogYG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUoKWAuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHNldEluZGV4TWFuYWdlcihpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGBhZGRFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRTdG9yZS5wdXQoZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGRvY3VtZW50IGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcclxuICAgICAqIHJldHVybmVkIGJ5IGBuZXdDaGFuZ2VCdWZmZXIoKWAgdG8gZW5zdXJlIHByb3BlciBhY2NvdW50aW5nIG9mIG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShkYlJlYWRUaW1lS2V5KGRvY3VtZW50S2V5LCByZWFkVGltZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNhY2hlIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbGVycyB0byBgYWRkRW50cnkoKWAgYW5kIGByZW1vdmVFbnRyeSgpYCAqbXVzdCogY2FsbCB0aGlzIGFmdGVyd2FyZHMgdG8gdXBkYXRlIHRoZVxyXG4gICAgICogY2FjaGUncyBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgbGV0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IGVudHJ5IGFuZCBpdHMgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBzaXplOiAwLFxyXG4gICAgICAgICAgICBkb2N1bWVudDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChkb2N1bWVudEtleSwgZGJSZW1vdGVEb2MpLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogZGJEb2N1bWVudFNpemUoZGJSZW1vdGVEb2MpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGtleSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIHNldmVyYWwgZW50cmllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBkb2N1bWVudHMgaW5kZXhlZCBieSBrZXkgYW5kIGEgbWFwIG9mIHNpemVzIGluZGV4ZWQgYnlcclxuICAgICAqICAgICBrZXkgKHplcm8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0KS5cclxuICAgICAqL1xyXG4gICAgZ2V0U2l6ZWRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoRGJFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCAoa2V5LCBkYlJlbW90ZURvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIHNpemVNYXAgPSBzaXplTWFwLmluc2VydChrZXksIGRiRG9jdW1lbnRTaXplKGRiUmVtb3RlRG9jKSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRLZXlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNvcnRlZEtleXMgPSBuZXcgU29ydGVkU2V0KGRiS2V5Q29tcGFyYXRvcik7XHJcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZSA9PiAoc29ydGVkS2V5cyA9IHNvcnRlZEtleXMuYWRkKGUpKSk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkYktleShzb3J0ZWRLZXlzLmZpcnN0KCkpLCBkYktleShzb3J0ZWRLZXlzLmxhc3QoKSkpO1xyXG4gICAgICAgIGNvbnN0IGtleUl0ZXIgPSBzb3J0ZWRLZXlzLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgbGV0IG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LCByYW5nZSB9LCAoXywgZGJSZW1vdGVEb2MsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsS2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKFtcclxuICAgICAgICAgICAgICAgIC4uLmRiUmVtb3RlRG9jLnByZWZpeFBhdGgsXHJcbiAgICAgICAgICAgICAgICBkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBkYlJlbW90ZURvYy5kb2N1bWVudElkXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGtleXMgbm90IGZvdW5kIGluIGNhY2hlLlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSAmJiBkYktleUNvbXBhcmF0b3IobmV4dEtleSwgcG90ZW50aWFsS2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0S2V5ICYmIG5leHRLZXkuaXNFcXVhbChwb3RlbnRpYWxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBLZXkgZm91bmQgaW4gY2FjaGUuXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2tpcCB0byB0aGUgbmV4dCBrZXkgKGlmIHRoZXJlIGlzIG9uZSkuXHJcbiAgICAgICAgICAgIGlmIChuZXh0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnNraXAoZGJLZXkobmV4dEtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBrZXlzIGFyZSBub3QgaW4gdGhlIGNhY2hlLiBPbmUgY2FzZSB3aGVyZSBgaXRlcmF0ZWBcclxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG11dGF0ZWREb2NzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHF1ZXJ5LnBhdGg7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBbXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbi5sYXN0U2VnbWVudCgpLFxyXG4gICAgICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXHJcbiAgICAgICAgICAgIG9mZnNldC5kb2N1bWVudEtleS5wYXRoLmlzRW1wdHkoKVxyXG4gICAgICAgICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgICAgICAgOiBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5sYXN0U2VnbWVudCgpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBlbmRLZXkgPSBbXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgY29sbGVjdGlvbi5sYXN0U2VnbWVudCgpLFxyXG4gICAgICAgICAgICBbTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcclxuICAgICAgICAgICAgJydcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmxvYWRBbGwoSURCS2V5UmFuZ2UuYm91bmQoc3RhcnRLZXksIGVuZEtleSwgdHJ1ZSkpXHJcbiAgICAgICAgICAgIC5uZXh0KGRiUmVtb3RlRG9jcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5pbmNyZW1lbnREb2N1bWVudFJlYWRDb3VudChkYlJlbW90ZURvY3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkYlJlbW90ZURvYyBvZiBkYlJlbW90ZURvY3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpIHx8IG11dGF0ZWREb2NzLmhhcyhkb2N1bWVudC5rZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGUgZG9jdW1lbnQgbWF0Y2hlcyB0aGUgZ2l2ZW4gcXVlcnksIG9yIGl0IGlzIG11dGF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGxpbWl0KSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBjb25zdCBzdGFydEtleSA9IGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBlbmRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIEluZGV4T2Zmc2V0Lm1heCgpKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCxcclxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLmJvdW5kKHN0YXJ0S2V5LCBlbmRLZXksIHRydWUpXHJcbiAgICAgICAgfSwgKF8sIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLnNpemUgPT09IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgbmV3Q2hhbmdlQnVmZmVyKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMsICEhb3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrUmVtb3ZhbHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSh0eG4pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEuYnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWV0YWRhdGEodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAuZ2V0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydCghIW1ldGFkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0TWV0YWRhdGEodHhuLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBgZGJSZW1vdGVEb2NgIGFuZCByZXR1cm5zIHRoZSBkb2N1bWVudCAob3IgYW4gaW52YWxpZCBkb2N1bWVudCBpZlxyXG4gICAgICogdGhlIGRvY3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBmb3JtYXQgdXNlZCBmb3Igc2VudGluZWwgZGVsZXRlcykuXHJcbiAgICAgKi9cclxuICAgIG1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKSB7XHJcbiAgICAgICAgaWYgKGRiUmVtb3RlRG9jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGZyb21EYlJlbW90ZURvY3VtZW50KHRoaXMuc2VyaWFsaXplciwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRoZSBkb2N1bWVudCBpcyBhIHNlbnRpbmVsIHJlbW92YWwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcclxuICAgICAgICAgICAgY29uc3QgaXNTZW50aW5lbFJlbW92YWwgPSBkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzU2VudGluZWxSZW1vdmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KTtcclxuICAgIH1cclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlLiAqL1xyXG5mdW5jdGlvbiBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHNlcmlhbGl6ZXIpIHtcclxuICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwoc2VyaWFsaXplcik7XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGRldGFpbHMgb2YgYWRkaW5nIGFuZCB1cGRhdGluZyBkb2N1bWVudHMgaW4gdGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqXHJcbiAqIFVubGlrZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIsIHRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gY29tcHV0ZXMgdGhlIHNpemVcclxuICogZGVsdGEgZm9yIGFsbCBzdWJtaXR0ZWQgY2hhbmdlcy4gVGhpcyBhdm9pZHMgaGF2aW5nIHRvIHJlLXJlYWQgYWxsIGRvY3VtZW50cyBmcm9tIEluZGV4ZWREYlxyXG4gKiB3aGVuIHdlIGFwcGx5IHRoZSBjaGFuZ2VzLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudENhY2hlIC0gVGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXHJcbiAgICAgKiBAcGFyYW0gdHJhY2tSZW1vdmFscyAtIFdoZXRoZXIgdG8gY3JlYXRlIHNlbnRpbmVsIGRlbGV0ZXMgdGhhdCBjYW4gYmUgdHJhY2tlZCBieVxyXG4gICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSwgdHJhY2tSZW1vdmFscykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcclxuICAgICAgICB0aGlzLnRyYWNrUmVtb3ZhbHMgPSB0cmFja1JlbW92YWxzO1xyXG4gICAgICAgIC8vIEEgbWFwIG9mIGRvY3VtZW50IHNpemVzIGFuZCByZWFkIHRpbWVzIHByaW9yIHRvIGFwcGx5aW5nIHRoZSBjaGFuZ2VzIGluXHJcbiAgICAgICAgLy8gdGhpcyBidWZmZXIuXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgIH1cclxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgbGV0IHNpemVEZWx0YSA9IDA7XHJcbiAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnRDaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNEb2MgPSB0aGlzLmRvY3VtZW50U3RhdGVzLmdldChrZXkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBwcmV2aW91c0RvYy5yZWFkVGltZSkpO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRDaGFuZ2UuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQoa2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhICs9IHNpemUgLSBwcmV2aW91c0RvYy5zaXplO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRGVsdGEgLT0gcHJldmlvdXNEb2Muc2l6ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmVtb3ZhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byB0cmFjayByZW1vdmFscywgd2Ugc3RvcmUgYSBcInNlbnRpbmVsIGRlbGV0ZVwiIGluIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW90ZURvY3VtZW50Q2FjaGUuIFRoaXMgZW50cnkgaXMgcmVwcmVzZW50ZWQgYnkgYSBOb0RvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBhIHZlcnNpb24gb2YgMCBhbmQgaWdub3JlZCBieSBgbWF5YmVEZWNvZGVEb2N1bWVudCgpYCBidXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVkRG9jID0gdG9EYlJlbW90ZURvY3VtZW50KHRoaXMuZG9jdW1lbnRDYWNoZS5zZXJpYWxpemVyLCBkb2N1bWVudENoYW5nZS5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRlbGV0ZWREb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS51cGRhdGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgc2l6ZURlbHRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICAvLyBSZWNvcmQgdGhlIHNpemUgb2YgZXZlcnl0aGluZyB3ZSBsb2FkIGZyb20gdGhlIGNhY2hlIHNvIHdlIGNhbiBjb21wdXRlIGEgZGVsdGEgbGF0ZXIuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KGdldFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMuc2V0KGRvY3VtZW50S2V5LCB7XHJcbiAgICAgICAgICAgICAgICBzaXplOiBnZXRSZXN1bHQuc2l6ZSxcclxuICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBnZXRSZXN1bHQuZG9jdW1lbnQucmVhZFRpbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQuZG9jdW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIC8vIFJlY29yZCB0aGUgc2l6ZSBvZiBldmVyeXRoaW5nIHdlIGxvYWQgZnJvbSB0aGUgY2FjaGUgc28gd2UgY2FuIGNvbXB1dGVcclxuICAgICAgICAvLyBhIGRlbHRhIGxhdGVyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgLmdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxyXG4gICAgICAgICAgICAubmV4dCgoeyBkb2N1bWVudHMsIHNpemVNYXAgfSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBgZ2V0QWxsRnJvbUNhY2hlYCByZXR1cm5zIHR3byBtYXBzIGluc3RlYWQgb2YgYSBzaW5nbGUgbWFwIGZyb21cclxuICAgICAgICAgICAgLy8ga2V5cyB0byBgRG9jdW1lbnRTaXplRW50cnlgcy4gVGhpcyBpcyB0byBhbGxvdyByZXR1cm5pbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIGBNdXRhYmxlRG9jdW1lbnRNYXBgIGRpcmVjdGx5LCB3aXRob3V0IGEgY29udmVyc2lvbi5cclxuICAgICAgICAgICAgc2l6ZU1hcC5mb3JFYWNoKChkb2N1bWVudEtleSwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcy5zZXQoZG9jdW1lbnRLZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBkb2N1bWVudHMuZ2V0KGRvY3VtZW50S2V5KS5yZWFkVGltZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHJlbW90ZURvY3VtZW50cyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdGVEb2N1bWVudHNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUmVtb3RlRG9jdW1lbnRTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcclxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4YCBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGRiS2V5KGRvY3VtZW50S2V5KSB7XHJcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcclxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyB2aWEgdGhlIHByaW1hcnkga2V5IG9mXHJcbiAqIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XHJcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcclxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KHJlYWRUaW1lKSxcclxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcclxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4YCBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBwYXRoID0gb2Zmc2V0LmRvY3VtZW50S2V5LnBhdGgudG9BcnJheSgpO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIGNvbGxlY3Rpb25Hcm91cCxcclxuICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXHJcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxyXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGgubGVuZ3RoID4gMCA/IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA6ICcnXHJcbiAgICBdO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJhdG9yIHRoYXQgY29tcGFyZXMgZG9jdW1lbnQga2V5cyBhY2NvcmRpbmcgdG8gdGhlIHByaW1hcnkga2V5IHNvcnRpbmdcclxuICogdXNlZCBieSB0aGUgYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudGAgc3RvcmUgKGJ5IHByZWZpeCBwYXRoLCBjb2xsZWN0aW9uIGlkXHJcbiAqIGFuZCB0aGVuIGRvY3VtZW50IElEKS5cclxuICpcclxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGRiS2V5Q29tcGFyYXRvcihsLCByKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gbC5wYXRoLnRvQXJyYXkoKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gci5wYXRoLnRvQXJyYXkoKTtcclxuICAgIC8vIFRoZSBvcmRlcmluZyBpcyBiYXNlZCBvbiBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vYmxpbmsvKy9mZTVjMjFmZWY5NGRhZTcxYzFjMzM0NDc3NWI4ZDhhN2Y3ZTZkOWVjL1NvdXJjZS9tb2R1bGVzL2luZGV4ZWRkYi9JREJLZXkuY3BwIzc0XHJcbiAgICBsZXQgY21wID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggLSAyICYmIGkgPCByaWdodC5sZW5ndGggLSAyOyArK2kpIHtcclxuICAgICAgICBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRbaV0sIHJpZ2h0W2ldKTtcclxuICAgICAgICBpZiAoY21wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcclxuICAgIGlmIChjbXApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2xlZnQubGVuZ3RoIC0gMl0sIHJpZ2h0W3JpZ2h0Lmxlbmd0aCAtIDJdKTtcclxuICAgIGlmIChjbXApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFtyaWdodC5sZW5ndGggLSAxXSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFNjaGVtYSBWZXJzaW9uIGZvciB0aGUgV2ViIGNsaWVudDpcclxuICogMS4gIEluaXRpYWwgdmVyc2lvbiBpbmNsdWRpbmcgTXV0YXRpb24gUXVldWUsIFF1ZXJ5IENhY2hlLCBhbmQgUmVtb3RlXHJcbiAqICAgICBEb2N1bWVudCBDYWNoZVxyXG4gKiAyLiAgVXNlZCB0byBlbnN1cmUgYSB0YXJnZXRHbG9iYWwgb2JqZWN0IGV4aXN0cyBhbmQgYWRkIHRhcmdldENvdW50IHRvIGl0LiBOb1xyXG4gKiAgICAgbG9uZ2VyIHJlcXVpcmVkIGJlY2F1c2UgbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cclxuICogMy4gIERyb3BwZWQgYW5kIHJlLWNyZWF0ZWQgUXVlcnkgQ2FjaGUgdG8gZGVhbCB3aXRoIGNhY2hlIGNvcnJ1cHRpb24gcmVsYXRlZFxyXG4gKiAgICAgdG8gbGltYm8gcmVzb2x1dGlvbi4gQWRkcmVzc2VzXHJcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtaW9zLXNkay9pc3N1ZXMvMTU0OFxyXG4gKiA0LiAgTXVsdGktVGFiIFN1cHBvcnQuXHJcbiAqIDUuICBSZW1vdmFsIG9mIGhlbGQgd3JpdGUgYWNrcy5cclxuICogNi4gIENyZWF0ZSBkb2N1bWVudCBnbG9iYWwgZm9yIHRyYWNraW5nIGRvY3VtZW50IGNhY2hlIHNpemUuXHJcbiAqIDcuICBFbnN1cmUgZXZlcnkgY2FjaGVkIGRvY3VtZW50IGhhcyBhIHNlbnRpbmVsIHJvdyB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLlxyXG4gKiA4LiAgQWRkIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGZvciBDb2xsZWN0aW9uIEdyb3VwIHF1ZXJpZXMuXHJcbiAqIDkuICBDaGFuZ2UgUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIHN0b3JlIHRvIGJlIGtleWVkIGJ5IHJlYWRUaW1lIHJhdGhlciB0aGFuXHJcbiAqICAgICBhbiBhdXRvLWluY3JlbWVudGluZyBJRC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgSW5kZXgtRnJlZSBxdWVyaWVzLlxyXG4gKiAxMC4gUmV3cml0ZSB0aGUgY2Fub25pY2FsIElEcyB0byB0aGUgZXhwbGljaXQgUHJvdG9idWYtYmFzZWQgZm9ybWF0LlxyXG4gKiAxMS4gQWRkIGJ1bmRsZXMgYW5kIG5hbWVkX3F1ZXJpZXMgZm9yIGJ1bmRsZSBzdXBwb3J0LlxyXG4gKiAxMi4gQWRkIGRvY3VtZW50IG92ZXJsYXlzLlxyXG4gKiAxMy4gUmV3cml0ZSB0aGUga2V5cyBvZiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIHRvIGFsbG93IGZvciBlZmZpY2llbnRcclxuICogICAgIGRvY3VtZW50IGxvb2t1cCB2aWEgYGdldEFsbCgpYC5cclxuICogMTQuIEFkZCBvdmVybGF5cy5cclxuICogMTUuIEFkZCBpbmRleGluZyBzdXBwb3J0LlxyXG4gKiAxNi4gUGFyc2UgdGltZXN0YW1wIHN0cmluZ3MgYmVmb3JlIGNyZWF0aW5nIGluZGV4IGVudHJpZXMuXHJcbiAqL1xyXG5jb25zdCBTQ0hFTUFfVkVSU0lPTiA9IDE2O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxvY2FsIHZpZXcgKG92ZXJsYXkpIG9mIGEgZG9jdW1lbnQsIGFuZCB0aGUgZmllbGRzIHRoYXQgYXJlXHJcbiAqIGxvY2FsbHkgbXV0YXRlZC5cclxuICovXHJcbmNsYXNzIE92ZXJsYXllZERvY3VtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXllZERvY3VtZW50LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpZWxkcyB0aGF0IGFyZSBsb2NhbGx5IG11dGF0ZWQgYnkgcGF0Y2ggbXV0YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBvdmVybGF5ZWRcdGRvY3VtZW50IGlzIGZyb20gc2V0IG9yIGRlbGV0ZSBtdXRhdGlvbnMsIHRoaXMgaXMgYG51bGxgLlxyXG4gICAgICogSWYgdGhlcmUgaXMgbm8gb3ZlcmxheSAobXV0YXRpb24pIGZvciB0aGUgZG9jdW1lbnQsIHRoaXMgaXMgYW4gZW1wdHkgYEZpZWxkTWFza2AuXHJcbiAgICAgKi9cclxuICAgIG11dGF0ZWRGaWVsZHMpIHtcclxuICAgICAgICB0aGlzLm92ZXJsYXllZERvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5tdXRhdGVkRmllbGRzID0gbXV0YXRlZEZpZWxkcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSByZWFkb25seSB2aWV3IG9mIHRoZSBsb2NhbCBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHdlJ3JlIHRyYWNraW5nIChpLmUuIHdlXHJcbiAqIGhhdmUgYSBjYWNoZWQgdmVyc2lvbiBpbiByZW1vdGVEb2N1bWVudENhY2hlIG9yIGxvY2FsIG11dGF0aW9ucyBmb3IgdGhlXHJcbiAqIGRvY3VtZW50KS4gVGhlIHZpZXcgaXMgY29tcHV0ZWQgYnkgYXBwbHlpbmcgdGhlIG11dGF0aW9ucyBpbiB0aGVcclxuICogTXV0YXRpb25RdWV1ZSB0byB0aGUgUmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICovXHJcbmNsYXNzIExvY2FsRG9jdW1lbnRzVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlID0gcmVtb3RlRG9jdW1lbnRDYWNoZTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSBtdXRhdGlvblF1ZXVlO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSBkb2N1bWVudE92ZXJsYXlDYWNoZTtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudCBpZGVudGlmaWVkIGJ5IGBrZXlgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIExvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IG9yIG51bGwgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkXHJcbiAgICAgKiBzdGF0ZSBmb3IgaXQuXHJcbiAgICAgKi9cclxuICAgIGdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSlcclxuICAgICAgICAgICAgLm5leHQodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBvdmVybGF5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGtleSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoZG9jdW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvY3VtZW50LCBGaWVsZE1hc2suZW1wdHkoKSwgVGltZXN0YW1wLm5vdygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBpZGVudGlmaWVkIGJ5IGBrZXlzYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzdGF0ZSBmb3IgYSBkb2N1bWVudCBpbiBga2V5c2AsIGEgTm9Eb2N1bWVudCB3aWxsXHJcbiAgICAgKiBiZSBzdG9yZWQgZm9yIHRoYXQga2V5IGluIHRoZSByZXN1bHRpbmcgc2V0LlxyXG4gICAgICovXHJcbiAgICBnZXREb2N1bWVudHModHJhbnNhY3Rpb24sIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXHJcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXlzKVxyXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MsIGRvY3VtZW50S2V5U2V0KCkpLm5leHQoKCkgPT4gZG9jcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1pbGFyIHRvIGBnZXREb2N1bWVudHNgLCBidXQgY3JlYXRlcyB0aGUgbG9jYWwgdmlldyBmcm9tIHRoZSBnaXZlblxyXG4gICAgICogYGJhc2VEb2NzYCB3aXRob3V0IHJldHJpZXZpbmcgZG9jdW1lbnRzIGZyb20gdGhlIGxvY2FsIHN0b3JlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0aGlzIG9wZXJhdGlvbiBpcyBzY29wZWQgdG8uXHJcbiAgICAgKiBAcGFyYW0gZG9jcyAtIFRoZSBkb2N1bWVudHMgdG8gYXBwbHkgbG9jYWwgbXV0YXRpb25zIHRvIGdldCB0aGUgbG9jYWwgdmlld3MuXHJcbiAgICAgKiBAcGFyYW0gZXhpc3RlbmNlU3RhdGVDaGFuZ2VkIC0gVGhlIHNldCBvZiBkb2N1bWVudCBrZXlzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZVxyXG4gICAgICogICBpcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWZ1bCB0byBkZXRlcm1pbmUgaWYgc29tZSBkb2N1bWVudHMgb3ZlcmxheSBuZWVkc1xyXG4gICAgICogICB0byBiZSByZWNhbGN1bGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldExvY2FsVmlld09mRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgPSBkb2N1bWVudEtleVNldCgpKSB7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpLm5leHQoY29tcHV0ZVZpZXdzUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpZXdzUmVzdWx0LmZvckVhY2goKGRvY3VtZW50S2V5LCBvdmVybGF5ZWREb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50Lm92ZXJsYXllZERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG92ZXJsYXllZCBkb2N1bWVudHMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBtYXAsIHdoaWNoIHdpbGwgaW5jbHVkZVxyXG4gICAgICogdGhlIGxvY2FsIHZpZXcgb2YgdGhvc2UgZG9jdW1lbnRzIGFuZCBhIGBGaWVsZE1hc2tgIGluZGljYXRpbmcgd2hpY2ggZmllbGRzXHJcbiAgICAgKiBhcmUgbXV0YXRlZCBsb2NhbGx5LCBgbnVsbGAgaWYgb3ZlcmxheSBpcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldE92ZXJsYXllZERvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcykge1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBkb2NzKS5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZG9jdW1lbnRLZXlTZXQoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIHRoZSBvdmVybGF5cyBmb3Ige0Bjb2RlIGRvY3N9IGFuZCBhZGRzIHRoZW0gdG8gcHJvdmlkZWQgb3ZlcmxheSBtYXBcclxuICAgICAqIGlmIHRoZSBtYXAgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFuIGVudHJ5IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5LlxyXG4gICAgICovXHJcbiAgICBwb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykge1xyXG4gICAgICAgIGNvbnN0IG1pc3NpbmdPdmVybGF5cyA9IFtdO1xyXG4gICAgICAgIGRvY3MuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXlzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNzaW5nT3ZlcmxheXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBtaXNzaW5nT3ZlcmxheXMpXHJcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKChrZXksIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgdmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2NzIC0gVGhlIGRvY3VtZW50cyB0byBjb21wdXRlIHZpZXdzIGZvci4gSXQgYWxzbyBoYXMgdGhlIGJhc2VcclxuICAgICAqICAgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRzLlxyXG4gICAgICogQHBhcmFtIG92ZXJsYXlzIC0gVGhlIG92ZXJsYXlzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBnaXZlbiBiYXNlXHJcbiAgICAgKiAgIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50cy5cclxuICAgICAqIEBwYXJhbSBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgLSBBIHNldCBvZiBkb2N1bWVudHMgd2hvc2UgZXhpc3RlbmNlIHN0YXRlc1xyXG4gICAgICogICBtaWdodCBoYXZlIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byByZS1jYWxjdWxhdGVcclxuICAgICAqICAgb3ZlcmxheXMgZnJvbSBtdXRhdGlvbiBxdWV1ZXMuXHJcbiAgICAgKiBAcmV0dXJuIEEgbWFwIHJlcHJlc2VudHMgdGhlIGxvY2FsIGRvY3VtZW50cyB2aWV3LlxyXG4gICAgICovXHJcbiAgICBjb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICBsZXQgcmVjYWxjdWxhdGVEb2N1bWVudHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBjb25zdCBtdXRhdGVkRmllbGRzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3T3ZlcmxheWVkRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBkb2NzLmZvckVhY2goKF8sIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXMuZ2V0KGRvYy5rZXkpO1xyXG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBhbiBvdmVybGF5IGlmIHRoZSBkb2N1bWVudCdzIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2VkIGR1ZSB0b1xyXG4gICAgICAgICAgICAvLyBhIHJlbW90ZSBldmVudCAqYW5kKiB0aGUgb3ZlcmxheSBpcyBhIFBhdGNoTXV0YXRpb24uIFRoaXMgaXMgYmVjYXVzZVxyXG4gICAgICAgICAgICAvLyBkb2N1bWVudCBleGlzdGVuY2Ugc3RhdGUgY2FuIGNoYW5nZSBpZiBzb21lIHBhdGNoIG11dGF0aW9uJ3NcclxuICAgICAgICAgICAgLy8gcHJlY29uZGl0aW9ucyBhcmUgbWV0LlxyXG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSByZWNhbGN1bGF0ZSB3aGVuIGBvdmVybGF5YCBpcyB1bmRlZmluZWQgYXMgd2VsbCwgYmVjYXVzZSB0aGVyZVxyXG4gICAgICAgICAgICAvLyBtaWdodCBiZSBhIHBhdGNoIG11dGF0aW9uIHdob3NlIHByZWNvbmRpdGlvbiBkb2VzIG5vdCBtYXRjaCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSAoaGVuY2Ugb3ZlcmxheSBpcyB1bmRlZmluZWQpLCBidXQgd291bGQgbm93IG1hdGNoLlxyXG4gICAgICAgICAgICBpZiAoZXhpc3RlbmNlU3RhdGVDaGFuZ2VkLmhhcyhkb2Mua2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgKG92ZXJsYXkgPT09IHVuZGVmaW5lZCB8fCBvdmVybGF5Lm11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gcmVjYWxjdWxhdGVEb2N1bWVudHMuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzLnNldChkb2Mua2V5LCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpKTtcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2MsIG92ZXJsYXkubXV0YXRpb24uZ2V0RmllbGRNYXNrKCksIFRpbWVzdGFtcC5ub3coKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBvdmVybGF5IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgRU1QVFkgdG8gaW5kaWNhdGUgdGhlcmUgaXMgbm8gb3ZlcmxheSBmb3IgdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgRmllbGRNYXNrLmVtcHR5KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIHJlY2FsY3VsYXRlRG9jdW1lbnRzKS5uZXh0KHJlY2FsY3VsYXRlZEZpZWxkcyA9PiB7XHJcbiAgICAgICAgICAgIHJlY2FsY3VsYXRlZEZpZWxkcy5mb3JFYWNoKChkb2N1bWVudEtleSwgbWFzaykgPT4gbXV0YXRlZEZpZWxkcy5zZXQoZG9jdW1lbnRLZXksIG1hc2spKTtcclxuICAgICAgICAgICAgZG9jcy5mb3JFYWNoKChkb2N1bWVudEtleSwgZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzLnNldChkb2N1bWVudEtleSwgbmV3IE92ZXJsYXllZERvY3VtZW50KGRvY3VtZW50LCAoX2EgPSBtdXRhdGVkRmllbGRzLmdldChkb2N1bWVudEtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpIHtcclxuICAgICAgICBjb25zdCBtYXNrcyA9IG5ld0RvY3VtZW50S2V5TWFwKCk7XHJcbiAgICAgICAgLy8gQSByZXZlcnNlIGxvb2t1cCBtYXAgZnJvbSBiYXRjaCBpZCB0byB0aGUgZG9jdW1lbnRzIHdpdGhpbiB0aGF0IGJhdGNoLlxyXG4gICAgICAgIGxldCBkb2N1bWVudHNCeUJhdGNoSWQgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XHJcbiAgICAgICAgbGV0IHByb2Nlc3NlZCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAuZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBkb2NzKVxyXG4gICAgICAgICAgICAubmV4dChiYXRjaGVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEb2MgPSBkb2NzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRG9jID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBtYXNrcy5nZXQoa2V5KSB8fCBGaWVsZE1hc2suZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNrID0gYmF0Y2guYXBwbHlUb0xvY2FsVmlldyhiYXNlRG9jLCBtYXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNrcy5zZXQoa2V5LCBtYXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAoZG9jdW1lbnRzQnlCYXRjaElkLmdldChiYXRjaC5iYXRjaElkKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudHNCeUJhdGNoSWQgPSBkb2N1bWVudHNCeUJhdGNoSWQuaW5zZXJ0KGJhdGNoLmJhdGNoSWQsIG5ld1NldCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIGJhdGNoIElEcywgYW5kIHNraXAgZG9jdW1lbnRzIHRoYXQgYXJlXHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgc2F2ZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudHNCeUJhdGNoSWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoSWQgPSBlbnRyeS5rZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld011dGF0aW9uTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5TXV0YXRpb24gPSBjYWxjdWxhdGVPdmVybGF5TXV0YXRpb24oZG9jcy5nZXQoa2V5KSwgbWFza3MuZ2V0KGtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheU11dGF0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQoa2V5LCBvdmVybGF5TXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGJhdGNoSWQsIG92ZXJsYXlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBtYXNrcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBvdmVybGF5cyBieSByZWFkaW5nIHRoZSBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGVcclxuICAgICAqIGZpcnN0LCBhbmQgc2F2ZXMgdGhlbSBhZnRlciB0aGV5IGFyZSBjYWxjdWxhdGVkLlxyXG4gICAgICovXHJcbiAgICByZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxyXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGRvY3MpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCB2aWV3IG9mIGFsbCBkb2N1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIG1hdGNoIGRvY3VtZW50cyBhZ2FpbnN0LlxyXG4gICAgICogQHBhcmFtIG9mZnNldCAtIFJlYWQgdGltZSBhbmQga2V5IHRvIHN0YXJ0IHNjYW5uaW5nIGJ5IChleGNsdXNpdmUpLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIG9wdGlvbmFsIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlsc1xyXG4gICAgICogICBkdXJpbmcgZGF0YWJhc2UgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRRdWVyeSQxKHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0RvY3VtZW50UXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29sbGVjdGlvbiBncm91cCwgcmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCwgYWxvbmdcclxuICAgICAqIHdpdGggYW4gdXBkYXRlZCBiYXRjaCBJRC5cclxuICAgICAqXHJcbiAgICAgKiA8cD5UaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBvcmRlcmVkIGJ5IHJlbW90ZSB2ZXJzaW9uIGZyb20gdGhlIHByb3ZpZGVkXHJcbiAgICAgKiBvZmZzZXQuIElmIHRoZXJlIGFyZSBubyBtb3JlIHJlbW90ZSBkb2N1bWVudHMgYWZ0ZXIgdGhlIHByb3ZpZGVkIG9mZnNldCwgZG9jdW1lbnRzIHdpdGhcclxuICAgICAqIG11dGF0aW9ucyBpbiBvcmRlciBvZiBiYXRjaCBpZCBmcm9tIHRoZSBvZmZzZXQgYXJlIHJldHVybmVkLiBTaW5jZSBhbGwgZG9jdW1lbnRzIGluIGEgYmF0Y2ggYXJlXHJcbiAgICAgKiByZXR1cm5lZCB0b2dldGhlciwgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgY2FuIGV4Y2VlZCB7QGNvZGUgY291bnR9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvblxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25Hcm91cCBUaGUgY29sbGVjdGlvbiBncm91cCBmb3IgdGhlIGRvY3VtZW50cy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBpbmRleCBpbnRvLlxyXG4gICAgICogQHBhcmFtIGNvdW50IFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRvIHJldHVyblxyXG4gICAgICogQHJldHVybiBBIExvY2FsV3JpdGVSZXN1bHQgd2l0aCB0aGUgZG9jdW1lbnRzIHRoYXQgZm9sbG93IHRoZSBwcm92aWRlZCBvZmZzZXQgYW5kIHRoZSBsYXN0IHByb2Nlc3NlZCBiYXRjaCBpZC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KVxyXG4gICAgICAgICAgICAubmV4dCgob3JpZ2luYWxEb2NzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzUHJvbWlzZSA9IGNvdW50IC0gb3JpZ2luYWxEb2NzLnNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUuZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkLCBjb3VudCAtIG9yaWdpbmFsRG9jcy5zaXplKVxyXG4gICAgICAgICAgICAgICAgOiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShuZXdPdmVybGF5TWFwKCkpO1xyXG4gICAgICAgICAgICAvLyBUaGUgY2FsbHNpdGUgd2lsbCB1c2UgdGhlIGxhcmdlc3QgYmF0Y2ggSUQgdG9nZXRoZXIgd2l0aCB0aGUgbGF0ZXN0IHJlYWQgdGltZSB0byBjcmVhdGVcclxuICAgICAgICAgICAgLy8gYSBuZXcgaW5kZXggb2Zmc2V0LiBTaW5jZSB3ZSBvbmx5IHByb2Nlc3MgYmF0Y2ggSURzIGlmIGFsbCByZW1vdGUgZG9jdW1lbnRzIGhhdmUgYmVlbiByZWFkLFxyXG4gICAgICAgICAgICAvLyBubyBvdmVybGF5IHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGwgcmVhZCB0aW1lLiBUaGlzIGlzIHdoeSB3ZSBvbmx5IG5lZWQgdG8gc3BlY2lhbCBjYXNlXHJcbiAgICAgICAgICAgIC8vIHRoZSBiYXRjaCBpZC5cclxuICAgICAgICAgICAgbGV0IGxhcmdlc3RCYXRjaElkID0gSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWREb2NzID0gb3JpZ2luYWxEb2NzO1xyXG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheXNQcm9taXNlLm5leHQob3ZlcmxheXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKG92ZXJsYXlzLCAoa2V5LCBvdmVybGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhcmdlc3RCYXRjaElkIDwgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbERvY3MuZ2V0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KGRvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jcyA9IG1vZGlmaWVkRG9jcy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBvcmlnaW5hbERvY3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBtb2RpZmllZERvY3MsIG92ZXJsYXlzLCBkb2N1bWVudEtleVNldCgpKSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChsb2NhbERvY3MgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkOiBsYXJnZXN0QmF0Y2hJZCxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKGxvY2FsRG9jcylcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0RvY3VtZW50UXVlcnkodHJhbnNhY3Rpb24sIGRvY1BhdGgpIHtcclxuICAgICAgICAvLyBKdXN0IGRvIGEgc2ltcGxlIGRvY3VtZW50IGxvb2t1cC5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudCh0cmFuc2FjdGlvbiwgbmV3IERvY3VtZW50S2V5KGRvY1BhdGgpKS5uZXh0KGRvY3VtZW50ID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uR3JvdXBRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgIC5nZXRDb2xsZWN0aW9uUGFyZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbklkKVxyXG4gICAgICAgICAgICAubmV4dChwYXJlbnRzID0+IHtcclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGNvbGxlY3Rpb24gcXVlcnkgYWdhaW5zdCBlYWNoIHBhcmVudCB0aGF0IGNvbnRhaW5zIHRoZVxyXG4gICAgICAgICAgICAvLyBjb2xsZWN0aW9uSWQgYW5kIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cy5cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHBhcmVudHMsIChwYXJlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25RdWVyeSA9IGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXJlbnQuY2hpbGQoY29sbGVjdGlvbklkKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpLm5leHQociA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xyXG4gICAgICAgIC8vIFF1ZXJ5IHRoZSByZW1vdGUgZG9jdW1lbnRzIGFuZCBvdmVybGF5IG11dGF0aW9ucy5cclxuICAgICAgICBsZXQgb3ZlcmxheXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcclxuICAgICAgICAgICAgLmdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbih0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCwgb2Zmc2V0Lmxhcmdlc3RCYXRjaElkKVxyXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBvdmVybGF5cyA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZS5nZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBvdmVybGF5cywgY29udGV4dCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQocmVtb3RlRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgLy8gQXMgZG9jdW1lbnRzIG1pZ2h0IG1hdGNoIHRoZSBxdWVyeSBiZWNhdXNlIG9mIHRoZWlyIG92ZXJsYXkgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGRvY3VtZW50cyBmb3IgYWxsIG92ZXJsYXlzIGluIHRoZSBpbml0aWFsIGRvY3VtZW50IHNldC5cclxuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgb3ZlcmxheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVEb2N1bWVudHMuZ2V0KGtleSkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVEb2N1bWVudHMgPSByZW1vdGVEb2N1bWVudHMuaW5zZXJ0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvdmVybGF5cyBhbmQgbWF0Y2ggYWdhaW5zdCB0aGUgcXVlcnkuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcclxuICAgICAgICAgICAgcmVtb3RlRG9jdW1lbnRzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jdW1lbnQsIEZpZWxkTWFzay5lbXB0eSgpLCBUaW1lc3RhbXAubm93KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgaW5zZXJ0IHRoZSBkb2N1bWVudHMgdGhhdCBzdGlsbCBtYXRjaCB0aGUgcXVlcnlcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeU1hdGNoZXMocXVlcnksIGRvY3VtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeUJ1bmRsZUNhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5hbWVkUXVlcmllcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmJ1bmRsZXMuZ2V0KGJ1bmRsZUlkKSk7XHJcbiAgICB9XHJcbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idW5kbGVzLnNldChidW5kbGVNZXRhZGF0YS5pZCwgZnJvbUJ1bmRsZU1ldGFkYXRhKGJ1bmRsZU1ldGFkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5uYW1lZFF1ZXJpZXMuZ2V0KHF1ZXJ5TmFtZSkpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5Lm5hbWUsIGZyb21Qcm90b05hbWVkUXVlcnkocXVlcnkpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIERvY3VtZW50T3ZlcmxheUNhY2hlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5RG9jdW1lbnRPdmVybGF5Q2FjaGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gQSBtYXAgc29ydGVkIGJ5IERvY3VtZW50S2V5LCB3aG9zZSB2YWx1ZSBpcyBhIHBhaXIgb2YgdGhlIGxhcmdlc3QgYmF0Y2ggaWRcclxuICAgICAgICAvLyBmb3IgdGhlIG92ZXJsYXkgYW5kIHRoZSBvdmVybGF5IGl0c2VsZi5cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5vdmVybGF5cy5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goa2V5cywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcclxuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChfLCBtdXRhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChiYXRjaElkKTtcclxuICAgICAgICBpZiAoa2V5cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLnJlbW92ZShrZXkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5kZWxldGUoYmF0Y2hJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uLmNoaWxkKCcnKSk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XHJcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEb2N1bWVudHMgZnJvbSBzdWItY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcclxuICAgICAgICBsZXQgYmF0Y2hJZFRvT3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGVudHJ5LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmdldENvbGxlY3Rpb25Hcm91cCgpICE9PSBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVybGF5Lmxhcmdlc3RCYXRjaElkID4gc2luY2VCYXRjaElkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheXNGb3JCYXRjaElkID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzRm9yQmF0Y2hJZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZCA9IG5ld092ZXJsYXlNYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkVG9PdmVybGF5cyA9IGJhdGNoSWRUb092ZXJsYXlzLmluc2VydChvdmVybGF5Lmxhcmdlc3RCYXRjaElkLCBvdmVybGF5c0ZvckJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXNGb3JCYXRjaElkLnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hJdGVyID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoYmF0Y2hJdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGJhdGNoSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKGtleSwgb3ZlcmxheSkgPT4gcmVzdWx0LnNldChrZXksIG92ZXJsYXkpKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplKCkgPj0gY291bnQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikge1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXNzb2NpYXRpb24gb2YgdGhlIG92ZXJsYXkgdG8gaXRzIGJhdGNoIGlkLlxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5vdmVybGF5cy5nZXQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2V0ID0gdGhpcy5vdmVybGF5QnlCYXRjaElkXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkKVxyXG4gICAgICAgICAgICAgICAgLmRlbGV0ZShtdXRhdGlvbi5rZXkpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkLCBuZXdTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5pbnNlcnQobXV0YXRpb24ua2V5LCBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pKTtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGFzc29jaWF0aW9uIG9mIHRoaXMgb3ZlcmxheSB0byB0aGUgZ2l2ZW4gbGFyZ2VzdEJhdGNoSWQuXHJcbiAgICAgICAgbGV0IGJhdGNoID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChsYXJnZXN0QmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGJhdGNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmF0Y2ggPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGxhcmdlc3RCYXRjaElkLCBiYXRjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQobGFyZ2VzdEJhdGNoSWQsIGJhdGNoLmFkZChtdXRhdGlvbi5rZXkpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBmcm9tIHNvbWUga2luZCBvZiBudW1iZXJlZCBlbnRpdHlcclxuICogKGVpdGhlciBhIHRhcmdldCBJRCBvciBiYXRjaCBJRCkuIEFzIHJlZmVyZW5jZXMgYXJlIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbVxyXG4gKiB0aGUgc2V0IGNvcnJlc3BvbmRpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIHRvIGEgcmVnaXN0ZXJlZCBnYXJiYWdlIGNvbGxlY3Rvci5cclxuICpcclxuICogRWFjaCByZWZlcmVuY2UgaXMgcmVwcmVzZW50ZWQgYnkgYSBEb2N1bWVudFJlZmVyZW5jZSBvYmplY3QuIEVhY2ggb2YgdGhlbVxyXG4gKiBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHJlZmVyZW5jZS4gVGhleSBhcmUgYWxsXHJcbiAqIHN0b3JlZCBwcmltYXJpbHkgaW4gYSBzZXQgc29ydGVkIGJ5IGtleS4gQSBkb2N1bWVudCBpcyBjb25zaWRlcmVkIGdhcmJhZ2UgaWZcclxuICogdGhlcmUncyBubyByZWZlcmVuY2VzIGluIHRoYXQgc2V0ICh0aGlzIGNhbiBiZSBlZmZpY2llbnRseSBjaGVja2VkIHRoYW5rcyB0b1xyXG4gKiBzb3J0aW5nIGJ5IGtleSkuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZVNldCBhbHNvIGtlZXBzIGEgc2Vjb25kYXJ5IHNldCB0aGF0IGNvbnRhaW5zIHJlZmVyZW5jZXMgc29ydGVkIGJ5XHJcbiAqIElEcy4gVGhpcyBvbmUgaXMgdXNlZCB0byBlZmZpY2llbnRseSBpbXBsZW1lbnQgcmVtb3ZhbCBvZiBhbGwgcmVmZXJlbmNlcyBieVxyXG4gKiBzb21lIHRhcmdldCBJRC5cclxuICovXHJcbmNsYXNzIFJlZmVyZW5jZVNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBBIHNldCBvZiBvdXRzdGFuZGluZyByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgc29ydGVkIGJ5IGtleS5cclxuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeUtleSk7XHJcbiAgICAgICAgLy8gQSBzZXQgb2Ygb3V0c3RhbmRpbmcgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IHNvcnRlZCBieSB0YXJnZXQgaWQuXHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlUYXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2Ugc2V0IGNvbnRhaW5zIG5vIHJlZmVyZW5jZXMuICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNCeUtleS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5IGZvciB0aGUgZ2l2ZW4gSUQuICovXHJcbiAgICBhZGRSZWZlcmVuY2Uoa2V5LCBpZCkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCBpZCk7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSB0aGlzLnJlZnNCeUtleS5hZGQocmVmKTtcclxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IHRoaXMucmVmc0J5VGFyZ2V0LmFkZChyZWYpO1xyXG4gICAgfVxyXG4gICAgLyoqIEFkZCByZWZlcmVuY2VzIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXlzIGZvciB0aGUgZ2l2ZW4gSUQuICovXHJcbiAgICBhZGRSZWZlcmVuY2VzKGtleXMsIGlkKSB7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLmFkZFJlZmVyZW5jZShrZXksIGlkKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleSBmb3IgdGhlIGdpdmVuXHJcbiAgICAgKiBJRC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVJlZihuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVJlZmVyZW5jZXMoa2V5cywgaWQpIHtcclxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMucmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCByZWZlcmVuY2VzIHdpdGggYSBnaXZlbiBJRC4gQ2FsbHMgcmVtb3ZlUmVmKCkgZm9yIGVhY2gga2V5XHJcbiAgICAgKiByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVSZWZlcmVuY2VzRm9ySWQoaWQpIHtcclxuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XHJcbiAgICAgICAgY29uc3QgZW5kUmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQgKyAxKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJlZihyZWYpO1xyXG4gICAgICAgICAgICBrZXlzLnB1c2gocmVmLmtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICByZW1vdmVBbGxSZWZlcmVuY2VzKCkge1xyXG4gICAgICAgIHRoaXMucmVmc0J5S2V5LmZvckVhY2gocmVmID0+IHRoaXMucmVtb3ZlUmVmKHJlZikpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmKHJlZikge1xyXG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gdGhpcy5yZWZzQnlLZXkuZGVsZXRlKHJlZik7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5kZWxldGUocmVmKTtcclxuICAgIH1cclxuICAgIHJlZmVyZW5jZXNGb3JJZChpZCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5S2V5ID0gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoW10pKTtcclxuICAgICAgICBjb25zdCBzdGFydFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkKTtcclxuICAgICAgICBjb25zdCBlbmRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCArIDEpO1xyXG4gICAgICAgIGxldCBrZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldC5mb3JFYWNoSW5SYW5nZShbc3RhcnRSZWYsIGVuZFJlZl0sIHJlZiA9PiB7XHJcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmFkZChyZWYua2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIGNvbnRhaW5zS2V5KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCAwKTtcclxuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMucmVmc0J5S2V5LmZpcnN0QWZ0ZXJPckVxdWFsKHJlZik7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVmICE9PSBudWxsICYmIGtleS5pc0VxdWFsKGZpcnN0UmVmLmtleSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRG9jUmVmZXJlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdGFyZ2V0T3JCYXRjaElkKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRPckJhdGNoSWQgPSB0YXJnZXRPckJhdGNoSWQ7XHJcbiAgICB9XHJcbiAgICAvKiogQ29tcGFyZSBieSBrZXkgdGhlbiBieSBJRCAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVCeUtleShsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSB8fFxyXG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQudGFyZ2V0T3JCYXRjaElkLCByaWdodC50YXJnZXRPckJhdGNoSWQpKTtcclxuICAgIH1cclxuICAgIC8qKiBDb21wYXJlIGJ5IElEIHRoZW4gYnkga2V5ICovXHJcbiAgICBzdGF0aWMgY29tcGFyZUJ5VGFyZ2V0SWQobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkgfHxcclxuICAgICAgICAgICAgRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmtleSwgcmlnaHQua2V5KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5TXV0YXRpb25RdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYWxsIG11dGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzZW50IGJ1dCBub3QgeWV0IGJlZW4gYXBwbGllZCB0b1xyXG4gICAgICAgICAqIHRoZSBiYWNrZW5kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IFtdO1xyXG4gICAgICAgIC8qKiBOZXh0IHZhbHVlIHRvIHVzZSB3aGVuIGFzc2lnbmluZyBzZXF1ZW50aWFsIElEcyB0byBlYWNoIG11dGF0aW9uIGJhdGNoLiAqL1xyXG4gICAgICAgIHRoaXMubmV4dEJhdGNoSWQgPSAxO1xyXG4gICAgICAgIC8qKiBBbiBvcmRlcmVkIG1hcHBpbmcgYmV0d2VlbiBkb2N1bWVudHMgYW5kIHRoZSBtdXRhdGlvbnMgYmF0Y2ggSURzLiAqL1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlLZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwKTtcclxuICAgIH1cclxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBiYXRjaElkID0gdGhpcy5uZXh0QmF0Y2hJZDtcclxuICAgICAgICB0aGlzLm5leHRCYXRjaElkKys7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZVt0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgIC8vIFRyYWNrIHJlZmVyZW5jZXMgYnkgZG9jdW1lbnQga2V5IGFuZCBpbmRleCBjb2xsZWN0aW9uIHBhcmVudHMuXHJcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleSA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuYWRkKG5ldyBEb2NSZWZlcmVuY2UobXV0YXRpb24ua2V5LCBiYXRjaElkKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBtdXRhdGlvbi5rZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpKTtcclxuICAgIH1cclxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dEJhdGNoSWQgPSBiYXRjaElkICsgMTtcclxuICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIGJhdGNoSWQgbWF5IHN0aWxsIGJlIG91dCBvZiByYW5nZSBzbyBub3JtYWxpemUgaXQgdG8gdGhlXHJcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIHF1ZXVlLlxyXG4gICAgICAgIGNvbnN0IHJhd0luZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChuZXh0QmF0Y2hJZCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSByYXdJbmRleCA8IDAgPyAwIDogcmF3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiBpbmRleCA/IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF0gOiBudWxsKTtcclxuICAgIH1cclxuICAgIGdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDAgPyBCQVRDSElEX1VOS05PV04gOiB0aGlzLm5leHRCYXRjaElkIC0gMSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCAwKTtcclxuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2gocmVmLnRhcmdldE9yQmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhdGNoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgcXVlcnkgcGF0aCBhcyBhIHByZWZpeCBmb3IgdGVzdGluZyBpZiBhIGRvY3VtZW50IG1hdGNoZXMgdGhlXHJcbiAgICAgICAgLy8gcXVlcnkuXHJcbiAgICAgICAgY29uc3QgcHJlZml4ID0gcXVlcnkucGF0aDtcclxuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgMTtcclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBkb2N1bWVudCByZWZlcmVuY2UgZm9yIGFjdHVhbGx5IHNjYW5uaW5nIHRoZSBpbmRleC4gVW5saWtlXHJcbiAgICAgICAgLy8gdGhlIHByZWZpeCB0aGUgZG9jdW1lbnQga2V5IGluIHRoaXMgcmVmZXJlbmNlIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZlxyXG4gICAgICAgIC8vIHNlZ21lbnRzLiBUaGUgZW1wdHkgc2VnbWVudCBjYW4gYmUgdXNlZCBhIHN1ZmZpeCBvZiB0aGUgcXVlcnkgcGF0aFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgcHJlY2VkZXMgYWxsIG90aGVyIHNlZ21lbnRzIGluIGFuIG9yZGVyZWQgdHJhdmVyc2FsLlxyXG4gICAgICAgIGxldCBzdGFydFBhdGggPSBwcmVmaXg7XHJcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHN0YXJ0UGF0aCkpIHtcclxuICAgICAgICAgICAgc3RhcnRQYXRoID0gc3RhcnRQYXRoLmNoaWxkKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKG5ldyBEb2N1bWVudEtleShzdGFydFBhdGgpLCAwKTtcclxuICAgICAgICAvLyBGaW5kIHVuaXF1ZSBiYXRjaElEcyByZWZlcmVuY2VkIGJ5IGFsbCBkb2N1bWVudHMgcG90ZW50aWFsbHkgbWF0Y2hpbmcgdGhlXHJcbiAgICAgICAgLy8gcXVlcnkuXHJcbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hXaGlsZShyZWYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByb3dLZXlQYXRoID0gcmVmLmtleS5wYXRoO1xyXG4gICAgICAgICAgICBpZiAoIXByZWZpeC5pc1ByZWZpeE9mKHJvd0tleVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSb3dzIHdpdGggZG9jdW1lbnQga2V5cyBtb3JlIHRoYW4gb25lIHNlZ21lbnQgbG9uZ2VyIHRoYW4gdGhlIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNhbid0IGJlIG1hdGNoZXMuIEZvciBleGFtcGxlLCBhIHF1ZXJ5IG9uICdyb29tcycgY2FuJ3QgbWF0Y2hcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogd2UnbGwgbmVlZCBhIGRpZmZlcmVudCBzY2FubmVyIHdoZW4gd2UgaW1wbGVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNlc3RvciBxdWVyaWVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHJvd0tleVBhdGgubGVuZ3RoID09PSBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChyZWYudGFyZ2V0T3JCYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcclxuICAgIH1cclxuICAgIGZpbmRNdXRhdGlvbkJhdGNoZXMoYmF0Y2hJRHMpIHtcclxuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmF0Y2hlcywgc29ydGVkIGJ5IGJhdGNoSUQgdG8gZW5zdXJlIHRoYXRcclxuICAgICAgICAvLyBtdWx0aXBsZSBtdXRhdGlvbnMgYWZmZWN0aW5nIHRoZSBzYW1lIGRvY3VtZW50IGtleSBhcmUgYXBwbGllZCBpbiBvcmRlci5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBiYXRjaElEcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJhdGNoIGZvciByZW1vdmFsLlxyXG4gICAgICAgIGNvbnN0IGJhdGNoSW5kZXggPSB0aGlzLmluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2guYmF0Y2hJZCwgJ3JlbW92ZWQnKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoSW5kZXggPT09IDApO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIGxldCByZWZlcmVuY2VzID0gdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goYmF0Y2gubXV0YXRpb25zLCAobXV0YXRpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoLmJhdGNoSWQpO1xyXG4gICAgICAgICAgICByZWZlcmVuY2VzID0gcmVmZXJlbmNlcy5kZWxldGUocmVmKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUubWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHJhbnNhY3Rpb24sIG11dGF0aW9uLmtleSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSByZWZlcmVuY2VzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcclxuICAgICAgICAvLyBOby1vcCBzaW5jZSB0aGUgbWVtb3J5IG11dGF0aW9uIHF1ZXVlIGRvZXMgbm90IG1haW50YWluIGEgc2VwYXJhdGUgY2FjaGUuXHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCAwKTtcclxuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoa2V5LmlzRXF1YWwoZmlyc3RSZWYgJiYgZmlyc3RSZWYua2V5KSk7XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkgO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlIGFuZCBhc3NlcnRzIHRoYXRcclxuICAgICAqIHRoZSByZXN1bHRpbmcgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBiYXRjaElkIC0gVGhlIGJhdGNoSWQgdG8gc2VhcmNoIGZvclxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgY2FsbGVyIGlzIGRvaW5nLCBwaHJhc2VkIGluIHBhc3NpdmVcclxuICAgICAqIGZvcm0gKGUuZy4gXCJhY2tub3dsZWRnZWRcIiBpbiBhIHJvdXRpbmUgdGhhdCBhY2tub3dsZWRnZXMgYmF0Y2hlcykuXHJcbiAgICAgKi9cclxuICAgIGluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2hJZCwgYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2ZCYXRjaElkKGJhdGNoSWQpO1xyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZS4gVGhpcyBvcGVyYXRpb25cclxuICAgICAqIGlzIE8oMSkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXB1dGVkIGluZGV4IG9mIHRoZSBiYXRjaCB3aXRoIHRoZSBnaXZlbiBiYXRjaElkLCBiYXNlZCBvblxyXG4gICAgICogdGhlIHN0YXRlIG9mIHRoZSBxdWV1ZS4gTm90ZSB0aGlzIGluZGV4IGNhbiBiZSBuZWdhdGl2ZSBpZiB0aGUgcmVxdWVzdGVkXHJcbiAgICAgKiBiYXRjaElkIGhhcyBhbHJlYWR5IGJlZW4gcmVtdm9lZCBmcm9tIHRoZSBxdWV1ZSBvciBwYXN0IHRoZSBlbmQgb2YgdGhlXHJcbiAgICAgKiBxdWV1ZSBpZiB0aGUgYmF0Y2hJZCBpcyBsYXJnZXIgdGhhbiB0aGUgbGFzdCBhZGRlZCBiYXRjaC5cclxuICAgICAqL1xyXG4gICAgaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCkge1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIEFzIGFuIGluZGV4IHRoaXMgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXhhbWluZSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHRvIGZpZ3VyZSBvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcclxuICAgICAgICAvLyBiYXRjaElkIGFuZCBpbmRleGVzIGluIHRoZSBhcnJheS4gTm90ZSB0aGF0IHNpbmNlIHRoZSBxdWV1ZSBpcyBvcmRlcmVkXHJcbiAgICAgICAgLy8gYnkgYmF0Y2hJZCwgaWYgdGhlIGZpcnN0IGJhdGNoIGhhcyBhIGxhcmdlciBiYXRjaElkIHRoZW4gdGhlIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIGJhdGNoSWQgZG9lc24ndCBleGlzdCBpbiB0aGUgcXVldWUuXHJcbiAgICAgICAgY29uc3QgZmlyc3RCYXRjaElkID0gdGhpcy5tdXRhdGlvblF1ZXVlWzBdLmJhdGNoSWQ7XHJcbiAgICAgICAgcmV0dXJuIGJhdGNoSWQgLSBmaXJzdEJhdGNoSWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdmVyc2lvbiBvZiBsb29rdXBNdXRhdGlvbkJhdGNoIHRoYXQgZG9lc24ndCByZXR1cm4gYSBwcm9taXNlLCB0aGlzIG1ha2VzXHJcbiAgICAgKiBvdGhlciBmdW5jdGlvbnMgdGhhdCB1c2VzIHRoaXMgY29kZSBlYXNpZXIgdG8gcmVhZCBhbmQgbW9yZSBlZmZpY2VudC5cclxuICAgICAqL1xyXG4gICAgZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5tdXRhdGlvblF1ZXVlW2luZGV4XTtcclxuICAgICAgICByZXR1cm4gYmF0Y2g7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZG9jdW1lbnRFbnRyeU1hcCgpIHtcclxuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgbWVtb3J5LW9ubHkgUmVtb3RlRG9jdW1lbnRDYWNoZSBmb3IgSW5kZXhlZERiLiBUbyBjb25zdHJ1Y3QsIGludm9rZVxyXG4gKiBgbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cclxuICovXHJcbmNsYXNzIE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNpemVyIC0gVXNlZCB0byBhc3Nlc3MgdGhlIHNpemUgb2YgYSBkb2N1bWVudC4gRm9yIGVhZ2VyIEdDLCB0aGlzIGlzXHJcbiAgICAgKiBleHBlY3RlZCB0byBqdXN0IHJldHVybiAwIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgZG9pbmcgdGhlIHdvcmsgb2ZcclxuICAgICAqIGNhbGN1bGF0aW5nIHRoZSBzaXplLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaXplcikge1xyXG4gICAgICAgIHRoaXMuc2l6ZXIgPSBzaXplcjtcclxuICAgICAgICAvKiogVW5kZXJseWluZyBjYWNoZSBvZiBkb2N1bWVudHMgYW5kIHRoZWlyIHJlYWQgdGltZXMuICovXHJcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jdW1lbnRFbnRyeU1hcCgpO1xyXG4gICAgICAgIC8qKiBTaXplIG9mIGFsbCBjYWNoZWQgZG9jdW1lbnRzLiAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBzZXRJbmRleE1hbmFnZXIoaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHN1cHBsaWVkIGVudHJ5IHRvIHRoZSBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgY2FjaGUgc2l6ZSBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxyXG4gICAgICovXHJcbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZG9jLmtleTtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoa2V5KTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBlbnRyeSA/IGVudHJ5LnNpemUgOiAwO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplcihkb2MpO1xyXG4gICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2MubXV0YWJsZUNvcHkoKSxcclxuICAgICAgICAgICAgc2l6ZTogY3VycmVudFNpemVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNpemUgKz0gY3VycmVudFNpemUgLSBwcmV2aW91c1NpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBrZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZW50cnkgZnJvbSB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGByZW1vdmVFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRyeShkb2N1bWVudEtleSkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5yZW1vdmUoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUgLT0gZW50cnkuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShlbnRyeVxyXG4gICAgICAgICAgICA/IGVudHJ5LmRvY3VtZW50Lm11dGFibGVDb3B5KClcclxuICAgICAgICAgICAgOiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50S2V5LCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXHJcbiAgICAgICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBtdXRhdGVkRG9jcykge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvdyBkb3duXHJcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50cyB3ZSBuZWVkIHRvIG1hdGNoIHRoZSBxdWVyeSBhZ2FpbnN0LlxyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gcXVlcnkucGF0aDtcclxuICAgICAgICBjb25zdCBwcmVmaXggPSBuZXcgRG9jdW1lbnRLZXkoY29sbGVjdGlvblBhdGguY2hpbGQoJycpKTtcclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuZG9jcy5nZXRJdGVyYXRvckZyb20ocHJlZml4KTtcclxuICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZTogeyBkb2N1bWVudCB9IH0gPSBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvblBhdGguaXNQcmVmaXhPZihrZXkucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXkucGF0aC5sZW5ndGggPiBjb2xsZWN0aW9uUGF0aC5sZW5ndGggKyAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIGVudHJpZXMgZnJvbSBzdWJjb2xsZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3SW5kZXhPZmZzZXRGcm9tRG9jdW1lbnQoZG9jdW1lbnQpLCBvZmZzZXQpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgdGhlIG9mZnNldC5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbXV0YXRlZERvY3MuaGFzKGRvY3VtZW50LmtleSkgJiYgIXF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgY2Fubm90IHBvc3NpYmx5IG1hdGNoIHRoZSBxdWVyeS5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50Lm11dGFibGVDb3B5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgbGltdGkpIHtcclxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgSW5kZXhCYWNrZmlsbGVyIGlmIHBlcnNpc3RlbmNlXHJcbiAgICAgICAgLy8gaXMgZW5hYmxlZC5cclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGYpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5kb2NzLCAoa2V5KSA9PiBmKGtleSkpO1xyXG4gICAgfVxyXG4gICAgbmV3Q2hhbmdlQnVmZmVyKG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBgdHJhY2tSZW1vdmFsc2AgaXMgaWdub3JlcyBzaW5jZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSBrZWVwc1xyXG4gICAgICAgIC8vIGEgc2VwYXJhdGUgY2hhbmdlbG9nIGFuZCBkb2VzIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlbW92YWxzLlxyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXRTaXplKHR4bikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnNpemUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1lbW9yeS1vbmx5IFJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xyXG4gKiBleHBlY3RlZCB0byBqdXN0IHJldHVybiAwIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgZG9pbmcgdGhlIHdvcmsgb2ZcclxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNpemVyKTtcclxufVxyXG4vKipcclxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIGV4dGVuZHMgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcclxuICAgIH1cclxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBkb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGUuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlUYXJnZXRDYWNoZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0IHRvIHRoZSBkYXRhIGFib3V0IHRoYXQgdGFyZ2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXRzID0gbmV3IE9iamVjdE1hcCh0ID0+IGNhbm9uaWZ5VGFyZ2V0KHQpLCB0YXJnZXRFcXVhbHMpO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCByZWNlaXZlZCBzbmFwc2hvdCB2ZXJzaW9uLiAqL1xyXG4gICAgICAgIHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICAvKiogVGhlIGhpZ2hlc3QgbnVtYmVyZWQgdGFyZ2V0IElEIGVuY291bnRlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gMDtcclxuICAgICAgICAvKiogVGhlIGhpZ2hlc3Qgc2VxdWVuY2UgbnVtYmVyIGVuY291bnRlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG9yZGVyZWQgYmlkaXJlY3Rpb25hbCBtYXBwaW5nIGJldHdlZW4gZG9jdW1lbnRzIGFuZCB0aGUgcmVtb3RlIHRhcmdldFxyXG4gICAgICAgICAqIElEcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclRhcmdldENhY2hlKCk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChfLCB0YXJnZXREYXRhKSA9PiBmKHRhcmdldERhdGEpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKTtcclxuICAgIH1cclxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcik7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0aGlzLnRhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0VGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgc2V0VGFyZ2V0c01ldGFkYXRhKHRyYW5zYWN0aW9uLCBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICBpZiAobGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5zZXQodGFyZ2V0RGF0YS50YXJnZXQsIHRhcmdldERhdGEpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgICAgICBpZiAodGFyZ2V0SWQgPiB0aGlzLmhpZ2hlc3RUYXJnZXRJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldElkR2VuZXJhdG9yID0gbmV3IFRhcmdldElkR2VuZXJhdG9yKHRhcmdldElkKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPiB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRDb3VudCArPSAxO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRzLmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXREYXRhLnRhcmdldElkKTtcclxuICAgICAgICB0aGlzLnRhcmdldENvdW50IC09IDE7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXRzKHRyYW5zYWN0aW9uLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHJlbW92YWxzID0gW107XHJcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKGtleSwgdGFyZ2V0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHMuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmFscy5wdXNoKHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpKTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocmVtb3ZhbHMpLm5leHQoKCkgPT4gY291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy50YXJnZXRDb3VudCk7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXRzLmdldCh0YXJnZXQpIHx8IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xyXG4gICAgfVxyXG4gICAgYWRkTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMuYWRkUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzKGtleXMsIHRhcmdldElkKTtcclxuICAgICAgICBjb25zdCByZWZlcmVuY2VEZWxlZ2F0ZSA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGU7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBpZiAocmVmZXJlbmNlRGVsZWdhdGUpIHtcclxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nS2V5cyA9IHRoaXMucmVmZXJlbmNlcy5yZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtYXRjaGluZ0tleXMpO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5yZWZlcmVuY2VzLmNvbnRhaW5zS2V5KGtleSkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckZCA9ICdNZW1vcnlQZXJzaXN0ZW5jZSc7XHJcbi8qKlxyXG4gKiBBIG1lbW9yeS1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIG9ubHkgaW4gUkFNIGFuZFxyXG4gKiBub3QgcGVyc2lzdGVkIGFjcm9zcyBzZXNzaW9ucy5cclxuICovXHJcbmNsYXNzIE1lbW9yeVBlcnNpc3RlbmNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBkZWxlZ2F0ZS4gVGhpc1xyXG4gICAgICogYWxsb3dzIGJvdGggdGhlIGRlbGVnYXRlIGFuZCB0aGlzIGluc3RhbmNlIHRvIGhhdmUgc3Ryb25nIHJlZmVyZW5jZXMgdG9cclxuICAgICAqIGVhY2ggb3RoZXIgd2l0aG91dCBoYXZpbmcgbnVsbGFibGUgZmllbGRzIHRoYXQgd291bGQgdGhlbiBuZWVkIHRvIGJlXHJcbiAgICAgKiBjaGVja2VkIG9yIGFzc2VydGVkIG9uIGV2ZXJ5IGFjY2Vzcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5LCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlblNlcXVlbmNlID0gbmV3IExpc3RlblNlcXVlbmNlKDApO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q2FjaGUgPSBuZXcgTWVtb3J5VGFyZ2V0Q2FjaGUodGhpcyk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZXIgPSAoZG9jKSA9PiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gbmV3IE1lbW9yeUluZGV4TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBMb2NhbFNlcmlhbGl6ZXIoc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBNZW1vcnlCdW5kbGVDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgLy8gTm8gZHVyYWJsZSBzdGF0ZSB0byBlbnN1cmUgaXMgY2xvc2VkIG9uIHNodXRkb3duLlxyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RhcnRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcclxuICAgIH1cclxuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgc2V0TmV0d29ya0VuYWJsZWQoKSB7XHJcbiAgICAgICAgLy8gTm8gb3AuXHJcbiAgICB9XHJcbiAgICBnZXRJbmRleE1hbmFnZXIodXNlcikge1xyXG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBpbmRpY2VzIGZvciBtZW1vcnkgcGVyc2lzdGVuY2UsIHNvIHdlIGNhblxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIG1lbW9yeSBpbmRleCBtYW5hZ2VyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcclxuICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMub3ZlcmxheXNbdXNlci50b0tleSgpXTtcclxuICAgICAgICBpZiAoIW92ZXJsYXkpIHtcclxuICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV0gPSBvdmVybGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3ZlcmxheTtcclxuICAgIH1cclxuICAgIGdldE11dGF0aW9uUXVldWUodXNlciwgaW5kZXhNYW5hZ2VyKSB7XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldO1xyXG4gICAgICAgIGlmICghcXVldWUpIHtcclxuICAgICAgICAgICAgcXVldWUgPSBuZXcgTWVtb3J5TXV0YXRpb25RdWV1ZShpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV0gPSBxdWV1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVEb2N1bWVudENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRCdW5kbGVDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcclxuICAgIH1cclxuICAgIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgdHJhbnNhY3Rpb25PcGVyYXRpb24pIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGQsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHR4biA9IG5ldyBNZW1vcnlUcmFuc2FjdGlvbih0aGlzLmxpc3RlblNlcXVlbmNlLm5leHQoKSk7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5vblRyYW5zYWN0aW9uU3RhcnRlZCgpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbih0eG4pXHJcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlXHJcbiAgICAgICAgICAgICAgICAub25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxyXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0eG4ucmFpc2VPbkNvbW1pdHRlZEV2ZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHJhbnNhY3Rpb24sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoT2JqZWN0LnZhbHVlcyh0aGlzLm11dGF0aW9uUXVldWVzKS5tYXAocXVldWUgPT4gKCkgPT4gcXVldWUuY29udGFpbnNLZXkodHJhbnNhY3Rpb24sIGtleSkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWVtb3J5IHBlcnNpc3RlbmNlIGlzIG5vdCBhY3R1YWxseSB0cmFuc2FjdGlvbmFsLCBidXQgZnV0dXJlIGltcGxlbWVudGF0aW9uc1xyXG4gKiBtYXkgaGF2ZSB0cmFuc2FjdGlvbi1zY29wZWQgc3RhdGUuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlUcmFuc2FjdGlvbiBleHRlbmRzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZU51bWJlciA9IGN1cnJlbnRTZXF1ZW5jZU51bWJlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBNZW1vcnlFYWdlckRlbGVnYXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIC8qKiBUcmFja3MgYWxsIGRvY3VtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gUXVlcnkgdmlld3MuICovXHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xyXG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiBkb2N1bWVudHMgdGhhdCBhcmUgcG90ZW50aWFsbHkgR0NlZCBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLiAqL1xyXG4gICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmYWN0b3J5KHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlFYWdlckRlbGVnYXRlKHBlcnNpc3RlbmNlKTtcclxuICAgIH1cclxuICAgIGdldCBvcnBoYW5lZERvY3VtZW50cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29ycGhhbmVkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcnBoYW5lZERvY3VtZW50cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLmFkZFJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmRlbGV0ZShrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBtYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0eG4sIGtleSkge1xyXG4gICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpIHtcclxuICAgICAgICBjb25zdCBvcnBoYW5lZCA9IHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICAgICAgb3JwaGFuZWQuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcclxuICAgICAgICByZXR1cm4gY2FjaGVcclxuICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgLm5leHQoa2V5cyA9PiB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjYWNoZS5yZW1vdmVUYXJnZXREYXRhKHR4biwgdGFyZ2V0RGF0YSkpO1xyXG4gICAgfVxyXG4gICAgb25UcmFuc2FjdGlvblN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBvblRyYW5zYWN0aW9uQ29tbWl0dGVkKHR4bikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBuZXdseSBvcnBoYW5lZCBkb2N1bWVudHMuXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5vcnBoYW5lZERvY3VtZW50cywgKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlZCh0eG4sIGtleSkubmV4dChpc1JlZmVyZW5jZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZmVyZW5jZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlQnVmZmVyLmFwcGx5KHR4bik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2VkKHR4biwga2V5KS5uZXh0KGlzUmVmZXJlbmNlZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuZGVsZXRlKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZG9jdW1lbnRTaXplKGRvYykge1xyXG4gICAgICAgIC8vIEZvciBlYWdlciBHQywgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZG9jdW1lbnQgc2l6ZSwgdGhlcmUgYXJlIG5vIHNpemUgdGhyZXNob2xkcy5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGlzUmVmZXJlbmNlZCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoW1xyXG4gICAgICAgICAgICAoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSksXHJcbiAgICAgICAgICAgICgpID0+IHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5jb250YWluc0tleSh0eG4sIGtleSksXHJcbiAgICAgICAgICAgICgpID0+IHRoaXMucGVyc2lzdGVuY2UubXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwga2V5KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE1lbW9yeUxydURlbGVnYXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycyA9IG5ldyBPYmplY3RNYXAoayA9PiBlbmNvZGVSZXNvdXJjZVBhdGgoay5wYXRoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XHJcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBscnVQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZhY3RvcnkocGVyc2lzdGVuY2UsIGxydVBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5THJ1RGVsZWdhdGUocGVyc2lzdGVuY2UsIGxydVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICAvLyBOby1vcHMsIHByZXNlbnQgc28gbWVtb3J5IHBlcnNpc3RlbmNlIGRvZXNuJ3QgaGF2ZSB0byBjYXJlIHdoaWNoIGRlbGVnYXRlXHJcbiAgICAvLyBpdCBoYXMuXHJcbiAgICBvblRyYW5zYWN0aW9uU3RhcnRlZCgpIHsgfVxyXG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XHJcbiAgICB9XHJcbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xyXG4gICAgICAgIGNvbnN0IGRvY0NvdW50UHJvbWlzZSA9IHRoaXMub3JwaGFuZWREb2N1bWVudENvdW50KHR4bik7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q291bnRQcm9taXNlID0gdGhpcy5wZXJzaXN0ZW5jZVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q291bnQodHhuKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0Q291bnRQcm9taXNlLm5leHQodGFyZ2V0Q291bnQgPT4gZG9jQ291bnRQcm9taXNlLm5leHQoZG9jQ291bnQgPT4gdGFyZ2V0Q291bnQgKyBkb2NDb3VudCkpO1xyXG4gICAgfVxyXG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xyXG4gICAgICAgIGxldCBvcnBoYW5lZENvdW50ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgXyA9PiB7XHJcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcclxuICAgICAgICB9KS5uZXh0KCgpID0+IG9ycGhhbmVkQ291bnQpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIGYpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycywgKGtleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgZXhhY3Qgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSB1cHBlciBib3VuZCBzbyB3ZSBrbm93IGl0IHdvbid0IGJlIHBpbm5lZCBieVxyXG4gICAgICAgICAgICAvLyBiZWluZyB0b28gcmVjZW50LlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bpbm5lZCh0eG4sIGtleSwgc2VxdWVuY2VOdW1iZXIpLm5leHQoaXNQaW5uZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxyXG4gICAgICAgICAgICAucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XHJcbiAgICAgICAgY29uc3QgcCA9IGNhY2hlLmZvckVhY2hEb2N1bWVudEtleSh0eG4sIGtleSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKS5uZXh0KGlzUGlubmVkID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNQaW5uZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwLm5leHQoKCkgPT4gY2hhbmdlQnVmZmVyLmFwcGx5KHR4bikpLm5leHQoKCkgPT4gY291bnQpO1xyXG4gICAgfVxyXG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0KHR4biwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLnVwZGF0ZVRhcmdldERhdGEodHhuLCB1cGRhdGVkKTtcclxuICAgIH1cclxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLnNldChrZXksIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMuc2V0KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGRvY3VtZW50U2l6ZShkb2N1bWVudCkge1xyXG4gICAgICAgIGxldCBkb2N1bWVudFNpemUgPSBkb2N1bWVudC5rZXkudG9TdHJpbmcoKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50U2l6ZSArPSBlc3RpbWF0ZUJ5dGVTaXplKGRvY3VtZW50LmRhdGEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRTaXplO1xyXG4gICAgfVxyXG4gICAgaXNQaW5uZWQodHhuLCBrZXksIHVwcGVyQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKFtcclxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpLFxyXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcnBoYW5lZEF0ID0gdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShvcnBoYW5lZEF0ICE9PSB1bmRlZmluZWQgJiYgb3JwaGFuZWRBdCA+IHVwcGVyQm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy4gKi9cclxuY2xhc3MgU2NoZW1hQ29udmVydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBpbiBwcm9kdWN0aW9uLCB0aGlzIG1ldGhvZCBpcyBvbmx5IGV2ZXIgdXNlZCB0byB1cGdyYWRlIHRoZSBzY2hlbWFcclxuICAgICAqIHRvIFNDSEVNQV9WRVJTSU9OLiBEaWZmZXJlbnQgdmFsdWVzIG9mIHRvVmVyc2lvbiBhcmUgb25seSB1c2VkIGZvciB0ZXN0aW5nXHJcbiAgICAgKiBhbmQgbG9jYWwgZmVhdHVyZSBkZXZlbG9wbWVudC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlT3JVcGdyYWRlKGRiLCB0eG4sIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24pIHtcclxuICAgICAgICBjb25zdCBzaW1wbGVEYlRyYW5zYWN0aW9uID0gbmV3IFNpbXBsZURiVHJhbnNhY3Rpb24oJ2NyZWF0ZU9yVXBncmFkZScsIHR4bik7XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMSAmJiB0b1ZlcnNpb24gPj0gMSkge1xyXG4gICAgICAgICAgICBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpO1xyXG4gICAgICAgICAgICBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKTtcclxuICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XHJcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNaWdyYXRpb24gMiB0byBwb3B1bGF0ZSB0aGUgdGFyZ2V0R2xvYmFsIG9iamVjdCBubyBsb25nZXIgbmVlZGVkIHNpbmNlXHJcbiAgICAgICAgLy8gbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cclxuICAgICAgICBsZXQgcCA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMyAmJiB0b1ZlcnNpb24gPj0gMykge1xyXG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgY2xpZW50cyBkb24ndCBuZWVkIHRvIGRyb3AgYW5kIHJlY3JlYXRlLS1vbmx5IGNsaWVudHMgdGhhdFxyXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWxseSBoYXZlIGNvcnJ1cHQgZGF0YS5cclxuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkcm9wUXVlcnlDYWNoZShkYik7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeShzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDQgJiYgdG9WZXJzaW9uID49IDQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlbWEgdmVyc2lvbiAzIHVzZXMgYXV0by1nZW5lcmF0ZWQga2V5cyB0byBnZW5lcmF0ZSBnbG9iYWxseSB1bmlxdWVcclxuICAgICAgICAgICAgICAgIC8vIG11dGF0aW9uIGJhdGNoIElEcyAodGhpcyB3YXMgcHJldmlvdXNseSBlbnN1cmVkIGludGVybmFsbHkgYnkgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQpLiBUbyBtaWdyYXRlIHRvIHRoZSBuZXcgc2NoZW1hLCB3ZSBoYXZlIHRvIHJlYWQgYWxsIG11dGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdyaXRlIHRoZW0gYmFjayBvdXQuIFdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBiYXRjaCBJRHMgdG8gZ3VhcmFudGVlXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIG9iamVjdCBzdG9yZXMuIEFueSBmdXJ0aGVyIG11dGF0aW9uIGJhdGNoIElEcyB3aWxsXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBhdXRvLWdlbmVyYXRlZC5cclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdXBncmFkZU11dGF0aW9uQmF0Y2hTY2hlbWFBbmRNaWdyYXRlRGF0YShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlQ2xpZW50TWV0YWRhdGFTdG9yZShkYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA1ICYmIHRvVmVyc2lvbiA+PSA1KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZW1vdmVBY2tub3dsZWRnZWRNdXRhdGlvbnMoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA2ICYmIHRvVmVyc2lvbiA+PSA2KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGREb2N1bWVudEdsb2JhbChzaW1wbGVEYlRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDcgJiYgdG9WZXJzaW9uID49IDcpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLmVuc3VyZVNlcXVlbmNlTnVtYmVycyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDggJiYgdG9WZXJzaW9uID49IDgpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLmNyZWF0ZUNvbGxlY3Rpb25QYXJlbnRJbmRleChkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA5ICYmIHRvVmVyc2lvbiA+PSA5KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gTXVsdGktVGFiIHVzZWQgdG8gbWFuYWdlIGl0cyBvd24gY2hhbmdlbG9nLCBidXQgdGhpcyBoYXMgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIERiUmVtb3RlRG9jdW1lbnQgb2JqZWN0IHN0b3JlIGl0c2VsZi4gU2luY2UgdGhlIHByZXZpb3VzIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgLy8gbG9nIG9ubHkgY29udGFpbmVkIHRyYW5zaWVudCBkYXRhLCB3ZSBjYW4gZHJvcCBpdHMgb2JqZWN0IHN0b3JlLlxyXG4gICAgICAgICAgICAgICAgZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFNjaGVtYSB2ZXJzaW9uIDkgdXNlZCB0byBjcmVhdGUgYSByZWFkIHRpbWUgaW5kZXggZm9yIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3RlRG9jdW1lbnRDYWNoZS4gVGhpcyBpcyBub3cgZG9uZSB3aXRoIHNjaGVtYSB2ZXJzaW9uIDEzLlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTAgJiYgdG9WZXJzaW9uID49IDEwKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlQ2Fub25pY2FsSWRzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTEgJiYgdG9WZXJzaW9uID49IDExKSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlQnVuZGxlc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZU5hbWVkUXVlcmllc1N0b3JlKGRiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEyICYmIHRvVmVyc2lvbiA+PSAxMikge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEzICYmIHRvVmVyc2lvbiA+PSAxMykge1xyXG4gICAgICAgICAgICBwID0gcFxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnJld3JpdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE0ICYmIHRvVmVyc2lvbiA+PSAxNCkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMucnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNSAmJiB0b1ZlcnNpb24gPj0gMTUpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiBjcmVhdGVGaWVsZEluZGV4KGRiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDE2ICYmIHRvVmVyc2lvbiA+PSAxNikge1xyXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgb2JqZWN0IHN0b3JlcyB0byByZW1vdmUgcG9zc2libHkgY29ycnVwdGVkIGluZGV4IGVudHJpZXNcclxuICAgICAgICAgICAgcCA9IHBcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhdGVTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4U3RhdGVTdG9yZSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleFN0YXRlU3RvcmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleEVudHJ5U3RvcmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgYWRkRG9jdW1lbnRHbG9iYWwodHhuKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVTaXplID0gMDtcclxuICAgICAgICByZXR1cm4gdHhuXHJcbiAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSlcclxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBieXRlU2l6ZSArPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7IGJ5dGVTaXplIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0eG5cclxuICAgICAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpXHJcbiAgICAgICAgICAgICAgICAucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyh0eG4pIHtcclxuICAgICAgICBjb25zdCBxdWV1ZXNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSk7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBxdWV1ZXNTdG9yZS5sb2FkQWxsKCkubmV4dChxdWV1ZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocXVldWVzLCAocXVldWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3F1ZXVlLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3F1ZXVlLnVzZXJJZCwgcXVldWUubGFzdEFja25vd2xlZGdlZEJhdGNoSWRdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoZGJCYXRjaGVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goZGJCYXRjaGVzLCAoZGJCYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSBxdWV1ZS51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBxdWV1ZS51c2VySWQsIGJhdGNoKS5uZXh0KCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCBldmVyeSBkb2N1bWVudCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2VudGluZWwgcm93XHJcbiAgICAgKiB3aXRoIGEgc2VxdWVuY2UgbnVtYmVyLiBNaXNzaW5nIHJvd3MgYXJlIGdpdmVuIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgc2VxdWVuY2UgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBlbnN1cmVTZXF1ZW5jZU51bWJlcnModHhuKSB7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50c1N0b3JlID0gdHhuLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcclxuICAgICAgICBjb25zdCBnbG9iYWxUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVTZW50aW5lbEtleSA9IChwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGVuY29kZVJlc291cmNlUGF0aChwYXRoKSxcclxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50c1N0b3JlXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NTZW50aW5lbEtleSA9IHNlbnRpbmVsS2V5KHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFRhcmdldFN0b3JlLmdldChkb2NTZW50aW5lbEtleSkubmV4dChtYXliZVNlbnRpbmVsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCB0eG4pIHtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxyXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlLCB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IERiQ29sbGVjdGlvblBhcmVudEtleVBhdGhcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGFyZW50c1N0b3JlID0gdHhuLnN0b3JlKERiQ29sbGVjdGlvblBhcmVudFN0b3JlKTtcclxuICAgICAgICAvLyBIZWxwZXIgdG8gYWRkIGFuIGluZGV4IGVudHJ5IGlmZiB3ZSBoYXZlbid0IGFscmVhZHkgd3JpdHRlbiBpdC5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcclxuICAgICAgICBjb25zdCBhZGRFbnRyeSA9IChjb2xsZWN0aW9uUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUuYWRkKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZS5wdXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGVuY29kZVJlc291cmNlUGF0aChwYXJlbnRQYXRoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIHJlbW90ZSBkb2N1bWVudHMuXHJcbiAgICAgICAgcmV0dXJuIHR4blxyXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsga2V5c09ubHk6IHRydWUgfSwgKHBhdGhTZWdtZW50cywgXykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChwYXRoU2VnbWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkRW50cnkocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgbXV0YXRpb25zLlxyXG4gICAgICAgICAgICByZXR1cm4gdHhuXHJcbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSh7IGtleXNPbmx5OiB0cnVlIH0sIChbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0sIF8pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXdyaXRlQ2Fub25pY2FsSWRzKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0U3RvcmUpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5pdGVyYXRlKChrZXksIG9yaWdpbmFsRGJUYXJnZXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KG9yaWdpbmFsRGJUYXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGJUYXJnZXQgPSB0b0RiVGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgb3JpZ2luYWxUYXJnZXREYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLnB1dCh1cGRhdGVkRGJUYXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV3cml0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIsIHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKTtcclxuICAgICAgICBjb25zdCB3cml0ZXMgPSBbXTtcclxuICAgICAgICByZXR1cm4gbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSgoXywgbGVnYWN5RG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBleHRyYWN0S2V5KGxlZ2FjeURvY3VtZW50KS5wYXRoLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgZGJSZW1vdGVEb2N1bWVudCA9IHtcclxuICAgICAgICAgICAgICAgIHByZWZpeFBhdGg6IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cDogcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgcmVhZFRpbWU6IGxlZ2FjeURvY3VtZW50LnJlYWRUaW1lIHx8IFswLCAwXSxcclxuICAgICAgICAgICAgICAgIHVua25vd25Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQudW5rbm93bkRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgbm9Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQubm9Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50OiBsZWdhY3lEb2N1bWVudC5kb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGhhc0NvbW1pdHRlZE11dGF0aW9uczogISFsZWdhY3lEb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd3JpdGVzLnB1c2gocmVtb3RlRG9jdW1lbnRTdG9yZS5wdXQoZGJSZW1vdGVEb2N1bWVudCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHdyaXRlcykpO1xyXG4gICAgfVxyXG4gICAgcnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IHRyYW5zYWN0aW9uLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCByZW1vdGVEb2N1bWVudENhY2hlID0gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeVBlcnNpc3RlbmNlID0gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZS5sb2FkQWxsKCkubmV4dChkYkJhdGNoZXMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyVG9Eb2N1bWVudFNldCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZGJCYXRjaGVzLmZvckVhY2goZGJCYXRjaCA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnRTZXQgPSAoX2EgPSB1c2VyVG9Eb2N1bWVudFNldC5nZXQoZGJCYXRjaC51c2VySWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5rZXlzKCkuZm9yRWFjaChrZXkgPT4gKGRvY3VtZW50U2V0ID0gZG9jdW1lbnRTZXQuYWRkKGtleSkpKTtcclxuICAgICAgICAgICAgICAgIHVzZXJUb0RvY3VtZW50U2V0LnNldChkYkJhdGNoLnVzZXJJZCwgZG9jdW1lbnRTZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHVzZXJUb0RvY3VtZW50U2V0LCAoYWxsRG9jdW1lbnRLZXlzRm9yVXNlciwgdXNlcklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIodXNlcklkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheUNhY2hlID0gSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUuZm9yVXNlcih0aGlzLnNlcmlhbGl6ZXIsIHVzZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGluZGV4IG1hbmFnZXIgYW5kIHRoZSByZWZlcmVuY2UgZGVsZWdhdGUgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBpcnJlbGV2YW50IGZvciB0aGUgcHVycG9zZSBvZiByZWNhbGN1bGF0aW5nIGFuZCBzYXZpbmdcclxuICAgICAgICAgICAgICAgIC8vIG92ZXJsYXlzLiBXZSBjYW4gdGhlcmVmb3JlIHNpbXBseSB1c2UgdGhlIG1lbW9yeVxyXG4gICAgICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBtZW1vcnlQZXJzaXN0ZW5jZS5nZXRJbmRleE1hbmFnZXIodXNlcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvblF1ZXVlID0gSW5kZXhlZERiTXV0YXRpb25RdWV1ZS5mb3JVc2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCBtZW1vcnlQZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbERvY3VtZW50c1ZpZXcgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHJlbW90ZURvY3VtZW50Q2FjaGUsIG11dGF0aW9uUXVldWUsIGRvY3VtZW50T3ZlcmxheUNhY2hlLCBpbmRleE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsRG9jdW1lbnRzVmlld1xyXG4gICAgICAgICAgICAgICAgICAgIC5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyhuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpLCBhbGxEb2N1bWVudEtleXNGb3JVc2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlbnRpbmVsS2V5KHBhdGgpIHtcclxuICAgIHJldHVybiBbMCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpIHtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUHJpbWFyeUNsaWVudFN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25RdWV1ZUtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbXV0YXRpb25CYXRjaGVzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXHJcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBtdXRhdGlvbkJhdGNoZXNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcclxufVxyXG4vKipcclxuICogVXBncmFkZSBmdW5jdGlvbiB0byBtaWdyYXRlIHRoZSAnbXV0YXRpb25zJyBzdG9yZSBmcm9tIFYxIHRvIFYzLiBMb2Fkc1xyXG4gKiBhbmQgcmV3cml0ZXMgYWxsIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGdyYWRlTXV0YXRpb25CYXRjaFNjaGVtYUFuZE1pZ3JhdGVEYXRhKGRiLCB0eG4pIHtcclxuICAgIGNvbnN0IHYxTXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUpO1xyXG4gICAgcmV0dXJuIHYxTXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdNdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlLCB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXHJcbiAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBtdXRhdGlvbnNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCB2M011dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcclxuICAgICAgICBjb25zdCB3cml0ZUFsbCA9IGV4aXN0aW5nTXV0YXRpb25zLm1hcChtdXRhdGlvbiA9PiB2M011dGF0aW9uc1N0b3JlLnB1dChtdXRhdGlvbikpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZUFsbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lSZW1vdGVEb2N1bWVudENhY2hlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikge1xyXG4gICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsIERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCk7XHJcbiAgICByZW1vdGVEb2N1bWVudFN0b3JlLmNyZWF0ZUluZGV4KERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCwgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNhY2hlKGRiKSB7XHJcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudHNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIHRhcmdldERvY3VtZW50c1N0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCwgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgY29uc3QgdGFyZ2V0U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXRLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdW5pcXVlIG9ubHkgYmVjYXVzZSB0aGUgVGFyZ2V0SWQgaXMgdGhlIHN1ZmZpeC5cclxuICAgIHRhcmdldFN0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lLCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRHbG9iYWxTdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gZHJvcFF1ZXJ5Q2FjaGUoZGIpIHtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XHJcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlKTtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGRyb3BSZW1vdGVEb2N1bWVudENoYW5nZXNTdG9yZShkYikge1xyXG4gICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpKSB7XHJcbiAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSB0YXJnZXQgZ2xvYmFsIHNpbmdsZXRvbiByb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eG4gLSBUaGUgdmVyc2lvbiB1cGdyYWRlIHRyYW5zYWN0aW9uIGZvciBpbmRleGVkZGJcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeSh0eG4pIHtcclxuICAgIGNvbnN0IGdsb2JhbFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XHJcbiAgICAgICAgaGlnaGVzdFRhcmdldElkOiAwLFxyXG4gICAgICAgIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjogMCxcclxuICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uOiBTbmFwc2hvdFZlcnNpb24ubWluKCkudG9UaW1lc3RhbXAoKSxcclxuICAgICAgICB0YXJnZXRDb3VudDogMFxyXG4gICAgfTtcclxuICAgIHJldHVybiBnbG9iYWxTdG9yZS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRhZGF0YVN0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNsaWVudE1ldGFkYXRhU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkNsaWVudE1ldGFkYXRhS2V5UGF0aFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlc1N0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkJ1bmRsZVN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJCdW5kbGVLZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVOYW1lZFF1ZXJpZXNTdG9yZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJOYW1lZFF1ZXJ5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYk5hbWVkUXVlcnlLZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGaWVsZEluZGV4KGRiKSB7XHJcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGgsXHJcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBpbmRleENvbmZpZ3VyYXRpb25TdG9yZS5jcmVhdGVJbmRleChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleFN0YXRlU3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4U3RhdGVLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIGluZGV4U3RhdGVTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4LCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleEVudHJ5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4RW50cnlLZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIGluZGV4RW50cnlTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4LCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50T3ZlcmxheVN0b3JlKGRiKSB7XHJcbiAgICBjb25zdCBkb2N1bWVudE92ZXJsYXlTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRPdmVybGF5U3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgIGRvY3VtZW50T3ZlcmxheVN0b3JlLmNyZWF0ZUluZGV4KERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0S2V5KHJlbW90ZURvYykge1xyXG4gICAgaWYgKHJlbW90ZURvYy5kb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmVtb3RlRG9jLmRvY3VtZW50Lm5hbWUpLnBvcEZpcnN0KDUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2Mubm9Eb2N1bWVudC5wYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQucGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYyA9ICdJbmRleGVkRGJQZXJzaXN0ZW5jZSc7XHJcbi8qKlxyXG4gKiBPbGRlc3QgYWNjZXB0YWJsZSBhZ2UgaW4gbWlsbGlzZWNvbmRzIGZvciBjbGllbnQgbWV0YWRhdGEgYmVmb3JlIHRoZSBjbGllbnRcclxuICogaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgaXRzIGFzc29jaWF0ZWQgZGF0YSBpcyBnYXJiYWdlIGNvbGxlY3RlZC5cclxuICovXHJcbmNvbnN0IE1BWF9DTElFTlRfQUdFX01TID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcclxuLyoqXHJcbiAqIE9sZGVzdCBhY2NlcHRhYmxlIG1ldGFkYXRhIGFnZSBmb3IgY2xpZW50cyB0aGF0IG1heSBwYXJ0aWNpcGF0ZSBpbiB0aGVcclxuICogcHJpbWFyeSBsZWFzZSBlbGVjdGlvbi4gQ2xpZW50cyB0aGF0IGhhdmUgbm90IHVwZGF0ZWQgdGhlaXIgY2xpZW50IG1ldGFkYXRhXHJcbiAqIHdpdGhpbiA1IHNlY29uZHMgYXJlIG5vdCBlbGlnaWJsZSB0byByZWNlaXZlIGEgcHJpbWFyeSBsZWFzZS5cclxuICovXHJcbmNvbnN0IE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUyA9IDUwMDA7XHJcbi8qKlxyXG4gKiBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggY2xpZW50cyB3aWxsIHVwZGF0ZSB0aGVpciBtZXRhZGF0YSwgaW5jbHVkaW5nXHJcbiAqIHJlZnJlc2hpbmcgdGhlaXIgcHJpbWFyeSBsZWFzZSBpZiBoZWxkIG9yIHBvdGVudGlhbGx5IHRyeWluZyB0byBhY3F1aXJlIGl0IGlmXHJcbiAqIG5vdCBoZWxkLlxyXG4gKlxyXG4gKiBQcmltYXJ5IGNsaWVudHMgbWF5IG9wcG9ydHVuaXN0aWNhbGx5IHJlZnJlc2ggdGhlaXIgbWV0YWRhdGEgZWFybGllclxyXG4gKiBpZiB0aGV5J3JlIGFscmVhZHkgcGVyZm9ybWluZyBhbiBJbmRleGVkREIgb3BlcmF0aW9uLlxyXG4gKi9cclxuY29uc3QgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMgPSA0MDAwO1xyXG4vKiogVXNlci1mYWNpbmcgZXJyb3Igd2hlbiB0aGUgcHJpbWFyeSBsZWFzZSBpcyByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZS4gKi9cclxuY29uc3QgUFJJTUFSWV9MRUFTRV9FWENMVVNJVkVfRVJST1JfTVNHID0gJ0ZhaWxlZCB0byBvYnRhaW4gZXhjbHVzaXZlIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIuIFRvIGFsbG93ICcgK1xyXG4gICAgJ3NoYXJlZCBhY2Nlc3MsIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24gaGFzIHRvIGJlIGVuYWJsZWQgaW4gYWxsIHRhYnMuICcgK1xyXG4gICAgJ0lmIHlvdSBhcmUgdXNpbmcgYGV4cGVyaW1lbnRhbEZvcmNlT3duaW5nVGFiOnRydWVgLCBtYWtlIHN1cmUgdGhhdCBvbmx5ICcgK1xyXG4gICAgJ29uZSB0YWIgaGFzIHBlcnNpc3RlbmNlIGVuYWJsZWQgYXQgYW55IGdpdmVuIHRpbWUuJztcclxuY29uc3QgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHID0gJ1RoaXMgcGxhdGZvcm0gaXMgZWl0aGVyIG1pc3NpbmcgSW5kZXhlZERCIG9yIGlzIGtub3duIHRvIGhhdmUgJyArXHJcbiAgICAnYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gT2ZmbGluZSBwZXJzaXN0ZW5jZSBoYXMgYmVlbiBkaXNhYmxlZC4nO1xyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHpvbWJpZWQgY2xpZW50IGlzOlxyXG4vLyAgICAgZmlyZXN0b3JlX3pvbWJpZV88cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxyXG5jb25zdCBaT01CSUVEX0NMSUVOVFNfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfem9tYmllJztcclxuLyoqXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtYWluIChhbmQgY3VycmVudGx5IG9ubHkpIEluZGV4ZWREQiBkYXRhYmFzZS4gVGhpcyBuYW1lIGlzXHJcbiAqIGFwcGVuZGVkIHRvIHRoZSBwcmVmaXggcHJvdmlkZWQgdG8gdGhlIEluZGV4ZWREYlBlcnNpc3RlbmNlIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuY29uc3QgTUFJTl9EQVRBQkFTRSA9ICdtYWluJztcclxuLyoqXHJcbiAqIEFuIEluZGV4ZWREQi1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIHBlcnNpc3RlbnRseVxyXG4gKiBhY3Jvc3Mgc2Vzc2lvbnMuXHJcbiAqXHJcbiAqIE9uIFdlYiBvbmx5LCB0aGUgRmlyZXN0b3JlIFNES3Mgc3VwcG9ydCBzaGFyZWQgYWNjZXNzIHRvIGl0cyBwZXJzaXN0ZW5jZVxyXG4gKiBsYXllci4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgYnJvd3NlciB0YWJzIHRvIHJlYWQgYW5kIHdyaXRlIHRvIEluZGV4ZWREYiBhbmRcclxuICogdG8gc3luY2hyb25pemUgc3RhdGUgZXZlbiB3aXRob3V0IG5ldHdvcmsgY29ubmVjdGl2aXR5LiBTaGFyZWQgYWNjZXNzIGlzXHJcbiAqIGN1cnJlbnRseSBvcHRpb25hbCBhbmQgbm90IGVuYWJsZWQgdW5sZXNzIGFsbCBjbGllbnRzIGludm9rZVxyXG4gKiBgZW5hYmxlUGVyc2lzdGVuY2UoKWAgd2l0aCBge3N5bmNocm9uaXplVGFiczp0cnVlfWAuXHJcbiAqXHJcbiAqIEluIG11bHRpLXRhYiBtb2RlLCBpZiBtdWx0aXBsZSBjbGllbnRzIGFyZSBhY3RpdmUgYXQgdGhlIHNhbWUgdGltZSwgdGhlIFNES1xyXG4gKiB3aWxsIGRlc2lnbmF0ZSBvbmUgY2xpZW50IGFzIHRoZSDigJxwcmltYXJ5IGNsaWVudOKAnS4gQW4gZWZmb3J0IGlzIG1hZGUgdG8gcGlja1xyXG4gKiBhIHZpc2libGUsIG5ldHdvcmstY29ubmVjdGVkIGFuZCBhY3RpdmUgY2xpZW50LCBhbmQgdGhpcyBjbGllbnQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIGxldHRpbmcgb3RoZXIgY2xpZW50cyBrbm93IGFib3V0IGl0cyBwcmVzZW5jZS4gVGhlIHByaW1hcnlcclxuICogY2xpZW50IHdyaXRlcyBhIHVuaXF1ZSBjbGllbnQtZ2VuZXJhdGVkIGlkZW50aWZpZXIgKHRoZSBjbGllbnQgSUQpIHRvXHJcbiAqIEluZGV4ZWREYuKAmXMg4oCcb3duZXLigJ0gc3RvcmUgZXZlcnkgNCBzZWNvbmRzLiBJZiB0aGUgcHJpbWFyeSBjbGllbnQgZmFpbHMgdG9cclxuICogdXBkYXRlIHRoaXMgZW50cnksIGFub3RoZXIgY2xpZW50IGNhbiBhY3F1aXJlIHRoZSBsZWFzZSBhbmQgdGFrZSBvdmVyIGFzXHJcbiAqIHByaW1hcnkuXHJcbiAqXHJcbiAqIFNvbWUgcGVyc2lzdGVuY2Ugb3BlcmF0aW9ucyBpbiB0aGUgU0RLIGFyZSBkZXNpZ25hdGVkIGFzIHByaW1hcnktY2xpZW50IG9ubHlcclxuICogb3BlcmF0aW9ucy4gVGhpcyBpbmNsdWRlcyB0aGUgYWNrbm93bGVkZ21lbnQgb2YgbXV0YXRpb25zIGFuZCBhbGwgdXBkYXRlcyBvZlxyXG4gKiByZW1vdGUgZG9jdW1lbnRzLiBUaGUgZWZmZWN0cyBvZiB0aGVzZSBvcGVyYXRpb25zIGFyZSB3cml0dGVuIHRvIHBlcnNpc3RlbmNlXHJcbiAqIGFuZCB0aGVuIGJyb2FkY2FzdCB0byBvdGhlciB0YWJzIHZpYSBMb2NhbFN0b3JhZ2UgKHNlZVxyXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCksIHdoaWNoIHRoZW4gcmVmcmVzaCB0aGVpciBzdGF0ZSBmcm9tXHJcbiAqIHBlcnNpc3RlbmNlLlxyXG4gKlxyXG4gKiBTaW1pbGFybHksIHRoZSBwcmltYXJ5IGNsaWVudCBsaXN0ZW5zIHRvIG5vdGlmaWNhdGlvbnMgc2VudCBieSBzZWNvbmRhcnlcclxuICogY2xpZW50cyB0byBkaXNjb3ZlciBwZXJzaXN0ZW5jZSBjaGFuZ2VzIHdyaXR0ZW4gYnkgc2Vjb25kYXJ5IGNsaWVudHMsIHN1Y2ggYXNcclxuICogdGhlIGFkZGl0aW9uIG9mIG5ldyBtdXRhdGlvbnMgYW5kIHF1ZXJ5IHRhcmdldHMuXHJcbiAqXHJcbiAqIElmIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZCBhbmQgYW5vdGhlciB0YWIgYWxyZWFkeSBvYnRhaW5lZCB0aGUgcHJpbWFyeVxyXG4gKiBsZWFzZSwgSW5kZXhlZERiUGVyc2lzdGVuY2UgZW50ZXJzIGEgZmFpbGVkIHN0YXRlIGFuZCBhbGwgc3Vic2VxdWVudFxyXG4gKiBvcGVyYXRpb25zIHdpbGwgYXV0b21hdGljYWxseSBmYWlsLlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHksIHRoZXJlIGlzIGFuIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gYSB0YWIgaXMgY2xvc2VkLCB0aGVcclxuICogcHJpbWFyeSBsZWFzZSBpcyByZWxlYXNlZCBpbW1lZGlhdGVseSAodGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBtYWtlXHJcbiAqIHN1cmUgdGhhdCBhIHJlZnJlc2hlZCB0YWIgaXMgYWJsZSB0byBpbW1lZGlhdGVseSByZS1hY3F1aXJlIHRoZSBwcmltYXJ5XHJcbiAqIGxlYXNlKS4gVW5mb3J0dW5hdGVseSwgSW5kZXhlZERCIGNhbm5vdCBiZSByZWxpYWJseSB1c2VkIGluIHdpbmRvdy51bmxvYWRcclxuICogc2luY2UgaXQgaXMgYW4gYXN5bmNocm9ub3VzIEFQSS4gU28gaW4gYWRkaXRpb24gdG8gYXR0ZW1wdGluZyB0byBnaXZlIHVwIHRoZVxyXG4gKiBsZWFzZSwgdGhlIGxlYXNlaG9sZGVyIHdyaXRlcyBpdHMgY2xpZW50IElEIHRvIGEgXCJ6b21iaWVkQ2xpZW50XCIgZW50cnkgaW5cclxuICogTG9jYWxTdG9yYWdlIHdoaWNoIGFjdHMgYXMgYW4gaW5kaWNhdG9yIHRoYXQgYW5vdGhlciB0YWIgc2hvdWxkIGdvIGFoZWFkIGFuZFxyXG4gKiB0YWtlIHRoZSBwcmltYXJ5IGxlYXNlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbGVhc2UgdGltZXN0YW1wLlxyXG4gKlxyXG4gKiBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIGBzeW5jaHJvbml6ZVRhYnNgIHNlY3Rpb24gd2hlbiBtdWx0aS10YWIgaXMgbm9cclxuICogbG9uZ2VyIG9wdGlvbmFsLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiUGVyc2lzdGVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc3luY2hyb25pemUgdGhlIGluLW1lbW9yeSBzdGF0ZSBvZiBtdWx0aXBsZSB0YWJzIGFuZCBzaGFyZVxyXG4gICAgICogYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxyXG4gICAgICovXHJcbiAgICBhbGxvd1RhYlN5bmNocm9uaXphdGlvbiwgcGVyc2lzdGVuY2VLZXksIGNsaWVudElkLCBscnVQYXJhbXMsIHF1ZXVlLCB3aW5kb3csIGRvY3VtZW50LCBzZXJpYWxpemVyLCBzZXF1ZW5jZU51bWJlclN5bmNlciwgXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCBmb3JjZWZ1bGx5IG9idGFpbnMgZGF0YWJhc2UgYWNjZXNzLiBFeGlzdGluZyB0YWJzIHdpbGxcclxuICAgICAqIG5vIGxvbmdlciBiZSBhYmxlIHRvIGFjY2VzcyBJbmRleGVkREIuXHJcbiAgICAgKi9cclxuICAgIGZvcmNlT3duaW5nVGFiLCBzY2hlbWFWZXJzaW9uID0gU0NIRU1BX1ZFUlNJT04pIHtcclxuICAgICAgICB0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uID0gYWxsb3dUYWJTeW5jaHJvbml6YXRpb247XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIgPSBzZXF1ZW5jZU51bWJlclN5bmNlcjtcclxuICAgICAgICB0aGlzLmZvcmNlT3duaW5nVGFiID0gZm9yY2VPd25pbmdUYWI7XHJcbiAgICAgICAgdGhpcy5zY2hlbWFWZXJzaW9uID0gc2NoZW1hVmVyc2lvbjtcclxuICAgICAgICB0aGlzLmxpc3RlblNlcXVlbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAvKiogT3VyIHdpbmRvdy51bmxvYWQgaGFuZGxlciwgaWYgcmVnaXN0ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5Gb3JlZ3JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIE91ciAndmlzaWJpbGl0eWNoYW5nZScgbGlzdGVuZXIgaWYgcmVnaXN0ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKiBUaGUgY2xpZW50IG1ldGFkYXRhIHJlZnJlc2ggdGFzay4gKi9cclxuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGxhc3QgdGltZSB3ZSBnYXJiYWdlIGNvbGxlY3RlZCB0aGUgY2xpZW50IG1ldGFkYXRhIG9iamVjdCBzdG9yZS4gKi9cclxuICAgICAgICB0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgLyoqIEEgbGlzdGVuZXIgdG8gbm90aWZ5IG9uIHByaW1hcnkgc3RhdGUgY2hhbmdlcy4gKi9cclxuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gXyA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICBpZiAoIUluZGV4ZWREYlBlcnNpc3RlbmNlLmlzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IG5ldyBJbmRleGVkRGJMcnVEZWxlZ2F0ZUltcGwodGhpcywgbHJ1UGFyYW1zKTtcclxuICAgICAgICB0aGlzLmRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgTG9jYWxTZXJpYWxpemVyKHNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGIgPSBuZXcgU2ltcGxlRGIodGhpcy5kYk5hbWUsIHRoaXMuc2NoZW1hVmVyc2lvbiwgbmV3IFNjaGVtYUNvbnZlcnRlcih0aGlzLnNlcmlhbGl6ZXIpKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IEluZGV4ZWREYlRhcmdldENhY2hlKHRoaXMucmVmZXJlbmNlRGVsZWdhdGUsIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlID0gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgSW5kZXhlZERiQnVuZGxlQ2FjaGUoKTtcclxuICAgICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZSA9IHRoaXMud2luZG93LmxvY2FsU3RvcmFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZU93bmluZ1RhYiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYywgJ0xvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZS4gQXMgYSByZXN1bHQsIHBlcnNpc3RlbmNlIG1heSBub3Qgd29yayAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmVsaWFibHkuIEluIHBhcnRpY3VsYXIgZW5hYmxlUGVyc2lzdGVuY2UoKSBjb3VsZCBmYWlsIGltbWVkaWF0ZWx5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciByZWZyZXNoaW5nIHRoZSBwYWdlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0IHRvIHN0YXJ0IEluZGV4ZWREYiBwZXJzaXN0ZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHBlcnNpc3RlbmNlIHdhcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGZhaWwgc29tZXRpbWVzIChpbiB0aGUgY2FzZSBvZiBhbm90aGVyIHRhYlxyXG4gICAgICAgIC8vIGFscmVhZHkgaGF2aW5nIHRoZSBwZXJzaXN0ZW5jZSBsb2NrKSwgc28gaXQncyB0aGUgZmlyc3QgdGhpbmcgd2Ugc2hvdWxkXHJcbiAgICAgICAgLy8gZG8uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmltYXJ5ICYmICF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGYWlsIGBzdGFydCgpYCBpZiBgc3luY2hyb25pemVUYWJzYCBpcyBkaXNhYmxlZCBhbmQgd2UgY2Fubm90XHJcbiAgICAgICAgICAgICAgICAvLyBvYnRhaW4gdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaW5kb3dVbmxvYWRIb29rKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0SGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyJywgJ3JlYWRvbmx5JywgdHhuID0+IHRoaXMudGFyZ2V0Q2FjaGUuZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHR4bikpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBuZXcgTGlzdGVuU2VxdWVuY2UoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCB0aGlzLnNlcXVlbmNlTnVtYmVyU3luY2VyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNpbXBsZURiICYmIHRoaXMuc2ltcGxlRGIuY2xvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcHJpbWFyeSBzdGF0ZSBvZiB0aGVcclxuICAgICAqIGluc3RhbmNlIGNoYW5nZXMuIFVwb24gcmVnaXN0ZXJpbmcsIHRoaXMgbGlzdGVuZXIgaXMgaW52b2tlZCBpbW1lZGlhdGVseVxyXG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmltYXJ5IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldFByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lciA9IGFzeW5jIChwcmltYXJ5U3RhdGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW1hcnlTdGF0ZUxpc3RlbmVyKHByaW1hcnlTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcih0aGlzLmlzUHJpbWFyeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgcmVjZWl2ZXMgYVxyXG4gICAgICogdmVyc2lvbiBjaGFuZ2UgZXZlbnQgaW5kaWNhdGluZyB0aGF0IGl0IGhhcyBkZWxldGVkLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVEYi5zZXRWZXJzaW9uQ2hhbmdlTGlzdGVuZXIoYXN5bmMgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBkZWxldGUgSW5kZXhlZERCLlxyXG4gICAgICAgICAgICBpZiAoZXZlbnQubmV3VmVyc2lvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUgaW4gdGhlIGNsaWVudCdzIG1ldGFkYXRhLCBwb3RlbnRpYWxseVxyXG4gICAgICogYWZmZWN0aW5nIHRoZSBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICpcclxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXHJcbiAgICAgKi9cclxuICAgIHNldE5ldHdvcmtFbmFibGVkKG5ldHdvcmtFbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgIT09IG5ldHdvcmtFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSBuZXR3b3JrRW5hYmxlZDtcclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBwcmltYXJ5IGxlYXNlIHJlZnJlc2ggZm9yIGltbWVkaWF0ZSBleGVjdXRpb24uIFRoZSBldmVudHVhbFxyXG4gICAgICAgICAgICAvLyBsZWFzZSB1cGRhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHZpYSBgcHJpbWFyeVN0YXRlTGlzdGVuZXJgLlxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgY2xpZW50IG1ldGFkYXRhIGluIEluZGV4ZWREYiBhbmQgYXR0ZW1wdHMgdG8gZWl0aGVyIG9idGFpbiBvclxyXG4gICAgICogZXh0ZW5kIHRoZSBwcmltYXJ5IGxlYXNlIGZvciB0aGUgbG9jYWwgY2xpZW50LiBBc3luY2hyb25vdXNseSBub3RpZmllcyB0aGVcclxuICAgICAqIHByaW1hcnkgc3RhdGUgbGlzdGVuZXIgaWYgdGhlIGNsaWVudCBlaXRoZXIgbmV3bHkgb2J0YWluZWQgb3IgcmVsZWFzZWQgaXRzXHJcbiAgICAgKiBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ3VwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeScsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFTdG9yZVxyXG4gICAgICAgICAgICAgICAgLnB1dCh7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtFbmFibGVkOiB0aGlzLm5ldHdvcmtFbmFibGVkLFxyXG4gICAgICAgICAgICAgICAgaW5Gb3JlZ3JvdW5kOiB0aGlzLmluRm9yZWdyb3VuZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5UHJpbWFyeUxlYXNlKHR4bikubmV4dChzdWNjZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5jYW5BY3RBc1ByaW1hcnkodHhuKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KGNhbkFjdEFzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiYgIWNhbkFjdEFzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKS5uZXh0KCgpID0+IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkFjdEFzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pLm5leHQoKCkgPT4gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyogY2FuQWN0QXNQcmltYXJ5PSAqLyBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdGYWlsZWQgdG8gZXh0ZW5kIG93bmVyIGxlYXNlOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIC8vIFByb2NlZWQgd2l0aCB0aGUgZXhpc3Rpbmcgc3RhdGUuIEFueSBzdWJzZXF1ZW50IGFjY2VzcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlZERCIHdpbGwgdmVyaWZ5IHRoZSBsZWFzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUHJpbWFyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIG93bmVyIGxlYXNlIGFmdGVyIGVycm9yIGR1cmluZyBsZWFzZSByZWZyZXNoJywgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAvKiBpc1ByaW1hcnk9ICovIGZhbHNlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGlzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAhPT0gaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihpc1ByaW1hcnkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGlzUHJpbWFyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZlcmlmeVByaW1hcnlMZWFzZSh0eG4pIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5pc0xvY2FsQ2xpZW50KHByaW1hcnlDbGllbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNsaWVudE1ldGFkYXRhKHR4bikge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhU3RvcmUgPSBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUuZGVsZXRlKHRoaXMuY2xpZW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRocmVzaG9sZCBoYXMgcGFzc2VkLCBwcnVuZXMgdGhlXHJcbiAgICAgKiBSZW1vdGVEb2N1bWVudENoYW5nZXMgYW5kIHRoZSBDbGllbnRNZXRhZGF0YSBzdG9yZSBiYXNlZCBvbiB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAqIHRpbWUgb2YgYWxsIGNsaWVudHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG1heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5pc1dpdGhpbkFnZSh0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUsIE1BWF9DTElFTlRfQUdFX01TKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmFjdGl2ZUNsaWVudHMgPSBhd2FpdCB0aGlzLnJ1blRyYW5zYWN0aW9uKCdtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZScsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhU3RvcmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfQ0xJRU5UX0FHRV9NUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG1ldGFkYXRhIGZvciBjbGllbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBjb25zaWRlcmVkIGFjdGl2ZS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5hY3RpdmUsIChpbmFjdGl2ZUNsaWVudCkgPT4gbWV0YWRhdGFTdG9yZS5kZWxldGUoaW5hY3RpdmVDbGllbnQuY2xpZW50SWQpKS5uZXh0KCgpID0+IGluYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcHJpbWFyeSBsZWFzZSB2aW9sYXRpb25zIG9yIGFueSBvdGhlciB0eXBlIG9mIGVycm9yLiBUaGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgYGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcygpYCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGRlcGVuZFxyXG4gICAgICAgICAgICAgICAgLy8gb24gTG9jYWxTdG9yZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwb3RlbnRpYWwgbGVmdG92ZXIgZW50cmllcyB0aGF0IG1heSBjb250aW51ZSB0byBtYXJrIHRoZVxyXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxyXG4gICAgICAgICAgICAvLyBJZGVhbGx5IHdlJ2QgZGVsZXRlIHRoZSBJbmRleGVkRGIgYW5kIExvY2FsU3RvcmFnZSB6b21iaWUgZW50cmllcyBmb3JcclxuICAgICAgICAgICAgLy8gdGhlIGNsaWVudCBhdG9taWNhbGx5LCBidXQgd2UgY2FuJ3QuIFNvIHdlIG9wdCB0byBkZWxldGUgdGhlIEluZGV4ZWREYlxyXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlYlN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5hY3RpdmVDbGllbnQgb2YgaW5hY3RpdmVDbGllbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXHJcbiAgICAgKiBleHRlbmQgb3IgYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSBpZiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xyXG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiY2xpZW50X21ldGFkYXRhX3JlZnJlc2hcIiAvKiBUaW1lcklkLkNsaWVudE1ldGFkYXRhUmVmcmVzaCAqLywgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMsICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMubWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVDbGllbnRNZXRhZGF0YUFuZFByaW1hcnlMZWFzZVJlZnJlc2hlcygpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBDaGVja3Mgd2hldGhlciBgY2xpZW50YCBpcyB0aGUgbG9jYWwgY2xpZW50LiAqL1xyXG4gICAgaXNMb2NhbENsaWVudChjbGllbnQpIHtcclxuICAgICAgICByZXR1cm4gY2xpZW50ID8gY2xpZW50Lm93bmVySWQgPT09IHRoaXMuY2xpZW50SWQgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGUgdGhlIHN0YXRlIG9mIGFsbCBhY3RpdmUgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGxvY2FsXHJcbiAgICAgKiBjbGllbnQgaXMgb3IgY2FuIGFjdCBhcyB0aGUgaG9sZGVyIG9mIHRoZSBwcmltYXJ5IGxlYXNlLiBSZXR1cm5zIHdoZXRoZXJcclxuICAgICAqIHRoZSBjbGllbnQgaXMgZWxpZ2libGUgZm9yIHRoZSBsZWFzZSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IGFjcXVpcmUgaXQuXHJcbiAgICAgKiBNYXkgcmV0dXJuICdmYWxzZScgZXZlbiBpZiB0aGVyZSBpcyBubyBhY3RpdmUgbGVhc2Vob2xkZXIgYW5kIGFub3RoZXJcclxuICAgICAqIChmb3JlZ3JvdW5kKSBjbGllbnQgc2hvdWxkIGJlY29tZSBsZWFzZWhvbGRlciBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBjYW5BY3RBc1ByaW1hcnkodHhuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VPd25pbmdUYWIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBzdG9yZVxyXG4gICAgICAgICAgICAuZ2V0KERiUHJpbWFyeUNsaWVudEtleSlcclxuICAgICAgICAgICAgLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGVhc2VJc1ZhbGlkID0gY3VycmVudFByaW1hcnkgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xyXG4gICAgICAgICAgICAvLyBBIGNsaWVudCBpcyBlbGlnaWJsZSBmb3IgdGhlIHByaW1hcnkgbGVhc2UgaWY6XHJcbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGUgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBpdHMgbmV0d29yayBpcyBlbmFibGVkIGFuZCBubyBvdGhlciBjbGllbnQncyB0YWIgaXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vICAgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIHRoZSBjbGllbnQncyB0YWIgaXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vICAgZm9yZWdyb3VuZC5cclxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIG5vIG90aGVyIGNsaWVudCdzIHRhYiBpcyBpblxyXG4gICAgICAgICAgICAvLyAgIHRoZSBmb3JlZ3JvdW5kLlxyXG4gICAgICAgICAgICAvLyAtIHRoZSBgZm9yY2VPd25pbmdUYWJgIHNldHRpbmcgd2FzIHBhc3NlZCBpbi5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFzZUlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpICYmIHRoaXMubmV0d29ya0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFpbCB0aGUgYGNhbkFjdEFzUHJpbWFyeWAgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbGVhc2Vob2xkZXIgaGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uIElmIHRoaXMgaGFwcGVucyBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQgc3RhcnR1cCwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBlbmFibGVQZXJzaXN0ZW5jZSgpYCBhbmQgdGhlIHVzZXIgY2FuIGNvbnRpbnVlIHRvIHVzZSBGaXJlc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMgZHVyaW5nIGEgbGVhc2UgcmVmcmVzaCwgd2Ugd2lsbCBpbnN0ZWFkIGJsb2NrIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3luY1F1ZXVlIGZyb20gZXhlY3V0aW5nIGZ1cnRoZXIgb3BlcmF0aW9ucy4gTm90ZSB0aGF0IHRoaXMgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBzaW5jZSBtaXhpbmcgJiBtYXRjaGluZyBkaWZmZXJlbnQgYHN5bmNocm9uaXplVGFic2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZ3MgaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciBiZSB0dXJuZWQgb2ZmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgJiYgdGhpcy5pbkZvcmVncm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5sb2FkQWxsKClcclxuICAgICAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFsbCBleGlzdGluZyBjbGllbnRzIGFuZCBkZXRlcm1pbmUgd2hldGhlciBhdCBsZWFzdCBvbmUgb2ZcclxuICAgICAgICAgICAgICAgIC8vIHRoZW0gaXMgYmV0dGVyIHN1aXRlZCB0byBvYnRhaW4gdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDYW5kaWRhdGUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpLmZpbmQob3RoZXJDbGllbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudElkICE9PSBvdGhlckNsaWVudC5jbGllbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlck5ldHdvcmtTdGF0ZSA9ICF0aGlzLm5ldHdvcmtFbmFibGVkICYmIG90aGVyQ2xpZW50Lm5ldHdvcmtFbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgPSAhdGhpcy5pbkZvcmVncm91bmQgJiYgb3RoZXJDbGllbnQuaW5Gb3JlZ3JvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc1NhbWVOZXR3b3JrU3RhdGUgPSB0aGlzLm5ldHdvcmtFbmFibGVkID09PSBvdGhlckNsaWVudC5uZXR3b3JrRW5hYmxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3RoZXJDbGllbnRIYXNCZXR0ZXJWaXNpYmlsaXR5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZmVycmVkQ2FuZGlkYXRlID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KGNhbkFjdEFzUHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSAhPT0gY2FuQWN0QXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJHtjYW5BY3RBc1ByaW1hcnkgPyAnaXMnIDogJ2lzIG5vdCd9IGVsaWdpYmxlIGZvciBhIHByaW1hcnkgbGVhc2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbkFjdEFzUHJpbWFyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNodXRkb3duKCkge1xyXG4gICAgICAgIC8vIFRoZSBzaHV0ZG93bigpIG9wZXJhdGlvbnMgYXJlIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSBjYWxsZWQgZXZlbiB3aGVuXHJcbiAgICAgICAgLy8gc3RhcnQoKSBhYm9ydGVkIChlLmcuIGJlY2F1c2UgaXQgY291bGRuJ3QgYWNxdWlyZSB0aGUgcGVyc2lzdGVuY2UgbGVhc2UpLlxyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGV0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKTtcclxuICAgICAgICB0aGlzLmRldGFjaFdpbmRvd1VubG9hZEhvb2soKTtcclxuICAgICAgICAvLyBVc2UgYFNpbXBsZURiLnJ1blRyYW5zYWN0aW9uYCBkaXJlY3RseSB0byBhdm9pZCBmYWlsaW5nIGlmIGFub3RoZXIgdGFiXHJcbiAgICAgICAgLy8gaGFzIG9idGFpbmVkIHRoZSBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICAgIGF3YWl0IHRoaXMuc2ltcGxlRGIucnVuVHJhbnNhY3Rpb24oJ3NodXRkb3duJywgJ3JlYWR3cml0ZScsIFtEYlByaW1hcnlDbGllbnRTdG9yZSwgRGJDbGllbnRNZXRhZGF0YVN0b3JlXSwgc2ltcGxlRGJUeG4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uID0gbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHNpbXBsZURiVHhuLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsZWFzZVByaW1hcnlMZWFzZUlmSGVsZChwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHRoaXMucmVtb3ZlQ2xpZW50TWV0YWRhdGEocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGIuY2xvc2UoKTtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGVudHJ5IG1hcmtpbmcgdGhlIGNsaWVudCBhcyB6b21iaWVkIGZyb20gTG9jYWxTdG9yYWdlIHNpbmNlXHJcbiAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgaXRzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLlxyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xpZW50Wm9tYmllZEVudHJ5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY2xpZW50cyB0aGF0IGFyZSBub3Qgem9tYmllZCBhbmQgaGF2ZSBhbiB1cGRhdGVUaW1lIHdpdGhpbiB0aGVcclxuICAgICAqIHByb3ZpZGVkIHRocmVzaG9sZC5cclxuICAgICAqL1xyXG4gICAgZmlsdGVyQWN0aXZlQ2xpZW50cyhjbGllbnRzLCBhY3Rpdml0eVRocmVzaG9sZE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudHMuZmlsdGVyKGNsaWVudCA9PiB0aGlzLmlzV2l0aGluQWdlKGNsaWVudC51cGRhdGVUaW1lTXMsIGFjdGl2aXR5VGhyZXNob2xkTXMpICYmXHJcbiAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjbGllbnQuY2xpZW50SWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuIElmIG11bHRpLXRhYlxyXG4gICAgICogaXMgbm90IHN1cHBvcnRlZCwgcmV0dXJucyBhbiBhcnJheSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGxvY2FsIGNsaWVudCdzXHJcbiAgICAgKiBJRC5cclxuICAgICAqXHJcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVDbGllbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRBY3RpdmVDbGllbnRzJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoY2xpZW50cyA9PiB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgTUFYX0NMSUVOVF9BR0VfTVMpLm1hcChjbGllbnRNZXRhZGF0YSA9PiBjbGllbnRNZXRhZGF0YS5jbGllbnRJZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlKHVzZXIsIGluZGV4TWFuYWdlcikge1xyXG4gICAgICAgIHJldHVybiBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0Q2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVEb2N1bWVudENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleE1hbmFnZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiSW5kZXhNYW5hZ2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLmRhdGFiYXNlSWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcikge1xyXG4gICAgICAgIHJldHVybiBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XHJcbiAgICB9XHJcbiAgICBnZXRCdW5kbGVDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcclxuICAgIH1cclxuICAgIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgdHJhbnNhY3Rpb25PcGVyYXRpb24pIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHNpbXBsZURiTW9kZSA9IG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZG9ubHknIDogJ3JlYWR3cml0ZSc7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVzID0gZ2V0T2JqZWN0U3RvcmVzKHRoaXMuc2NoZW1hVmVyc2lvbik7XHJcbiAgICAgICAgbGV0IHBlcnNpc3RlbmNlVHJhbnNhY3Rpb247XHJcbiAgICAgICAgLy8gRG8gYWxsIHRyYW5zYWN0aW9ucyBhcyByZWFkd3JpdGUgYWdhaW5zdCBhbGwgb2JqZWN0IHN0b3Jlcywgc2luY2Ugd2VcclxuICAgICAgICAvLyBhcmUgdGhlIG9ubHkgcmVhZGVyL3dyaXRlci5cclxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVEYlxyXG4gICAgICAgICAgICAucnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBzaW1wbGVEYk1vZGUsIG9iamVjdFN0b3Jlcywgc2ltcGxlRGJUeG4gPT4ge1xyXG4gICAgICAgICAgICBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uID0gbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHNpbXBsZURiVHhuLCB0aGlzLmxpc3RlblNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMubGlzdGVuU2VxdWVuY2UubmV4dCgpXHJcbiAgICAgICAgICAgICAgICA6IExpc3RlblNlcXVlbmNlLklOVkFMSUQpO1xyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZS1wcmltYXJ5Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgbWVyZWx5IHZlcmlmeSB0aGF0IHdlIGhhdmUgKG9yIGNhbiBhY3F1aXJlKSB0aGUgbGVhc2VcclxuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5LCB3ZSB3YWl0IHRvIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSB1bnRpbCBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0aW5nIHRyYW5zYWN0aW9uT3BlcmF0aW9uKCkuIFRoaXMgZW5zdXJlcyB0aGF0IGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbk9wZXJhdGlvbiB0YWtlcyBhIGxvbmcgdGltZSwgd2UnbGwgdXNlIGEgcmVjZW50XHJcbiAgICAgICAgICAgICAgICAvLyBsZWFzZVRpbWVzdGFtcE1zIGluIHRoZSBleHRlbmRlZCAob3IgbmV3bHkgYWNxdWlyZWQpIGxlYXNlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5UHJpbWFyeUxlYXNlKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkc1ByaW1hcnlMZWFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyogaG9sZHNQcmltYXJ5TGVhc2U9ICovIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbkFjdEFzUHJpbWFyeShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9sZHNQcmltYXJ5TGVhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoYEZhaWxlZCB0byBvYnRhaW4gcHJpbWFyeSBsZWFzZSBmb3IgYWN0aW9uICcke2FjdGlvbn0nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uT3BlcmF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUFsbG93VGFiU3luY2hyb25pemF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pLm5leHQoKCkgPT4gdHJhbnNhY3Rpb25PcGVyYXRpb24ocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCB0YWIgaXMgdGhlIHByaW1hcnkgbGVhc2Vob2xkZXIgb3IgYWx0ZXJuYXRpdmVseVxyXG4gICAgICogdGhhdCB0aGUgbGVhc2Vob2xkZXIgaGFzIG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuIG5vIGxvbmdlclxyXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cclxuICAgIHZlcmlmeUFsbG93VGFiU3luY2hyb25pemF0aW9uKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGVhc2VJc1ZhbGlkID0gY3VycmVudFByaW1hcnkgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCAmJiAhdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlT3duaW5nVGFiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50UHJpbWFyeS5hbGxvd1RhYlN5bmNocm9uaXphdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgb3IgZXh0ZW5kcyB0aGUgbmV3IHByaW1hcnkgbGVhc2UgZm9yIHRoZSBsb2NhbCBjbGllbnQuIFRoaXNcclxuICAgICAqIG1ldGhvZCBkb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGlzIGxlYXNlLlxyXG4gICAgICovXHJcbiAgICBhY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UHJpbWFyeSA9IHtcclxuICAgICAgICAgICAgb3duZXJJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgYWxsb3dUYWJTeW5jaHJvbml6YXRpb246IHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24sXHJcbiAgICAgICAgICAgIGxlYXNlVGltZXN0YW1wTXM6IERhdGUubm93KClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKS5wdXQoRGJQcmltYXJ5Q2xpZW50S2V5LCBuZXdQcmltYXJ5KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gU2ltcGxlRGIuaXNBdmFpbGFibGUoKTtcclxuICAgIH1cclxuICAgIC8qKiBDaGVja3MgdGhlIHByaW1hcnkgbGVhc2UgYW5kIHJlbW92ZXMgaXQgaWYgd2UgYXJlIHRoZSBjdXJyZW50IHByaW1hcnkuICovXHJcbiAgICByZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQocHJpbWFyeUNsaWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShEYlByaW1hcnlDbGllbnRLZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBWZXJpZmllcyB0aGF0IGB1cGRhdGVUaW1lTXNgIGlzIHdpdGhpbiBgbWF4QWdlTXNgLiAqL1xyXG4gICAgaXNXaXRoaW5BZ2UodXBkYXRlVGltZU1zLCBtYXhBZ2VNcykge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgbWluQWNjZXB0YWJsZSA9IG5vdyAtIG1heEFnZU1zO1xyXG4gICAgICAgIGNvbnN0IG1heEFjY2VwdGFibGUgPSBub3c7XHJcbiAgICAgICAgaWYgKHVwZGF0ZVRpbWVNcyA8IG1pbkFjY2VwdGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh1cGRhdGVUaW1lTXMgPiBtYXhBY2NlcHRhYmxlKSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKGBEZXRlY3RlZCBhbiB1cGRhdGUgdGltZSB0aGF0IGlzIGluIHRoZSBmdXR1cmU6ICR7dXBkYXRlVGltZU1zfSA+ICR7bWF4QWNjZXB0YWJsZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGF0dGFjaFZpc2liaWxpdHlIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50ICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSB0aGlzLmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaFZpc2liaWxpdHlIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgd2luZG93LnVubG9hZCBoYW5kbGVyIHRoYXQgd2lsbCBzeW5jaHJvbm91c2x5IHdyaXRlIG91clxyXG4gICAgICogY2xpZW50SWQgdG8gYSBcInpvbWJpZSBjbGllbnQgaWRcIiBsb2NhdGlvbiBpbiBMb2NhbFN0b3JhZ2UuIFRoaXMgY2FuIGJlIHVzZWRcclxuICAgICAqIGJ5IHRhYnMgdHJ5aW5nIHRvIGFjcXVpcmUgdGhlIHByaW1hcnkgbGVhc2UgdG8gZGV0ZXJtaW5lIHRoYXQgdGhlIGxlYXNlXHJcbiAgICAgKiBpcyBubyBsb25nZXIgdmFsaWQgZXZlbiBpZiB0aGUgdGltZXN0YW1wIGlzIHJlY2VudC4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcclxuICAgICAqIGltcG9ydGFudCBmb3IgdGhlIHJlZnJlc2ggY2FzZSAoc28gdGhlIHRhYiBjb3JyZWN0bHkgcmUtYWNxdWlyZXMgdGhlXHJcbiAgICAgKiBwcmltYXJ5IGxlYXNlKS4gTG9jYWxTdG9yYWdlIGlzIHVzZWQgZm9yIHRoaXMgcmF0aGVyIHRoYW4gSW5kZXhlZERiIGJlY2F1c2VcclxuICAgICAqIGl0IGlzIGEgc3luY2hyb25vdXMgQVBJIGFuZCBzbyBjYW4gYmUgdXNlZCByZWxpYWJseSBmcm9tICBhbiB1bmxvYWRcclxuICAgICAqIGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKChfYSA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogSW4gdGhlb3J5LCB0aGlzIHNob3VsZCBiZSBzY2hlZHVsZWQgb24gdGhlIEFzeW5jUXVldWUgc2luY2UgaXRcclxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzc2VzIGludGVybmFsIHN0YXRlLiBXZSBleGVjdXRlIHRoaXMgY29kZSBkaXJlY3RseSBkdXJpbmcgc2h1dGRvd25cclxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdCBnZXRzIGEgY2hhbmNlIHRvIHJ1bi5cclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0NsaWVudFpvbWJpZWQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXggPSAvKD86VmVyc2lvbnxNb2JpbGUpXFwvMVs0NTZdLztcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gU2FmYXJpIDE0LCAxNSwgYW5kIDE2LCB3ZSBkbyBub3QgcnVuIGFueSBjbGVhbnVwIGFjdGlvbnMgYXMgaXQgbWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgYnVnIHRoYXQgcHJldmVudHMgU2FmYXJpIGZyb20gcmUtb3BlbmluZyBJbmRleGVkREIgZHVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgcGFnZSBsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKC8qIHB1cmdlRXhpc3RpbmdUYXNrcz0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd24gKGluY2x1ZGluZyByZWxlYXNpbmcgb3VyIHByaW1hcnkgbGVhc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSdzIG5vIGd1YXJhbnRlZSBpdCB3aWxsIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93VW5sb2FkSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMud2luZG93VW5sb2FkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjbGllbnQgaXMgXCJ6b21iaWVkXCIgYmFzZWQgb24gaXRzIExvY2FsU3RvcmFnZSBlbnRyeS5cclxuICAgICAqIENsaWVudHMgYmVjb21lIHpvbWJpZWQgd2hlbiB0aGVpciB0YWIgY2xvc2VzIHdpdGhvdXQgcnVubmluZyBhbGwgb2YgdGhlXHJcbiAgICAgKiBjbGVhbnVwIGxvZ2ljIGluIGBzaHV0ZG93bigpYC5cclxuICAgICAqL1xyXG4gICAgaXNDbGllbnRab21iaWVkKGNsaWVudElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzWm9tYmllZCA9ICgoX2EgPSB0aGlzLndlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleShjbGllbnRJZCkpKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCBgQ2xpZW50ICcke2NsaWVudElkfScgJHtpc1pvbWJpZWQgPyAnaXMnIDogJ2lzIG5vdCd9IHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1pvbWJpZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGlmIExvY2FsU3RvcmFnZSBpc24ndCB3b3JraW5nLlxyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGMsICdGYWlsZWQgdG8gZ2V0IHpvbWJpZWQgY2xpZW50IGlkLicsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvcmQgY2xpZW50IGFzIHpvbWJpZWQgKGEgY2xpZW50IHRoYXQgaGFkIGl0cyB0YWIgY2xvc2VkKS4gWm9tYmllZFxyXG4gICAgICogY2xpZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgcHJpbWFyeSB0YWIgc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBtYXJrQ2xpZW50Wm9tYmllZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5zZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSwgU3RyaW5nKERhdGUubm93KCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgaWYgTG9jYWxTdG9yYWdlIGlzbid0IGF2YWlsYWJsZSAvIHdvcmtpbmcuXHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2V0IHpvbWJpZSBjbGllbnQgaWQuJywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFJlbW92ZXMgdGhlIHpvbWJpZWQgY2xpZW50IGVudHJ5IGlmIGl0IGV4aXN0cy4gKi9cclxuICAgIHJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIElnbm9yZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpIHtcclxuICAgICAgICByZXR1cm4gYCR7Wk9NQklFRF9DTElFTlRTX0tFWV9QUkVGSVh9XyR7dGhpcy5wZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHByaW1hcnkgY2xpZW50IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUHJpbWFyeUNsaWVudFN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjbGllbnQgbWV0YWRhdGEgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGFTdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB1c2VkIGFzIGEgcHJlZml4IHdoZW4gc3RvcmluZyBkYXRhIGluIEluZGV4ZWREQiBhbmRcclxuICogTG9jYWxTdG9yYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5kZXhlZERiU3RvcmFnZVByZWZpeChkYXRhYmFzZUlkLCBwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgLy8gVXNlIHR3byBkaWZmZXJlbnQgcHJlZml4IGZvcm1hdHM6XHJcbiAgICAvL1xyXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC4gZGF0YWJhc2VJRCAvIC4uLlxyXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC8gLi4uXHJcbiAgICAvL1xyXG4gICAgLy8gcHJvamVjdElEcyBhcmUgRE5TLWNvbXBhdGlibGUgbmFtZXMgYW5kIGNhbm5vdCBjb250YWluIGRvdHNcclxuICAgIC8vIHNvIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGNvbGxpc2lvbnMuXHJcbiAgICBsZXQgZGF0YWJhc2UgPSBkYXRhYmFzZUlkLnByb2plY3RJZDtcclxuICAgIGlmICghZGF0YWJhc2VJZC5pc0RlZmF1bHREYXRhYmFzZSkge1xyXG4gICAgICAgIGRhdGFiYXNlICs9ICcuJyArIGRhdGFiYXNlSWQuZGF0YWJhc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ2ZpcmVzdG9yZS8nICsgcGVyc2lzdGVuY2VLZXkgKyAnLycgKyBkYXRhYmFzZSArICcvJztcclxufVxyXG5hc3luYyBmdW5jdGlvbiBpbmRleGVkRGJDbGVhclBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICBpZiAoIVNpbXBsZURiLmlzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYk5hbWUgPSBwZXJzaXN0ZW5jZUtleSArIE1BSU5fREFUQUJBU0U7XHJcbiAgICBhd2FpdCBTaW1wbGVEYi5kZWxldGUoZGJOYW1lKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIGFycmF5IGZvciBlcXVhbGl0eSB1c2luZyBjb21wYXJhdG9yLiBUaGUgbWV0aG9kIGNvbXB1dGVzIHRoZVxyXG4gKiBpbnRlcnNlY3Rpb24gYW5kIGludm9rZXMgYG9uQWRkYCBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIGluIGBhZnRlcmAgYnV0IG5vdFxyXG4gKiBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluIGBiZWZvcmVgIGJ1dCBtaXNzaW5nXHJcbiAqIGZyb20gYGFmdGVyYC5cclxuICpcclxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcclxuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cclxuICpcclxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBhcnJheS5cclxuICogQHBhcmFtIGFmdGVyIC0gVGhlIGVsZW1lbnRzIHRvIGRpZmYgYWdhaW5zdCB0aGUgb3JpZ2luYWwgYXJyYXkuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxyXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxyXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cclxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXHJcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cclxuICovXHJcbmZ1bmN0aW9uIGRpZmZBcnJheXMoYmVmb3JlLCBhZnRlciwgY29tcGFyYXRvciwgb25BZGQsIG9uUmVtb3ZlKSB7XHJcbiAgICBiZWZvcmUgPSBbLi4uYmVmb3JlXTtcclxuICAgIGFmdGVyID0gWy4uLmFmdGVyXTtcclxuICAgIGJlZm9yZS5zb3J0KGNvbXBhcmF0b3IpO1xyXG4gICAgYWZ0ZXIuc29ydChjb21wYXJhdG9yKTtcclxuICAgIGNvbnN0IGJMZW4gPSBiZWZvcmUubGVuZ3RoO1xyXG4gICAgY29uc3QgYUxlbiA9IGFmdGVyLmxlbmd0aDtcclxuICAgIGxldCBhID0gMDtcclxuICAgIGxldCBiID0gMDtcclxuICAgIHdoaWxlIChhIDwgYUxlbiAmJiBiIDwgYkxlbikge1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlW2JdLCBhZnRlclthXSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZFxyXG4gICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxyXG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcclxuICAgICAgICAgICAgLy8gaXMgb25seSBpbiBgYWZ0ZXJgLlxyXG4gICAgICAgICAgICBvbkFkZChhZnRlclthKytdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGErKztcclxuICAgICAgICAgICAgYisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdoaWxlIChhIDwgYUxlbikge1xyXG4gICAgICAgIG9uQWRkKGFmdGVyW2ErK10pO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGIgPCBiTGVuKSB7XHJcbiAgICAgICAgb25SZW1vdmUoYmVmb3JlW2IrK10pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYiA9ICdMb2NhbFN0b3JlJztcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gbGVhdmUgYSByZXN1bWUgdG9rZW4gYnVmZmVyZWQgd2l0aG91dCB3cml0aW5nIGl0IG91dC5cclxuICogVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnk6IGl0J3MgbG9uZyBlbm91Z2ggdG8gYXZvaWQgc2V2ZXJhbCB3cml0ZXNcclxuICogKHBvc3NpYmx5IGluZGVmaW5pdGVseSBpZiB1cGRhdGVzIGNvbWUgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcykgYnV0XHJcbiAqIHNob3J0IGVub3VnaCB0aGF0IHJlc3RhcnRpbmcgYWZ0ZXIgY3Jhc2hpbmcgd2lsbCBzdGlsbCBoYXZlIGEgcHJldHR5XHJcbiAqIHJlY2VudCByZXN1bWUgdG9rZW4uXHJcbiAqL1xyXG5jb25zdCBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MgPSA1ICogNjAgKiAxZTY7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBMb2NhbFN0b3JlYCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XHJcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXHJcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXHJcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxyXG4gKi9cclxuY2xhc3MgTG9jYWxTdG9yZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXHJcbiAgICBwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUgPSBxdWVyeUVuZ2luZTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcHMgYSB0YXJnZXRJRCB0byBkYXRhIGFib3V0IGl0cyB0YXJnZXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQT1JUSU5HIE5PVEU6IFdlIGFyZSB1c2luZyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgb24gV2ViIHRvIG1ha2UgcmUtcnVuc1xyXG4gICAgICAgICAqIG9mIGBhcHBseVJlbW90ZUV2ZW50KClgIGlkZW1wb3RlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIC8qKiBNYXBzIGEgdGFyZ2V0IHRvIGl0cyB0YXJnZXRJRC4gKi9cclxuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IEV2YWx1YXRlIGlmIFRhcmdldElkIGNhbiBiZSBwYXJ0IG9mIFRhcmdldC5cclxuICAgICAgICB0aGlzLnRhcmdldElkQnlUYXJnZXQgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBwZXIgY29sbGVjdGlvbiBncm91cCBpbmRleCBvZiB0aGUgbGFzdCByZWFkIHRpbWUgcHJvY2Vzc2VkIGJ5XHJcbiAgICAgICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cyA9IHBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gcGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLmJ1bmRsZUNhY2hlID0gcGVyc2lzdGVuY2UuZ2V0QnVuZGxlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyhpbml0aWFsVXNlcik7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcikge1xyXG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBBZGQgc3BlYyB0ZXN0cyB0aGF0IHRlc3QgdGhlc2UgY29tcG9uZW50cyBjaGFuZ2UgYWZ0ZXIgYVxyXG4gICAgICAgIC8vIHVzZXIgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcik7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSB0aGlzLnBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldE11dGF0aW9uUXVldWUodXNlciwgdGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHMgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHRoaXMucmVtb3RlRG9jdW1lbnRzLCB0aGlzLm11dGF0aW9uUXVldWUsIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cy5zZXRJbmRleE1hbmFnZXIodGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUuaW5pdGlhbGl6ZSh0aGlzLmxvY2FsRG9jdW1lbnRzLCB0aGlzLmluZGV4TWFuYWdlcik7XHJcbiAgICB9XHJcbiAgICBjb2xsZWN0R2FyYmFnZShnYXJiYWdlQ29sbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0NvbGxlY3QgZ2FyYmFnZScsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiBnYXJiYWdlQ29sbGVjdG9yLmNvbGxlY3QodHhuLCB0aGlzLnRhcmdldERhdGFCeVRhcmdldCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0xvY2FsU3RvcmUoXHJcbi8qKiBNYW5hZ2VzIG91ciBpbi1tZW1vcnkgb3IgZHVyYWJsZSBwZXJzaXN0ZW5jZS4gKi9cclxucGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JlSW1wbChwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKTtcclxufVxyXG4vKipcclxuICogVGVsbHMgdGhlIExvY2FsU3RvcmUgdGhhdCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgY2hhbmdlZC5cclxuICpcclxuICogSW4gcmVzcG9uc2UgdGhlIGxvY2FsIHN0b3JlIHN3aXRjaGVzIHRoZSBtdXRhdGlvbiBxdWV1ZSB0byB0aGUgbmV3IHVzZXIgYW5kXHJcbiAqIHJldHVybnMgYW55IHJlc3VsdGluZyBkb2N1bWVudCBjaGFuZ2VzLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBBbmRyb2lkIGFuZCBpT1Mgb25seSByZXR1cm4gdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSB0aGVcclxuLy8gY2hhbmdlLlxyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShsb2NhbFN0b3JlLCB1c2VyKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdIYW5kbGUgdXNlciBjaGFuZ2UnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgIC8vIFN3YXAgb3V0IHRoZSBtdXRhdGlvbiBxdWV1ZSwgZ3JhYmJpbmcgdGhlIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlc1xyXG4gICAgICAgIC8vIGJlZm9yZSBhbmQgYWZ0ZXIuXHJcbiAgICAgICAgbGV0IG9sZEJhdGNoZXM7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWVcclxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pXHJcbiAgICAgICAgICAgIC5uZXh0KHByb21pc2VkT2xkQmF0Y2hlcyA9PiB7XHJcbiAgICAgICAgICAgIG9sZEJhdGNoZXMgPSBwcm9taXNlZE9sZEJhdGNoZXM7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHR4bik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQobmV3QmF0Y2hlcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRCYXRjaElkcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZEJhdGNoSWRzID0gW107XHJcbiAgICAgICAgICAgIC8vIFVuaW9uIHRoZSBvbGQvbmV3IGNoYW5nZWQga2V5cy5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBvbGRCYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIG5ld0JhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNldCBvZiBhbGwgKHBvdGVudGlhbGx5KSBjaGFuZ2VkIGRvY3VtZW50cyBhbmQgdGhlIGxpc3RcclxuICAgICAgICAgICAgLy8gb2YgbXV0YXRpb24gYmF0Y2ggSURzIHRoYXQgd2VyZSBhZmZlY3RlZCBieSBjaGFuZ2UuXHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50c1xyXG4gICAgICAgICAgICAgICAgLmdldERvY3VtZW50cyh0eG4sIGNoYW5nZWRLZXlzKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoYWZmZWN0ZWREb2N1bWVudHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZERvY3VtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRCYXRjaElkc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyogQWNjZXB0cyBsb2NhbGx5IGdlbmVyYXRlZCBNdXRhdGlvbnMgYW5kIGNvbW1pdCB0aGVtIHRvIHN0b3JhZ2UuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkobG9jYWxTdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gVGltZXN0YW1wLm5vdygpO1xyXG4gICAgY29uc3Qga2V5cyA9IG11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICBsZXQgb3ZlcmxheWVkRG9jdW1lbnRzO1xyXG4gICAgbGV0IG11dGF0aW9uQmF0Y2g7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcclxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0xvY2FsbHkgd3JpdGUgbXV0YXRpb25zJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XHJcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBrZXlzIGRvIG5vdCBoYXZlIGEgcmVtb3RlIHZlcnNpb24gaW4gdGhlIGNhY2hlLCB0aGlzXHJcbiAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgcmlnaHQgb3ZlcmxheSBtdXRhdGlvbjogaWYgbm8gcmVtb3RlIHZlcnNpb25cclxuICAgICAgICAvLyBwcmVzZW50cywgd2UgZG8gbm90IG5lZWQgdG8gY3JlYXRlIG92ZXJsYXlzIGFzIHBhdGNoIG11dGF0aW9ucy5cclxuICAgICAgICAvLyBUT0RPKE92ZXJsYXkpOiBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZGV0ZXJtaW5lIHRoaXM/IFVzaW5nIHRoZVxyXG4gICAgICAgIC8vICBkb2N1bWVudCB2ZXJzaW9uIGRvZXMgbm90IHdvcmsgYmVjYXVzZSBsb2NhbCBtdXRhdGlvbnMgc2V0IHRoZW0gYmFja1xyXG4gICAgICAgIC8vICB0byAwLlxyXG4gICAgICAgIGxldCByZW1vdGVEb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgbGV0IGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbiA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50c1xyXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0eG4sIGtleXMpXHJcbiAgICAgICAgICAgIC5uZXh0KGRvY3MgPT4ge1xyXG4gICAgICAgICAgICByZW1vdGVEb2NzID0gZG9jcztcclxuICAgICAgICAgICAgcmVtb3RlRG9jcy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24gPSBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24uYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gTG9hZCBhbmQgYXBwbHkgYWxsIGV4aXN0aW5nIG11dGF0aW9ucy4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgdGhlXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYmFzZSBzdGF0ZSBmb3IgYWxsIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYmVmb3JlIGFwcGx5aW5nXHJcbiAgICAgICAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHVzZXItcHJvdmlkZWQgd3JpdGVzLlxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHR4biwgcmVtb3RlRG9jcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKGRvY3MpID0+IHtcclxuICAgICAgICAgICAgb3ZlcmxheWVkRG9jdW1lbnRzID0gZG9jcztcclxuICAgICAgICAgICAgLy8gRm9yIG5vbi1pZGVtcG90ZW50IG11dGF0aW9ucyAoc3VjaCBhcyBgRmllbGRWYWx1ZS5pbmNyZW1lbnQoKWApLFxyXG4gICAgICAgICAgICAvLyB3ZSByZWNvcmQgdGhlIGJhc2Ugc3RhdGUgaW4gYSBzZXBhcmF0ZSBwYXRjaCBtdXRhdGlvbi4gVGhpcyBpc1xyXG4gICAgICAgICAgICAvLyBsYXRlciB1c2VkIHRvIGd1YXJhbnRlZSBjb25zaXN0ZW50IHZhbHVlcyBhbmQgcHJldmVudHMgZmxpY2tlclxyXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBiYWNrZW5kIHNlbmRzIHVzIGFuIHVwZGF0ZSB0aGF0IGFscmVhZHkgaW5jbHVkZXMgb3VyXHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVZhbHVlID0gbXV0YXRpb25FeHRyYWN0QmFzZVZhbHVlKG11dGF0aW9uLCBvdmVybGF5ZWREb2N1bWVudHMuZ2V0KG11dGF0aW9uLmtleSkub3ZlcmxheWVkRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhlIGJhc2Ugc3RhdGUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCBpZiB0aGVyZSdzIHNvbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBkb2N1bWVudCB0byBvdmVycmlkZSwgc28gdXNlIGEgUHJlY29uZGl0aW9uIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzPXRydWVcclxuICAgICAgICAgICAgICAgICAgICBiYXNlTXV0YXRpb25zLnB1c2gobmV3IFBhdGNoTXV0YXRpb24obXV0YXRpb24ua2V5LCBiYXNlVmFsdWUsIGV4dHJhY3RGaWVsZE1hc2soYmFzZVZhbHVlLnZhbHVlLm1hcFZhbHVlKSwgUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmFkZE11dGF0aW9uQmF0Y2godHhuLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChiYXRjaCA9PiB7XHJcbiAgICAgICAgICAgIG11dGF0aW9uQmF0Y2ggPSBiYXRjaDtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBiYXRjaC5hcHBseVRvTG9jYWxEb2N1bWVudFNldChvdmVybGF5ZWREb2N1bWVudHMsIGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHhuLCBiYXRjaC5iYXRjaElkLCBvdmVybGF5cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKCgpID0+ICh7XHJcbiAgICAgICAgYmF0Y2hJZDogbXV0YXRpb25CYXRjaC5iYXRjaElkLFxyXG4gICAgICAgIGNoYW5nZXM6IGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAob3ZlcmxheWVkRG9jdW1lbnRzKVxyXG4gICAgfSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBY2tub3dsZWRnZXMgdGhlIGdpdmVuIGJhdGNoLlxyXG4gKlxyXG4gKiBPbiB0aGUgaGFwcHkgcGF0aCB3aGVuIGEgYmF0Y2ggaXMgYWNrbm93bGVkZ2VkLCB0aGUgbG9jYWwgc3RvcmUgd2lsbFxyXG4gKlxyXG4gKiAgKyByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlO1xyXG4gKiAgKyBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlO1xyXG4gKiAgKyByZWNhbGN1bGF0ZSB0aGUgbGF0ZW5jeSBjb21wZW5zYXRlZCB2aWV3IGltcGxpZWQgYnkgdGhvc2UgY2hhbmdlcyAodGhlcmVcclxuICogICAgbWF5IGJlIG11dGF0aW9ucyBpbiB0aGUgcXVldWUgdGhhdCBhZmZlY3QgdGhlIGRvY3VtZW50cyBidXQgaGF2ZW4ndCBiZWVuXHJcbiAqICAgIGFja25vd2xlZGdlZCB5ZXQpOyBhbmRcclxuICogICsgZ2l2ZSB0aGUgY2hhbmdlZCBkb2N1bWVudHMgYmFjayB0aGUgc3luYyBlbmdpbmVcclxuICpcclxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyAobW9kaWZpZWQpIGRvY3VtZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKGxvY2FsU3RvcmUsIGJhdGNoUmVzdWx0KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQWNrbm93bGVkZ2UgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IGFmZmVjdGVkID0gYmF0Y2hSZXN1bHQuYmF0Y2gua2V5cygpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcHBseVdyaXRlVG9SZW1vdGVEb2N1bWVudHMobG9jYWxTdG9yZUltcGwsIHR4biwgYmF0Y2hSZXN1bHQsIGRvY3VtZW50QnVmZmVyKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmRvY3VtZW50T3ZlcmxheUNhY2hlLnJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0eG4sIGFmZmVjdGVkLCBiYXRjaFJlc3VsdC5iYXRjaC5iYXRjaElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWQpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEtleXNXaXRoVHJhbnNmb3JtUmVzdWx0cyhiYXRjaFJlc3VsdCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gYmF0Y2hSZXN1bHQubXV0YXRpb25SZXN1bHRzW2ldO1xyXG4gICAgICAgIGlmIChtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChiYXRjaFJlc3VsdC5iYXRjaC5tdXRhdGlvbnNbaV0ua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIG11dGF0aW9ucyBmcm9tIHRoZSBNdXRhdGlvblF1ZXVlIGZvciB0aGUgc3BlY2lmaWVkIGJhdGNoO1xyXG4gKiBMb2NhbERvY3VtZW50cyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cclxuICpcclxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtb2RpZmllZCBkb2N1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVqZWN0QmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlamVjdCBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkS2V5cztcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAubG9va3VwTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KChiYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoICE9PSBudWxsKTtcclxuICAgICAgICAgICAgYWZmZWN0ZWRLZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5yZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2gpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuZG9jdW1lbnRPdmVybGF5Q2FjaGUucmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHR4biwgYWZmZWN0ZWRLZXlzLCBiYXRjaElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBhZmZlY3RlZEtleXMpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBhZmZlY3RlZEtleXMpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXN0IChsYXRlc3QpIGJhdGNoIGlkIGluIG11dGF0aW9uIHF1ZXVlIHRoYXQgaXMgcGVuZGluZ1xyXG4gKiBzZXJ2ZXIgcmVzcG9uc2UuXHJcbiAqXHJcbiAqIFJldHVybnMgYEJBVENISURfVU5LTk9XTmAgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQobG9jYWxTdG9yZSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBoaWdoZXN0IHVuYWNrbm93bGVkZ2VkIGJhdGNoIGlkJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0eG4pKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGFzdCBjb25zaXN0ZW50IHNuYXBzaG90IHByb2Nlc3NlZCAodXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG9cclxuICogZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYnVmZmVyIGluY29taW5nIHNuYXBzaG90cyBmcm9tIHRoZSBiYWNrZW5kKS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKGxvY2FsU3RvcmUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbGFzdCByZW1vdGUgc25hcHNob3QgdmVyc2lvbicsICdyZWFkb25seScsIHR4biA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bikpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBcImdyb3VuZC1zdGF0ZVwiIChyZW1vdGUpIGRvY3VtZW50cy4gV2UgYXNzdW1lIHRoYXQgdGhlIHJlbW90ZVxyXG4gKiBldmVudCByZWZsZWN0cyBhbnkgd3JpdGUgYmF0Y2hlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgb3IgcmVqZWN0ZWRcclxuICogKGkuZS4gd2UgZG8gbm90IHJlLWFwcGx5IGxvY2FsIG11dGF0aW9ucyB0byB1cGRhdGVzIGZyb20gdGhpcyBldmVudCkuXHJcbiAqXHJcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxyXG4gKiBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKGxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHJlbW90ZVZlcnNpb24gPSByZW1vdGVFdmVudC5zbmFwc2hvdFZlcnNpb247XHJcbiAgICBsZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdBcHBseSByZW1vdGUgZXZlbnQnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFJlc2V0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCBpbiBjYXNlIHRoaXMgdHJhbnNhY3Rpb24gZ2V0cyByZS1ydW4uXHJcbiAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhQnlUYXJnZXRNYXAuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgaWYgKCFvbGRUYXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHJlbW90ZSBrZXlzIGlmIHRoZSB0YXJnZXQgaXMgc3RpbGwgYWN0aXZlLiBUaGlzXHJcbiAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhhdCB3ZSBjYW4gcGVyc2lzdCB0aGUgdXBkYXRlZCB0YXJnZXQgZGF0YSBhbG9uZyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHRoZSB1cGRhdGVkIGFzc2lnbm1lbnQuXHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cywgdGFyZ2V0SWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgY2hhbmdlLmFkZGVkRG9jdW1lbnRzLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldERhdGEgPSBvbGRUYXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgaWYgKHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZ2V0KHRhcmdldElkKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGFcclxuICAgICAgICAgICAgICAgICAgICAud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFNuYXBzaG90VmVyc2lvbi5taW4oKSlcclxuICAgICAgICAgICAgICAgICAgICAud2l0aExhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24oU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgcmVtb3RlVmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmluc2VydCh0YXJnZXRJZCwgbmV3VGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGFyZ2V0IGRhdGEgaWYgdGhlcmUgYXJlIHRhcmdldCBjaGFuZ2VzIChvciBpZlxyXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLlxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUGVyc2lzdFRhcmdldERhdGEob2xkVGFyZ2V0RGF0YSwgbmV3VGFyZ2V0RGF0YSwgY2hhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS51cGRhdGVUYXJnZXREYXRhKHR4biwgbmV3VGFyZ2V0RGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGNoYW5nZWREb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICByZW1vdGVFdmVudC5kb2N1bWVudFVwZGF0ZXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVtb3RlRXZlbnQucmVzb2x2ZWRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS51cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBFYWNoIGxvb3AgaXRlcmF0aW9uIG9ubHkgYWZmZWN0cyBpdHMgXCJvd25cIiBkb2MsIHNvIGl0J3Mgc2FmZSB0byBnZXQgYWxsXHJcbiAgICAgICAgLy8gdGhlIHJlbW90ZSBkb2N1bWVudHMgaW4gYWR2YW5jZSBpbiBhIHNpbmdsZSBjYWxsLlxyXG4gICAgICAgIHByb21pc2VzLnB1c2gocG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCByZW1vdGVFdmVudC5kb2N1bWVudFVwZGF0ZXMpLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlZERvY3MgPSByZXN1bHQuY2hhbmdlZERvY3VtZW50cztcclxuICAgICAgICAgICAgZXhpc3RlbmNlQ2hhbmdlZEtleXMgPSByZXN1bHQuZXhpc3RlbmNlQ2hhbmdlZEtleXM7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIEhBQ0s6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBhIG51bGwgc25hcHNob3QgdmVyc2lvbiBpcyBzbyB0aGF0IHdlXHJcbiAgICAgICAgLy8gY2FuIHN5bnRoZXNpemUgcmVtb3RlIGV2ZW50cyB3aGVuIHdlIGdldCBwZXJtaXNzaW9uIGRlbmllZCBlcnJvcnMgd2hpbGVcclxuICAgICAgICAvLyB0cnlpbmcgdG8gcmVzb2x2ZSB0aGUgc3RhdGUgb2YgYSBsb2NhbGx5IGNhY2hlZCBkb2N1bWVudCB0aGF0IGlzIGluXHJcbiAgICAgICAgLy8gbGltYm8uXHJcbiAgICAgICAgaWYgKCFyZW1vdGVWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVSZW1vdGVWZXJzaW9uID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bilcclxuICAgICAgICAgICAgICAgIC5uZXh0KGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnNldFRhcmdldHNNZXRhZGF0YSh0eG4sIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIsIHJlbW90ZVZlcnNpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh1cGRhdGVSZW1vdGVWZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXRMb2NhbFZpZXdPZkRvY3VtZW50cyh0eG4sIGNoYW5nZWREb2NzLCBleGlzdGVuY2VDaGFuZ2VkS2V5cykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUG9wdWxhdGVzIGRvY3VtZW50IGNoYW5nZSBidWZmZXIgd2l0aCBkb2N1bWVudHMgZnJvbSBiYWNrZW5kIG9yIGEgYnVuZGxlLlxyXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cywgYW5kXHJcbiAqIGFsc28gYSBzZXQgb2YgZG9jdW1lbnRzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZSBhcmUgY2hhbmdlZCBhcyBhIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudEJ1ZmZlciAtIERvY3VtZW50IGJ1ZmZlciB0byBjb2xsZWN0IHRoZSByZXN1bHRlZCBjaGFuZ2VzIHRvIGJlXHJcbiAqICAgICAgICBhcHBsaWVkIHRvIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cclxuICovXHJcbmZ1bmN0aW9uIHBvcHVsYXRlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodHhuLCBkb2N1bWVudEJ1ZmZlciwgZG9jdW1lbnRzKSB7XHJcbiAgICBsZXQgdXBkYXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgIGRvY3VtZW50cy5mb3JFYWNoKGsgPT4gKHVwZGF0ZWRLZXlzID0gdXBkYXRlZEtleXMuYWRkKGspKSk7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZWREb2N1bWVudHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBkb2N1bWVudHMuZm9yRWFjaCgoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ0RvY3MuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlZSBpZiB0aGVyZSBpcyBhIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2UgZm9yIHRoaXMgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNGb3VuZERvY3VtZW50KCkgIT09IGV4aXN0aW5nRG9jLmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGV4aXN0ZW5jZUNoYW5nZWRLZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBvcmRlciBvZiB0aGUgc3RlcHMgYmVsb3cgaXMgaW1wb3J0YW50LCBzaW5jZSB3ZSB3YW50XHJcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHJlamVjdGVkIGxpbWJvIHJlc29sdXRpb25zICh3aGljaCBmYWJyaWNhdGVcclxuICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkpIG5ldmVyIGFkZCBkb2N1bWVudHMgdG9cclxuICAgICAgICAgICAgLy8gY2FjaGUuXHJcbiAgICAgICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb0RvY3VtZW50cyB3aXRoIFNuYXBzaG90VmVyc2lvbi5taW4oKSBhcmUgdXNlZCBpbiBtYW51ZmFjdHVyZWRcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cy4gV2UgcmVtb3ZlIHRoZXNlIGRvY3VtZW50cyBmcm9tIGNhY2hlIHNpbmNlIHdlIGxvc3RcclxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzcy5cclxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLnJlbW92ZUVudHJ5KGtleSwgZG9jLnJlYWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWREb2N1bWVudHMgPSBjaGFuZ2VkRG9jdW1lbnRzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nRG9jLmlzVmFsaWREb2N1bWVudCgpIHx8XHJcbiAgICAgICAgICAgICAgICBkb2MudmVyc2lvbi5jb21wYXJlVG8oZXhpc3RpbmdEb2MudmVyc2lvbikgPiAwIHx8XHJcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEb2MuaGFzUGVuZGluZ1dyaXRlcykpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnSWdub3Jpbmcgb3V0ZGF0ZWQgd2F0Y2ggdXBkYXRlIGZvciAnLCBrZXksICcuIEN1cnJlbnQgdmVyc2lvbjonLCBleGlzdGluZ0RvYy52ZXJzaW9uLCAnIFdhdGNoIHZlcnNpb246JywgZG9jLnZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZERvY3VtZW50cywgZXhpc3RlbmNlQ2hhbmdlZEtleXMgfTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG5ld1RhcmdldERhdGEgc2hvdWxkIGJlIHBlcnNpc3RlZCBkdXJpbmcgYW4gdXBkYXRlIG9mXHJcbiAqIGFuIGFjdGl2ZSB0YXJnZXQuIFRhcmdldERhdGEgc2hvdWxkIGFsd2F5cyBiZSBwZXJzaXN0ZWQgd2hlbiBhIHRhcmdldCBpc1xyXG4gKiBiZWluZyByZWxlYXNlZCBhbmQgc2hvdWxkIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFdoaWxlIHRoZSB0YXJnZXQgaXMgYWN0aXZlLCBUYXJnZXREYXRhIHVwZGF0ZXMgY2FuIGJlIG9taXR0ZWQgd2hlbiBub3RoaW5nXHJcbiAqIGFib3V0IHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgZXhjZXB0IG1ldGFkYXRhIGxpa2UgdGhlIHJlc3VtZSB0b2tlbiBvclxyXG4gKiBzbmFwc2hvdCB2ZXJzaW9uLiBPY2Nhc2lvbmFsbHkgaXQncyB3b3J0aCB0aGUgZXh0cmEgd3JpdGUgdG8gcHJldmVudCB0aGVzZVxyXG4gKiB2YWx1ZXMgZnJvbSBnZXR0aW5nIHRvbyBzdGFsZSBhZnRlciBhIGNyYXNoLCBidXQgdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmVcclxuICogdG9vIGZyZXF1ZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkUGVyc2lzdFRhcmdldERhdGEob2xkVGFyZ2V0RGF0YSwgbmV3VGFyZ2V0RGF0YSwgY2hhbmdlKSB7XHJcbiAgICAvLyBBbHdheXMgcGVyc2lzdCB0YXJnZXQgZGF0YSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bWUgdG9rZW4uXHJcbiAgICBpZiAob2xkVGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGFsbG93IHJlc3VtZSB0b2tlbiBjaGFuZ2VzIHRvIGJlIGJ1ZmZlcmVkIGluZGVmaW5pdGVseS4gVGhpc1xyXG4gICAgLy8gYWxsb3dzIHVzIHRvIGJlIHJlYXNvbmFibHkgdXAtdG8tZGF0ZSBhZnRlciBhIGNyYXNoIGFuZCBhdm9pZHMgbmVlZGluZ1xyXG4gICAgLy8gdG8gbG9vcCBvdmVyIGFsbCBhY3RpdmUgcXVlcmllcyBvbiBzaHV0ZG93bi4gRXNwZWNpYWxseSBpbiB0aGUgYnJvd3NlclxyXG4gICAgLy8gd2UgbWF5IG5vdCBnZXQgdGltZSB0byBkbyBhbnl0aGluZyBpbnRlcmVzdGluZyB3aGlsZSB0aGUgY3VycmVudCB0YWIgaXNcclxuICAgIC8vIGNsb3NpbmcuXHJcbiAgICBjb25zdCB0aW1lRGVsdGEgPSBuZXdUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpIC1cclxuICAgICAgICBvbGRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpO1xyXG4gICAgaWYgKHRpbWVEZWx0YSA+PSBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIE90aGVyd2lzZSBpZiB0aGUgb25seSB0aGluZyB0aGF0IGhhcyBjaGFuZ2VkIGFib3V0IGEgdGFyZ2V0IGlzIGl0cyByZXN1bWVcclxuICAgIC8vIHRva2VuIGl0J3Mgbm90IHdvcnRoIHBlcnNpc3RpbmcuIE5vdGUgdGhhdCB0aGUgUmVtb3RlU3RvcmUga2VlcHMgYW5cclxuICAgIC8vIGluLW1lbW9yeSB2aWV3IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhcmdldHMgd2hpY2ggaW5jbHVkZXMgdGhlIGN1cnJlbnRcclxuICAgIC8vIHJlc3VtZSB0b2tlbiwgc28gc3RyZWFtIGZhaWx1cmUgb3IgdXNlciBjaGFuZ2VzIHdpbGwgc3RpbGwgdXNlIGFuXHJcbiAgICAvLyB1cC10by1kYXRlIHJlc3VtZSB0b2tlbiByZWdhcmRsZXNzIG9mIHdoYXQgd2UgZG8gaGVyZS5cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXHJcbiAgICAgICAgY2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemU7XHJcbiAgICByZXR1cm4gY2hhbmdlcyA+IDA7XHJcbn1cclxuLyoqXHJcbiAqIE5vdGlmaWVzIGxvY2FsIHN0b3JlIG9mIHRoZSBjaGFuZ2VkIHZpZXdzIHRvIGxvY2FsbHkgcGluIGRvY3VtZW50cy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKGxvY2FsU3RvcmUsIHZpZXdDaGFuZ2VzKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ25vdGlmeUxvY2FsVmlld0NoYW5nZXMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2VzLCAodmlld0NoYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2UuYWRkZWRLZXlzLCAoa2V5KSA9PiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5hZGRSZWZlcmVuY2UodHhuLCB2aWV3Q2hhbmdlLnRhcmdldElkLCBrZXkpKS5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHZpZXdDaGFuZ2UucmVtb3ZlZEtleXMsIChrZXkpID0+IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVJlZmVyZW5jZSh0eG4sIHZpZXdDaGFuZ2UudGFyZ2V0SWQsIGtleSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgLy8gSWYgYG5vdGlmeUxvY2FsVmlld0NoYW5nZXNgIGZhaWxzLCB3ZSBkaWQgbm90IGFkdmFuY2UgdGhlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgIC8vIG51bWJlciBmb3IgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgaW5jbHVkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgICAgLy8gVGhpcyBtaWdodCB0cmlnZ2VyIHRoZW0gdG8gYmUgZGVsZXRlZCBlYXJsaWVyIHRoYW4gdGhleSBvdGhlcndpc2VcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSwgYnV0IGl0IHNob3VsZCBub3QgaW52YWxpZGF0ZSB0aGUgaW50ZWdyaXR5IG9mIHRoZSBkYXRhLlxyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnM6ICcgKyBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB2aWV3Q2hhbmdlIG9mIHZpZXdDaGFuZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB2aWV3Q2hhbmdlLnRhcmdldElkO1xyXG4gICAgICAgIGlmICghdmlld0NoYW5nZS5mcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBsYXN0IGxpbWJvIGZyZWUgc25hcHNob3QgdmVyc2lvblxyXG4gICAgICAgICAgICBjb25zdCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5pbnNlcnQodGFyZ2V0SWQsIHVwZGF0ZWRUYXJnZXREYXRhKTtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzI3MjU2NDMxNik6IEFwcGx5IHRoZSBvcHRpbWl6YXRpb24gZG9uZSBvbiBvdGhlciBwbGF0Zm9ybXMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcm9ibGVtIGZvciB3ZWIgYmVjYXVzZSBzYXZpbmcgdGhlIHVwZGF0ZWQgdGFyZ2V0RGF0YSBmcm9tXHJcbiAgICAgICAgICAgIC8vIG5vbi1wcmltYXJ5IGNsaWVudCBjb25mbGljdHMgd2l0aCB3aGF0IHByaW1hcnkgY2xpZW50IHNhdmVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgbXV0YXRpb24gYmF0Y2ggYWZ0ZXIgdGhlIHBhc3NlZCBpbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZVxyXG4gKiBvciBudWxsIGlmIGVtcHR5LlxyXG4gKiBAcGFyYW0gYWZ0ZXJCYXRjaElkIC0gSWYgcHJvdmlkZWQsIHRoZSBiYXRjaCB0byBzZWFyY2ggYWZ0ZXIuXHJcbiAqIEByZXR1cm5zIFRoZSBuZXh0IG11dGF0aW9uIG9yIG51bGwgaWYgdGhlcmUgd2Fzbid0IG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChsb2NhbFN0b3JlLCBhZnRlckJhdGNoSWQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV4dCBtdXRhdGlvbiBiYXRjaCcsICdyZWFkb25seScsIHR4biA9PiB7XHJcbiAgICAgICAgaWYgKGFmdGVyQmF0Y2hJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFmdGVyQmF0Y2hJZCA9IEJBVENISURfVU5LTk9XTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHhuLCBhZnRlckJhdGNoSWQpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgRG9jdW1lbnQgd2l0aCBhIGdpdmVuIGtleSBvciBudWxsIGlmIG5vdFxyXG4gKiBmb3VuZCAtIHVzZWQgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGtleSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ3JlYWQgZG9jdW1lbnQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnQodHhuLCBrZXkpKTtcclxufVxyXG4vKipcclxuICogQXNzaWducyB0aGUgZ2l2ZW4gdGFyZ2V0IGFuIGludGVybmFsIElEIHNvIHRoYXQgaXRzIHJlc3VsdHMgY2FuIGJlIHBpbm5lZCBzb1xyXG4gKiB0aGV5IGRvbid0IGdldCBHQydkLiBBIHRhcmdldCBtdXN0IGJlIGFsbG9jYXRlZCBpbiB0aGUgbG9jYWwgc3RvcmUgYmVmb3JlXHJcbiAqIHRoZSBzdG9yZSBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgaXRzIHZpZXcuXHJcbiAqXHJcbiAqIEFsbG9jYXRpbmcgYW4gYWxyZWFkeSBhbGxvY2F0ZWQgYFRhcmdldGAgd2lsbCByZXR1cm4gdGhlIGV4aXN0aW5nIGBUYXJnZXREYXRhYFxyXG4gKiBmb3IgdGhhdCBgVGFyZ2V0YC5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdBbGxvY2F0ZSB0YXJnZXQnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0RGF0YTtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgLmdldFRhcmdldERhdGEodHhuLCB0YXJnZXQpXHJcbiAgICAgICAgICAgIC5uZXh0KChjYWNoZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0YXJnZXQgaGFzIGJlZW4gbGlzdGVuZWQgdG8gcHJldmlvdXNseSwgc28gcmV1c2UgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0YXJnZXRJRC5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogZnJlc2hlbiBsYXN0IGFjY2Vzc2VkIGRhdGU/XHJcbiAgICAgICAgICAgICAgICB0YXJnZXREYXRhID0gY2FjaGVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgLmFsbG9jYXRlVGFyZ2V0SWQodHhuKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhID0gbmV3IFRhcmdldERhdGEodGFyZ2V0LCB0YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIHR4bi5jdXJyZW50U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4odGFyZ2V0RGF0YSA9PiB7XHJcbiAgICAgICAgLy8gSWYgTXVsdGktVGFiIGlzIGVuYWJsZWQsIHRoZSBleGlzdGluZyB0YXJnZXQgZGF0YSBtYXkgYmUgbmV3ZXIgdGhhblxyXG4gICAgICAgIC8vIHRoZSBpbi1tZW1vcnkgZGF0YVxyXG4gICAgICAgIGNvbnN0IGNhY2hlZFRhcmdldERhdGEgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmIChjYWNoZWRUYXJnZXREYXRhID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhjYWNoZWRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikgPlxyXG4gICAgICAgICAgICAgICAgMCkge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQgPVxyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5zZXQodGFyZ2V0LCB0YXJnZXREYXRhLnRhcmdldElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldERhdGE7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgVGFyZ2V0RGF0YSBhcyBzZWVuIGJ5IHRoZSBMb2NhbFN0b3JlLCBpbmNsdWRpbmcgdXBkYXRlcyB0aGF0IG1heVxyXG4gKiBoYXZlIG5vdCB5ZXQgYmVlbiBwZXJzaXN0ZWQgdG8gdGhlIFRhcmdldENhY2hlLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZSwgdHJhbnNhY3Rpb24sIHRhcmdldCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXRJZCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0SWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVW5waW5zIGFsbCB0aGUgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0LiBJZlxyXG4gKiBga2VlcFBlcnNpc3RlZFRhcmdldERhdGFgIGlzIHNldCB0byBmYWxzZSBhbmQgRWFnZXIgR0MgZW5hYmxlZCwgdGhlIG1ldGhvZFxyXG4gKiBkaXJlY3RseSByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIHRhcmdldCBkYXRhIGZyb20gdGhlIHRhcmdldCBjYWNoZS5cclxuICpcclxuICogUmVsZWFzaW5nIGEgbm9uLWV4aXN0aW5nIGBUYXJnZXRgIGlzIGEgbm8tb3AuXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgbXVsdGktdGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldElkLCBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBjb25zdCBtb2RlID0ga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgPyAncmVhZHdyaXRlJyA6ICdyZWFkd3JpdGUtcHJpbWFyeSc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgha2VlcFBlcnNpc3RlZFRhcmdldERhdGEpIHtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlbGVhc2UgdGFyZ2V0JywgbW9kZSwgdHhuID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgIC8vIEFsbCBgcmVsZWFzZVRhcmdldGAgZG9lcyBpcyByZWNvcmQgdGhlIGZpbmFsIG1ldGFkYXRhIHN0YXRlIGZvciB0aGVcclxuICAgICAgICAgICAgLy8gdGFyZ2V0LCBidXQgd2UndmUgYmVlbiByZWNvcmRpbmcgdGhpcyBwZXJpb2RpY2FsbHkgZHVyaW5nIHRhcmdldFxyXG4gICAgICAgICAgICAvLyBhY3Rpdml0eS4gSWYgd2UgbG9zZSB0aGlzIHdyaXRlIHRoaXMgY291bGQgY2F1c2UgYSB2ZXJ5IHNsaWdodFxyXG4gICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSBvcmRlciBvZiB0YXJnZXQgZGVsZXRpb24gZHVyaW5nIEdDLCBidXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZGVmaW5lIGV4YWN0IExSVSBzZW1hbnRpY3Mgc28gdGhpcyBpcyBhY2NlcHRhYmxlLlxyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsIGBGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnMgZm9yIHRhcmdldCAke3RhcmdldElkfTogJHtlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQgPVxyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5yZW1vdmUodGFyZ2V0SWQpO1xyXG4gICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBSdW5zIHRoZSBzcGVjaWZpZWQgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgc3RvcmUgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMsXHJcbiAqIHBvdGVudGlhbGx5IHRha2luZyBhZHZhbnRhZ2Ugb2YgcXVlcnkgZGF0YSBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgKHN1Y2hcclxuICogYXMgdGhlIHNldCBvZiByZW1vdGUga2V5cykuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VQcmV2aW91c1Jlc3VsdHMgLSBXaGV0aGVyIHJlc3VsdHMgZnJvbSBwcmV2aW91cyBleGVjdXRpb25zIGNhblxyXG4gKiBiZSB1c2VkIHRvIG9wdGltaXplIHRoaXMgcXVlcnkgZXhlY3V0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGxldCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgbGV0IHJlbW90ZUtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdFeGVjdXRlIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIC8vIFVzZSByZWFkd3JpdGUgaW5zdGVhZCBvZiByZWFkb25seSBzbyBpbmRleGVzIGNhbiBiZSBjcmVhdGVkXHJcbiAgICAvLyBVc2UgcmVhZHdyaXRlIGluc3RlYWQgb2YgcmVhZG9ubHkgc28gaW5kZXhlcyBjYW4gYmUgY3JlYXRlZFxyXG4gICAgdHhuID0+IHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZUltcGwsIHR4biwgcXVlcnlUb1RhcmdldChxdWVyeSkpXHJcbiAgICAgICAgICAgIC5uZXh0KHRhcmdldERhdGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUtleXMgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnF1ZXJ5RW5naW5lLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHhuLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzXHJcbiAgICAgICAgICAgID8gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvblxyXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdXNlUHJldmlvdXNSZXN1bHRzID8gcmVtb3RlS2V5cyA6IGRvY3VtZW50S2V5U2V0KCkpKVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHMgPT4ge1xyXG4gICAgICAgICAgICBzZXRNYXhSZWFkVGltZShsb2NhbFN0b3JlSW1wbCwgcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnkpLCBkb2N1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb2N1bWVudHMsIHJlbW90ZUtleXMgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hSZXN1bHQuYmF0Y2g7XHJcbiAgICBjb25zdCBkb2NLZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgbGV0IHByb21pc2VDaGFpbiA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICBkb2NLZXlzLmZvckVhY2goZG9jS2V5ID0+IHtcclxuICAgICAgICBwcm9taXNlQ2hhaW4gPSBwcm9taXNlQ2hhaW5cclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpKVxyXG4gICAgICAgICAgICAubmV4dChkb2MgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY2tWZXJzaW9uID0gYmF0Y2hSZXN1bHQuZG9jVmVyc2lvbnMuZ2V0KGRvY0tleSk7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYWNrVmVyc2lvbiAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChkb2MudmVyc2lvbi5jb21wYXJlVG8oYWNrVmVyc2lvbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5hcHBseVRvUmVtb3RlRG9jdW1lbnQoZG9jLCBiYXRjaFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBjb21taXRWZXJzaW9uIGFzIHRoZSByZWFkVGltZSByYXRoZXIgdGhhbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudCdzIHVwZGF0ZVRpbWUgc2luY2UgdGhlIHVwZGF0ZVRpbWUgaXMgbm90IGFkdmFuY2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVwZGF0ZXMgdGhhdCBkbyBub3QgbW9kaWZ5IHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRSZWFkVGltZShiYXRjaFJlc3VsdC5jb21taXRWZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5hZGRFbnRyeShkb2MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwcm9taXNlQ2hhaW4ubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCkpO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgYSBtdXRhdGlvbiBiYXRjaC4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUxvb2t1cE11dGF0aW9uRG9jdW1lbnRzKGxvY2FsU3RvcmUsIGJhdGNoSWQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0xvb2t1cCBtdXRhdGlvbiBkb2N1bWVudHMnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlSW1wbC5sb29rdXBNdXRhdGlvbktleXModHhuLCBiYXRjaElkKS5uZXh0KGtleXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldERvY3VtZW50cyh0eG4sIGtleXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVtb3ZlQ2FjaGVkTXV0YXRpb25CYXRjaE1ldGFkYXRhKGxvY2FsU3RvcmUsIGJhdGNoSWQpIHtcclxuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkubXV0YXRpb25RdWV1ZSk7XHJcbiAgICBtdXRhdGlvblF1ZXVlSW1wbC5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2hJZCk7XHJcbn1cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEFjdGl2ZUNsaWVudHMobG9jYWxTdG9yZSkge1xyXG4gICAgY29uc3QgcGVyc2lzdGVuY2VJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkucGVyc2lzdGVuY2UpO1xyXG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlSW1wbC5nZXRBY3RpdmVDbGllbnRzKCk7XHJcbn1cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXRJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCB0YXJnZXRDYWNoZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUpO1xyXG4gICAgY29uc3QgY2FjaGVkVGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgaWYgKGNhY2hlZFRhcmdldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFRhcmdldERhdGEudGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IHRhcmdldCBkYXRhJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhY2hlSW1wbFxyXG4gICAgICAgICAgICAgICAgLmdldFRhcmdldERhdGFGb3JUYXJnZXQodHhuLCB0YXJnZXRJZClcclxuICAgICAgICAgICAgICAgIC5uZXh0KHRhcmdldERhdGEgPT4gKHRhcmdldERhdGEgPyB0YXJnZXREYXRhLnRhcmdldCA6IG51bGwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwuXHJcbiAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIHJldHVybnMgdGhlIHNldCBvZiBjaGFuZ2VzIHNpbmNlIGNsaWVudFxyXG4gKiBpbml0aWFsaXphdGlvbi4gRnVydGhlciBpbnZvY2F0aW9ucyB3aWxsIHJldHVybiBkb2N1bWVudCB0aGF0IGhhdmUgY2hhbmdlZFxyXG4gKiBzaW5jZSB0aGUgcHJpb3IgY2FsbC5cclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMobG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXhpbXVtIHJlYWQgdGltZSBmb3IgdGhlIGNvbGxlY3Rpb24uIFRoaXMgc2hvdWxkIGFsd2F5c1xyXG4gICAgLy8gZXhpc3QsIGJ1dCB0byByZWR1Y2UgdGhlIGNoYW5jZSBmb3IgcmVncmVzc2lvbnMgd2UgZGVmYXVsdCB0b1xyXG4gICAgLy8gU25hcHNob3RWZXJzaW9uLk1pbigpXHJcbiAgICAvLyBUT0RPKGluZGV4aW5nKTogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIGRlZmF1bHQgdmFsdWUuXHJcbiAgICBjb25zdCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XHJcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXHJcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV3IGRvY3VtZW50IGNoYW5nZXMnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHhuLCBjb2xsZWN0aW9uR3JvdXAsIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKHJlYWRUaW1lLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpLCBcclxuICAgIC8qIGxpbWl0PSAqLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpXHJcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xyXG4gICAgICAgIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKiogU2V0cyB0aGUgY29sbGVjdGlvbiBncm91cCdzIG1heGltdW0gcmVhZCB0aW1lIGZyb20gdGhlIGdpdmVuIGRvY3VtZW50cy4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIGNvbGxlY3Rpb25Hcm91cCwgY2hhbmdlZERvY3MpIHtcclxuICAgIGxldCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XHJcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgY2hhbmdlZERvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XHJcbiAgICAgICAgaWYgKGRvYy5yZWFkVGltZS5jb21wYXJlVG8ocmVhZFRpbWUpID4gMCkge1xyXG4gICAgICAgICAgICByZWFkVGltZSA9IGRvYy5yZWFkVGltZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLnNldChjb2xsZWN0aW9uR3JvdXAsIHJlYWRUaW1lKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgdXNpbmcgdGhlIGdpdmVuIGJ1bmRsZSBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgdG9cclxuICogaG9sZCB0aGUga2V5cyBvZiBhbGwgZG9jdW1lbnRzIGZyb20gdGhlIGJ1bmRsZSBpbiBxdWVyeS1kb2N1bWVudCBtYXBwaW5ncy5cclxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGxvYWRlZCBkb2N1bWVudHMgZG8gbm90IGdldCBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gKiByaWdodCBhd2F5LlxyXG4gKi9cclxuZnVuY3Rpb24gdW1icmVsbGFUYXJnZXQoYnVuZGxlTmFtZSkge1xyXG4gICAgLy8gSXQgaXMgT0sgdGhhdCB0aGUgcGF0aCB1c2VkIGZvciB0aGUgcXVlcnkgaXMgbm90IHZhbGlkLCBiZWNhdXNlIHRoaXMgd2lsbFxyXG4gICAgLy8gbm90IGJlIHJlYWQgYW5kIHF1ZXJpZWQuXHJcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoYF9fYnVuZGxlX18vZG9jcy8ke2J1bmRsZU5hbWV9YCkpKTtcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgZG9jdW1lbnRzIGZyb20gYSBidW5kbGUgdG8gdGhlIFwiZ3JvdW5kLXN0YXRlXCIgKHJlbW90ZSlcclxuICogZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBMb2NhbERvY3VtZW50cyBhcmUgcmUtY2FsY3VsYXRlZCBpZiB0aGVyZSBhcmUgcmVtYWluaW5nIG11dGF0aW9ucyBpbiB0aGVcclxuICogcXVldWUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKGxvY2FsU3RvcmUsIGJ1bmRsZUNvbnZlcnRlciwgZG9jdW1lbnRzLCBidW5kbGVOYW1lKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGxldCBkb2N1bWVudEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgbGV0IGRvY3VtZW50TWFwID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICBmb3IgKGNvbnN0IGJ1bmRsZURvYyBvZiBkb2N1bWVudHMpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcclxuICAgICAgICBpZiAoYnVuZGxlRG9jLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50S2V5cyA9IGRvY3VtZW50S2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkb2MgPSBidW5kbGVDb252ZXJ0ZXIudG9NdXRhYmxlRG9jdW1lbnQoYnVuZGxlRG9jKTtcclxuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYnVuZGxlQ29udmVydGVyLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZURvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xyXG4gICAgICAgIGRvY3VtZW50TWFwID0gZG9jdW1lbnRNYXAuaW5zZXJ0KGRvY3VtZW50S2V5LCBkb2MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcclxuICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcclxuICAgIH0pO1xyXG4gICAgLy8gQWxsb2NhdGVzIGEgdGFyZ2V0IHRvIGhvbGQgYWxsIGRvY3VtZW50IGtleXMgZnJvbSB0aGUgYnVuZGxlLCBzdWNoIHRoYXRcclxuICAgIC8vIHRoZXkgd2lsbCBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkIHJpZ2h0IGF3YXkuXHJcbiAgICBjb25zdCB1bWJyZWxsYVRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZUltcGwsIHVtYnJlbGxhVGFyZ2V0KGJ1bmRsZU5hbWUpKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQXBwbHkgYnVuZGxlIGRvY3VtZW50cycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xyXG4gICAgICAgIHJldHVybiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50TWFwKVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bik7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudENoYW5nZVJlc3VsdDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdW1icmVsbGFUYXJnZXREYXRhLnRhcmdldElkKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgZG9jdW1lbnRLZXlzLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHhuLCBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzLCBkb2N1bWVudENoYW5nZVJlc3VsdC5leGlzdGVuY2VDaGFuZ2VkS2V5cykpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGdpdmVuIGJ1bmRsZSBoYXMgYWxyZWFkeVxyXG4gKiBiZWVuIGxvYWRlZCBhbmQgdGhlIGNyZWF0ZSB0aW1lIGlzIG5ld2VyIHRoYW4gdGhlIGN1cnJlbnQgbG9hZGluZyBidW5kbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlSGFzTmV3ZXJCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgY29uc3QgY3VycmVudFJlYWRUaW1lID0gZnJvbVZlcnNpb24oYnVuZGxlTWV0YWRhdGEuY3JlYXRlVGltZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcclxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ2hhc05ld2VyQnVuZGxlJywgJ3JlYWRvbmx5JywgdHJhbnNhY3Rpb24gPT4ge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEuaWQpO1xyXG4gICAgfSlcclxuICAgICAgICAudGhlbihjYWNoZWQgPT4ge1xyXG4gICAgICAgIHJldHVybiAhIWNhY2hlZCAmJiBjYWNoZWQuY3JlYXRlVGltZS5jb21wYXJlVG8oY3VycmVudFJlYWRUaW1lKSA+PSAwO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFNhdmVzIHRoZSBnaXZlbiBgQnVuZGxlTWV0YWRhdGFgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdTYXZlIGJ1bmRsZScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIG9mIGEgYE5hbWVkUXVlcnlgIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBxdWVyeSBuYW1lLiBQcm9taXNlXHJcbiAqIHJlc29sdmVzIHRvIHVuZGVmaW5lZCBpZiBubyBwZXJzaXN0ZWQgZGF0YSBjYW4gYmUgZm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeU5hbWUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmFtZWQgcXVlcnknLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpKTtcclxufVxyXG4vKipcclxuICogU2F2ZXMgdGhlIGdpdmVuIGBOYW1lZFF1ZXJ5YCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgZG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKSkge1xyXG4gICAgLy8gQWxsb2NhdGUgYSB0YXJnZXQgZm9yIHRoZSBuYW1lZCBxdWVyeSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWRcclxuICAgIC8vIGZyb20gYXNzb2NpYXRlZCByZWFkIHRpbWUgaWYgdXNlcnMgdXNlIGl0IHRvIGxpc3Rlbi5cclxuICAgIC8vIE5PVEU6IHRoaXMgYWxzbyBtZWFucyBpZiBubyBjb3JyZXNwb25kaW5nIHRhcmdldCBleGlzdHMsIHRoZSBuZXcgdGFyZ2V0XHJcbiAgICAvLyB3aWxsIHJlbWFpbiBhY3RpdmUgYW5kIHdpbGwgbm90IGdldCBjb2xsZWN0ZWQsIHVubGVzcyB1c2VycyBoYXBwZW4gdG9cclxuICAgIC8vIHVubGlzdGVuIHRoZSBxdWVyeSBzb21laG93LlxyXG4gICAgY29uc3QgYWxsb2NhdGVkID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KGxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQoZnJvbUJ1bmRsZWRRdWVyeShxdWVyeS5idW5kbGVkUXVlcnkpKSk7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBuYW1lZCBxdWVyeScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVhZFRpbWUgPSBmcm9tVmVyc2lvbihxdWVyeS5yZWFkVGltZSk7XHJcbiAgICAgICAgLy8gU2ltcGx5IHNhdmUgdGhlIHF1ZXJ5IGl0c2VsZiBpZiBpdCBpcyBvbGRlciB0aGFuIHdoYXQgdGhlIFNESyBhbHJlYWR5XHJcbiAgICAgICAgLy8gaGFzLlxyXG4gICAgICAgIGlmIChhbGxvY2F0ZWQuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhyZWFkVGltZSkgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHRhcmdldCBkYXRhIGJlY2F1c2UgdGhlIHF1ZXJ5IGZyb20gdGhlIGJ1bmRsZSBpcyBuZXdlci5cclxuICAgICAgICBjb25zdCBuZXdUYXJnZXREYXRhID0gYWxsb2NhdGVkLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCByZWFkVGltZSk7XHJcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cclxuICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydChuZXdUYXJnZXREYXRhLnRhcmdldElkLCBuZXdUYXJnZXREYXRhKTtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgLnVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIG5ld1RhcmdldERhdGEpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCBhbGxvY2F0ZWQudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHJhbnNhY3Rpb24sIGRvY3VtZW50cywgYWxsb2NhdGVkLnRhcmdldElkKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSk7XHJcbiAgICB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGxvY2FsU3RvcmUsIG5ld0ZpZWxkSW5kZXhlcykge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdDb25maWd1cmUgaW5kZXhlcycsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiBpbmRleE1hbmFnZXJcclxuICAgICAgICAuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgIC5uZXh0KG9sZEZpZWxkSW5kZXhlcyA9PiBkaWZmQXJyYXlzKG9sZEZpZWxkSW5kZXhlcywgbmV3RmllbGRJbmRleGVzLCBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yLCBmaWVsZEluZGV4ID0+IHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5hZGRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XHJcbiAgICB9LCBmaWVsZEluZGV4ID0+IHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5kZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XHJcbiAgICB9KSlcclxuICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpKTtcclxufVxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlU2V0SW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGxvY2FsU3RvcmUsIGlzRW5hYmxlZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBsb2NhbFN0b3JlSW1wbC5xdWVyeUVuZ2luZS5pbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQgPSBpc0VuYWJsZWQ7XHJcbn1cclxuZnVuY3Rpb24gbG9jYWxTdG9yZURlbGV0ZUFsbEZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IGxvY2FsU3RvcmVJbXBsLmluZGV4TWFuYWdlcjtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignRGVsZXRlIEFsbCBJbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlci5kZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB0cmFja2VyIHRvIGtlZXAgYSByZWNvcmQgb2YgaW1wb3J0YW50IGRldGFpbHMgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5XHJcbiAqIGV4ZWN1dGlvbi5cclxuICovXHJcbmNsYXNzIFF1ZXJ5Q29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcGFzc2VkIHRocm91Z2ggZHVyaW5nIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kb2N1bWVudFJlYWRDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgZG9jdW1lbnRSZWFkQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50UmVhZENvdW50O1xyXG4gICAgfVxyXG4gICAgaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoYW1vdW50KSB7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQgKz0gYW1vdW50O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFID0gMTAwO1xyXG4vKipcclxuICogVGhpcyBjb3N0IHJlcHJlc2VudHMgdGhlIGV2YWx1YXRpb24gcmVzdWx0IG9mXHJcbiAqICgoW2luZGV4LCBkb2NLZXldICsgW2RvY0tleSwgZG9jQ29udGVudF0pIHBlciBkb2N1bWVudCBpbiB0aGUgcmVzdWx0IHNldClcclxuICogLyAoW2RvY0tleSwgZG9jQ29udGVudF0gcGVyIGRvY3VtZW50cyBpbiBmdWxsIGNvbGxlY3Rpb24gc2NhbikgY29taW5nIGZyb21cclxuICogZXhwZXJpbWVudCBbZW50ZXIgUFIgZXhwZXJpbWVudCBVUkwgaGVyZV0uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKSB7XHJcbiAgICAvLyBUaGVzZSB2YWx1ZXMgd2VyZSBkZXJpdmVkIGZyb20gYW4gZXhwZXJpbWVudCB3aGVyZSBzZXZlcmFsIG1lbWJlcnMgb2YgdGhlXHJcbiAgICAvLyBGaXJlc3RvcmUgU0RLIHRlYW0gcmFuIGEgcGVyZm9ybWFuY2UgdGVzdCBpbiB2YXJpb3VzIGVudmlyb25tZW50cy5cclxuICAgIC8vIEdvb2dsZXJzIGNhbiBzZWUgYi8yOTkyODQyODcgZm9yIGRldGFpbHMuXHJcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xyXG4gICAgICAgIHJldHVybiA4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ2V0QW5kcm9pZFZlcnNpb24oZ2V0VUEoKSkgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDY7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gNDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIEZpcmVzdG9yZSBxdWVyeSBlbmdpbmUuXHJcbiAqXHJcbiAqIEZpcmVzdG9yZSBxdWVyaWVzIGNhbiBiZSBleGVjdXRlZCBpbiB0aHJlZSBtb2Rlcy4gVGhlIFF1ZXJ5IEVuZ2luZSBkZXRlcm1pbmVzXHJcbiAqIHdoYXQgbW9kZSB0byB1c2UgYmFzZWQgb24gd2hhdCBkYXRhIGlzIHBlcnNpc3RlZC4gVGhlIG1vZGUgb25seSBkZXRlcm1pbmVzXHJcbiAqIHRoZSBydW50aW1lIGNvbXBsZXhpdHkgb2YgdGhlIHF1ZXJ5IC0gdGhlIHJlc3VsdCBzZXQgaXMgZXF1aXZhbGVudCBhY3Jvc3MgYWxsXHJcbiAqIGltcGxlbWVudGF0aW9ucy5cclxuICpcclxuICogVGhlIFF1ZXJ5IGVuZ2luZSB3aWxsIHVzZSBpbmRleGVkLWJhc2VkIGV4ZWN1dGlvbiBpZiBhIHVzZXIgaGFzIGNvbmZpZ3VyZWRcclxuICogYW55IGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBxdWVyeSAodmlhIGBzZXRJbmRleENvbmZpZ3VyYXRpb24oKWApLlxyXG4gKiBPdGhlcndpc2UsIHRoZSBlbmdpbmUgd2lsbCB0cnkgdG8gb3B0aW1pemUgdGhlIHF1ZXJ5IGJ5IHJlLXVzaW5nIGEgcHJldmlvdXNseVxyXG4gKiBwZXJzaXN0ZWQgcXVlcnkgcmVzdWx0LiBJZiB0aGF0IGlzIG5vdCBwb3NzaWJsZSwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWRcclxuICogdmlhIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4uXHJcbiAqXHJcbiAqIEluZGV4LWJhc2VkIGV4ZWN1dGlvbiBpcyB0aGUgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZS4gVGhlIHF1ZXJ5IGVuZ2luZVxyXG4gKiBzdXBwb3J0cyBwYXJ0aWFsIGluZGV4ZWQgZXhlY3V0aW9uIGFuZCBtZXJnZXMgdGhlIHJlc3VsdCBmcm9tIHRoZSBpbmRleFxyXG4gKiBsb29rdXAgd2l0aCBkb2N1bWVudHMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLiBUaGUgaW5kZXggZXZhbHVhdGlvblxyXG4gKiBtYXRjaGVzIHRoZSBiYWNrZW5kJ3MgZm9ybWF0IGFuZCBhcyBzdWNoLCB0aGUgU0RLIGNhbiB1c2UgaW5kZXhpbmcgZm9yIGFsbFxyXG4gKiBxdWVyaWVzIHRoYXQgdGhlIGJhY2tlbmQgc3VwcG9ydHMuXHJcbiAqXHJcbiAqIElmIG5vIGluZGV4IGV4aXN0cywgdGhlIHF1ZXJ5IGVuZ2luZSB0cmllcyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGUgdGFyZ2V0XHJcbiAqIGRvY3VtZW50IG1hcHBpbmcgaW4gdGhlIFRhcmdldENhY2hlLiBUaGVzZSBtYXBwaW5ncyBleGlzdHMgZm9yIGFsbCBxdWVyaWVzXHJcbiAqIHRoYXQgaGF2ZSBiZWVuIHN5bmNlZCB3aXRoIHRoZSBiYWNrZW5kIGF0IGxlYXN0IG9uY2UgYW5kIGFsbG93IHRoZSBxdWVyeVxyXG4gKiBlbmdpbmUgdG8gb25seSByZWFkIGRvY3VtZW50cyB0aGF0IHByZXZpb3VzbHkgbWF0Y2hlZCBhIHF1ZXJ5IHBsdXMgYW55XHJcbiAqIGRvY3VtZW50cyB0aGF0IHdlcmUgZWRpdGVkIGFmdGVyIHRoZSBxdWVyeSB3YXMgbGFzdCBsaXN0ZW5lZCB0by5cclxuICpcclxuICogVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlbiB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBwcm9kdWNlXHJcbiAqIHRoZSBzYW1lIHJlc3VsdHMgYXMgZnVsbCBjb2xsZWN0aW9uIHNjYW5zLiBJbiB0aGVzZSBjYXNlcywgcXVlcnlcclxuICogcHJvY2Vzc2luZyBmYWxscyBiYWNrIHRvIGZ1bGwgc2NhbnMuIFRoZXNlIGNhc2VzIGFyZTpcclxuICpcclxuICogLSBMaW1pdCBxdWVyaWVzIHdoZXJlIGEgZG9jdW1lbnQgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSBwcmV2aW91c2x5IG5vIGxvbmdlclxyXG4gKiAgIG1hdGNoZXMgdGhlIHF1ZXJ5LlxyXG4gKlxyXG4gKiAtIExpbWl0IHF1ZXJpZXMgd2hlcmUgYSBkb2N1bWVudCBlZGl0IG1heSBjYXVzZSB0aGUgZG9jdW1lbnQgdG8gc29ydCBiZWxvd1xyXG4gKiAgIGFub3RoZXIgZG9jdW1lbnQgdGhhdCBpcyBpbiB0aGUgbG9jYWwgY2FjaGUuXHJcbiAqXHJcbiAqIC0gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBDVVJSRU5UIG9yIGZyZWUgb2YgbGltYm8gZG9jdW1lbnRzLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlFbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU0RLIG9ubHkgZGVjaWRlcyB3aGV0aGVyIGl0IHNob3VsZCBjcmVhdGUgaW5kZXggd2hlbiBjb2xsZWN0aW9uIHNpemUgaXNcclxuICAgICAgICAgKiBsYXJnZXIgdGhhbiB0aGlzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSA9IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFO1xyXG4gICAgICAgIHRoaXMucmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQgPSBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKiBTZXRzIHRoZSBkb2N1bWVudCB2aWV3IHRvIHF1ZXJ5IGFnYWluc3QuICovXHJcbiAgICBpbml0aWFsaXplKGxvY2FsRG9jdW1lbnRzLCBpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLmxvY2FsRG9jdW1lbnRzVmlldyA9IGxvY2FsRG9jdW1lbnRzO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYWxsIGxvY2FsIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHF1ZXJ5LiAqL1xyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlbW90ZUtleXMpIHtcclxuICAgICAgICAvLyBTdG9yZXMgdGhlIHJlc3VsdCBmcm9tIGV4ZWN1dGluZyB0aGUgcXVlcnk7IHVzaW5nIHRoaXMgb2JqZWN0IGlzIG1vcmVcclxuICAgICAgICAvLyBjb252ZW5pZW50IHRoYW4gcGFzc2luZyB0aGUgcmVzdWx0IGJldHdlZW4gc3RlcHMgb2YgdGhlIHBlcnNpc3RlbmNlXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gYW5kIGltcHJvdmVzIHJlYWRhYmlsaXR5IGNvbXBhcmF0aXZlbHkuXHJcbiAgICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSB7IHJlc3VsdDogbnVsbCB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KVxyXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlSZXN1bHQucmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFF1ZXJ5Q29udGV4dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlRnVsbENvbGxlY3Rpb25TY2FuKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCkubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2FjaGVJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCwgcmVzdWx0LnNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBxdWVyeVJlc3VsdC5yZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FjaGVJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCwgcmVzdWx0U2l6ZSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0LmRvY3VtZW50UmVhZENvdW50IDwgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnU0RLIHdpbGwgbm90IGNyZWF0ZSBjYWNoZSBpbmRleGVzIGZvciBxdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdzaW5jZSBpdCBvbmx5IGNyZWF0ZXMgY2FjaGUgaW5kZXhlcyBmb3IgY29sbGVjdGlvbiBjb250YWlucycsICdtb3JlIHRoYW4gb3IgZXF1YWwgdG8nLCB0aGlzLmluZGV4QXV0b0NyZWF0aW9uTWluQ29sbGVjdGlvblNpemUsICdkb2N1bWVudHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1F1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NjYW5zJywgY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCwgJ2xvY2FsIGRvY3VtZW50cyBhbmQgcmV0dXJucycsIHJlc3VsdFNpemUsICdkb2N1bWVudHMgYXMgcmVzdWx0cy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPlxyXG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ICogcmVzdWx0U2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1RoZSBTREsgZGVjaWRlcyB0byBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnYXMgdXNpbmcgY2FjaGUgaW5kZXhlcyBtYXkgaGVscCBpbXByb3ZlIHBlcmZvcm1hbmNlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5jcmVhdGVUYXJnZXRJbmRleGVzKHRyYW5zYWN0aW9uLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhbiBpbmRleGVkIHF1ZXJ5IHRoYXQgZXZhbHVhdGVzIHRoZSBxdWVyeSBiYXNlZCBvbiBhIGNvbGxlY3Rpb24nc1xyXG4gICAgICogcGVyc2lzdGVkIGluZGV4IHZhbHVlcy4gUmV0dXJucyBgbnVsbGAgaWYgYW4gaW5kZXggaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcclxuICAgICAgICAgICAgLy8ga2V5LWJhc2VkIGxvb2t1cHMuIEl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHNjYW4gYWxsIGRvY3VtZW50cyBpbiBhXHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24sIHJhdGhlciB0aGFuIHRvIHBlcmZvcm0gaW5kaXZpZHVhbCBsb29rdXBzLlxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0YXJnZXQgPSBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxyXG4gICAgICAgICAgICAubmV4dChpbmRleFR5cGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhUeXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhbm5vdCBiZSBzZXJ2ZWQgZnJvbSBhbnkgaW5kZXguXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkubGltaXQgIT09IG51bGwgJiYgaW5kZXhUeXBlID09PSAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgYXBwbHkgYSBsaW1pdCBmb3IgdGFyZ2V0cyB0aGF0IGFyZSBzZXJ2ZWQgdXNpbmcgYSBwYXJ0aWFsXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRleC4gSWYgYSBwYXJ0aWFsIGluZGV4IHdpbGwgYmUgdXNlZCB0byBzZXJ2ZSB0aGUgdGFyZ2V0LCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IG1heSByZXR1cm4gYSBzdXBlcnNldCBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBpZiB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGFsbCB0aGUgdGFyZ2V0J3MgZmlsdGVycyksIG9yXHJcbiAgICAgICAgICAgICAgICAvLyBtYXkgcmV0dXJuIHRoZSBjb3JyZWN0IHNldCBvZiBkb2N1bWVudHMgaW4gdGhlIHdyb25nIG9yZGVyIChlLmcuIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGEgc2VnbWVudCBmb3Igb25lIG9mIHRoZSBvcmRlckJ5cykuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIGEgbGltaXQgc2hvdWxkIG5vdCBiZSBhcHBsaWVkIGluIHN1Y2ggY2FzZXMuXHJcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBudWxsLCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXHJcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldClcclxuICAgICAgICAgICAgICAgIC5uZXh0KGtleXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KC4uLmtleXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XHJcbiAgICAgICAgICAgICAgICAgICAgLmdldERvY3VtZW50cyh0cmFuc2FjdGlvbiwgc29ydGVkS2V5cylcclxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleGVkRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChvZmZzZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGluZGV4ZWREb2N1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlZmlsbChxdWVyeSwgcHJldmlvdXNSZXN1bHRzLCBzb3J0ZWRLZXlzLCBvZmZzZXQucmVhZFRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGxpbWl0IHF1ZXJ5IHdob3NlIGJvdW5kYXJpZXMgY2hhbmdlIGR1ZSB0byBsb2NhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWRpdHMgY2FuIGJlIHJlLXJ1biBhZ2FpbnN0IHRoZSBjYWNoZSBieSBleGNsdWRpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaW1pdC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkncyBmaWx0ZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gVGhlIFNES1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHRoZW4gYXBwbHkgdGhlIGxpbWl0IG9uY2UgYWxsIGxvY2FsIGVkaXRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jb3Jwb3JhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYmFzZWQgb24gdGhlIHRhcmdldCdzIHBlcnNpc3RlZCBxdWVyeSBtYXBwaW5nLiBSZXR1cm5zXHJcbiAgICAgKiBgbnVsbGAgaWYgdGhlIG1hcHBpbmcgaXMgbm90IGF2YWlsYWJsZSBvciBjYW5ub3QgYmUgdXNlZC5cclxuICAgICAqL1xyXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBtYXRjaCBhbGwgZG9jdW1lbnRzIGRvbid0IGJlbmVmaXQgZnJvbSB1c2luZ1xyXG4gICAgICAgICAgICAvLyBrZXktYmFzZWQgbG9va3Vwcy4gSXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gc2NhbiBhbGwgZG9jdW1lbnRzIGluIGFcclxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgc2VlbiBhIHNuYXBzaG90IHdpdGhvdXQgbGltYm8gZnJlZSBkb2N1bWVudHNcclxuICAgICAgICAvLyBzaG91bGQgYWxzbyBiZSBydW4gYXMgYSBmdWxsIGNvbGxlY3Rpb24gc2Nhbi5cclxuICAgICAgICBpZiAobGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCByZW1vdGVLZXlzKS5uZXh0KGRvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IHRoaXMuYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZWZpbGwocXVlcnksIHByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1JlLXVzaW5nIHByZXZpb3VzIHJlc3VsdCBmcm9tICVzIHRvIGV4ZWN1dGUgcXVlcnk6ICVzJywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi50b1N0cmluZygpLCBzdHJpbmdpZnlRdWVyeShxdWVyeSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gbGltYm8tZG9jdW1lbnQgZnJlZSByZW1vdGUgc25hcHNob3QuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCkpLm5leHQocmVzdWx0cyA9PiByZXN1bHRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBBcHBsaWVzIHRoZSBxdWVyeSBmaWx0ZXIgYW5kIHNvcnRpbmcgdG8gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gICovXHJcbiAgICBhcHBseVF1ZXJ5KHF1ZXJ5LCBkb2N1bWVudHMpIHtcclxuICAgICAgICAvLyBTb3J0IHRoZSBkb2N1bWVudHMgYW5kIHJlLWFwcGx5IHRoZSBxdWVyeSBmaWx0ZXIgc2luY2UgcHJldmlvdXNseVxyXG4gICAgICAgIC8vIG1hdGNoaW5nIGRvY3VtZW50cyBkbyBub3QgbmVjZXNzYXJpbHkgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5LlxyXG4gICAgICAgIGxldCBxdWVyeVJlc3VsdHMgPSBuZXcgU29ydGVkU2V0KG5ld1F1ZXJ5Q29tcGFyYXRvcihxdWVyeSkpO1xyXG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChfLCBtYXliZURvYykgPT4ge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBtYXliZURvYykpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cyA9IHF1ZXJ5UmVzdWx0cy5hZGQobWF5YmVEb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGxpbWl0IHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGZyb20gY2FjaGUsIG1ha2luZyBpdFxyXG4gICAgICogaW5lbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBleGVjdXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHNvcnRlZFByZXZpb3VzUmVzdWx0cyAtIFRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSB3aGVuIGl0XHJcbiAgICAgKiB3YXMgbGFzdCBzeW5jaHJvbml6ZWQsIHNvcnRlZCBieSB0aGUgcXVlcnkncyBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJlbW90ZUtleXMgLSBUaGUgZG9jdW1lbnQga2V5cyB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IGF0IHRoZSBsYXN0XHJcbiAgICAgKiBzbmFwc2hvdC5cclxuICAgICAqIEBwYXJhbSBsaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgc25hcHNob3Qgd2hlbiB0aGVcclxuICAgICAqIHF1ZXJ5IHdhcyBsYXN0IHN5bmNocm9uaXplZC5cclxuICAgICAqL1xyXG4gICAgbmVlZHNSZWZpbGwocXVlcnksIHNvcnRlZFByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5LmxpbWl0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgd2l0aG91dCBsaW1pdHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmaWxsZWQuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW90ZUtleXMuc2l6ZSAhPT0gc29ydGVkUHJldmlvdXNSZXN1bHRzLnNpemUpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGlmIGEgcHJldmlvdXNseSBtYXRjaGluZyBkb2N1bWVudCBub1xyXG4gICAgICAgICAgICAvLyBsb25nZXIgbWF0Y2hlcy5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExpbWl0IHF1ZXJpZXMgYXJlIG5vdCBlbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBxdWVyeSBleGVjdXRpb24gaWYgdGhlcmUgaXNcclxuICAgICAgICAvLyBhIHBvdGVudGlhbCB0aGF0IGFuIG9sZGVyIGRvY3VtZW50IGZyb20gY2FjaGUgbm93IHNvcnRzIGJlZm9yZSBhIGRvY3VtZW50XHJcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSBwYXJ0IG9mIHRoZSBsaW1pdC4gVGhpcywgaG93ZXZlciwgY2FuIG9ubHkgaGFwcGVuIGlmXHJcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50IGF0IHRoZSBlZGdlIG9mIHRoZSBsaW1pdCBnb2VzIG91dCBvZiBsaW1pdC5cclxuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IHRoYXQgaXMgbm90IHRoZSBsaW1pdCBib3VuZGFyeSBzb3J0cyBkaWZmZXJlbnRseSxcclxuICAgICAgICAvLyB0aGUgYm91bmRhcnkgb2YgdGhlIGxpbWl0IGl0c2VsZiBkaWQgbm90IGNoYW5nZSBhbmQgZG9jdW1lbnRzIGZyb20gY2FjaGVcclxuICAgICAgICAvLyB3aWxsIGNvbnRpbnVlIHRvIGJlIFwicmVqZWN0ZWRcIiBieSB0aGlzIGJvdW5kYXJ5LiBUaGVyZWZvcmUsIHdlIGNhbiBpZ25vcmVcclxuICAgICAgICAvLyBhbnkgbW9kaWZpY2F0aW9ucyB0aGF0IGRvbid0IGFmZmVjdCB0aGUgbGFzdCBkb2N1bWVudC5cclxuICAgICAgICBjb25zdCBkb2NBdExpbWl0RWRnZSA9IHF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXHJcbiAgICAgICAgICAgID8gc29ydGVkUHJldmlvdXNSZXN1bHRzLmxhc3QoKVxyXG4gICAgICAgICAgICA6IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5maXJzdCgpO1xyXG4gICAgICAgIGlmICghZG9jQXRMaW1pdEVkZ2UpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWZpbGwgdGhlIHF1ZXJ5IGlmIHRoZXJlIHdlcmUgYWxyZWFkeSBubyBkb2N1bWVudHMuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkb2NBdExpbWl0RWRnZS5oYXNQZW5kaW5nV3JpdGVzIHx8XHJcbiAgICAgICAgICAgIGRvY0F0TGltaXRFZGdlLnZlcnNpb24uY29tcGFyZVRvKGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikgPiAwKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1VzaW5nIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHRvIGV4ZWN1dGUgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3LmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBJbmRleE9mZnNldC5taW4oKSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSByZXN1bHRzIGZyb20gYW4gaW5kZXhlZCBleGVjdXRpb24gd2l0aCB0aGUgcmVtYWluaW5nIGRvY3VtZW50c1xyXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLlxyXG4gICAgICovXHJcbiAgICBhcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBpbmRleGVkUmVzdWx0cywgcXVlcnksIG9mZnNldCkge1xyXG4gICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIG9mZnNldC5cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXdcclxuICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQpXHJcbiAgICAgICAgICAgIC5uZXh0KHJlbWFpbmluZ1Jlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHJlc3VsdHNcclxuICAgICAgICAgICAgaW5kZXhlZFJlc3VsdHMuZm9yRWFjaChkID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1Jlc3VsdHMgPSByZW1haW5pbmdSZXN1bHRzLmluc2VydChkLmtleSwgZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nUmVzdWx0cztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBjbGllbnQgc3RhdGUgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfY2xpZW50c188cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxyXG5jb25zdCBDTElFTlRfU1RBVEVfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfY2xpZW50cyc7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBjbGllbnQgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkocGVyc2lzdGVuY2VLZXksIGNsaWVudElkKSB7XHJcbiAgICByZXR1cm4gYCR7Q0xJRU5UX1NUQVRFX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcclxufVxyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyB0aGUgbXV0YXRpb24gc3RhdGUgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5cclxuLy8gICAgIChmb3IgdW5hdXRoZW50aWNhdGVkIHVzZXJzKVxyXG4vLyBvcjogZmlyZXN0b3JlX211dGF0aW9uc188cGVyc2lzdGVuY2VfcHJlZml4Pl88YmF0Y2hfaWQ+Xzx1c2VyX3VpZD5cclxuLy9cclxuLy8gJ3VzZXJfdWlkJyBpcyBsYXN0IHRvIGF2b2lkIG5lZWRpbmcgdG8gZXNjYXBlICdfJyBjaGFyYWN0ZXJzIHRoYXQgaXQgbWlnaHRcclxuLy8gY29udGFpbi5cclxuY29uc3QgTVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfbXV0YXRpb25zJztcclxuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciBhIG11dGF0aW9uIGJhdGNoIGluIFdlYlN0b3JhZ2UgKi9cclxuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkocGVyc2lzdGVuY2VLZXksIHVzZXIsIGJhdGNoSWQpIHtcclxuICAgIGxldCBtdXRhdGlvbktleSA9IGAke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7YmF0Y2hJZH1gO1xyXG4gICAgaWYgKHVzZXIuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICBtdXRhdGlvbktleSArPSBgXyR7dXNlci51aWR9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBtdXRhdGlvbktleTtcclxufVxyXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyBhIHF1ZXJ5IHRhcmdldCdzIG1ldGFkYXRhIGlzOlxyXG4vLyAgICAgZmlyZXN0b3JlX3RhcmdldHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPHRhcmdldF9pZD5cclxuY29uc3QgUVVFUllfVEFSR0VUX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3RhcmdldHMnO1xyXG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgcXVlcnkgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleShwZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpIHtcclxuICAgIHJldHVybiBgJHtRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHt0YXJnZXRJZH1gO1xyXG59XHJcbi8vIFRoZSBXZWJTdG9yYWdlIHByZWZpeCB0aGF0IHN0b3JlcyB0aGUgcHJpbWFyeSB0YWIncyBvbmxpbmUgc3RhdGUuIFRoZVxyXG4vLyBmb3JtYXQgb2YgdGhlIGtleSBpczpcclxuLy8gICAgIGZpcmVzdG9yZV9vbmxpbmVfc3RhdGVfPHBlcnNpc3RlbmNlX3ByZWZpeD5cclxuY29uc3QgT05MSU5FX1NUQVRFX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX29ubGluZV9zdGF0ZSc7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIG9ubGluZSBzdGF0ZSBvZiB0aGUgcHJpbWFyeSB0YWIuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgcmV0dXJuIGAke09OTElORV9TVEFURV9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XHJcbn1cclxuLy8gVGhlIFdlYlN0b3JhZ2UgcHJlZml4IHRoYXQgcGxheXMgYXMgYSBldmVudCB0byBpbmRpY2F0ZSB0aGUgcmVtb3RlIGRvY3VtZW50c1xyXG4vLyBtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIHNvbWUgc2Vjb25kYXJ5IHRhYnMgbG9hZGluZyBhIGJ1bmRsZS5cclxuLy8gZm9ybWF0IG9mIHRoZSBrZXkgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Ml88cGVyc2lzdGVuY2VLZXk+XHJcbi8vIFRoZSB2ZXJzaW9uIGVuZGluZyB3aXRoIFwidjJcIiBzdG9yZXMgdGhlIGxpc3Qgb2YgbW9kaWZpZWQgY29sbGVjdGlvbiBncm91cHMuXHJcbmNvbnN0IEJVTkRMRV9MT0FERURfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Mic7XHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZUxvYWRlZEtleShwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgcmV0dXJuIGAke0JVTkRMRV9MT0FERURfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xyXG59XHJcbi8vIFRoZSBXZWJTdG9yYWdlIGtleSBwcmVmaXggZm9yIHRoZSBrZXkgdGhhdCBzdG9yZXMgdGhlIGxhc3Qgc2VxdWVuY2UgbnVtYmVyIGFsbG9jYXRlZC4gVGhlIGtleVxyXG4vLyBsb29rcyBsaWtlICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Jy5cclxuY29uc3QgU0VRVUVOQ0VfTlVNQkVSX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3NlcXVlbmNlX251bWJlcic7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIGN1cnJlbnQgc2VxdWVuY2UgbnVtYmVyLiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkocGVyc2lzdGVuY2VLZXkpIHtcclxuICAgIHJldHVybiBgJHtTRVFVRU5DRV9OVU1CRVJfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYSA9ICdTaGFyZWRDbGllbnRTdGF0ZSc7XHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBtdXRhdGlvbiBiYXRjaCwgaW5jbHVkaW5nIGl0cyB1c2VyIElELCBiYXRjaCBJRCBhbmRcclxuICogd2hldGhlciB0aGUgYmF0Y2ggaXMgJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJyBvciAncmVqZWN0ZWQnLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jbGFzcyBNdXRhdGlvbk1ldGFkYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHVzZXIsIGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5iYXRjaElkID0gYmF0Y2hJZDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBNdXRhdGlvbk1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cclxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHVzZXIsIGJhdGNoSWQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25CYXRjaCA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgbXV0YXRpb25CYXRjaCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgWydwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcsICdyZWplY3RlZCddLmluZGV4T2YobXV0YXRpb25CYXRjaC5zdGF0ZSkgIT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICAobXV0YXRpb25CYXRjaC5lcnJvciA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvciA9PT0gJ29iamVjdCcpO1xyXG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodmFsaWREYXRhICYmIG11dGF0aW9uQmF0Y2guZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFsaWREYXRhID1cclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSwgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXV0YXRpb25NZXRhZGF0YSh1c2VyLCBiYXRjaElkLCBtdXRhdGlvbkJhdGNoLnN0YXRlLCBmaXJlc3RvcmVFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2UgbXV0YXRpb24gc3RhdGUgZm9yIElEICcke2JhdGNoSWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcclxuICAgICAgICBjb25zdCBiYXRjaE1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICBiYXRjaE1ldGFkYXRhLmVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgY29kZTogdGhpcy5lcnJvci5jb2RlLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5lcnJvci5tZXNzYWdlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiYXRjaE1ldGFkYXRhKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSG9sZHMgdGhlIHN0YXRlIG9mIGEgcXVlcnkgdGFyZ2V0LCBpbmNsdWRpbmcgaXRzIHRhcmdldCBJRCBhbmQgd2hldGhlciB0aGVcclxuICogdGFyZ2V0IGlzICdub3QtY3VycmVudCcsICdjdXJyZW50JyBvciAncmVqZWN0ZWQnLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jbGFzcyBRdWVyeVRhcmdldE1ldGFkYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgUXVlcnlUYXJnZXRNZXRhZGF0YSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeSh0YXJnZXRJZCwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgdGFyZ2V0U3RhdGUgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIFsnbm90LWN1cnJlbnQnLCAnY3VycmVudCcsICdyZWplY3RlZCddLmluZGV4T2YodGFyZ2V0U3RhdGUuc3RhdGUpICE9PVxyXG4gICAgICAgICAgICAgICAgLTEgJiZcclxuICAgICAgICAgICAgKHRhcmdldFN0YXRlLmVycm9yID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvciA9PT0gJ29iamVjdCcpO1xyXG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodmFsaWREYXRhICYmIHRhcmdldFN0YXRlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhbGlkRGF0YSA9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKHRhcmdldFN0YXRlLmVycm9yLmNvZGUsIHRhcmdldFN0YXRlLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCB0YXJnZXRTdGF0ZS5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIHRhcmdldCBzdGF0ZSBmb3IgSUQgJyR7dGFyZ2V0SWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSAvLyBNb2RpZnkgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRyaWdnZXIgdXBkYXRlLlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgdGFyZ2V0U3RhdGUuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVycm9yLmNvZGUsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRhcmdldFN0YXRlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBpbW11dGFibGUgQ2xpZW50U3RhdGUgZm9yIGEgY2xpZW50IHJlYWQgZnJvbVxyXG4gKiBXZWJTdG9yYWdlLCBjb250YWluaW5nIHRoZSBsaXN0IG9mIGFjdGl2ZSBxdWVyeSB0YXJnZXRzLlxyXG4gKi9cclxuY2xhc3MgUmVtb3RlQ2xpZW50U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IGFjdGl2ZVRhcmdldElkcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgUmVtb3RlQ2xpZW50U3RhdGUgZnJvbSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxyXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkoY2xpZW50SWQsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIGNsaWVudFN0YXRlID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMgaW5zdGFuY2VvZiBBcnJheTtcclxuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0SWRzU2V0ID0gdGFyZ2V0SWRTZXQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgdmFsaWREYXRhICYmIGkgPCBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFsaWREYXRhID0gaXNTYWZlSW50ZWdlcihjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHNbaV0pO1xyXG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHNTZXQgPSBhY3RpdmVUYXJnZXRJZHNTZXQuYWRkKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVDbGllbnRTdGF0ZShjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgZGF0YSBmb3IgaW5zdGFuY2UgJyR7Y2xpZW50SWR9JzogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIG9ubGluZSBzdGF0ZSBmb3IgYWxsIGNsaWVudHMgcGFydGljaXBhdGluZyBpblxyXG4gKiBtdWx0aS10YWIuIFRoZSBvbmxpbmUgc3RhdGUgaXMgb25seSB3cml0dGVuIHRvIGJ5IHRoZSBwcmltYXJ5IGNsaWVudCwgYW5kXHJcbiAqIHVzZWQgaW4gc2Vjb25kYXJ5IGNsaWVudHMgdG8gdXBkYXRlIHRoZWlyIHF1ZXJ5IHZpZXdzLlxyXG4gKi9cclxuY2xhc3MgU2hhcmVkT25saW5lU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgU2hhcmVkT25saW5lU3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxyXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IHR5cGVvZiBvbmxpbmVTdGF0ZSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgWydVbmtub3duJywgJ09ubGluZScsICdPZmZsaW5lJ10uaW5kZXhPZihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSkgIT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICB0eXBlb2Ygb25saW5lU3RhdGUuY2xpZW50SWQgPT09ICdzdHJpbmcnO1xyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZWRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZS5jbGllbnRJZCwgb25saW5lU3RhdGUub25saW5lU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIG9ubGluZSBzdGF0ZTogJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXRhZGF0YSBzdGF0ZSBvZiB0aGUgbG9jYWwgY2xpZW50LiBVbmxpa2UgYFJlbW90ZUNsaWVudFN0YXRlYCwgdGhpcyBjbGFzcyBpc1xyXG4gKiBtdXRhYmxlIGFuZCBrZWVwcyB0cmFjayBvZiBhbGwgcGVuZGluZyBtdXRhdGlvbnMsIHdoaWNoIGFsbG93cyB1cyB0b1xyXG4gKiB1cGRhdGUgdGhlIHJhbmdlIG9mIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2ggSURzIGFzIG5ldyBtdXRhdGlvbnMgYXJlIGFkZGVkIG9yXHJcbiAqIHJlbW92ZWQuXHJcbiAqXHJcbiAqIFRoZSBkYXRhIGluIGBMb2NhbENsaWVudFN0YXRlYCBpcyBub3QgcmVhZCBmcm9tIFdlYlN0b3JhZ2UgYW5kIGluc3RlYWRcclxuICogdXBkYXRlZCB2aWEgaXRzIGluc3RhbmNlIG1ldGhvZHMuIFRoZSB1cGRhdGVkIHN0YXRlIGNhbiBiZSBzZXJpYWxpemVkIHZpYVxyXG4gKiBgdG9XZWJTdG9yYWdlSlNPTigpYC5cclxuICovXHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbmNsYXNzIExvY2FsQ2xpZW50U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0YXJnZXRJZFNldCgpO1xyXG4gICAgfVxyXG4gICAgYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRoaXMuYWN0aXZlVGFyZ2V0SWRzLmFkZCh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGhpcy5hY3RpdmVUYXJnZXRJZHMuZGVsZXRlKHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBlbnRyeSBpbnRvIGEgSlNPTi1lbmNvZGVkIGZvcm1hdCB3ZSBjYW4gdXNlIGZvciBXZWJTdG9yYWdlLlxyXG4gICAgICogRG9lcyBub3QgZW5jb2RlIGBjbGllbnRJZGAgYXMgaXQgaXMgcGFydCBvZiB0aGUga2V5IGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKi9cclxuICAgIHRvV2ViU3RvcmFnZUpTT04oKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzOiB0aGlzLmFjdGl2ZVRhcmdldElkcy50b0FycmF5KCksXHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWVNczogRGF0ZS5ub3coKSAvLyBNb2RpZnkgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRyaWdnZXIgdXBkYXRlLlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCB1c2VzIFdlYlN0b3JhZ2UgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIGFzIHRoZVxyXG4gKiBiYWNraW5nIHN0b3JlIGZvciB0aGUgU2hhcmVkQ2xpZW50U3RhdGUuIEl0IGtlZXBzIHRyYWNrIG9mIGFsbCBhY3RpdmVcclxuICogY2xpZW50cyBhbmQgc3VwcG9ydHMgbW9kaWZpY2F0aW9ucyBvZiB0aGUgbG9jYWwgY2xpZW50J3MgZGF0YS5cclxuICovXHJcbmNsYXNzIFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aW5kb3csIHF1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgbG9jYWxDbGllbnRJZCwgaW5pdGlhbFVzZXIpIHtcclxuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRJZCA9IGxvY2FsQ2xpZW50SWQ7XHJcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlckhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVXZWJTdG9yYWdlRXZlbnQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhcHR1cmVzIFdlYlN0b3JhZ2UgZXZlbnRzIHRoYXQgb2NjdXIgYmVmb3JlIGBzdGFydCgpYCBpcyBjYWxsZWQuIFRoZXNlXHJcbiAgICAgICAgICogZXZlbnRzIGFyZSByZXBsYXllZCBvbmNlIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgIGlzIHN0YXJ0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIEVzY2FwZSB0aGUgc3BlY2lhbCBjaGFyYWN0ZXJzIG1lbnRpb25lZCBoZXJlOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9uc1xyXG4gICAgICAgIGNvbnN0IGVzY2FwZWRQZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBpbml0aWFsVXNlcjtcclxuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmxvY2FsQ2xpZW50SWQpO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJLZXkgPSBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdGhpcy5hY3RpdmVDbGllbnRzLmluc2VydCh0aGlzLmxvY2FsQ2xpZW50SWQsIG5ldyBMb2NhbENsaWVudFN0YXRlKCkpO1xyXG4gICAgICAgIHRoaXMuY2xpZW50U3RhdGVLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke0NMSUVOVF9TVEFURV9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFteX10qKSRgKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSg/Ol8oLiopKT8kYCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRhcmdldEtleVJlID0gbmV3IFJlZ0V4cChgXiR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSRgKTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlTG9hZGVkS2V5ID0gY3JlYXRlQnVuZGxlTG9hZGVkS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xyXG4gICAgICAgIC8vIFJhdGhlciB0aGFuIGFkZGluZyB0aGUgc3RvcmFnZSBvYnNlcnZlciBkdXJpbmcgc3RhcnQoKSwgd2UgYWRkIHRoZVxyXG4gICAgICAgIC8vIHN0b3JhZ2Ugb2JzZXJ2ZXIgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBjb2xsZWN0XHJcbiAgICAgICAgLy8gZXZlbnRzIGJlZm9yZSBvdGhlciBjb21wb25lbnRzIHBvcHVsYXRlIHRoZWlyIGluaXRpYWwgc3RhdGUgKGR1cmluZyB0aGVpclxyXG4gICAgICAgIC8vIHJlc3BlY3RpdmUgc3RhcnQoKSBjYWxscykuIE90aGVyd2lzZSwgd2UgbWlnaHQgZm9yIGV4YW1wbGUgbWlzcyBhXHJcbiAgICAgICAgLy8gbXV0YXRpb24gdGhhdCBpcyBhZGRlZCBhZnRlciBMb2NhbFN0b3JlJ3Mgc3RhcnQoKSBwcm9jZXNzZWQgdGhlIGV4aXN0aW5nXHJcbiAgICAgICAgLy8gbXV0YXRpb25zIGJ1dCBiZWZvcmUgd2Ugb2JzZXJ2ZSBXZWJTdG9yYWdlIGV2ZW50cy5cclxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgJ3RydWUnIGlmIFdlYlN0b3JhZ2UgaXMgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAqL1xyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKHdpbmRvdykge1xyXG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjbGllbnRzIHRvIGJhY2tmaWxsIHRoZSBkYXRhIGluXHJcbiAgICAgICAgLy8gU2hhcmVkQ2xpZW50U3RhdGUuXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGllbnRzID0gYXdhaXQgdGhpcy5zeW5jRW5naW5lLmdldEFjdGl2ZUNsaWVudHMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElkIG9mIGV4aXN0aW5nQ2xpZW50cykge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50SWQgPT09IHRoaXMubG9jYWxDbGllbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLmdldEl0ZW0oY3JlYXRlV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIGNsaWVudElkKSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCBzdG9yYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBvbmxpbmUgc3RhdGUgYW5kIGNhbGwgdGhlIGNhbGxiYWNrIGhhbmRsZXJcclxuICAgICAgICAvLyBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlSlNPTiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXkpO1xyXG4gICAgICAgIGlmIChvbmxpbmVTdGF0ZUpTT04pIHtcclxuICAgICAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSB0aGlzLmZyb21XZWJTdG9yYWdlT25saW5lU3RhdGUob25saW5lU3RhdGVKU09OKTtcclxuICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9ubGluZVN0YXRlRXZlbnQob25saW5lU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5lYXJseUV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWFybHlFdmVudHMgPSBbXTtcclxuICAgICAgICAvLyBSZWdpc3RlciBhIHdpbmRvdyB1bmxvYWQgaG9vayB0byByZW1vdmUgdGhlIGNsaWVudCBtZXRhZGF0YSBlbnRyeSBmcm9tXHJcbiAgICAgICAgLy8gV2ViU3RvcmFnZSBldmVuIGlmIGBzaHV0ZG93bigpYCB3YXMgbm90IGNhbGxlZC5cclxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHRoaXMuc2h1dGRvd24oKSk7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHdyaXRlU2VxdWVuY2VOdW1iZXIoc2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5zZXF1ZW5jZU51bWJlcktleSwgSlNPTi5zdHJpbmdpZnkoc2VxdWVuY2VOdW1iZXIpKTtcclxuICAgIH1cclxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XHJcbiAgICB9XHJcbiAgICBpc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ3BlbmRpbmcnKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xyXG4gICAgICAgIC8vIE9uY2UgYSBmaW5hbCBtdXRhdGlvbiByZXN1bHQgaXMgb2JzZXJ2ZWQgYnkgb3RoZXIgY2xpZW50cywgdGhleSBubyBsb25nZXJcclxuICAgICAgICAvLyBhY2Nlc3MgdGhlIG11dGF0aW9uJ3MgbWV0YWRhdGEgZW50cnkuIFNpbmNlIFdlYlN0b3JhZ2UgcmVwbGF5cyBldmVudHNcclxuICAgICAgICAvLyBpbiBvcmRlciwgaXQgaXMgc2FmZSB0byBkZWxldGUgdGhlIGVudHJ5IHJpZ2h0IGFmdGVyIHVwZGF0aW5nIGl0LlxyXG4gICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcclxuICAgIH1cclxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBsZXQgcXVlcnlTdGF0ZSA9ICdub3QtY3VycmVudCc7XHJcbiAgICAgICAgLy8gTG9va3VwIGFuIGV4aXN0aW5nIHF1ZXJ5IHN0YXRlIGlmIHRoZSB0YXJnZXQgSUQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFxyXG4gICAgICAgIC8vIGJ5IGFub3RoZXIgdGFiXHJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gUXVlcnlUYXJnZXRNZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCBzdG9yYWdlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gbWV0YWRhdGEuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0YXRlLmFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5yZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcclxuICAgIH1cclxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsQ2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdFF1ZXJ5VGFyZ2V0U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xyXG4gICAgICAgIHJlbW92ZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgYWRkZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0T25saW5lU3RhdGUob25saW5lU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RCdW5kbGVMb2FkZWRTdGF0ZShjb2xsZWN0aW9uR3JvdXBzKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMuc3RvcmFnZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnUkVBRCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1NFVCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdSRU1PVkUnLCBrZXkpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVXZWJTdG9yYWdlRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAvLyBOb3RlOiBUaGUgZnVuY3Rpb24gaXMgdHlwZWQgdG8gdGFrZSBFdmVudCB0byBiZSBpbnRlcmZhY2UtY29tcGF0aWJsZSB3aXRoXHJcbiAgICAgICAgLy8gYFdpbmRvdy5hZGRFdmVudExpc3RlbmVyYC5cclxuICAgICAgICBjb25zdCBzdG9yYWdlRXZlbnQgPSBldmVudDtcclxuICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LnN0b3JhZ2VBcmVhID09PSB0aGlzLnN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnRVZFTlQnLCBzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdSZWNlaXZlZCBXZWJTdG9yYWdlIG5vdGlmaWNhdGlvbiBmb3IgbG9jYWwgY2hhbmdlLiBBbm90aGVyIGNsaWVudCBtaWdodCBoYXZlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdnYXJiYWdlLWNvbGxlY3RlZCBvdXIgc3RhdGUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RXZlbnRzLnB1c2goc3RvcmFnZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFN0YXRlS2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoc3RvcmFnZUV2ZW50LmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50SWQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV0YXRpb25CYXRjaEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uTWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5xdWVyeVRhcmdldEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0TWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlUYXJnZXRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUXVlcnlUYXJnZXRFdmVudChxdWVyeVRhcmdldE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0b3JhZ2VFdmVudC5rZXkgPT09IHRoaXMub25saW5lU3RhdGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBmcm9tV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmJ1bmRsZUxvYWRlZEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cHMgPSB0aGlzLmZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29sbGVjdGlvbkdyb3Vwcy5tYXAoY2cgPT4gdGhpcy5zeW5jRW5naW5lLnN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoY2cpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBsb2NhbENsaWVudFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KHRoaXMubG9jYWxDbGllbnRJZCk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0Q2xpZW50U3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5LCB0aGlzLmxvY2FsQ2xpZW50U3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcclxuICAgIH1cclxuICAgIHBlcnNpc3RNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RhdGUgPSBuZXcgTXV0YXRpb25NZXRhZGF0YSh0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKG11dGF0aW9uS2V5LCBtdXRhdGlvblN0YXRlLnRvV2ViU3RvcmFnZUpTT04oKSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNdXRhdGlvblN0YXRlKGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShtdXRhdGlvbktleSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHtcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMubG9jYWxDbGllbnRJZCxcclxuICAgICAgICAgICAgb25saW5lU3RhdGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXksIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1ldGFkYXRhID0gbmV3IFF1ZXJ5VGFyZ2V0TWV0YWRhdGEodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcik7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRhcmdldEtleSwgdGFyZ2V0TWV0YWRhdGEudG9XZWJTdG9yYWdlSlNPTigpKTtcclxuICAgIH1cclxuICAgIHBlcnNpc3RCdW5kbGVMb2FkZWRTdGF0ZShjb2xsZWN0aW9uR3JvdXBzKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY29sbGVjdGlvbkdyb3VwcykpO1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLmJ1bmRsZUxvYWRlZEtleSwganNvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBrZXkgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyBudWxsIGlmIHRoZSBrZXkgZG9lcyBub3RcclxuICAgICAqIG1hdGNoIHRoZSBleHBlY3RlZCBrZXkgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jbGllbnRTdGF0ZUtleVJlLmV4ZWMoa2V5KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWUgY291bGQgbm90XHJcbiAgICAgKiBiZSBwYXJzZWQuXHJcbiAgICAgKi9cclxuICAgIGZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIFJlbW90ZUNsaWVudFN0YXRlLmZyb21XZWJTdG9yYWdlRW50cnkoY2xpZW50SWQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgbXV0YXRpb24gYmF0Y2ggc3RhdGUgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXHJcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZU11dGF0aW9uTWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUuZXhlYyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGJhdGNoSWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQgPyBtYXRjaFsyXSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIE11dGF0aW9uTWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeShuZXcgVXNlcih1c2VySWQpLCBiYXRjaElkLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIHF1ZXJ5IHRhcmdldCBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxyXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMucXVlcnlUYXJnZXRLZXlSZS5leGVjKGtleSk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xyXG4gICAgICAgIHJldHVybiBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGFuIG9ubGluZSBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxyXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTaGFyZWRPbmxpbmVTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uQmF0Y2gpIHtcclxuICAgICAgICBpZiAobXV0YXRpb25CYXRjaC51c2VyLnVpZCAhPT0gdGhpcy5jdXJyZW50VXNlci51aWQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCBgSWdub3JpbmcgbXV0YXRpb24gZm9yIG5vbi1hY3RpdmUgdXNlciAke211dGF0aW9uQmF0Y2gudXNlci51aWR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUJhdGNoU3RhdGUobXV0YXRpb25CYXRjaC5iYXRjaElkLCBtdXRhdGlvbkJhdGNoLnN0YXRlLCBtdXRhdGlvbkJhdGNoLmVycm9yKTtcclxuICAgIH1cclxuICAgIGhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQodGFyZ2V0TWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRW5naW5lLmFwcGx5VGFyZ2V0U3RhdGUodGFyZ2V0TWV0YWRhdGEudGFyZ2V0SWQsIHRhcmdldE1ldGFkYXRhLnN0YXRlLCB0YXJnZXRNZXRhZGF0YS5lcnJvcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBjbGllbnRTdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDbGllbnRzID0gY2xpZW50U3RhdGVcclxuICAgICAgICAgICAgPyB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudElkLCBjbGllbnRTdGF0ZSlcclxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsaWVudHMucmVtb3ZlKGNsaWVudElkKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1RhcmdldHMgPSB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBuZXdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHVwZGF0ZWRDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBhZGRlZFRhcmdldHMgPSBbXTtcclxuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIG5ld1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV4aXN0aW5nVGFyZ2V0cy5mb3JFYWNoKHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgaWYgKCFuZXdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UoYWRkZWRUYXJnZXRzLCByZW1vdmVkVGFyZ2V0cykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHVwZGF0ZWRDbGllbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgIC8vIFdlIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWVudCB0aGF0IHdyb3RlIHRoaXMgb25saW5lIHN0YXRlIGlzIHN0aWxsIGFjdGl2ZVxyXG4gICAgICAgIC8vIGJ5IGNvbXBhcmluZyBpdHMgY2xpZW50IElEIHRvIHRoZSBsaXN0IG9mIGNsaWVudHMga2VwdCBhY3RpdmUgaW5cclxuICAgICAgICAvLyBJbmRleGVkRGIuIElmIGEgY2xpZW50IGRvZXMgbm90IHVwZGF0ZSB0aGVpciBJbmRleGVkRGIgY2xpZW50IHN0YXRlXHJcbiAgICAgICAgLy8gd2l0aGluIDUgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgd2UgZG9uJ3QgZW1pdCBhbiBvbmxpbmVcclxuICAgICAgICAvLyBzdGF0ZSBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDbGllbnRzLmdldChvbmxpbmVTdGF0ZS5jbGllbnRJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIob25saW5lU3RhdGUub25saW5lU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHMoY2xpZW50cykge1xyXG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRzID0gdGFyZ2V0SWRTZXQoKTtcclxuICAgICAgICBjbGllbnRzLmZvckVhY2goKGtldiwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cyA9IGFjdGl2ZVRhcmdldHMudW5pb25XaXRoKHZhbHVlLmFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVRhcmdldHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcihzZXFTdHJpbmcpIHtcclxuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IExpc3RlblNlcXVlbmNlLklOVkFMSUQ7XHJcbiAgICBpZiAoc2VxU3RyaW5nICE9IG51bGwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcVN0cmluZyk7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlciA9IHBhcnNlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCAnRmFpbGVkIHRvIHJlYWQgc2VxdWVuY2UgbnVtYmVyIGZyb20gV2ViU3RvcmFnZScsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzZXF1ZW5jZU51bWJlcjtcclxufVxyXG4vKipcclxuICogYE1lbW9yeVNoYXJlZENsaWVudFN0YXRlYCBpcyBhIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBTaGFyZWRDbGllbnRTdGF0ZSBmb3JcclxuICogY2xpZW50cyB1c2luZyBtZW1vcnkgcGVyc2lzdGVuY2UuIFRoZSBzdGF0ZSBpbiB0aGlzIGNsYXNzIHJlbWFpbnMgZnVsbHlcclxuICogaXNvbGF0ZWQgYW5kIG5vIHN5bmNocm9uaXphdGlvbiBpcyBwZXJmb3JtZWQuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdIHx8ICdub3QtY3VycmVudCc7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdID0gc3RhdGU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXTtcclxuICAgIH1cclxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcztcclxuICAgIH1cclxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7IH1cclxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKSB7XHJcbiAgICAgICAgLy8gTm8gb3AuXHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTm9vcENvbm5lY3Rpdml0eU1vbml0b3Ige1xyXG4gICAgYWRkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBOby1vcC5cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIC8vIE5vLW9wLlxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHNpbXBsZSBoZWxwZXIgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBTdHJlYW0gaW50ZXJmYWNlIHRvXHJcbiAqIGJyaWRnZSB0byBvdGhlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmUgc3RyZWFtcyBidXQgZG8gbm90IGltcGxlbWVudCB0aGVcclxuICogaW50ZXJmYWNlLiBUaGUgc3RyZWFtIGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBjYWxsT24uLi4gbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIFN0cmVhbUJyaWRnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kRm4gPSBhcmdzLnNlbmRGbjtcclxuICAgICAgICB0aGlzLmNsb3NlRm4gPSBhcmdzLmNsb3NlRm47XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3RlZChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvbk9wZW4oY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk9wZW4gPSBjYWxsYmFjaztcclxuICAgIH1cclxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbkNsb3NlID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UgPSBjYWxsYmFjaztcclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuY2xvc2VGbigpO1xyXG4gICAgfVxyXG4gICAgc2VuZChtc2cpIHtcclxuICAgICAgICB0aGlzLnNlbmRGbihtc2cpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ29ubmVjdGVkKCk7XHJcbiAgICB9XHJcbiAgICBjYWxsT25PcGVuKCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbigpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uQ2xvc2UoZXJyKSB7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZShlcnIpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uTWVzc2FnZShtc2cpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UobXNnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIG1vc3QgcmVjZW50IGludm9jYXRpb24gb2ZcclxuICogYGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpYCwgb3IgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBpbnZva2VkLlxyXG4gKi9cclxubGV0IGxhc3RVbmlxdWVEZWJ1Z0lkID0gbnVsbDtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBpbml0aWFsIHZhbHVlIGZvciBgbGFzdFVuaXF1ZURlYnVnSWRgLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgYXJlXHJcbiAqIHJlcHJlc2VudGVkIGFzIDggaGV4YWRlY2ltYWwgZGlnaXRzLiBUaGlzIG1lYW5zIHRoYXQgKHdpdGhpbiByZWFzb24pIGFueVxyXG4gKiBudW1iZXJzIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgdGhlIHJldHVybmVkIG51bWJlciBieSAxIHdpbGwgYWxzbyBiZVxyXG4gKiByZXByZXNlbnRlZCBieSA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBsZWFkcyB0byBhbGwgXCJJRHNcIiBoYXZpbmcgdGhlIHNhbWVcclxuICogbGVuZ3RoIHdoZW4gY29udmVydGVkIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBtYWtpbmcgcmVhZGluZyBsb2dzIGNvbnRhaW5pbmdcclxuICogdGhlc2UgSURzIGVhc2llciB0byBmb2xsb3cuIEFuZCBzaW5jZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHJhbmRvbWx5IHNlbGVjdGVkXHJcbiAqIGl0IHdpbGwgaGVscCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbG9ncyBmcm9tIGRpZmZlcmVudCBleGVjdXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpIHtcclxuICAgIGNvbnN0IG1pblJlc3VsdCA9IDB4MTAwMDAwMDA7XHJcbiAgICBjb25zdCBtYXhSZXN1bHQgPSAweDkwMDAwMDAwO1xyXG4gICAgY29uc3QgcmVzdWx0UmFuZ2UgPSBtYXhSZXN1bHQgLSBtaW5SZXN1bHQ7XHJcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBNYXRoLnJvdW5kKHJlc3VsdFJhbmdlICogTWF0aC5yYW5kb20oKSk7XHJcbiAgICByZXR1cm4gbWluUmVzdWx0ICsgcmVzdWx0T2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB1bmlxdWUgSUQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBJRCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlYnVnIGxvZ2dpbmcgbWVzc2FnZXMgdG8gaGVscFxyXG4gKiBjb3JyZWxhdGUgbG9nIG1lc3NhZ2VzIHRoYXQgbWF5IGJlIHNwYXRpYWxseSBzZXBhcmF0ZWQgaW4gdGhlIGxvZ3MsIGJ1dFxyXG4gKiBsb2dpY2FsbHkgcmVsYXRlZC4gRm9yIGV4YW1wbGUsIGEgbmV0d29yayBjb25uZWN0aW9uIGNvdWxkIGluY2x1ZGUgdGhlIHNhbWVcclxuICogXCJkZWJ1ZyBJRFwiIHN0cmluZyBpbiBhbGwgb2YgaXRzIGxvZyBtZXNzYWdlcyB0byBoZWxwIHRyYWNlIGEgc3BlY2lmaWNcclxuICogY29ubmVjdGlvbiBvdmVyIHRpbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdGhlIDEwLWNoYXJhY3RlciBnZW5lcmF0ZWQgSUQgKGUuZy4gXCIweGExYjJjM2Q0XCIpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCkge1xyXG4gICAgaWYgKGxhc3RVbmlxdWVEZWJ1Z0lkID09PSBudWxsKSB7XHJcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQgPSBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0VW5pcXVlRGVidWdJZCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcweCcgKyBsYXN0VW5pcXVlRGVidWdJZC50b1N0cmluZygxNik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLypcclxuICogVXRpbGl0aWVzIGZvciBkZWFsaW5nIHdpdGggbm9kZS5qcy1zdHlsZSBBUElzLiBTZWUgbm9kZVByb21pc2UgZm9yIG1vcmVcclxuICogZGV0YWlscy5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYSBuZXcgUHJvbWlzZS4gVGhlXHJcbiAqIGNhbGxiYWNrIGlzIHBhc3NlZCB0byB0aGUgZ2l2ZW4gYWN0aW9uIHdoaWNoIGNhbiB0aGVuIHVzZSB0aGUgY2FsbGJhY2sgYXNcclxuICogYSBwYXJhbWV0ZXIgdG8gYSBub2RlLXN0eWxlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgaW50ZW50IGlzIHRvIGRpcmVjdGx5IGJyaWRnZSBhIG5vZGUtc3R5bGUgZnVuY3Rpb24gKHdoaWNoIHRha2VzIGFcclxuICogY2FsbGJhY2spIGludG8gYSBQcm9taXNlIHdpdGhvdXQgbWFudWFsbHkgY29udmVydGluZyBiZXR3ZWVuIHRoZSBub2RlLXN0eWxlXHJcbiAqIGNhbGxiYWNrIGFuZCB0aGUgcHJvbWlzZSBhdCBlYWNoIGNhbGwuXHJcbiAqXHJcbiAqIEluIGVmZmVjdCBpdCBhbGxvd3MgeW91IHRvIGNvbnZlcnQ6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsdWU/OiBmcy5TdGF0cykgPT4gdm9pZCxcclxuICogICAgICAgICAgICAgIHJlamVjdDogKGVycm9yPzogYW55KSA9PiB2b2lkKSA9PiB7XHJcbiAqICAgZnMuc3RhdChwYXRoLCAoZXJyb3I/OiBhbnksIHN0YXQ/OiBmcy5TdGF0cykgPT4ge1xyXG4gKiAgICAgaWYgKGVycm9yKSB7XHJcbiAqICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICByZXNvbHZlKHN0YXQpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH0pO1xyXG4gKiB9KTtcclxuICpcclxuICogSW50b1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBub2RlUHJvbWlzZSgoY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxmcy5TdGF0cz4pID0+IHtcclxuICogICBmcy5zdGF0KHBhdGgsIGNhbGxiYWNrKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIGFuIGFyZ3VtZW50XHJcbiAqICAgICBhbmQgdGhlbiB1c2VzIHRoYXQgY2FsbGJhY2sgdG8gaW52b2tlIHNvbWUgbm9kZS1zdHlsZSBBUEkuXHJcbiAqIEByZXR1cm5zIGEgbmV3IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZWplY3RlZCBpZiB0aGUgY2FsbGJhY2sgaXMgZ2l2ZW4gdGhlXHJcbiAqICAgICBmaXJzdCBFcnJvciBwYXJhbWV0ZXIgb3Igd2lsbCByZXNvbHZlIHRvIHRoZSB2YWx1ZSBnaXZlbiBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlUHJvbWlzZShhY3Rpb24pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgYWN0aW9uKChlcnJvciwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFRPRE86IEZldGNoIHJ1bnRpbWUgdmVyc2lvbiBmcm9tIGdycGMtanMvcGFja2FnZS5qc29uIGluc3RlYWRcclxuLy8gd2hlbiB0aGVyZSdzIGEgY2xlYW5lciB3YXkgdG8gZHluYW1pYyByZXF1aXJlIEpTT04gaW4gYm90aCBOb2RlIEVTTSBhbmQgQ0pTXHJcbmNvbnN0IGdycGNWZXJzaW9uID0gJzEuOS4xJztcclxuY29uc3QgTE9HX1RBRyQ5ID0gJ0dycGNDb25uZWN0aW9uJztcclxuY29uc3QgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUgPSBgZ2wtbm9kZS8ke3Byb2Nlc3MudmVyc2lvbnMubm9kZX0gZmlyZS8ke1NES19WRVJTSU9OfSBncnBjLyR7Z3JwY1ZlcnNpb259YDtcclxuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGEoZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGFwcElkKSB7XHJcbiAgICBoYXJkQXNzZXJ0KGF1dGhUb2tlbiA9PT0gbnVsbCB8fCBhdXRoVG9rZW4udHlwZSA9PT0gJ09BdXRoJyk7XHJcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBncnBjLk1ldGFkYXRhKCk7XHJcbiAgICBpZiAoYXV0aFRva2VuKSB7XHJcbiAgICAgICAgYXV0aFRva2VuLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgYXBwQ2hlY2tUb2tlbi5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IG1ldGFkYXRhLnNldChrZXksIHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXBwSWQpIHtcclxuICAgICAgICBtZXRhZGF0YS5zZXQoJ1gtRmlyZWJhc2UtR01QSUQnLCBhcHBJZCk7XHJcbiAgICB9XHJcbiAgICBtZXRhZGF0YS5zZXQoJ1gtR29vZy1BcGktQ2xpZW50JywgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUpO1xyXG4gICAgLy8gVGhlc2UgaGVhZGVycyBhcmUgdXNlZCB0byBpbXByb3ZlIHJvdXRpbmcgYW5kIHByb2plY3QgaXNvbGF0aW9uIGJ5IHRoZVxyXG4gICAgLy8gYmFja2VuZC5cclxuICAgIC8vIFRPRE8oYi8xOTk3Njc3MTIpOiBXZSBhcmUga2VlcGluZyAnR29vZ2xlLUNsb3VkLVJlc291cmNlLVByZWZpeCcgdW50aWwgRW11bGF0b3JzIGNhbiBiZVxyXG4gICAgLy8gcmVsZWFzZWQgd2l0aCBjbC80Mjg4MjAwNDYuIEN1cnJlbnRseSBibG9ja2VkIGJlY2F1c2UgRW11bGF0b3JzIGFyZSBub3cgYnVpbHQgd2l0aCBKYXZhXHJcbiAgICAvLyAxMSBmcm9tIEdvb2dsZTMuXHJcbiAgICBtZXRhZGF0YS5zZXQoJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnLCBkYXRhYmFzZVBhdGgpO1xyXG4gICAgbWV0YWRhdGEuc2V0KCd4LWdvb2ctcmVxdWVzdC1wYXJhbXMnLCBkYXRhYmFzZVBhdGgpO1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xyXG59XHJcbi8qKlxyXG4gKiBBIENvbm5lY3Rpb24gaW1wbGVtZW50ZWQgYnkgR1JQQy1Ob2RlLlxyXG4gKi9cclxuY2xhc3MgR3JwY0Nvbm5lY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IocHJvdG9zLCBkYXRhYmFzZUluZm8pIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSW5mbyA9IGRhdGFiYXNlSW5mbztcclxuICAgICAgICAvLyBXZSBjYWNoZSBzdHVicyBmb3IgdGhlIG1vc3QtcmVjZW50bHktdXNlZCB0b2tlbi5cclxuICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBudWxsO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBwcm90b3NbJ2dvb2dsZSddWydmaXJlc3RvcmUnXVsndjEnXTtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlUGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSW5mby5kYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQuZGF0YWJhc2V9YDtcclxuICAgIH1cclxuICAgIGdldCBzaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KCkge1xyXG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCBpZ25vcmUgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cywgYW5kIGV4cGVjdFxyXG4gICAgICAgIC8vIHRoZSBcInBhdGhcIiB0byBiZSBwYXJ0IG9mIHRoZSBnaXZlbiBgcmVxdWVzdGAuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVBY3RpdmVTdHViKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRTdHViKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ0NyZWF0aW5nIEZpcmVzdG9yZSBzdHViLicpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuZGF0YWJhc2VJbmZvLnNzbFxyXG4gICAgICAgICAgICAgICAgPyBncnBjLmNyZWRlbnRpYWxzLmNyZWF0ZVNzbCgpXHJcbiAgICAgICAgICAgICAgICA6IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUoKTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gbmV3IHRoaXMuZmlyZXN0b3JlLkZpcmVzdG9yZSh0aGlzLmRhdGFiYXNlSW5mby5ob3N0LCBjcmVkZW50aWFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFN0dWI7XHJcbiAgICB9XHJcbiAgICBpbnZva2VSUEMocnBjTmFtZSwgcGF0aCwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcclxuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNZXRhZGF0YSh0aGlzLmRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCB0aGlzLmRhdGFiYXNlSW5mby5hcHBJZCk7XHJcbiAgICAgICAgY29uc3QganNvblJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0sIHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBpbnZva2VkIHdpdGggcmVxdWVzdDpgLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhLCAoZ3JwY0Vycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gZmFpbGVkIHdpdGggZXJyb3I6YCwgZ3JwY0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRmlyZXN0b3JlRXJyb3IobWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gY29tcGxldGVkIHdpdGggcmVzcG9uc2U6YCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgKHN0cmVhbWluZykgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IHN0dWIgPSB0aGlzLmVuc3VyZUFjdGl2ZVN0dWIoKTtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkKTtcclxuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0pO1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhKTtcclxuICAgICAgICBsZXQgY2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJHtycGNOYW1lfSAke3N0cmVhbUlkfSByZWNlaXZlZCByZXN1bHQ6YCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMubGVuZ3RoID09PSBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gY29tcGxldGVkLmApO1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRmlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChncnBjRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBmYWlsZWQgd2l0aCBlcnJvcjpgLCBncnBjRXJyb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gbWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKTtcclxuICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIGdycGNFcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8obWlrZWxlaGVuKTogVGhpcyBcIm1ldGhvZFwiIGlzIGEgbW9uc3Rlci4gU2hvdWxkIGJlIHJlZmFjdG9yZWQuXHJcbiAgICBvcGVuU3RyZWFtKHJwY05hbWUsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XHJcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xyXG4gICAgICAgIGNvbnN0IGdycGNTdHJlYW0gPSBzdHViW3JwY05hbWVdKG1ldGFkYXRhKTtcclxuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbkNsb3NlKGVycik7XHJcbiAgICAgICAgICAgICAgICBncnBjU3RyZWFtLmVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtQnJpZGdlKHtcclxuICAgICAgICAgICAgc2VuZEZuOiAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IHNlbmRpbmc6YCwgbXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncnBjU3RyZWFtLndyaXRlKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvYmFibHkgbWVhbnMgd2UgZGlkbid0IGNvbmZvcm0gdG8gdGhlIHByb3RvLiAgTWFrZSBzdXJlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZyB0aGUgbWVzc2FnZSB3ZSBzZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcignRmFpbHVyZSBzZW5kaW5nOicsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdFcnJvcjonLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGNsb3NlZCBsb2NhbGx5IHZpYSBjbG9zZSgpLmApO1xyXG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBvbkNvbm5lY3RlZFNlbnQgPSBmYWxzZTtcclxuICAgICAgICBncnBjU3RyZWFtLm9uKCdkYXRhJywgKG1zZykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gcmVjZWl2ZWQ6YCwgbXNnKTtcclxuICAgICAgICAgICAgICAgIC8vIEVtdWxhdGUgdGhlIFwib25Db25uZWN0ZWRcIiBldmVudCB0aGF0IFdlYkNoYW5uZWxDb25uZWN0aW9uIHNlbmRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFvbkNvbm5lY3RlZFNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uY2FsbE9uQ29ubmVjdGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0ZWRTZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25NZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBncnBjU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVuZGVkLmApO1xyXG4gICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgbG9nV2FybihMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBlcnJvci4gQ29kZTpgLCBncnBjRXJyb3IuY29kZSwgJ01lc3NhZ2U6JywgZ3JwY0Vycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XHJcbiAgICAgICAgICAgICAgICBjbG9zZShuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYE9wZW5pbmcgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gYCArXHJcbiAgICAgICAgICAgIGB0byAke3RoaXMuZGF0YWJhc2VJbmZvLmhvc3R9YCk7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTaW5jZSBncnBjIGhhcyBubyBleHBsaWNpdCBvcGVuIHN0YXR1cyAob3IgZG9lcyBpdD8pIHdlXHJcbiAgICAgICAgLy8gc2ltdWxhdGUgYW4gb25PcGVuIGluIHRoZSBuZXh0IGxvb3AgYWZ0ZXIgdGhlIHN0cmVhbSBoYWQgaXQncyBsaXN0ZW5lcnNcclxuICAgICAgICAvLyByZWdpc3RlcmVkXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHN0cmVhbS5jYWxsT25PcGVuKCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIGFuZCBjbGVhbnMgdXAgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEdycGNDb25uZWN0aW9uLlxyXG4gICAgICogSWYgYSBnUlBDIGNsaWVudCBoYXMgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoaXMgY29ubmVjdGlvbiwgdGhlIGdSUEMgY2xpZW50XHJcbiAgICAgKiBpcyBjbG9zZWQuIEZhaWx1cmUgdG8gY2FsbCB0ZXJtaW5hdGUgb24gYSBHcnBjQ29ubmVjdGlvbiBjYW4gcmVzdWx0XHJcbiAgICAgKiBpbiBsZWFrZWQgcmVzb3VyY2VzIG9mIHRoZSBnUlBDIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN0dWIpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmVzdGVkID0ge1xuXHRnb29nbGU6IHtcblx0XHRuZXN0ZWQ6IHtcblx0XHRcdHByb3RvYnVmOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc1wiLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ2l0aHViLmNvbS9nb2xhbmcvcHJvdG9idWYvcHR5cGVzL3dyYXBwZXJzXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucHJvdG9idWZcIixcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJXcmFwcGVyc1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHUEJcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdG9wdGltaXplX2ZvcjogXCJTUEVFRFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFRpbWVzdGFtcDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlY29uZHM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmFub3M6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JTZXQ6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpbGVEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInBhY2thZ2VcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1YmxpY0RlcGVuZGVuY3k6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYWNrZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmljZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbGVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNvdXJjZUNvZGVJbmZvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3ludGF4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVzdGVkVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVudW1UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRW51bURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkRlY2w6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlc2VydmVkUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZE5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kZWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b25lb2ZJbmRleDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqc29uTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9ET1VCTEU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0ZMT0FUOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQ2NDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDY0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQzMjogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQ2NDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQzMjogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfQk9PTDogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU1RSSU5HOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9HUk9VUDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX01FU1NBR0U6IDExLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CWVRFUzogMTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1VJTlQzMjogMTMsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0VOVU06IDE0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TRklYRUQzMjogMTUsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDY0OiAxNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDMyOiAxNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDY0OiAxOFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX09QVElPTkFMOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfUkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVBFQVRFRDogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0T25lb2ZEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbnVtRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG51bWJlcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U2VydmljZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0TWV0aG9kRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0aW5wdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvdXRwdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNZXRob2RPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2xpZW50U3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmVyU3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRqYXZhUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YU91dGVyQ2xhc3NuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhTXVsdGlwbGVGaWxlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFTdHJpbmdDaGVja1V0Zjg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW1pemVGb3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wdGltaXplTW9kZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5LFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIlNQRUVEXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGdvUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjR2VuZXJpY1NlcnZpY2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDE2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHlHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0VuYWJsZUFyZW5hczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvYmpjQ2xhc3NQcmVmaXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjc2hhcnBOYW1lc3BhY2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MzgsXG5cdFx0XHRcdFx0XHRcdFx0Mzhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRPcHRpbWl6ZU1vZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNQRUVEOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09ERV9TSVpFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0TElURV9SVU5USU1FOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXNzYWdlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VTZXRXaXJlRm9ybWF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bm9TdGFuZGFyZERlc2NyaXB0b3JBY2Nlc3Nvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtYXBFbnRyeToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ4LFxuXHRcdFx0XHRcdFx0XHRcdDhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y3R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1RSSU5HXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhY2tlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSlNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDYsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSlNfTk9STUFMXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhenk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0d2Vhazoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0NCxcblx0XHRcdFx0XHRcdFx0XHQ0XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0Q1R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklORzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdENPUkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRTVFJJTkdfUElFQ0U6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEpTVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTk9STUFMOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfU1RSSU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTlVNQkVSOiAyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZk9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0YWxsb3dBbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2RPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTmFtZVBhcnRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpZGVudGlmaWVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lUGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNFeHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXF1aXJlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNvdXJjZUNvZGVJbmZvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMb2NhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Bhbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFpbGluZ0NvbW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVhZGluZ0RldGFjaGVkQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0R2VuZXJhdGVkQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQW5ub3RhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QW5ub3RhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzb3VyY2VGaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YmVnaW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJ1Y3Q6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibnVtYmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RyaW5nVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYm9vbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImxpc3RWYWx1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdHJ1Y3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGlzdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMaXN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHROdWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHROVUxMX1ZBTFVFOiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRMaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVtcHR5OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdERvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZsb2F0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZmxvYXRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQ2NFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SW50MzJWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qnl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEFueToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHR5cGVVcmw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJlc3RvcmU6IHtcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0djE6IHtcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0Y3NoYXJwX25hbWVzcGFjZTogXCJHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxXCIsXG5cdFx0XHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9maXJlc3RvcmUvdjE7ZmlyZXN0b3JlXCIsXG5cdFx0XHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyaXRlUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUuZmlyZXN0b3JlLnYxXCIsXG5cdFx0XHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdDRlNcIixcblx0XHRcdFx0XHRcdFx0cGhwX25hbWVzcGFjZTogXCJHb29nbGVcXFxcQ2xvdWRcXFxcRmlyZXN0b3JlXFxcXFYxXCIsXG5cdFx0XHRcdFx0XHRcdHJ1YnlfcGFja2FnZTogXCJHb29nbGU6OkNsb3VkOjpGaXJlc3RvcmU6OlYxXCJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb25SZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZUZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCaXRTZXF1ZW5jZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Yml0bWFwOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJsb29tRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQml0U2VxdWVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNoQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFBhdGhzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFByZWNvbmRpdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uZGl0aW9uVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZXhpc3RzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleGlzdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRyYW5zYWN0aW9uT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZE9ubHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRXcml0ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE9ubHk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJSZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0cnlUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJib29sZWFuVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImludGVnZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG91YmxlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVzdGFtcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYnl0ZXNWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImdlb1BvaW50VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1hcFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJvb2xlYW5WYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZXN0YW1wVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGdlb1BvaW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUudHlwZS5MYXRMbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWFwVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdE1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RmlyZXN0b3JlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5kZWZhdWx0X2hvc3QpXCI6IFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm9hdXRoX3Njb3BlcylcIjogXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlXCJcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG1ldGhvZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEdldERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkdldERvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3REb2N1bWVudHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJVcGRhdGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBhdGNoXCI6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiZG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZG9jdW1lbnQsdXBkYXRlX21hc2tcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdGNoOiBcIi92MS97ZG9jdW1lbnQubmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiRGVsZXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJuYW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaEdldERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNvbW1pdFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkNvbW1pdFJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx3cml0ZXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJvbGxiYWNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJvbGxiYWNrUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkVtcHR5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2UsdHJhbnNhY3Rpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UnVuUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUGFydGl0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIldyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0U3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czp3cml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3Rlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0ZW5SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0ZW5SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmxpc3RlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmF0Y2hXcml0ZVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNyZWF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93TWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDcmVhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VXBkYXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmb3VuZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWlzc2luZ1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1pc3Npbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Q29tbWl0UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSb2xsYmFja1JlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c2tpcHBlZFJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFnZ3JlZ2F0aW9uUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25Db3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFydGl0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0ZW5SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFkZFRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlVGFyZ2V0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmlsdGVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnREZWxldGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudERlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50UmVtb3ZlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRSZW1vdmVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFeGlzdGVuY2VGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZXN1bWVUb2tlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUXVlcnlUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudHNUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGV4cGVjdGVkQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0RG9jdW1lbnRzVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UXVlcnlUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F1c2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT19DSEFOR0U6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0QUREOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFTU9WRTogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRDVVJSRU5UOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFU0VUOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaFdyaXRlUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnJwYy5TdGF0dXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJvamVjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZyb206IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbGxlY3Rpb25TZWxlY3RvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdoZXJlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3JkZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydEF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kQXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxpbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Q29sbGVjdGlvblNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhbGxEZXNjZW5kYW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidW5hcnlGaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5hcnlGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5hcnlGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBTkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9SOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0TEVTU19USEFOOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU5fT1JfRVFVQUw6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEdSRUFURVJfVEhBTjogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOX09SX0VRVUFMOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRFUVVBTDogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0VRVUFMOiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBUlJBWV9DT05UQUlOUzogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SU46IDgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TX0FOWTogOSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0lOOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhbmRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OQU46IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05VTEw6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OQU46IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OVUxMOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0T3JkZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGlyZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkUmVmZXJlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UHJvamVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGlyZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERJUkVDVElPTl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBU0NFTkRJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0REVTQ0VORElORzogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRTdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJhdmdcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3VtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXZnOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkF2Z1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFsaWFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXBUbzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBdmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDdXJzb3I6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWZvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidmVyaWZ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2Zvcm1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZlcmlmeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlTWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtLkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkVHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic2V0VG9TZXJ2ZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImluY3JlbWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1heGltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaW5pbXVtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlQWxsRnJvbUFycmF5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUb1NlcnZlclZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4aW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbmltdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEZyb21BcnJheToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTRVJWRVJfVkFMVUVfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFUVVFU1RfVElNRTogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4aXN0ZW5jZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1bmNoYW5nZWROYW1lczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkJsb29tRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YXBpOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvYXBpL2Fubm90YXRpb25zO2Fubm90YXRpb25zXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJIdHRwUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5hcGlcIixcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHQVBJXCIsXG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRodHRwOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRpZDogNzIyOTU3MjgsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SHR0cDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHJ1bGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwUnVsZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicHV0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBvc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBhdGNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGdldDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHV0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwb3N0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwYXRjaDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y3VzdG9tOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXN0b21IdHRwUGF0dGVyblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsQmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRDdXN0b21IdHRwUGF0dGVybjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1ldGhvZFNpZ25hdHVyZToge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUxLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRlZmF1bHRIb3N0OiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNDksXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG9hdXRoU2NvcGVzOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTAsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLmFwaS5GaWVsZEJlaGF2aW9yXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1Mixcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRGSUVMRF9CRUhBVklPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0T1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFJFUVVJUkVEOiAyLFxuXHRcdFx0XHRcdFx0XHRPVVRQVVRfT05MWTogMyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfT05MWTogNCxcblx0XHRcdFx0XHRcdFx0SU1NVVRBQkxFOiA1LFxuXHRcdFx0XHRcdFx0XHRVTk9SREVSRURfTElTVDogNixcblx0XHRcdFx0XHRcdFx0Tk9OX0VNUFRZX0RFRkFVTFQ6IDdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0eXBlOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy90eXBlL2xhdGxuZztsYXRsbmdcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkxhdExuZ1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUudHlwZVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdUUFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdExhdExuZzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGxhdGl0dWRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRsb25naXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRycGM6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3JwYy9zdGF0dXM7c3RhdHVzXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJTdGF0dXNQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLnJwY1wiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIlJQQ1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFN0YXR1czoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5BbnlcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHByb3RvcyA9IHtcblx0bmVzdGVkOiBuZXN0ZWRcbn07XG5cbnZhciBwcm90b3MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBuZXN0ZWQ6IG5lc3RlZCxcbiAgJ2RlZmF1bHQnOiBwcm90b3Ncbn0pO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVXNlZCBieSB0ZXN0cyBzbyB3ZSBjYW4gbWF0Y2ggQGdycGMvcHJvdG8tbG9hZGVyIGJlaGF2aW9yLiAqL1xyXG5jb25zdCBwcm90b0xvYWRlck9wdGlvbnMgPSB7XHJcbiAgICBsb25nczogU3RyaW5nLFxyXG4gICAgZW51bXM6IFN0cmluZyxcclxuICAgIGRlZmF1bHRzOiB0cnVlLFxyXG4gICAgb25lb2ZzOiBmYWxzZVxyXG59O1xyXG4vKipcclxuICogTG9hZHMgdGhlIHByb3RvY29sIGJ1ZmZlciBkZWZpbml0aW9ucyBmb3IgRmlyZXN0b3JlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgR3JwY09iamVjdCByZXByZXNlbnRpbmcgb3VyIHByb3Rvcy5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRQcm90b3MoKSB7XHJcbiAgICBjb25zdCBwYWNrYWdlRGVmaW5pdGlvbiA9IHByb3RvTG9hZGVyLmZyb21KU09OKHByb3RvcyQxLCBwcm90b0xvYWRlck9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGdycGMubG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWZpbml0aW9uKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogTG9hZHMgdGhlIEdSUEMgc3RhY2sgKi9cclxuZnVuY3Rpb24gbmV3Q29ubmVjdGlvbihkYXRhYmFzZUluZm8pIHtcclxuICAgIGNvbnN0IHByb3RvcyA9IGxvYWRQcm90b3MoKTtcclxuICAgIHJldHVybiBuZXcgR3JwY0Nvbm5lY3Rpb24ocHJvdG9zLCBkYXRhYmFzZUluZm8pO1xyXG59XHJcbi8qKiBSZXR1cm4gdGhlIFBsYXRmb3JtLXNwZWNpZmljIGNvbm5lY3Rpdml0eSBtb25pdG9yLiAqL1xyXG5mdW5jdGlvbiBuZXdDb25uZWN0aXZpdHlNb25pdG9yKCkge1xyXG4gICAgcmV0dXJuIG5ldyBOb29wQ29ubmVjdGl2aXR5TW9uaXRvcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBUaGUgUGxhdGZvcm0ncyAnd2luZG93JyBpbXBsZW1lbnRhdGlvbiBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuICovXHJcbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5VU0VfTU9DS19QRVJTSVNURU5DRSA9PT0gJ1lFUycpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKiBUaGUgUGxhdGZvcm0ncyAnZG9jdW1lbnQnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpIHtcclxuICAgIHJldHVybiBuZXcgSnNvblByb3RvU2VyaWFsaXplcihkYXRhYmFzZUlkLCAvKiB1c2VQcm90bzNKc29uPSAqLyBmYWxzZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ4ID0gJ0V4cG9uZW50aWFsQmFja29mZic7XHJcbi8qKlxyXG4gKiBJbml0aWFsIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgYW4gZXJyb3IuXHJcbiAqIFNldCB0byAxcyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDEuNTtcclxuLyoqIE1heGltdW0gYmFja29mZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TID0gNjAgKiAxMDAwO1xyXG4vKipcclxuICogQSBoZWxwZXIgZm9yIHJ1bm5pbmcgZGVsYXllZCB0YXNrcyBmb2xsb3dpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBjdXJ2ZVxyXG4gKiBiZXR3ZWVuIGF0dGVtcHRzLlxyXG4gKlxyXG4gKiBFYWNoIGRlbGF5IGlzIG1hZGUgdXAgb2YgYSBcImJhc2VcIiBkZWxheSB3aGljaCBmb2xsb3dzIHRoZSBleHBvbmVudGlhbFxyXG4gKiBiYWNrb2ZmIGN1cnZlLCBhbmQgYSArLy0gNTAlIFwiaml0dGVyXCIgdGhhdCBpcyBjYWxjdWxhdGVkIGFuZCBhZGRlZCB0byB0aGVcclxuICogYmFzZSBkZWxheS4gVGhpcyBwcmV2ZW50cyBjbGllbnRzIGZyb20gYWNjaWRlbnRhbGx5IHN5bmNocm9uaXppbmcgdGhlaXJcclxuICogZGVsYXlzIGNhdXNpbmcgc3Bpa2VzIG9mIGxvYWQgdG8gdGhlIGJhY2tlbmQuXHJcbiAqL1xyXG5jbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBBc3luY1F1ZXVlIHRvIHJ1biBiYWNrb2ZmIG9wZXJhdGlvbnMgb24uXHJcbiAgICAgKi9cclxuICAgIHF1ZXVlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIElEIHRvIHVzZSB3aGVuIHNjaGVkdWxpbmcgYmFja29mZiBvcGVyYXRpb25zIG9uIHRoZSBBc3luY1F1ZXVlLlxyXG4gICAgICovXHJcbiAgICB0aW1lcklkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluaXRpYWwgZGVsYXkgKHVzZWQgYXMgdGhlIGJhc2UgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5IGF0dGVtcHQpLlxyXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcclxuICAgICAqIGxpdHRsZSBhcyAwLjUqaW5pdGlhbERlbGF5TXMuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX0lOSVRJQUxfREVMQVlfTVMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbXVsdGlwbGllciB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBleHRlbmRlZCBiYXNlIGRlbGF5IGFmdGVyIGVhY2hcclxuICAgICAqIGF0dGVtcHQuXHJcbiAgICAgKi9cclxuICAgIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYmFzZSBkZWxheSBhZnRlciB3aGljaCBubyBmdXJ0aGVyIGJhY2tvZmYgaXMgcGVyZm9ybWVkLlxyXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcclxuICAgICAqIG11Y2ggYXMgMS41Km1heERlbGF5TXMuXHJcbiAgICAgKi9cclxuICAgIG1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TKSB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHRoaXMudGltZXJJZCA9IHRpbWVySWQ7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IGluaXRpYWxEZWxheU1zO1xyXG4gICAgICAgIHRoaXMuYmFja29mZkZhY3RvciA9IGJhY2tvZmZGYWN0b3I7XHJcbiAgICAgICAgdGhpcy5tYXhEZWxheU1zID0gbWF4RGVsYXlNcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xyXG4gICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGxhc3QgYmFja29mZiBhdHRlbXB0LCBhcyBlcG9jaCBtaWxsaXNlY29uZHMuICovXHJcbiAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSB2ZXJ5IG5leHQgYmFja29mZkFuZFdhaXQoKSB3aWxsIGhhdmUgbm8gZGVsYXkuIElmIGl0IGlzIGNhbGxlZCBhZ2FpblxyXG4gICAgICogKGkuZS4gZHVlIHRvIGFuIGVycm9yKSwgaW5pdGlhbERlbGF5TXMgKHBsdXMgaml0dGVyKSB3aWxsIGJlIHVzZWQsIGFuZFxyXG4gICAgICogc3Vic2VxdWVudCBvbmVzIHdpbGwgaW5jcmVhc2UgYWNjb3JkaW5nIHRvIHRoZSBiYWNrb2ZmRmFjdG9yLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gdGhlIG1heGltdW0gZGVsYXkgKGUuZy4gZm9yIHVzZSBhZnRlciBhXHJcbiAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IpLlxyXG4gICAgICovXHJcbiAgICByZXNldFRvTWF4KCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBjdXJyZW50RGVsYXlNcywgYW5kIGluY3JlYXNlcyB0aGVcclxuICAgICAqIGRlbGF5IGZvciBhbnkgc3Vic2VxdWVudCBhdHRlbXB0cy4gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvblxyXG4gICAgICogYWxyZWFkeSwgaXQgd2lsbCBiZSBjYW5jZWxlZC5cclxuICAgICAqL1xyXG4gICAgYmFja29mZkFuZFJ1bihvcCkge1xyXG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvbi5cclxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xyXG4gICAgICAgIC8vIEZpcnN0IHNjaGVkdWxlIHVzaW5nIHRoZSBjdXJyZW50IGJhc2UgKHdoaWNoIG1heSBiZSAwIGFuZCBzaG91bGQgYmVcclxuICAgICAgICAvLyBob25vcmVkIGFzIHN1Y2gpLlxyXG4gICAgICAgIGNvbnN0IGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyA9IE1hdGguZmxvb3IodGhpcy5jdXJyZW50QmFzZU1zICsgdGhpcy5qaXR0ZXJEZWxheU1zKCkpO1xyXG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgbGFzdEF0dGVtcHRUaW1lIGJlaW5nIGluIHRoZSBmdXR1cmUgZHVlIHRvIGEgY2xvY2sgY2hhbmdlLlxyXG4gICAgICAgIGNvbnN0IGRlbGF5U29GYXJNcyA9IE1hdGgubWF4KDAsIERhdGUubm93KCkgLSB0aGlzLmxhc3RBdHRlbXB0VGltZSk7XHJcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgYmFja29mZiBkZWxheSBhbHJlYWR5IGJlaW5nIHBhc3QuXHJcbiAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXlNcyA9IE1hdGgubWF4KDAsIGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyAtIGRlbGF5U29GYXJNcyk7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlbGF5TXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOCwgYEJhY2tpbmcgb2ZmIGZvciAke3JlbWFpbmluZ0RlbGF5TXN9IG1zIGAgK1xyXG4gICAgICAgICAgICAgICAgYChiYXNlIGRlbGF5OiAke3RoaXMuY3VycmVudEJhc2VNc30gbXMsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlbGF5IHdpdGggaml0dGVyOiAke2Rlc2lyZWREZWxheVdpdGhKaXR0ZXJNc30gbXMsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGxhc3QgYXR0ZW1wdDogJHtkZWxheVNvRmFyTXN9IG1zIGFnbylgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMudGltZXJJZCwgcmVtYWluaW5nRGVsYXlNcywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFwcGx5IGJhY2tvZmYgZmFjdG9yIHRvIGRldGVybWluZSBuZXh0IGRlbGF5IGFuZCBlbnN1cmUgaXQgaXMgd2l0aGluXHJcbiAgICAgICAgLy8gYm91bmRzLlxyXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyAqPSB0aGlzLmJhY2tvZmZGYWN0b3I7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA8IHRoaXMuaW5pdGlhbERlbGF5TXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5pbml0aWFsRGVsYXlNcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhc2VNcyA+IHRoaXMubWF4RGVsYXlNcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLm1heERlbGF5TXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLnNraXBEZWxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVyUHJvbWlzZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGluIHRoZSByYW5nZSBbLWN1cnJlbnRCYXNlTXMvMiwgY3VycmVudEJhc2VNcy8yXSAqL1xyXG4gICAgaml0dGVyRGVsYXlNcygpIHtcclxuICAgICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5jdXJyZW50QmFzZU1zO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckNyA9ICdQZXJzaXN0ZW50U3RyZWFtJztcclxuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gYWZ0ZXIgaXQgaXMgbWFya2VkIGlkbGUuICovXHJcbmNvbnN0IElETEVfVElNRU9VVF9NUyA9IDYwICogMTAwMDtcclxuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gdW50aWwgd2UgY29uc2lkZXIgaXQgaGVhbHRoeS4gKi9cclxuY29uc3QgSEVBTFRIWV9USU1FT1VUX01TID0gMTAgKiAxMDAwO1xyXG4vKipcclxuICogQSBQZXJzaXN0ZW50U3RyZWFtIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc3RyZWFtaW5nIFJQQ1xyXG4gKiB0byB0aGUgRmlyZXN0b3JlIGJhY2tlbmQuIEl0J3MgYnVpbHQgb24gdG9wIG9mIHRoZSBjb25uZWN0aW9ucyBvd24gc3VwcG9ydFxyXG4gKiBmb3Igc3RyZWFtaW5nIFJQQ3MsIGFuZCBhZGRzIHNldmVyYWwgY3JpdGljYWwgZmVhdHVyZXMgZm9yIG91ciBjbGllbnRzOlxyXG4gKlxyXG4gKiAgIC0gRXhwb25lbnRpYWwgYmFja29mZiBvbiBmYWlsdXJlXHJcbiAqICAgLSBBdXRoZW50aWNhdGlvbiB2aWEgQ3JlZGVudGlhbHNQcm92aWRlclxyXG4gKiAgIC0gRGlzcGF0Y2hpbmcgYWxsIGNhbGxiYWNrcyBpbnRvIHRoZSBzaGFyZWQgd29ya2VyIHF1ZXVlXHJcbiAqICAgLSBDbG9zaW5nIGlkbGUgc3RyZWFtcyBhZnRlciA2MCBzZWNvbmRzIG9mIGluYWN0aXZpdHlcclxuICpcclxuICogU3ViY2xhc3NlcyBvZiBQZXJzaXN0ZW50U3RyZWFtIGltcGxlbWVudCBzZXJpYWxpemF0aW9uIG9mIG1vZGVscyB0byBhbmRcclxuICogZnJvbSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdG9jb2wgYnVmZmVycyBmb3IgYSBzcGVjaWZpY1xyXG4gKiBzdHJlYW1pbmcgUlBDLlxyXG4gKlxyXG4gKiAjIyBTdGFydGluZyBhbmQgU3RvcHBpbmdcclxuICpcclxuICogU3RyZWFtaW5nIFJQQ3MgYXJlIHN0YXRlZnVsIGFuZCBuZWVkIHRvIGJlIHN0YXJ0KCllZCBiZWZvcmUgbWVzc2FnZXMgY2FuXHJcbiAqIGJlIHNlbnQgYW5kIHJlY2VpdmVkLiBUaGUgUGVyc2lzdGVudFN0cmVhbSB3aWxsIGNhbGwgdGhlIG9uT3BlbigpIGZ1bmN0aW9uXHJcbiAqIG9mIHRoZSBsaXN0ZW5lciBvbmNlIHRoZSBzdHJlYW0gaXMgcmVhZHkgdG8gYWNjZXB0IHJlcXVlc3RzLlxyXG4gKlxyXG4gKiBTaG91bGQgYSBzdGFydCgpIGZhaWwsIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSByZWdpc3RlcmVkIG9uQ2xvc2UoKVxyXG4gKiBsaXN0ZW5lciB3aXRoIGEgRmlyZXN0b3JlRXJyb3IgaW5kaWNhdGluZyB3aGF0IHdlbnQgd3JvbmcuXHJcbiAqXHJcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCByZXBlYXRlZGx5LlxyXG4gKlxyXG4gKiBHZW5lcmljIHR5cGVzOlxyXG4gKiAgU2VuZFR5cGU6IFRoZSB0eXBlIG9mIHRoZSBvdXRnb2luZyBtZXNzYWdlIG9mIHRoZSB1bmRlcmx5aW5nXHJcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXHJcbiAqICBSZWNlaXZlVHlwZTogVGhlIHR5cGUgb2YgdGhlIGluY29taW5nIG1lc3NhZ2Ugb2YgdGhlIHVuZGVybHlpbmdcclxuICogICAgY29ubmVjdGlvbiBzdHJlYW1cclxuICogIExpc3RlbmVyVHlwZTogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjYWxsYmFja3NcclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbnRTdHJlYW0ge1xyXG4gICAgY29uc3RydWN0b3IocXVldWUsIGNvbm5lY3Rpb25UaW1lcklkLCBpZGxlVGltZXJJZCwgaGVhbHRoVGltZXJJZCwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgbGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZXJJZCA9IGlkbGVUaW1lcklkO1xyXG4gICAgICAgIHRoaXMuaGVhbHRoVGltZXJJZCA9IGhlYWx0aFRpbWVySWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyID0gYXV0aENyZWRlbnRpYWxzUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIgPSBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xvc2UgY291bnQgdGhhdCdzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgdGhlIHN0cmVhbSBpcyBjbG9zZWQ7IHVzZWQgYnlcclxuICAgICAgICAgKiBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKCkgdG8gaW52YWxpZGF0ZSBjYWxsYmFja3MgdGhhdCBoYXBwZW4gYWZ0ZXJcclxuICAgICAgICAgKiBjbG9zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsb3NlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RhcnQoKSBoYXMgYmVlbiBjYWxsZWQgYW5kIG5vIGVycm9yIGhhcyBvY2N1cnJlZC4gVHJ1ZVxyXG4gICAgICogaW5kaWNhdGVzIHRoZSBzdHJlYW0gaXMgb3BlbiBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nICh3aGljaFxyXG4gICAgICogZW5jb21wYXNzZXMgcmVzcGVjdGluZyBiYWNrb2ZmLCBnZXR0aW5nIGF1dGggdG9rZW5zLCBhbmQgc3RhcnRpbmcgdGhlXHJcbiAgICAgKiBhY3R1YWwgUlBDKS4gVXNlIGlzT3BlbigpIHRvIGRldGVybWluZSBpZiB0aGUgc3RyZWFtIGlzIG9wZW4gYW5kIHJlYWR5IGZvclxyXG4gICAgICogb3V0Ym91bmQgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIGlzU3RhcnRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IDUgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkJhY2tvZmYgKi8gfHxcclxuICAgICAgICAgICAgdGhpcy5pc09wZW4oKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBSUEMgaXMgb3BlbiAodGhlIG9uT3BlbigpIGxpc3RlbmVyIGhhcyBiZWVuXHJcbiAgICAgKiBjYWxsZWQpIGFuZCB0aGUgc3RyZWFtIGlzIHJlYWR5IGZvciBvdXRib3VuZCByZXF1ZXN0cy5cclxuICAgICAqL1xyXG4gICAgaXNPcGVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLyB8fFxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBSUEMuIE9ubHkgYWxsb3dlZCBpZiBpc1N0YXJ0ZWQoKSByZXR1cm5zIGZhbHNlLiBUaGUgc3RyZWFtIGlzXHJcbiAgICAgKiBub3QgaW1tZWRpYXRlbHkgcmVhZHkgZm9yIHVzZTogb25PcGVuKCkgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIFJQQyBpc1xyXG4gICAgICogcmVhZHkgZm9yIG91dGJvdW5kIHJlcXVlc3RzLCBhdCB3aGljaCBwb2ludCBpc09wZW4oKSB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gc3RhcnQgcmV0dXJucywgaXNTdGFydGVkKCkgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybUJhY2tvZmYoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF1dGgoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIFJQQy4gVGhpcyBjYWxsIGlzIGlkZW1wb3RlbnQgYW5kIGFsbG93ZWQgcmVnYXJkbGVzcyBvZiB0aGVcclxuICAgICAqIGN1cnJlbnQgaXNTdGFydGVkKCkgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBzdG9wIHJldHVybnMsIGlzU3RhcnRlZCgpIGFuZCBpc09wZW4oKSB3aWxsIGJvdGggcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnRlZCgpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZnRlciBhbiBlcnJvciB0aGUgc3RyZWFtIHdpbGwgdXN1YWxseSBiYWNrIG9mZiBvbiB0aGUgbmV4dCBhdHRlbXB0IHRvXHJcbiAgICAgKiBzdGFydCBpdC4gSWYgdGhlIGVycm9yIHdhcnJhbnRzIGFuIGltbWVkaWF0ZSByZXN0YXJ0IG9mIHRoZSBzdHJlYW0sIHRoZVxyXG4gICAgICogc2VuZGVyIGNhbiB1c2UgdGhpcyB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZWNlaXZlciBzaG91bGQgbm90IGJhY2sgb2ZmLlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggZXJyb3Igd2lsbCBjYWxsIHRoZSBvbkNsb3NlKCkgbGlzdGVuZXIuIFRoYXQgZnVuY3Rpb24gY2FuIGRlY2lkZSB0b1xyXG4gICAgICogaW5oaWJpdCBiYWNrb2ZmIGlmIHJlcXVpcmVkLlxyXG4gICAgICovXHJcbiAgICBpbmhpYml0QmFja29mZigpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcclxuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgdGhpcyBzdHJlYW0gYXMgaWRsZS4gSWYgbm8gZnVydGhlciBhY3Rpb25zIGFyZSBwZXJmb3JtZWQgb24gdGhlXHJcbiAgICAgKiBzdHJlYW0gZm9yIG9uZSBtaW51dGUsIHRoZSBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlIGl0c2VsZiBhbmRcclxuICAgICAqIG5vdGlmeSB0aGUgc3RyZWFtJ3Mgb25DbG9zZSgpIGhhbmRsZXIgd2l0aCBTdGF0dXMuT0suIFRoZSBzdHJlYW0gd2lsbCB0aGVuXHJcbiAgICAgKiBiZSBpbiBhICFpc1N0YXJ0ZWQoKSBzdGF0ZSwgcmVxdWlyaW5nIHRoZSBjYWxsZXIgdG8gc3RhcnQgdGhlIHN0cmVhbSBhZ2FpblxyXG4gICAgICogYmVmb3JlIGZ1cnRoZXIgdXNlLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgc3RyZWFtcyB0aGF0IGFyZSBpbiBzdGF0ZSAnT3BlbicgY2FuIGJlIG1hcmtlZCBpZGxlLCBhcyBhbGwgb3RoZXJcclxuICAgICAqIHN0YXRlcyBpbXBseSBwZW5kaW5nIG5ldHdvcmsgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgbWFya0lkbGUoKSB7XHJcbiAgICAgICAgLy8gU3RhcnRzIHRoZSBpZGxlIHRpbWUgaWYgd2UgYXJlIGluIHN0YXRlICdPcGVuJyBhbmQgYXJlIG5vdCB5ZXQgYWxyZWFkeVxyXG4gICAgICAgIC8vIHJ1bm5pbmcgYSB0aW1lciAoaW4gd2hpY2ggY2FzZSB0aGUgcHJldmlvdXMgaWRsZSB0aW1lb3V0IHN0aWxsIGFwcGxpZXMpLlxyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpICYmIHRoaXMuaWRsZVRpbWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLmlkbGVUaW1lcklkLCBJRExFX1RJTUVPVVRfTVMsICgpID0+IHRoaXMuaGFuZGxlSWRsZUNsb3NlVGltZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uICovXHJcbiAgICBzZW5kUmVxdWVzdChtc2cpIHtcclxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLnNlbmQobXNnKTtcclxuICAgIH1cclxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIGlkbGUgdGltZXIgd2hlbiB0aGUgc3RyZWFtIHNob3VsZCBjbG9zZSBkdWUgdG8gaW5hY3Rpdml0eS4gKi9cclxuICAgIGFzeW5jIGhhbmRsZUlkbGVDbG9zZVRpbWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGltaW5nIG91dCBhbiBpZGxlIHN0cmVhbSB0aGVyZSdzIG5vIHJlYXNvbiB0byBmb3JjZSB0aGUgc3RyZWFtIGludG8gYmFja29mZiB3aGVuXHJcbiAgICAgICAgICAgIC8vIGl0IHJlc3RhcnRzIHNvIHNldCB0aGUgc3RyZWFtIHN0YXRlIHRvIEluaXRpYWwgaW5zdGVhZCBvZiBFcnJvci5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIE1hcmtzIHRoZSBzdHJlYW0gYXMgYWN0aXZlIGFnYWluLiAqL1xyXG4gICAgY2FuY2VsSWRsZUNoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBDYW5jZWxzIHRoZSBoZWFsdGggY2hlY2sgZGVsYXllZCBvcGVyYXRpb24uICovXHJcbiAgICBjYW5jZWxIZWFsdGhDaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFsdGhDaGVjaykge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAgYXMgbmVjZXNzYXJ5OlxyXG4gICAgICpcclxuICAgICAqICogY2xvc2VzIHRoZSB1bmRlcmx5aW5nIEdSUEMgc3RyZWFtO1xyXG4gICAgICogKiBjYWxscyB0aGUgb25DbG9zZSBoYW5kbGVyIHdpdGggdGhlIGdpdmVuICdlcnJvcic7XHJcbiAgICAgKiAqIHNldHMgaW50ZXJuYWwgc3RyZWFtIHN0YXRlIHRvICdmaW5hbFN0YXRlJztcclxuICAgICAqICogYWRqdXN0cyB0aGUgYmFja29mZiB0aW1lciBiYXNlZCBvbiB0aGUgZXJyb3JcclxuICAgICAqXHJcbiAgICAgKiBBIG5ldyBzdHJlYW0gY2FuIGJlIG9wZW5lZCBieSBjYWxsaW5nIHN0YXJ0KCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbmFsU3RhdGUgLSB0aGUgaW50ZW5kZWQgc3RhdGUgb2YgdGhlIHN0cmVhbSBhZnRlciBjbG9zaW5nLlxyXG4gICAgICogQHBhcmFtIGVycm9yIC0gdGhlIGVycm9yIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgd2l0aC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY2xvc2UoZmluYWxTdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBDYW5jZWwgYW55IG91dHN0YW5kaW5nIHRpbWVycyAodGhleSdyZSBndWFyYW50ZWVkIG5vdCB0byBleGVjdXRlKS5cclxuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsSGVhbHRoQ2hlY2soKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmYuY2FuY2VsKCk7XHJcbiAgICAgICAgLy8gSW52YWxpZGF0ZXMgYW55IHN0cmVhbS1yZWxhdGVkIGNhbGxiYWNrcyAoZS5nLiBmcm9tIGF1dGggb3IgdGhlXHJcbiAgICAgICAgLy8gdW5kZXJseWluZyBzdHJlYW0pLCBndWFyYW50ZWVpbmcgdGhleSB3b24ndCBleGVjdXRlLlxyXG4gICAgICAgIHRoaXMuY2xvc2VDb3VudCsrO1xyXG4gICAgICAgIGlmIChmaW5hbFN0YXRlICE9PSA0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGludGVudGlvbmFsIGNsb3NlIGVuc3VyZSB3ZSBkb24ndCBkZWxheSBvdXIgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRCkge1xyXG4gICAgICAgICAgICAvLyBMb2cgdGhlIGVycm9yLiAoUHJvYmFibHkgZWl0aGVyICdxdW90YSBleGNlZWRlZCcgb3IgJ21heCBxdWV1ZSBsZW5ndGggcmVhY2hlZCcuKVxyXG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ1VzaW5nIG1heGltdW0gYmFja29mZiBkZWxheSB0byBwcmV2ZW50IG92ZXJsb2FkaW5nIHRoZSBiYWNrZW5kLicpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXRUb01heCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJlxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKSB7XHJcbiAgICAgICAgICAgIC8vIFwidW5hdXRoZW50aWNhdGVkXCIgZXJyb3IgbWVhbnMgdGhlIHRva2VuIHdhcyByZWplY3RlZC4gVGhpcyBzaG91bGQgcmFyZWx5XHJcbiAgICAgICAgICAgIC8vIGhhcHBlbiBzaW5jZSBib3RoIEF1dGggYW5kIEFwcENoZWNrIGVuc3VyZSBhIHN1ZmZpY2llbnQgVFRMIHdoZW4gd2VcclxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhIHRva2VuLiBJZiBhIHVzZXIgbWFudWFsbHkgcmVzZXRzIHRoZWlyIHN5c3RlbSBjbG9jayB0aGlzIGNhblxyXG4gICAgICAgICAgICAvLyBmYWlsLCBob3dldmVyLiBJbiB0aGlzIGNhc2UsIHdlIHNob3VsZCBnZXQgYSBDb2RlLlVOQVVUSEVOVElDQVRFRCBlcnJvclxyXG4gICAgICAgICAgICAvLyBiZWZvcmUgd2UgcmVjZWl2ZWQgdGhlIGZpcnN0IG1lc3NhZ2UgYW5kIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSB0aGUgdG9rZW5cclxuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgd2UgZmV0Y2ggYSBuZXcgdG9rZW4uXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdW5kZXJseWluZyBzdHJlYW0gYmVjYXVzZSB3ZSBhcmUgbm8gbG9uZ2VyIGludGVyZXN0ZWQgaW4gZXZlbnRzLlxyXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRlYXJEb3duKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyBzdGF0ZSBtdXN0IGJlIGFzc2lnbmVkIGJlZm9yZSBjYWxsaW5nIG9uQ2xvc2UoKSB0byBhbGxvdyB0aGUgY2FsbGJhY2sgdG9cclxuICAgICAgICAvLyBpbmhpYml0IGJhY2tvZmYgb3Igb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdGhlIHN0YXRlIGluIGl0cyBub24tc3RhcnRlZCBzdGF0ZS5cclxuICAgICAgICB0aGlzLnN0YXRlID0gZmluYWxTdGF0ZTtcclxuICAgICAgICAvLyBOb3RpZnkgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIHN0cmVhbSBjbG9zZWQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5saXN0ZW5lci5vbkNsb3NlKGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG92ZXJyaWRkZW4gdG8gcGVyZm9ybSBhZGRpdGlvbmFsIGNsZWFudXAgYmVmb3JlIHRoZSBzdHJlYW0gaXMgY2xvc2VkLlxyXG4gICAgICogQ2FsbGluZyBzdXBlci50ZWFyRG93bigpIGlzIG5vdCByZXF1aXJlZC5cclxuICAgICAqL1xyXG4gICAgdGVhckRvd24oKSB7IH1cclxuICAgIGF1dGgoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovO1xyXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoSWZOb3RDbG9zZWQgPSB0aGlzLmdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIodGhpcy5jbG9zZUNvdW50KTtcclxuICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWQsIGJ1dCBzZWUgVE9ETyBiZWxvdy5cclxuICAgICAgICBjb25zdCBjbG9zZUNvdW50ID0gdGhpcy5jbG9zZUNvdW50O1xyXG4gICAgICAgIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgLy8gU3RyZWFtIGNhbiBiZSBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIGF1dGhlbnRpY2F0aW9uLlxyXG4gICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IFdlIHJlYWxseSBzaG91bGQganVzdCB1c2UgZGlzcGF0Y2hJZk5vdENsb3NlZFxyXG4gICAgICAgICAgICAvLyBhbmQgbGV0IHRoaXMgZGlzcGF0Y2ggb250byB0aGUgcXVldWUsIGJ1dCB0aGF0IG9wZW5lZCBhIHNwZWMgdGVzdCBjYW5cclxuICAgICAgICAgICAgLy8gb2Ygd29ybXMgdGhhdCBJIGRvbid0IHdhbnQgdG8gZGVhbCB3aXRoIGluIHRoaXMgUFIuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlQ291bnQgPT09IGNsb3NlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaGF2ZSB0byBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgb24gdGhlIEFzeW5jUXVldWUuXHJcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgZm9sbG93aW5nIGNhbGxzIGFyZSBzYWZlIHRvIGJlIGNhbGxlZCBvdXRzaWRlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gQXN5bmNRdWV1ZSBzaW5jZSB0aGV5IGRvbid0IGNoYWluIGFzeW5jaHJvbm91cyBjYWxsc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcnBjRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCAnRmV0Y2hpbmcgYXV0aCB0b2tlbiBmYWlsZWQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUNsb3NlKHJwY0Vycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub25Db25uZWN0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHRoaXMubGlzdGVuZXIub25Db25uZWN0ZWQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub25PcGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaGVhbHRoVGltZXJJZCwgSEVBTFRIWV9USU1FT1VUX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkhlYWx0aHkgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25PcGVuKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uQ2xvc2UoKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtQ2xvc2UoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbk1lc3NhZ2UoKG1zZykgPT4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBlcmZvcm1CYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA1IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5CYWNrb2ZmICovO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RzXHJcbiAgICBoYW5kbGVTdHJlYW1DbG9zZShlcnJvcikge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgYGNsb3NlIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGUgc3RyZWFtIGNvdWxkIGNsb3NlIGNsZWFubHksIGhvd2V2ZXIsIGluIG91ciBjdXJyZW50IG1vZGVsXHJcbiAgICAgICAgLy8gd2UgbmV2ZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlY2F1c2UgaWYgd2Ugc3RvcCBhIHN0cmVhbSBvdXJzZWx2ZXMsXHJcbiAgICAgICAgLy8gdGhpcyBjYWxsYmFjayB3aWxsIG5ldmVyIGJlIGNhbGxlZC4gVG8gcHJldmVudCBjYXNlcyB3aGVyZSB3ZSByZXRyeVxyXG4gICAgICAgIC8vIHdpdGhvdXQgYSBiYWNrb2ZmIGFjY2lkZW50YWxseSwgd2Ugc2V0IHRoZSBzdHJlYW0gdG8gZXJyb3IgaW4gYWxsIGNhc2VzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBcImRpc3BhdGNoZXJcIiBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb3BlcmF0aW9ucyBvbnRvIHRoZVxyXG4gICAgICogQXN5bmNRdWV1ZSBidXQgb25seSBydW5zIHRoZW0gaWYgY2xvc2VDb3VudCByZW1haW5zIHVuY2hhbmdlZC4gVGhpcyBhbGxvd3NcclxuICAgICAqIHVzIHRvIHR1cm4gYXV0aCAvIHN0cmVhbSBjYWxsYmFja3MgaW50byBuby1vcHMgaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQgL1xyXG4gICAgICogcmUtb3BlbmVkLCBldGMuXHJcbiAgICAgKi9cclxuICAgIGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIoc3RhcnRDbG9zZUNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChmbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VDb3VudCA9PT0gc3RhcnRDbG9zZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDcsICdzdHJlYW0gY2FsbGJhY2sgc2tpcHBlZCBieSBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBQZXJzaXN0ZW50U3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgTGlzdGVuIFJQQy5cclxuICpcclxuICogT25jZSB0aGUgTGlzdGVuIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBvbk9wZW4oKSBsaXN0ZW5lciwgYW55IG51bWJlciBvZlxyXG4gKiBsaXN0ZW4oKSBhbmQgdW5saXN0ZW4oKSBjYWxscyBjYW4gYmUgbWFkZSB0byBjb250cm9sIHdoYXQgY2hhbmdlcyB3aWxsIGJlXHJcbiAqIHNlbnQgZnJvbSB0aGUgc2VydmVyIGZvciBMaXN0ZW5SZXNwb25zZXMuXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50TGlzdGVuU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcImxpc3Rlbl9zdHJlYW1fY29ubmVjdGlvbl9iYWNrb2ZmXCIgLyogVGltZXJJZC5MaXN0ZW5TdHJlYW1Db25uZWN0aW9uQmFja29mZiAqLywgXCJsaXN0ZW5fc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLkxpc3RlblN0cmVhbUlkbGUgKi8sIFwiaGVhbHRoX2NoZWNrX3RpbWVvdXRcIiAvKiBUaW1lcklkLkhlYWx0aENoZWNrVGltZW91dCAqLywgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnTGlzdGVuJywgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgIH1cclxuICAgIG9uTWVzc2FnZSh3YXRjaENoYW5nZVByb3RvKSB7XHJcbiAgICAgICAgLy8gQSBzdWNjZXNzZnVsIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeVxyXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIGNvbnN0IHdhdGNoQ2hhbmdlID0gZnJvbVdhdGNoQ2hhbmdlKHRoaXMuc2VyaWFsaXplciwgd2F0Y2hDaGFuZ2VQcm90byk7XHJcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB2ZXJzaW9uRnJvbUxpc3RlblJlc3BvbnNlKHdhdGNoQ2hhbmdlUHJvdG8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2Uod2F0Y2hDaGFuZ2UsIHNuYXBzaG90KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGludGVyZXN0IGluIHRoZSByZXN1bHRzIG9mIHRoZSBnaXZlbiB0YXJnZXQuIElmIHRoZSB0YXJnZXRcclxuICAgICAqIGluY2x1ZGVzIGEgcmVzdW1lVG9rZW4gaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC4gUmVzdWx0cyB0aGF0XHJcbiAgICAgKiBhZmZlY3QgdGhlIHRhcmdldCB3aWxsIGJlIHN0cmVhbWVkIGJhY2sgYXMgV2F0Y2hDaGFuZ2UgbWVzc2FnZXMgdGhhdFxyXG4gICAgICogcmVmZXJlbmNlIHRoZSB0YXJnZXRJZC5cclxuICAgICAqL1xyXG4gICAgd2F0Y2godGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcclxuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICByZXF1ZXN0LmFkZFRhcmdldCA9IHRvVGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICByZXF1ZXN0LmxhYmVscyA9IGxhYmVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5yZWdpc3RlcnMgaW50ZXJlc3QgaW4gdGhlIHJlc3VsdHMgb2YgdGhlIHRhcmdldCBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAgICAgKiBnaXZlbiB0YXJnZXRJZC5cclxuICAgICAqL1xyXG4gICAgdW53YXRjaCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcclxuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICByZXF1ZXN0LnJlbW92ZVRhcmdldCA9IHRhcmdldElkO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgU3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgV3JpdGUgUlBDLlxyXG4gKlxyXG4gKiBUaGUgV3JpdGUgUlBDIHJlcXVpcmVzIHRoZSBjYWxsZXIgdG8gbWFpbnRhaW4gc3BlY2lhbCBzdHJlYW1Ub2tlblxyXG4gKiBzdGF0ZSBpbiBiZXR3ZWVuIGNhbGxzLCB0byBoZWxwIHRoZSBzZXJ2ZXIgdW5kZXJzdGFuZCB3aGljaCByZXNwb25zZXMgdGhlXHJcbiAqIGNsaWVudCBoYXMgcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIHRoZSBuZXh0IHJlcXVlc3QgaXMgbWFkZS4gRXZlcnkgcmVzcG9uc2VcclxuICogd2lsbCBjb250YWluIGEgc3RyZWFtVG9rZW47IHRoaXMgdmFsdWUgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIG5leHRcclxuICogcmVxdWVzdC5cclxuICpcclxuICogQWZ0ZXIgY2FsbGluZyBzdGFydCgpIG9uIHRoaXMgc3RyZWFtLCB0aGUgbmV4dCByZXF1ZXN0IG11c3QgYmUgYSBoYW5kc2hha2UsXHJcbiAqIGNvbnRhaW5pbmcgd2hhdGV2ZXIgc3RyZWFtVG9rZW4gaXMgb24gaGFuZC4gT25jZSBhIHJlc3BvbnNlIHRvIHRoaXNcclxuICogcmVxdWVzdCBpcyByZWNlaXZlZCwgYWxsIHBlbmRpbmcgbXV0YXRpb25zIG1heSBiZSBzdWJtaXR0ZWQuIFdoZW5cclxuICogc3VibWl0dGluZyBtdWx0aXBsZSBiYXRjaGVzIG9mIG11dGF0aW9ucyBhdCB0aGUgc2FtZSB0aW1lLCBpdCdzXHJcbiAqIG9rYXkgdG8gdXNlIHRoZSBzYW1lIHN0cmVhbVRva2VuIGZvciB0aGUgY2FsbHMgdG8gd3JpdGVNdXRhdGlvbnMuXHJcbiAqXHJcbiAqIFRPRE8oYi8zMzI3MTIzNSk6IFVzZSBwcm90byB0eXBlc1xyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudFdyaXRlU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcIndyaXRlX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwid3JpdGVfc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLldyaXRlU3RyZWFtSWRsZSAqLywgXCJoZWFsdGhfY2hlY2tfdGltZW91dFwiIC8qIFRpbWVySWQuSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyB3aGV0aGVyIG9yIG5vdCBhIGhhbmRzaGFrZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhjaGFuZ2VkIGFuZFxyXG4gICAgICogdGhlIHN0cmVhbSBpcyByZWFkeSB0byBhY2NlcHQgbXV0YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFuZHNoYWtlQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfO1xyXG4gICAgfVxyXG4gICAgLy8gT3ZlcnJpZGUgb2YgUGVyc2lzdGVudFN0cmVhbS5zdGFydFxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kc2hha2VDb21wbGV0ZV8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdXBlci5zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgdGVhckRvd24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVNdXRhdGlvbnMoW10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnV3JpdGUnLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgb25NZXNzYWdlKHJlc3BvbnNlUHJvdG8pIHtcclxuICAgICAgICAvLyBBbHdheXMgY2FwdHVyZSB0aGUgbGFzdCBzdHJlYW0gdG9rZW4uXHJcbiAgICAgICAgaGFyZEFzc2VydCghIXJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW4pO1xyXG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbjtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZHNoYWtlQ29tcGxldGVfKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCByZXNwb25zZSBpcyBhbHdheXMgdGhlIGhhbmRzaGFrZSByZXNwb25zZVxyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KCFyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cyB8fCByZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZUNvbXBsZXRlXyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uSGFuZHNoYWtlQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEEgc3VjY2Vzc2Z1bCBmaXJzdCB3cml0ZSByZXNwb25zZSBtZWFucyB0aGUgc3RyZWFtIGlzIGhlYWx0aHksXHJcbiAgICAgICAgICAgIC8vIE5vdGUsIHRoYXQgd2UgY291bGQgY29uc2lkZXIgYSBzdWNjZXNzZnVsIGhhbmRzaGFrZSBoZWFsdGh5LCBob3dldmVyLFxyXG4gICAgICAgICAgICAvLyB0aGUgd3JpdGUgaXRzZWxmIG1pZ2h0IGJlIGNhdXNpbmcgYW4gZXJyb3Igd2Ugd2FudCB0byBiYWNrIG9mZiBmcm9tLlxyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGZyb21Xcml0ZVJlc3VsdHMocmVzcG9uc2VQcm90by53cml0ZVJlc3VsdHMsIHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbW1pdFZlcnNpb24gPSBmcm9tVmVyc2lvbihyZXNwb25zZVByb3RvLmNvbW1pdFRpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk11dGF0aW9uUmVzdWx0KGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYW4gaW5pdGlhbCBzdHJlYW1Ub2tlbiB0byB0aGUgc2VydmVyLCBwZXJmb3JtaW5nIHRoZSBoYW5kc2hha2VcclxuICAgICAqIHJlcXVpcmVkIHRvIG1ha2UgdGhlIFN0cmVhbWluZ1dyaXRlIFJQQyB3b3JrLiBTdWJzZXF1ZW50XHJcbiAgICAgKiBjYWxscyBzaG91bGQgd2FpdCB1bnRpbCBvbkhhbmRzaGFrZUNvbXBsZXRlIHdhcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSGFuZHNoYWtlKCkge1xyXG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU3VwcG9ydCBzdHJlYW0gcmVzdW1wdGlvbi4gV2UgaW50ZW50aW9uYWxseSBkbyBub3Qgc2V0IHRoZVxyXG4gICAgICAgIC8vIHN0cmVhbSB0b2tlbiBvbiB0aGUgaGFuZHNoYWtlLCBpZ25vcmluZyBhbnkgc3RyZWFtIHRva2VuIHdlIG1pZ2h0IGhhdmUuXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xyXG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogU2VuZHMgYSBncm91cCBvZiBtdXRhdGlvbnMgdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kIHRvIGFwcGx5LiAqL1xyXG4gICAgd3JpdGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgc3RyZWFtVG9rZW46IHRoaXMubGFzdFN0cmVhbVRva2VuLFxyXG4gICAgICAgICAgICB3cml0ZXM6IG11dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdG9NdXRhdGlvbih0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERhdGFzdG9yZSBhbmQgaXRzIHJlbGF0ZWQgbWV0aG9kcyBhcmUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgR29vZ2xlXHJcbiAqIENsb3VkIERhdGFzdG9yZSBncnBjIEFQSSwgd2hpY2ggcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgaXMgbW9yZSBjb252ZW5pZW50XHJcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUgdG8gY29uc3VtZS5cclxuICovXHJcbmNsYXNzIERhdGFzdG9yZSB7XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERhdGFzdG9yZSB0aGF0IGV4cG9zZXMgYWRkaXRpb25hbCBzdGF0ZSBmb3IgaW50ZXJuYWxcclxuICogY29uc3VtcHRpb24uXHJcbiAqL1xyXG5jbGFzcyBEYXRhc3RvcmVJbXBsIGV4dGVuZHMgRGF0YXN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzID0gYXBwQ2hlY2tDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlJbml0aWFsaXplZCgpIHtcclxuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogSW52b2tlcyB0aGUgcHJvdmlkZWQgUlBDIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqL1xyXG4gICAgaW52b2tlUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgpLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXHJcbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0LCBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcclxuICAgICAgICB0aGlzLnZlcmlmeUluaXRpYWxpemVkKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKClcclxuICAgICAgICBdKVxyXG4gICAgICAgICAgICAudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoKSwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8oZmlyZXN0b3JleHApOiBNYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgRGF0YXN0b3JlIGluc3RhbmNlIHBlclxyXG4vLyBmaXJlc3RvcmUtZXhwIGNsaWVudC5cclxuZnVuY3Rpb24gbmV3RGF0YXN0b3JlKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhc3RvcmVJbXBsKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQ29tbWl0UnBjKGRhdGFzdG9yZSwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBtKSlcclxuICAgIH07XHJcbiAgICBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVJQQygnQ29tbWl0JywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGMoZGF0YXN0b3JlLCBrZXlzKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGRvY3VtZW50czoga2V5cy5tYXAoayA9PiB0b05hbWUoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBrKSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QsIGtleXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGRvY3MgPSBuZXcgTWFwKCk7XHJcbiAgICByZXNwb25zZS5mb3JFYWNoKHByb3RvID0+IHtcclxuICAgICAgICBjb25zdCBkb2MgPSBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvKTtcclxuICAgICAgICBkb2NzLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvYyk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gZG9jcy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoISFkb2MpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGRvYyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBjb25zdCB7IHJlcXVlc3QsIGFsaWFzTWFwLCBwYXJlbnQgfSA9IHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSwgYWdncmVnYXRlcyk7XHJcbiAgICBpZiAoIWRhdGFzdG9yZUltcGwuY29ubmVjdGlvbi5zaG91bGRSZXNvdXJjZVBhdGhCZUluY2x1ZGVkSW5SZXF1ZXN0KSB7XHJcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QucGFyZW50O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnUnVuQWdncmVnYXRpb25RdWVyeScsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBwYXJlbnQsIHJlcXVlc3QsIFxyXG4gICAgLypleHBlY3RlZFJlc3BvbnNlQ291bnQ9Ki8gMSk7XHJcbiAgICAvLyBPbWl0IFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZSB0aGF0IG9ubHkgY29udGFpbiByZWFkVGltZXMuXHJcbiAgICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IHJlc3BvbnNlLmZpbHRlcihwcm90byA9PiAhIXByb3RvLnJlc3VsdCk7XHJcbiAgICBoYXJkQXNzZXJ0KGZpbHRlcmVkUmVzdWx0Lmxlbmd0aCA9PT0gMSk7XHJcbiAgICAvLyBSZW1hcCB0aGUgc2hvcnQtZm9ybSBhbGlhc2VzIHRoYXQgd2VyZSBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgIC8vIHRvIHRoZSBjbGllbnQtc2lkZSBhbGlhc2VzLiBVc2VycyB3aWxsIGFjY2VzcyB0aGUgcmVzdWx0c1xyXG4gICAgLy8gdXNpbmcgdGhlIGNsaWVudC1zaWRlIGFsaWFzLlxyXG4gICAgY29uc3QgdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHMgPSAoX2EgPSBmaWx0ZXJlZFJlc3VsdFswXS5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2dyZWdhdGVGaWVsZHM7XHJcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcclxuICAgICAgICBhY2N1bXVsYXRvclthbGlhc01hcFtrZXldXSA9IHVubWFwcGVkQWdncmVnYXRlRmllbGRzW2tleV07XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHJlbWFwcGVkRmllbGRzO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xyXG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XHJcbn1cclxuZnVuY3Rpb24gbmV3UGVyc2lzdGVudFdhdGNoU3RyZWFtKGRhdGFzdG9yZSwgcXVldWUsIGxpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XHJcbiAgICBkYXRhc3RvcmVJbXBsLnZlcmlmeUluaXRpYWxpemVkKCk7XHJcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ2ID0gJ09ubGluZVN0YXRlVHJhY2tlcic7XHJcbi8vIFRvIGRlYWwgd2l0aCB0cmFuc2llbnQgZmFpbHVyZXMsIHdlIGFsbG93IG11bHRpcGxlIHN0cmVhbSBhdHRlbXB0cyBiZWZvcmVcclxuLy8gZ2l2aW5nIHVwIGFuZCB0cmFuc2l0aW9uaW5nIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPZmZsaW5lLlxyXG4vLyBUT0RPKG1pa2VsZWhlbik6IFRoaXMgdXNlZCB0byBiZSBzZXQgdG8gMiBhcyBhIG1pdGlnYXRpb24gZm9yIGIvNjYyMjgzOTQuXHJcbi8vIEBqZGltb25kIHRoaW5rcyB0aGF0IGJ1ZyBpcyBzdWZmaWNpZW50bHkgZml4ZWQgc28gdGhhdCB3ZSBjYW4gc2V0IHRoaXMgYmFja1xyXG4vLyB0byAxLiBJZiB0aGF0IHdvcmtzIG9rYXksIHdlIGNvdWxkIHBvdGVudGlhbGx5IHJlbW92ZSB0aGlzIGxvZ2ljIGVudGlyZWx5LlxyXG5jb25zdCBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTID0gMTtcclxuLy8gVG8gZGVhbCB3aXRoIHN0cmVhbSBhdHRlbXB0cyB0aGF0IGRvbid0IHN1Y2NlZWQgb3IgZmFpbCBpbiBhIHRpbWVseSBtYW5uZXIsXHJcbi8vIHdlIGhhdmUgYSB0aW1lb3V0IGZvciBPbmxpbmVTdGF0ZSB0byByZWFjaCBPbmxpbmUgb3IgT2ZmbGluZS5cclxuLy8gSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgd2UgdHJhbnNpdGlvbiB0byBPZmZsaW5lIHJhdGhlciB0aGFuIHdhaXRpbmdcclxuLy8gaW5kZWZpbml0ZWx5LlxyXG5jb25zdCBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcclxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHVzZWQgYnkgdGhlIFJlbW90ZVN0b3JlIHRvIHRyYWNrIHRoZSBPbmxpbmVTdGF0ZSAodGhhdCBpcyxcclxuICogd2hldGhlciBvciBub3QgdGhlIGNsaWVudCBhcyBhIHdob2xlIHNob3VsZCBiZSBjb25zaWRlcmVkIHRvIGJlIG9ubGluZSBvclxyXG4gKiBvZmZsaW5lKSwgaW1wbGVtZW50aW5nIHRoZSBhcHByb3ByaWF0ZSBoZXVyaXN0aWNzLlxyXG4gKlxyXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aGVuIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHdlXHJcbiAqIGFsbG93IHVwIHRvIE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgd2l0aGluIE9OTElORV9TVEFURV9USU1FT1VUX01TIGZvclxyXG4gKiBhIGNvbm5lY3Rpb24gdG8gc3VjY2VlZC4gSWYgd2UgaGF2ZSB0b28gbWFueSBmYWlsdXJlcyBvciB0aGUgdGltZW91dCBlbGFwc2VzLFxyXG4gKiB0aGVuIHdlIHNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSwgYW5kIHRoZSBjbGllbnQgd2lsbCBiZWhhdmUgYXMgaWZcclxuICogaXQgaXMgb2ZmbGluZSAoZ2V0KClzIHdpbGwgcmV0dXJuIGNhY2hlZCBkYXRhLCBldGMuKS5cclxuICovXHJcbmNsYXNzIE9ubGluZVN0YXRlVHJhY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGVIYW5kbGVyO1xyXG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBPbmxpbmVTdGF0ZS4gKi9cclxuICAgICAgICB0aGlzLnN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNvdW50IG9mIGNvbnNlY3V0aXZlIGZhaWx1cmVzIHRvIG9wZW4gdGhlIHN0cmVhbS4gSWYgaXQgcmVhY2hlcyB0aGVcclxuICAgICAgICAgKiBtYXhpbXVtIGRlZmluZWQgYnkgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUywgd2UnbGwgc2V0IHRoZSBPbmxpbmVTdGF0ZSB0b1xyXG4gICAgICAgICAqIE9mZmxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRpbWVyIHRoYXQgZWxhcHNlcyBhZnRlciBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUywgYXQgd2hpY2ggcG9pbnQgd2VcclxuICAgICAgICAgKiB0cmFuc2l0aW9uIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPbmxpbmVTdGF0ZS5PZmZsaW5lIHdpdGhvdXQgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgc3RyZWFtIHRvIGFjdHVhbGx5IGZhaWwgKE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgdGltZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUgY2xpZW50IHNob3VsZCBsb2cgYSB3YXJuaW5nIG1lc3NhZ2UgaWYgaXQgZmFpbHMgdG8gY29ubmVjdCB0b1xyXG4gICAgICAgICAqIHRoZSBiYWNrZW5kIChpbml0aWFsbHkgdHJ1ZSwgY2xlYXJlZCBhZnRlciBhIHN1Y2Nlc3NmdWwgc3RyZWFtLCBvciBpZiB3ZSd2ZVxyXG4gICAgICAgICAqIGxvZ2dlZCB0aGUgbWVzc2FnZSBhbHJlYWR5KS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNob3VsZFdhcm5DbGllbnRJc09mZmxpbmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgUmVtb3RlU3RvcmUgd2hlbiBhIHdhdGNoIHN0cmVhbSBpcyBzdGFydGVkIChpbmNsdWRpbmcgb24gZWFjaFxyXG4gICAgICogYmFja29mZiBhdHRlbXB0KS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LCBpdCBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byBVbmtub3duIGFuZCBzdGFydHNcclxuICAgICAqIHRoZSBvbmxpbmVTdGF0ZVRpbWVyLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcIm9ubGluZV9zdGF0ZV90aW1lb3V0XCIgLyogVGltZXJJZC5PbmxpbmVTdGF0ZVRpbWVvdXQgKi8sIE9OTElORV9TVEFURV9USU1FT1VUX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGBCYWNrZW5kIGRpZG4ndCByZXNwb25kIHdpdGhpbiAke09OTElORV9TVEFURV9USU1FT1VUX01TIC8gMTAwMH0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHNlY29uZHMuYCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZSgpIHdpbGwgY29udGludWUgdG8gaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyB3YXRjaFN0cmVhbUZhaWx1cmVzIGV2ZW4gdGhvdWdoIHdlIGFyZSBhbHJlYWR5IG1hcmtlZCBPZmZsaW5lLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm9uLWhhcm1mdWwuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBvdXIgT25saW5lU3RhdGUgYXMgYXBwcm9wcmlhdGUgYWZ0ZXIgdGhlIHdhdGNoIHN0cmVhbSByZXBvcnRzIGFcclxuICAgICAqIGZhaWx1cmUuIFRoZSBmaXJzdCBmYWlsdXJlIG1vdmVzIHVzIHRvIHRoZSAnVW5rbm93bicgc3RhdGUuIFdlIHRoZW4gbWF5XHJcbiAgICAgKiBhbGxvdyBtdWx0aXBsZSBmYWlsdXJlcyAoYmFzZWQgb24gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykgYmVmb3JlIHdlXHJcbiAgICAgKiBhY3R1YWxseSB0cmFuc2l0aW9uIHRvIHRoZSAnT2ZmbGluZScgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZShlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xyXG4gICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2F0Y2hTdHJlYW1GYWlsdXJlcysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID49IE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0NsaWVudE9mZmxpbmVXYXJuaW5nSWZOZWNlc3NhcnkoYENvbm5lY3Rpb24gZmFpbGVkICR7TUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFU30gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRpbWVzLiBNb3N0IHJlY2VudCBlcnJvcjogJHtlcnJvci50b1N0cmluZygpfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cGxpY2l0bHkgc2V0cyB0aGUgT25saW5lU3RhdGUgdG8gdGhlIHNwZWNpZmllZCBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyByZXNldHMgb3VyIHRpbWVycyAvIGZhaWx1cmUgY291bnRlcnMsIGV0Yy4gdXNlZCBieSBvdXJcclxuICAgICAqIE9mZmxpbmUgaGV1cmlzdGljcywgc28gbXVzdCBub3QgYmUgdXNlZCBpbiBwbGFjZSBvZlxyXG4gICAgICogaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIGFuZCBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKS5cclxuICAgICAqL1xyXG4gICAgc2V0KG5ld1N0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcclxuICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPSAwO1xyXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pIHtcclxuICAgICAgICAgICAgLy8gV2UndmUgY29ubmVjdGVkIHRvIHdhdGNoIGF0IGxlYXN0IG9uY2UuIERvbid0IHdhcm4gdGhlIGRldmVsb3BlclxyXG4gICAgICAgICAgICAvLyBhYm91dCBiZWluZyBvZmZsaW5lIGdvaW5nIGZvcndhcmQuXHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChuZXdTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBzZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpIHtcclxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihuZXdTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShkZXRhaWxzKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb3VsZCBub3QgcmVhY2ggQ2xvdWQgRmlyZXN0b3JlIGJhY2tlbmQuICR7ZGV0YWlsc31cXG5gICtcclxuICAgICAgICAgICAgYFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyB0aGF0IHlvdXIgZGV2aWNlIGRvZXMgbm90IGhhdmUgYSBoZWFsdGh5IGAgK1xyXG4gICAgICAgICAgICBgSW50ZXJuZXQgY29ubmVjdGlvbiBhdCB0aGUgbW9tZW50LiBUaGUgY2xpZW50IHdpbGwgb3BlcmF0ZSBpbiBvZmZsaW5lIGAgK1xyXG4gICAgICAgICAgICBgbW9kZSB1bnRpbCBpdCBpcyBhYmxlIHRvIHN1Y2Nlc3NmdWxseSBjb25uZWN0IHRvIHRoZSBiYWNrZW5kLmA7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSkge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDYsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyT25saW5lU3RhdGVUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5vbmxpbmVTdGF0ZVRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ1ID0gJ1JlbW90ZVN0b3JlJztcclxuLy8gVE9ETyhiLzM1ODUzNDAyKTogTmVnb3RpYXRlIHRoaXMgd2l0aCB0aGUgc3RyZWFtLlxyXG5jb25zdCBNQVhfUEVORElOR19XUklURVMgPSAxMDtcclxuY2xhc3MgUmVtb3RlU3RvcmVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9jYWwgc3RvcmUsIHVzZWQgdG8gZmlsbCB0aGUgd3JpdGUgcGlwZWxpbmUgd2l0aCBvdXRib3VuZCBtdXRhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGxvY2FsU3RvcmUsIFxyXG4gICAgLyoqIFRoZSBjbGllbnQtc2lkZSBwcm94eSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZC4gKi9cclxuICAgIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMucmVtb3RlU3luY2VyID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIHVwIHRvIE1BWF9QRU5ESU5HX1dSSVRFUyB3cml0ZXMgdGhhdCB3ZSBoYXZlIGZldGNoZWQgZnJvbSB0aGVcclxuICAgICAgICAgKiBMb2NhbFN0b3JlIHZpYSBmaWxsV3JpdGVQaXBlbGluZSgpIGFuZCBoYXZlIG9yIHdpbGwgc2VuZCB0byB0aGUgd3JpdGVcclxuICAgICAgICAgKiBzdHJlYW0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuZXZlciB3cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDAgdGhlIFJlbW90ZVN0b3JlIHdpbGwgYXR0ZW1wdCB0byBzdGFydCBvclxyXG4gICAgICAgICAqIHJlc3RhcnQgdGhlIHdyaXRlIHN0cmVhbS4gV2hlbiB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkIHRoZSB3cml0ZXMgaW4gdGhlXHJcbiAgICAgICAgICogcGlwZWxpbmUgd2lsbCBiZSBzZW50IGluIG9yZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV3JpdGVzIHJlbWFpbiBpbiB3cml0ZVBpcGVsaW5lIHVudGlsIHRoZXkgYXJlIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZFxyXG4gICAgICAgICAqIGFuZCB0aHVzIHdpbGwgYXV0b21hdGljYWxseSBiZSByZS1zZW50IGlmIHRoZSBzdHJlYW0gaXMgaW50ZXJydXB0ZWQgL1xyXG4gICAgICAgICAqIHJlc3RhcnRlZCBiZWZvcmUgdGhleSdyZSBhY2tub3dsZWRnZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXcml0ZSByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZCBhcmUgbGlua2VkIHRvIHRoZWlyIG9yaWdpbmF0aW5nIHJlcXVlc3RcclxuICAgICAgICAgKiBwdXJlbHkgYmFzZWQgb24gb3JkZXIsIGFuZCBzbyB3ZSBjYW4ganVzdCBzaGlmdCgpIHdyaXRlcyBmcm9tIHRoZSBmcm9udCBvZlxyXG4gICAgICAgICAqIHRoZSB3cml0ZVBpcGVsaW5lIGFzIHdlIHJlY2VpdmUgcmVzcG9uc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud3JpdGVQaXBlbGluZSA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB3YXRjaGVkIHRhcmdldHMgdGhhdCB0aGUgY2xpZW50IGNhcmVzIGFib3V0IHRyYWNraW5nIGFuZCB0aGVcclxuICAgICAgICAgKiB1c2VyIGhhcyBleHBsaWNpdGx5IGNhbGxlZCBhICdsaXN0ZW4nIGZvciB0aGlzIHRhcmdldC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZXNlIHRhcmdldHMgbWF5IG9yIG1heSBub3QgaGF2ZSBiZWVuIHNlbnQgdG8gb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZVxyXG4gICAgICAgICAqIHNlcnZlci4gT24gcmUtZXN0YWJsaXNoaW5nIHRoZSBsaXN0ZW4gc3RyZWFtLCB0aGVzZSB0YXJnZXRzIHNob3VsZCBiZSBzZW50XHJcbiAgICAgICAgICogdG8gdGhlIHNlcnZlci4gVGhlIHRhcmdldHMgcmVtb3ZlZCB3aXRoIHVubGlzdGVucyBhcmUgcmVtb3ZlZCBlYWdlcmx5XHJcbiAgICAgICAgICogd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb24gZnJvbSB0aGUgbGlzdGVuIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpc3RlblRhcmdldHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzZXQgb2YgcmVhc29ucyBmb3Igd2h5IHRoZSBSZW1vdGVTdG9yZSBtYXkgYmUgb2ZmbGluZS4gSWYgZW1wdHksIHRoZVxyXG4gICAgICAgICAqIFJlbW90ZVN0b3JlIG1heSBzdGFydCBpdHMgbmV0d29yayBjb25uZWN0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9mZmxpbmVDYXVzZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgdGhhdCBnZXQgY2FsbGVkIHdoZW4gdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIG9uIHRoZSBXZWIgY2xpZW50IHRvIGNyZWF0ZSB0aGVcclxuICAgICAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbXMgKHRvIHN1cHBvcnQgdHJlZS1zaGFrZWFibGUgc3RyZWFtcykuIE9uIEFuZHJvaWQgYW5kIGlPUyxcclxuICAgICAgICAgKiB0aGUgc3RyZWFtcyBhcmUgY3JlYXRlZCBkdXJpbmcgY29uc3RydWN0aW9uIG9mIFJlbW90ZVN0b3JlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlNb25pdG9yID0gY29ubmVjdGl2aXR5TW9uaXRvcjtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eU1vbml0b3IuYWRkQ2FsbGJhY2soKF8pID0+IHtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFBvcnRpbmcgTm90ZTogVW5saWtlIGlPUywgYHJlc3RhcnROZXR3b3JrKClgIGlzIGNhbGxlZCBldmVuIHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIGJlY29tZXMgdW5yZWFjaGFibGUgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgb3RoZXIgd2F5IHRvIHRlYXJcclxuICAgICAgICAgICAgICAgIC8vIGRvd24gb3VyIHN0cmVhbXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuVXNlTmV0d29yayh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1Jlc3RhcnRpbmcgc3RyZWFtcyBmb3IgbmV0d29yayByZWFjaGFiaWxpdHkgY2hhbmdlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3RhcnROZXR3b3JrKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlVHJhY2tlciA9IG5ldyBPbmxpbmVTdGF0ZVRyYWNrZXIoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdSZW1vdGVTdG9yZShsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyBSZW1vdGVTdG9yZUltcGwobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpO1xyXG59XHJcbi8qKiBSZS1lbmFibGVzIHRoZSBuZXR3b3JrLiBJZGVtcG90ZW50LiAqL1xyXG5mdW5jdGlvbiByZW1vdGVTdG9yZUVuYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5kZWxldGUoMCAvKiBPZmZsaW5lQ2F1c2UuVXNlckRpc2FibGVkICovKTtcclxuICAgIHJldHVybiBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrU3RhdHVzSGFuZGxlciBvZiByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldHdvcmtTdGF0dXNIYW5kbGVyKC8qIGVuYWJsZWQ9ICovIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGVtcG9yYXJpbHkgZGlzYWJsZXMgdGhlIG5ldHdvcmsuIFRoZSBuZXR3b3JrIGNhbiBiZSByZS1lbmFibGVkIHVzaW5nXHJcbiAqIGVuYWJsZU5ldHdvcmsoKS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMCAvKiBPZmZsaW5lQ2F1c2UuVXNlckRpc2FibGVkICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSBzbyBnZXQoKXMgcmV0dXJuIGZyb20gY2FjaGUsIGV0Yy5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBmb3IgKGNvbnN0IG5ldHdvcmtTdGF0dXNIYW5kbGVyIG9mIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UpIHtcclxuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JlbW90ZVN0b3JlIHNodXR0aW5nIGRvd24uJyk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBPZmZsaW5lQ2F1c2UuU2h1dGRvd24gKi8pO1xyXG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmNvbm5lY3Rpdml0eU1vbml0b3Iuc2h1dGRvd24oKTtcclxuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biAocmF0aGVyIHRoYW4gT2ZmbGluZSkgdG8gYXZvaWQgcG90ZW50aWFsbHlcclxuICAgIC8vIHRyaWdnZXJpbmcgc3B1cmlvdXMgbGlzdGVuZXIgZXZlbnRzIHdpdGggY2FjaGVkIGRhdGEsIGV0Yy5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG59XHJcbi8qKlxyXG4gKiBTdGFydHMgbmV3IGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldC4gVXNlcyByZXN1bWUgdG9rZW4gaWYgcHJvdmlkZWQuIEl0XHJcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIHRhcmdldCBvZiBnaXZlbiBgVGFyZ2V0RGF0YWAgaXMgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW90ZVN0b3JlTGlzdGVuKHJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmhhcyh0YXJnZXREYXRhLnRhcmdldElkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIE1hcmsgdGhpcyBhcyBzb21ldGhpbmcgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgbGlzdGVuaW5nIGZvci5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcclxuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcclxuICAgICAgICAvLyBUaGUgbGlzdGVuIHdpbGwgYmUgc2VudCBpbiBvbldhdGNoU3RyZWFtT3BlblxyXG4gICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNPcGVuKCkpIHtcclxuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbiBmcm9tIHNlcnZlci4gSXQgaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IGlkIGlzXHJcbiAqIG5vdCBiZWluZyBsaXN0ZW5lZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW90ZVN0b3JlVW5saXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldElkKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgY29uc3Qgd2F0Y2hTdHJlYW0gPSBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcclxuICAgIGlmICh3YXRjaFN0cmVhbS5pc09wZW4oKSkge1xyXG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgaWYgKHdhdGNoU3RyZWFtLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoU3RyZWFtLm1hcmtJZGxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgICAgICAvLyBSZXZlcnQgdG8gT25saW5lU3RhdGUuVW5rbm93biBpZiB0aGUgd2F0Y2ggc3RyZWFtIGlzIG5vdCBvcGVuIGFuZCB3ZVxyXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGxpc3RlbmVycywgc2luY2Ugd2l0aG91dCBhbnkgbGlzdGVucyB0byBzZW5kIHdlIGNhbm5vdFxyXG4gICAgICAgICAgICAvLyBjb25maXJtIGlmIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSBhbmQgdXBncmFkZSB0byBPbmxpbmVTdGF0ZS5PbmxpbmUuXHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcGVuZGluZyByZXNwb25zZXMgd2UncmUgZHVlXHJcbiAqIGZyb20gd2F0Y2ggc28gd2Ugd2FpdCBmb3IgdGhlIGFjayB0byBwcm9jZXNzIGFueSBtZXNzYWdlcyBmcm9tIHRoaXMgdGFyZ2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldERhdGEpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwIHx8XHJcbiAgICAgICAgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXREYXRhLnRhcmdldElkKS5zaXplO1xyXG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53YXRjaCh0YXJnZXREYXRhKTtcclxufVxyXG4vKipcclxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyB3ZSdyZSBkdWVcclxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgcmVtb3ZhbCBvbiB0aGUgc2VydmVyIGJlZm9yZSB3ZSBwcm9jZXNzIGFueVxyXG4gKiBtZXNzYWdlcyBmcm9tIHRoaXMgdGFyZ2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0SWQpO1xyXG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS51bndhdGNoKHRhcmdldElkKTtcclxufVxyXG5mdW5jdGlvbiBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvciA9IG5ldyBXYXRjaENoYW5nZUFnZ3JlZ2F0b3Ioe1xyXG4gICAgICAgIGdldFJlbW90ZUtleXNGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCksXHJcbiAgICAgICAgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldDogdGFyZ2V0SWQgPT4gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKSB8fCBudWxsLFxyXG4gICAgICAgIGdldERhdGFiYXNlSWQ6ICgpID0+IHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUuc2VyaWFsaXplci5kYXRhYmFzZUlkXHJcbiAgICB9KTtcclxuICAgIGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuc3RhcnQoKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHdhdGNoIHN0cmVhbSBzaG91bGQgYmUgc3RhcnRlZCBiZWNhdXNlIGl0J3MgbmVjZXNzYXJ5XHJcbiAqIGFuZCBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcclxuICAgICAgICAhZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNpemUgPiAwKTtcclxufVxyXG5mdW5jdGlvbiBjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLnNpemUgPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gdW5kZWZpbmVkO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIFwiY29ubmVjdGVkXCIgbm90aWZpY2F0aW9uLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZm9yRWFjaCgodGFyZ2V0RGF0YSwgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2xvc2UocmVtb3RlU3RvcmVJbXBsLCBlcnJvcikge1xyXG4gICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIC8vIElmIHdlIHN0aWxsIG5lZWQgdGhlIHdhdGNoIHN0cmVhbSwgcmV0cnkgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoZXJyb3IpO1xyXG4gICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcmVzdGFydCB3YXRjaCBzdHJlYW0gYmVjYXVzZSB0aGVyZSBhcmUgbm8gYWN0aXZlIHRhcmdldHMuXHJcbiAgICAgICAgLy8gVGhlIG9ubGluZSBzdGF0ZSBpcyBzZXQgdG8gdW5rbm93biBiZWNhdXNlIHRoZXJlIGlzIG5vIGFjdGl2ZSBhdHRlbXB0XHJcbiAgICAgICAgLy8gYXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvblxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1DaGFuZ2UocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSwgc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXHJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XHJcbiAgICBpZiAod2F0Y2hDaGFuZ2UgaW5zdGFuY2VvZiBXYXRjaFRhcmdldENoYW5nZSAmJlxyXG4gICAgICAgIHdhdGNoQ2hhbmdlLnN0YXRlID09PSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgIHdhdGNoQ2hhbmdlLmNhdXNlKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yIG9uIGEgdGFyZ2V0LCBkb24ndCB3YWl0IGZvciBhIGNvbnNpc3RlbnQgc25hcHNob3RcclxuICAgICAgICAvLyB0byByYWlzZSBldmVudHNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVUYXJnZXRFcnJvcihyZW1vdGVTdG9yZUltcGwsIHdhdGNoQ2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnRmFpbGVkIHRvIHJlbW92ZSB0YXJnZXRzICVzOiAlcyAnLCB3YXRjaENoYW5nZS50YXJnZXRJZHMuam9pbignLCcpLCBlKTtcclxuICAgICAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIERvY3VtZW50V2F0Y2hDaGFuZ2UpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZURvY3VtZW50Q2hhbmdlKHdhdGNoQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVFeGlzdGVuY2VGaWx0ZXIod2F0Y2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVUYXJnZXRDaGFuZ2Uod2F0Y2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzbmFwc2hvdFZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IGF3YWl0IGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlKTtcclxuICAgICAgICAgICAgaWYgKHNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8obGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIHRhcmdldCBjaGFuZ2Ugd2l0aCBhIGdsb2JhbCBzbmFwc2hvdCBpZiB0aGUgc25hcHNob3RcclxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gaXMgbm90IGVxdWFsIHRvIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnRmFpbGVkIHRvIHJhaXNlIHNuYXBzaG90OicsIGUpO1xyXG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY292ZXJ5IGxvZ2ljIGZvciBJbmRleGVkREIgZXJyb3JzIHRoYXQgdGFrZXMgdGhlIG5ldHdvcmsgb2ZmbGluZSB1bnRpbFxyXG4gKiBgb3BgIHN1Y2NlZWRzLiBSZXRyaWVzIGFyZSBzY2hlZHVsZWQgd2l0aCBiYWNrb2ZmIHVzaW5nXHJcbiAqIGBlbnF1ZXVlUmV0cnlhYmxlKClgLiBJZiBgb3AoKWAgaXMgbm90IHByb3ZpZGVkLCBJbmRleGVkREIgYWNjZXNzIGlzXHJcbiAqIHZhbGlkYXRlZCB2aWEgYSBnZW5lcmljIG9wZXJhdGlvbi5cclxuICpcclxuICogVGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgYmVmb3JlXHJcbiAqIGFueSByZXRyeSBhdHRlbXB0LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApIHtcclxuICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMSAvKiBPZmZsaW5lQ2F1c2UuSW5kZXhlZERiRmFpbGVkICovKTtcclxuICAgICAgICAvLyBEaXNhYmxlIG5ldHdvcmsgYW5kIHJhaXNlIG9mZmxpbmUgc25hcHNob3RzXHJcbiAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG4gICAgICAgIGlmICghb3ApIHtcclxuICAgICAgICAgICAgLy8gVXNlIGEgc2ltcGxlIHJlYWQgb3BlcmF0aW9uIHRvIGRldGVybWluZSBpZiBJbmRleGVkREIgcmVjb3ZlcmVkLlxyXG4gICAgICAgICAgICAvLyBJZGVhbGx5LCB3ZSB3b3VsZCBleHBvc2UgYSBoZWFsdGggY2hlY2sgZGlyZWN0bHkgb24gU2ltcGxlRGIsIGJ1dFxyXG4gICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBvbmx5IGhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVuY2UgdGhyb3VnaCBMb2NhbFN0b3JlLlxyXG4gICAgICAgICAgICBvcCA9ICgpID0+IGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvYmUgSW5kZXhlZERCIHBlcmlvZGljYWxseSBhbmQgcmUtZW5hYmxlIG5ldHdvcmtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmV0cnlpbmcgSW5kZXhlZERCIGFjY2VzcycpO1xyXG4gICAgICAgICAgICBhd2FpdCBvcCgpO1xyXG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5kZWxldGUoMSAvKiBPZmZsaW5lQ2F1c2UuSW5kZXhlZERiRmFpbGVkICovKTtcclxuICAgICAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBgb3BgLiBJZiBgb3BgIGZhaWxzLCB0YWtlcyB0aGUgbmV0d29yayBvZmZsaW5lIHVudGlsIGBvcGBcclxuICogc3VjY2VlZHMuIFJldHVybnMgYWZ0ZXIgdGhlIGZpcnN0IGF0dGVtcHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgb3ApIHtcclxuICAgIHJldHVybiBvcCgpLmNhdGNoKGUgPT4gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApKTtcclxufVxyXG4vKipcclxuICogVGFrZXMgYSBiYXRjaCBvZiBjaGFuZ2VzIGZyb20gdGhlIERhdGFzdG9yZSwgcmVwYWNrYWdlcyB0aGVtIGFzIGFcclxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcclxuICogU3luY0VuZ2luZS5cclxuICovXHJcbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgY29uc3QgcmVtb3RlRXZlbnQgPSByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmNyZWF0ZVJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHJlc3VtZSB0b2tlbnMuIExvY2FsU3RvcmUgd2lsbCB1cGRhdGUgdGhlXHJcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5nZS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIFJlLWVzdGFibGlzaCBsaXN0ZW5zIGZvciB0aGUgdGFyZ2V0cyB0aGF0IGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBieVxyXG4gICAgLy8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaGVzLlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKCh0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlc3VtZSB0b2tlbiBmb3IgdGhlIHRhcmdldCwgc2luY2Ugd2UncmUgaW4gYSBrbm93biBtaXNtYXRjaFxyXG4gICAgICAgIC8vIHN0YXRlLlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXRJZCwgdGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORywgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pKTtcclxuICAgICAgICAvLyBDYXVzZSBhIGhhcmQgcmVzZXQgYnkgdW53YXRjaGluZyBhbmQgcmV3YXRjaGluZyBpbW1lZGlhdGVseSwgYnV0XHJcbiAgICAgICAgLy8gZGVsaWJlcmF0ZWx5IGRvbid0IHNlbmQgYSByZXN1bWUgdG9rZW4gc28gdGhhdCB3ZSBnZXQgYSBmdWxsIHVwZGF0ZS5cclxuICAgICAgICBzZW5kVW53YXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdlIHNlbmQgYXMgYmVpbmcgb24gYmVoYWxmIG9mIGFuIGV4aXN0ZW5jZSBmaWx0ZXJcclxuICAgICAgICAvLyBtaXNtYXRjaCwgYnV0IGRvbid0IGFjdHVhbGx5IHJldGFpbiB0aGF0IGluIGxpc3RlblRhcmdldHMuIFRoaXMgZW5zdXJlc1xyXG4gICAgICAgIC8vIHRoYXQgd2UgZmxhZyB0aGUgZmlyc3QgcmUtbGlzdGVuIHRoaXMgd2F5IHdpdGhvdXQgaW1wYWN0aW5nIGZ1dHVyZVxyXG4gICAgICAgIC8vIGxpc3RlbnMgb2YgdGhpcyB0YXJnZXQgKHRoYXQgbWlnaHQgaGFwcGVuIGUuZy4gb24gcmVjb25uZWN0KS5cclxuICAgICAgICBjb25zdCByZXF1ZXN0VGFyZ2V0RGF0YSA9IG5ldyBUYXJnZXREYXRhKHRhcmdldERhdGEudGFyZ2V0LCB0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSwgdGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHJlcXVlc3RUYXJnZXREYXRhKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuYXBwbHlSZW1vdGVFdmVudChyZW1vdGVFdmVudCk7XHJcbn1cclxuLyoqIEhhbmRsZXMgYW4gZXJyb3Igb24gYSB0YXJnZXQgKi9cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVGFyZ2V0RXJyb3IocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSkge1xyXG4gICAgY29uc3QgZXJyb3IgPSB3YXRjaENoYW5nZS5jYXVzZTtcclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2Ygd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxyXG4gICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuKHRhcmdldElkLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmRlbGV0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVtb3ZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGZpbGwgb3VyIHdyaXRlIHBpcGVsaW5lIHdpdGggd3JpdGVzIGZyb20gdGhlIExvY2FsU3RvcmUuXHJcbiAqXHJcbiAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGJvb3RzdHJhcCBvciByZWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIGFuZCBieVxyXG4gKiBTeW5jRW5naW5lIHdoZW5ldmVyIHRoZXJlIGFyZSBuZXcgbXV0YXRpb25zIHRvIHByb2Nlc3MuXHJcbiAqXHJcbiAqIFN0YXJ0cyB0aGUgd3JpdGUgc3RyZWFtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgbGV0IGxhc3RCYXRjaElkUmV0cmlldmVkID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMFxyXG4gICAgICAgID8gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmVbcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgLmJhdGNoSWRcclxuICAgICAgICA6IEJBVENISURfVU5LTk9XTjtcclxuICAgIHdoaWxlIChjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgbG9jYWxTdG9yZUdldE5leHRNdXRhdGlvbkJhdGNoKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlLCBsYXN0QmF0Y2hJZFJldHJpZXZlZCk7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3RyZWFtLm1hcmtJZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhc3RCYXRjaElkUmV0cmlldmVkID0gYmF0Y2guYmF0Y2hJZDtcclxuICAgICAgICAgICAgICAgIGFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwsIGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgc3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgd2UgY2FuIGFkZCB0byB0aGUgd3JpdGUgcGlwZWxpbmUgKGkuZS4gdGhlIG5ldHdvcmsgaXNcclxuICogZW5hYmxlZCBhbmQgdGhlIHdyaXRlIHBpcGVsaW5lIGlzIG5vdCBmdWxsKS5cclxuICovXHJcbmZ1bmN0aW9uIGNhbkFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIDwgTUFYX1BFTkRJTkdfV1JJVEVTKTtcclxufVxyXG4vKipcclxuICogUXVldWVzIGFkZGl0aW9uYWwgd3JpdGVzIHRvIGJlIHNlbnQgdG8gdGhlIHdyaXRlIHN0cmVhbSwgc2VuZGluZyB0aGVtXHJcbiAqIGltbWVkaWF0ZWx5IGlmIHRoZSB3cml0ZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsLCBiYXRjaCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUucHVzaChiYXRjaCk7XHJcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICBpZiAod3JpdGVTdHJlYW0uaXNPcGVuKCkgJiYgd3JpdGVTdHJlYW0uaGFuZHNoYWtlQ29tcGxldGUpIHtcclxuICAgICAgICB3cml0ZVN0cmVhbS53cml0ZU11dGF0aW9ucyhiYXRjaC5tdXRhdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxyXG4gICAgICAgICFlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzU3RhcnRlZCgpICYmXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCk7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuc3RhcnQoKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldyaXRlU3RyZWFtT3BlbihyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkud3JpdGVIYW5kc2hha2UoKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldyaXRlSGFuZHNoYWtlQ29tcGxldGUocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAvLyBTZW5kIHRoZSB3cml0ZSBwaXBlbGluZSBub3cgdGhhdCB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxyXG4gICAgZm9yIChjb25zdCBiYXRjaCBvZiByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZSkge1xyXG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25NdXRhdGlvblJlc3VsdChyZW1vdGVTdG9yZUltcGwsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpIHtcclxuICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBNdXRhdGlvbkJhdGNoUmVzdWx0LmZyb20oYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpO1xyXG4gICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUoc3VjY2VzcykpO1xyXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvbiBhbm90aGVyXHJcbiAgICAvLyBzbG90IGhhcyBmcmVlZCB1cC5cclxuICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbUNsb3NlKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcclxuICAgIC8vIElmIHRoZSB3cml0ZSBzdHJlYW0gY2xvc2VkIGFmdGVyIHRoZSB3cml0ZSBoYW5kc2hha2UgY29tcGxldGVzLCBhIHdyaXRlXHJcbiAgICAvLyBvcGVyYXRpb24gZmFpbGVkIGFuZCB3ZSBmYWlsIHRoZSBwZW5kaW5nIG9wZXJhdGlvbi5cclxuICAgIGlmIChlcnJvciAmJiBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmhhbmRzaGFrZUNvbXBsZXRlKSB7XHJcbiAgICAgICAgLy8gVGhpcyBlcnJvciBhZmZlY3RzIHRoZSBhY3R1YWwgd3JpdGUuXHJcbiAgICAgICAgYXdhaXQgaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8vIFRoZSB3cml0ZSBzdHJlYW0gbWlnaHQgaGF2ZSBiZWVuIHN0YXJ0ZWQgYnkgcmVmaWxsaW5nIHRoZSB3cml0ZVxyXG4gICAgLy8gcGlwZWxpbmUgZm9yIGZhaWxlZCB3cml0ZXNcclxuICAgIGlmIChzaG91bGRTdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcclxuICAgICAgICBzdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XHJcbiAgICAvLyBPbmx5IGhhbmRsZSBwZXJtYW5lbnQgZXJyb3JzIGhlcmUuIElmIGl0J3MgdHJhbnNpZW50LCBqdXN0IGxldCB0aGUgcmV0cnlcclxuICAgIC8vIGxvZ2ljIGtpY2sgaW4uXHJcbiAgICBpZiAoaXNQZXJtYW5lbnRXcml0ZUVycm9yKGVycm9yLmNvZGUpKSB7XHJcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBwZXJtYW5lbnQgZXJyb3IsIHRoZSByZXF1ZXN0IGl0c2VsZiB3YXMgdGhlIHByb2JsZW1cclxuICAgICAgICAvLyBzbyBpdCdzIG5vdCBnb2luZyB0byBzdWNjZWVkIGlmIHdlIHJlc2VuZCBpdC5cclxuICAgICAgICBjb25zdCBiYXRjaCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnNoaWZ0KCk7XHJcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGl0J3MgYWxzbyB1bmxpa2VseSB0aGF0IHRoZSBzZXJ2ZXIgaXRzZWxmIGlzIG1lbHRpbmdcclxuICAgICAgICAvLyBkb3duIC0tIHRoaXMgd2FzIGp1c3QgYSBiYWQgcmVxdWVzdCBzbyBpbmhpYml0IGJhY2tvZmYgb24gdGhlIG5leHRcclxuICAgICAgICAvLyByZXN0YXJ0LlxyXG4gICAgICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaW5oaWJpdEJhY2tvZmYoKTtcclxuICAgICAgICBhd2FpdCBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgKCkgPT4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5yZWplY3RGYWlsZWRXcml0ZShiYXRjaC5iYXRjaElkLCBlcnJvcikpO1xyXG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3aXRoIHRoZSBjb21wbGV0aW9uIG9mIHRoaXMgbXV0YXRpb25cclxuICAgICAgICAvLyBhbm90aGVyIHNsb3QgaGFzIGZyZWVkIHVwLlxyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVzdGFydE5ldHdvcmsocmVtb3RlU3RvcmUpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNCAvKiBPZmZsaW5lQ2F1c2UuQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XHJcbiAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UocmVtb3RlU3RvcmUsIHVzZXIpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XHJcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZW1vdGVTdG9yZSByZWNlaXZlZCBuZXcgY3JlZGVudGlhbHMnKTtcclxuICAgIGNvbnN0IHVzZXNOZXR3b3JrID0gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgLy8gVGVhciBkb3duIGFuZCByZS1jcmVhdGUgb3VyIG5ldHdvcmsgc3RyZWFtcy4gVGhpcyB3aWxsIGVuc3VyZSB3ZSBnZXQgYVxyXG4gICAgLy8gZnJlc2ggYXV0aCB0b2tlbiBmb3IgdGhlIG5ldyB1c2VyIGFuZCByZS1maWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoXHJcbiAgICAvLyBuZXcgbXV0YXRpb25zIGZyb20gdGhlIExvY2FsU3RvcmUgKHNpbmNlIG11dGF0aW9ucyBhcmUgcGVyLXVzZXIpLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xyXG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgaWYgKHVzZXNOZXR3b3JrKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IHRoZSBuZXR3b3JrIHN0YXR1cyB0byBVbmtub3duIGlmIHdlIGFyZSBvZmZsaW5lLlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5oYW5kbGVDcmVkZW50aWFsQ2hhbmdlKHVzZXIpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xyXG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRvZ2dsZXMgdGhlIG5ldHdvcmsgc3RhdGUgd2hlbiB0aGUgY2xpZW50IGdhaW5zIG9yIGxvc2VzIGl0cyBwcmltYXJ5IGxlYXNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XHJcbiAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDIgLyogT2ZmbGluZUNhdXNlLklzU2Vjb25kYXJ5ICovKTtcclxuICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV2F0Y2hTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHdpdGggYHJlbW90ZVN0b3JlSW1wbGAuIFJldHVybnMgdGhlIGV4aXN0aW5nIHN0cmVhbSBpZiBvbmUgaXNcclxuICogYWxyZWFkeSBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogT24gaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2F0Y2hTdHJlYW0gZ2V0cyByZWdpc3RlcmVkIG9uIHN0YXJ0dXAuXHJcbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0gPSBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZSwgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUsIHtcclxuICAgICAgICAgICAgb25Db25uZWN0ZWQ6IG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxyXG4gICAgICAgICAgICBvbk9wZW46IG9uV2F0Y2hTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25DbG9zZTogb25XYXRjaFN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25XYXRjaENoYW5nZTogb25XYXRjaFN0cmVhbUNoYW5nZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbS5pbmhpYml0QmFja29mZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW07XHJcbn1cclxuLyoqXHJcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV3JpdGVTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHdpdGggYHJlbW90ZVN0b3JlSW1wbGAuIFJldHVybnMgdGhlIGV4aXN0aW5nIHN0cmVhbSBpZiBvbmUgaXNcclxuICogYWxyZWFkeSBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogT24gaU9TIGFuZCBBbmRyb2lkLCB0aGUgV3JpdGVTdHJlYW0gZ2V0cyByZWdpc3RlcmVkIG9uIHN0YXJ0dXAuXHJcbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0gPSBuZXdQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZSwgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUsIHtcclxuICAgICAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25DbG9zZTogb25Xcml0ZVN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25IYW5kc2hha2VDb21wbGV0ZTogb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5pbmhpYml0QmFja29mZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHN0YXJ0IHRoZSB3cml0ZSBzdHJlYW0gaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgYFN0b3BwaW5nIHdyaXRlIHN0cmVhbSB3aXRoICR7cmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RofSBwZW5kaW5nIHdyaXRlc2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ0ID0gJ0FzeW5jUXVldWUnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXHJcbiAqXHJcbiAqIEl0IGlzIGNyZWF0ZWQgdmlhIERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUoKS5cclxuICpcclxuICogU3VwcG9ydHMgY2FuY2VsbGF0aW9uICh2aWEgY2FuY2VsKCkpIGFuZCBlYXJseSBleGVjdXRpb24gKHZpYSBza2lwRGVsYXkoKSkuXHJcbiAqXHJcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcclxuICogaW4gbmV3ZXIgdmVyc2lvbnMgb2YgVHlwZVNjcmlwdCBkZWZpbmVzIGBmaW5hbGx5YCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpblxyXG4gKiBJRS5cclxuICovXHJcbmNsYXNzIERlbGF5ZWRPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSB0aW1lcklkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0VGltZU1zID0gdGFyZ2V0VGltZU1zO1xyXG4gICAgICAgIHRoaXMub3AgPSBvcDtcclxuICAgICAgICB0aGlzLnJlbW92YWxDYWxsYmFjayA9IHJlbW92YWxDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xyXG4gICAgICAgIC8vIEl0J3Mgbm9ybWFsIGZvciB0aGUgZGVmZXJyZWQgcHJvbWlzZSB0byBiZSBjYW5jZWxlZCAoZHVlIHRvIGNhbmNlbGxhdGlvbilcclxuICAgICAgICAvLyBhbmQgc28gd2UgYXR0YWNoIGEgZHVtbXkgY2F0Y2ggY2FsbGJhY2sgdG8gYXZvaWRcclxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxyXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucHJvbWlzZS5jYXRjaChlcnIgPT4geyB9KTtcclxuICAgIH1cclxuICAgIGdldCBwcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBEZWxheWVkT3BlcmF0aW9uIHRoYXQgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIGJlXHJcbiAgICAgKiBleGVjdXRlZCBvbiB0aGUgcHJvdmlkZWQgYXN5bmNRdWV1ZSBhZnRlciB0aGUgcHJvdmlkZWQgZGVsYXlNcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXN5bmNRdWV1ZSAtIFRoZSBxdWV1ZSB0byBzY2hlZHVsZSB0aGUgb3BlcmF0aW9uIG9uLlxyXG4gICAgICogQHBhcmFtIGlkIC0gQSBUaW1lciBJRCBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBvcGVyYXRpb24gdGhpcyBpcy5cclxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cclxuICAgICAqIEBwYXJhbSBvcCAtIFRoZSBvcGVyYXRpb24gdG8gcnVuLlxyXG4gICAgICogQHBhcmFtIHJlbW92YWxDYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgb25jZSB0aGVcclxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XHJcbiAgICAgKiAgIGZyb20gaXRzIGRlbGF5ZWRPcGVyYXRpb25zIGxpc3QuXHJcbiAgICAgKiAgIFBPUlRJTkcgTk9URTogVGhpcyBleGlzdHMgdG8gcHJldmVudCBtYWtpbmcgcmVtb3ZlRGVsYXllZE9wZXJhdGlvbigpIGFuZFxyXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVBbmRTY2hlZHVsZShhc3luY1F1ZXVlLCB0aW1lcklkLCBkZWxheU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IERhdGUubm93KCkgKyBkZWxheU1zO1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ZWRPcCA9IG5ldyBEZWxheWVkT3BlcmF0aW9uKGFzeW5jUXVldWUsIHRpbWVySWQsIHRhcmdldFRpbWUsIG9wLCByZW1vdmFsQ2FsbGJhY2spO1xyXG4gICAgICAgIGRlbGF5ZWRPcC5zdGFydChkZWxheU1zKTtcclxuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24gYnlcclxuICAgICAqIGNyZWF0ZUFuZFNjaGVkdWxlKCkuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KGRlbGF5TXMpIHtcclxuICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZURlbGF5RWxhcHNlZCgpLCBkZWxheU1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWVzIHRoZSBvcGVyYXRpb24gdG8gcnVuIGltbWVkaWF0ZWx5IChpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJ1biBvclxyXG4gICAgICogY2FuY2VsZWQpLlxyXG4gICAgICovXHJcbiAgICBza2lwRGVsYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgdGhlIG9wZXJhdGlvbiBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLiBUaGVcclxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBBcyBsb25nIGFzIHRoZSBvcGVyYXRpb24gaGFzIG5vdCB5ZXQgYmVlbiBydW4sIGNhbGxpbmcgY2FuY2VsKCkgcHJvdmlkZXMgYVxyXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbChyZWFzb24pIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsICdPcGVyYXRpb24gY2FuY2VsbGVkJyArIChyZWFzb24gPyAnOiAnICsgcmVhc29uIDogJycpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlRGVsYXlFbGFwc2VkKCkge1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZhbENhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckhhbmRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJIYW5kbGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIEZpcmVzdG9yZUVycm9yIHRoYXQgY2FuIGJlIHN1cmZhY2VkIHRvIHRoZSB1c2VyIGlmIHRoZSBwcm92aWRlZFxyXG4gKiBlcnJvciBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiBSZS10aHJvd3MgdGhlIGVycm9yIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgbXNnKSB7XHJcbiAgICBsb2dFcnJvcihMT0dfVEFHJDQsIGAke21zZ306ICR7ZX1gKTtcclxuICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsIGAke21zZ306ICR7ZX1gKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvY3VtZW50U2V0IGlzIGFuIGltbXV0YWJsZSAoY29weS1vbi13cml0ZSkgY29sbGVjdGlvbiB0aGF0IGhvbGRzIGRvY3VtZW50c1xyXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuIFdlIGFsd2F5cyBhZGQgYSBkb2N1bWVudCBrZXlcclxuICogY29tcGFyYXRvciBvbiB0b3Agb2Ygd2hhdCBpcyBwcm92aWRlZCB0byBndWFyYW50ZWUgZG9jdW1lbnQgZXF1YWxpdHkgYmFzZWQgb25cclxuICogdGhlIGtleS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U2V0IHtcclxuICAgIC8qKiBUaGUgZGVmYXVsdCBvcmRlcmluZyBpcyBieSBrZXkgaWYgdGhlIGNvbXBhcmF0b3IgaXMgb21pdHRlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tcCkge1xyXG4gICAgICAgIC8vIFdlIGFyZSBhZGRpbmcgZG9jdW1lbnQga2V5IGNvbXBhcmF0b3IgdG8gdGhlIGVuZCBhcyBpdCdzIHRoZSBvbmx5XHJcbiAgICAgICAgLy8gZ3VhcmFudGVlZCB1bmlxdWUgcHJvcGVydHkgb2YgYSBkb2N1bWVudC5cclxuICAgICAgICBpZiAoY29tcCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSAoZDEsIGQyKSA9PiBjb21wKGQxLCBkMikgfHwgRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSAoZDEsIGQyKSA9PiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5rZXllZE1hcCA9IGRvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRTZXQgPSBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgY29weSBvZiB0aGUgZXhpc3RpbmcgRG9jdW1lbnRTZXQsIHVzaW5nIHRoZSBzYW1lXHJcbiAgICAgKiBjb21wYXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW1wdHlTZXQob2xkU2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNldChvbGRTZXQuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ZWRNYXAuZ2V0KGtleSkgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXllZE1hcC5nZXQoa2V5KTtcclxuICAgIH1cclxuICAgIGZpcnN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIGxhc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0Lm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgcHJvdmlkZWQga2V5IGluIHRoZSBkb2N1bWVudCBzZXQsIG9yIC0xIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQga2V5IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzZXQ7XHJcbiAgICAgKi9cclxuICAgIGluZGV4T2Yoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5rZXllZE1hcC5nZXQoa2V5KTtcclxuICAgICAgICByZXR1cm4gZG9jID8gdGhpcy5zb3J0ZWRTZXQuaW5kZXhPZihkb2MpIDogLTE7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBJdGVyYXRlcyBkb2N1bWVudHMgaW4gb3JkZXIgZGVmaW5lZCBieSBcImNvbXBhcmF0b3JcIiAqL1xyXG4gICAgZm9yRWFjaChjYikge1xyXG4gICAgICAgIHRoaXMuc29ydGVkU2V0Lmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcclxuICAgICAgICAgICAgY2Ioayk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGtleSAqL1xyXG4gICAgYWRkKGRvYykge1xyXG4gICAgICAgIC8vIEZpcnN0IHJlbW92ZSB0aGUgZWxlbWVudCBpZiB3ZSBoYXZlIGl0LlxyXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuZGVsZXRlKGRvYy5rZXkpO1xyXG4gICAgICAgIHJldHVybiBzZXQuY29weShzZXQua2V5ZWRNYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyksIHNldC5zb3J0ZWRTZXQuaW5zZXJ0KGRvYywgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIERlbGV0ZXMgYSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5ICovXHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIWRvYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmtleWVkTWFwLnJlbW92ZShrZXkpLCB0aGlzLnNvcnRlZFNldC5yZW1vdmUoZG9jKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEb2N1bWVudFNldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuc29ydGVkU2V0LmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGhpc0RvYyA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckRvYyA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzRG9jLmlzRXF1YWwob3RoZXJEb2MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBjb25zdCBkb2NTdHJpbmdzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGRvY1N0cmluZ3MucHVzaChkb2MudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRvY1N0cmluZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnRG9jdW1lbnRTZXQgKCknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoXFxuICAnICsgZG9jU3RyaW5ncy5qb2luKCcgIFxcbicpICsgJ1xcbiknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvcHkoa2V5ZWRNYXAsIHNvcnRlZFNldCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBEb2N1bWVudFNldCgpO1xyXG4gICAgICAgIG5ld1NldC5jb21wYXJhdG9yID0gdGhpcy5jb21wYXJhdG9yO1xyXG4gICAgICAgIG5ld1NldC5rZXllZE1hcCA9IGtleWVkTWFwO1xyXG4gICAgICAgIG5ld1NldC5zb3J0ZWRTZXQgPSBzb3J0ZWRTZXQ7XHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9jdW1lbnRDaGFuZ2VTZXQga2VlcHMgdHJhY2sgb2YgYSBzZXQgb2YgY2hhbmdlcyB0byBkb2NzIGluIGEgcXVlcnksIG1lcmdpbmdcclxuICogZHVwbGljYXRlIGV2ZW50cyBmb3IgdGhlIHNhbWUgZG9jLlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRDaGFuZ2VTZXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdHJhY2soY2hhbmdlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gY2hhbmdlLmRvYy5rZXk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hhbmdlID0gdGhpcy5jaGFuZ2VNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFvbGRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCBjaGFuZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgY2hhbmdlIHdpdGggdGhlIGV4aXN0aW5nIGNoYW5nZS5cclxuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwgY2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSAhPT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcclxuICAgICAgICAgICAgICAgIGRvYzogY2hhbmdlLmRvY1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovICYmXHJcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IG9sZENoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8gJiZcclxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyB0aGVzZSBjYXNlcywgd2hpY2ggZG9uJ3QgbWFrZSBzZW5zZTpcclxuICAgICAgICAgICAgLy8gQWRkZWQtPkFkZGVkXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPlJlbW92ZWRcclxuICAgICAgICAgICAgLy8gTW9kaWZpZWQtPkFkZGVkXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPk1vZGlmaWVkXHJcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhLT5BZGRlZFxyXG4gICAgICAgICAgICAvLyBSZW1vdmVkLT5NZXRhZGF0YVxyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBjaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVmlld1NuYXBzaG90IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBkb2NzLCBvbGREb2NzLCBkb2NDaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBzeW5jU3RhdGVDaGFuZ2VkLCBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcywgaGFzQ2FjaGVkUmVzdWx0cykge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLmRvY3MgPSBkb2NzO1xyXG4gICAgICAgIHRoaXMub2xkRG9jcyA9IG9sZERvY3M7XHJcbiAgICAgICAgdGhpcy5kb2NDaGFuZ2VzID0gZG9jQ2hhbmdlcztcclxuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gbXV0YXRlZEtleXM7XHJcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XHJcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVDaGFuZ2VkID0gc3luY1N0YXRlQ2hhbmdlZDtcclxuICAgICAgICB0aGlzLmV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzID0gZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gaGFzQ2FjaGVkUmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgdmlldyBzbmFwc2hvdCBhcyBpZiBhbGwgZG9jdW1lbnRzIGluIHRoZSBzbmFwc2hvdCB3ZXJlIGFkZGVkLiAqL1xyXG4gICAgc3RhdGljIGZyb21Jbml0aWFsRG9jdW1lbnRzKHF1ZXJ5LCBkb2N1bWVudHMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIGhhc0NhY2hlZFJlc3VsdHMpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2MgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3U25hcHNob3QocXVlcnksIGRvY3VtZW50cywgRG9jdW1lbnRTZXQuZW1wdHlTZXQoZG9jdW1lbnRzKSwgY2hhbmdlcywgbXV0YXRlZEtleXMsIGZyb21DYWNoZSwgXHJcbiAgICAgICAgLyogc3luY1N0YXRlQ2hhbmdlZD0gKi8gdHJ1ZSwgXHJcbiAgICAgICAgLyogZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM9ICovIGZhbHNlLCBoYXNDYWNoZWRSZXN1bHRzKTtcclxuICAgIH1cclxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5tdXRhdGVkS2V5cy5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbUNhY2hlICE9PSBvdGhlci5mcm9tQ2FjaGUgfHxcclxuICAgICAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzICE9PSBvdGhlci5oYXNDYWNoZWRSZXN1bHRzIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCAhPT0gb3RoZXIuc3luY1N0YXRlQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAhdGhpcy5tdXRhdGVkS2V5cy5pc0VxdWFsKG90aGVyLm11dGF0ZWRLZXlzKSB8fFxyXG4gICAgICAgICAgICAhcXVlcnlFcXVhbHModGhpcy5xdWVyeSwgb3RoZXIucXVlcnkpIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmRvY3MuaXNFcXVhbChvdGhlci5kb2NzKSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5vbGREb2NzLmlzRXF1YWwob3RoZXIub2xkRG9jcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kb2NDaGFuZ2VzO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ2hhbmdlcyA9IG90aGVyLmRvY0NoYW5nZXM7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICE9PSBvdGhlckNoYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLnR5cGUgIT09IG90aGVyQ2hhbmdlc1tpXS50eXBlIHx8XHJcbiAgICAgICAgICAgICAgICAhY2hhbmdlc1tpXS5kb2MuaXNFcXVhbChvdGhlckNoYW5nZXNbaV0uZG9jKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgbGlzdGVuZXJzIGFuZCB0aGUgbGFzdCByZWNlaXZlZCBWaWV3U25hcHNob3QgZm9yIGEgcXVlcnkgYmVpbmdcclxuICogdHJhY2tlZCBieSBFdmVudE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUxpc3RlbmVyc0luZm8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3U25hcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdGhhdCBjaGVja3MgaWYgdGhlIHF1ZXJ5IGhhcyBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlXHJcbiAgICBoYXNSZW1vdGVMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNvbWUobGlzdGVuZXIgPT4gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RXZlbnRNYW5hZ2VyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXJJbXBsKCk7XHJcbn1cclxuY2xhc3MgRXZlbnRNYW5hZ2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBsZXQgbGlzdGVuZXJBY3Rpb24gPSAzIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uTm9BY3Rpb25SZXF1aXJlZCAqLztcclxuICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuZXIucXVlcnk7XHJcbiAgICBsZXQgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XHJcbiAgICBpZiAoIXF1ZXJ5SW5mbykge1xyXG4gICAgICAgIHF1ZXJ5SW5mbyA9IG5ldyBRdWVyeUxpc3RlbmVyc0luZm8oKTtcclxuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcclxuICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqL1xyXG4gICAgICAgICAgICA6IDEgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5Jbml0aWFsaXplTG9jYWxMaXN0ZW5Pbmx5ICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxyXG4gICAgICAgIGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKCkpIHtcclxuICAgICAgICAvLyBRdWVyeSBoYXMgYmVlbiBsaXN0ZW5pbmcgdG8gbG9jYWwgY2FjaGUsIGFuZCB0cmllcyB0byBhZGQgYSBuZXcgbGlzdGVuZXIgc291cmNlZCBmcm9tIHdhdGNoLlxyXG4gICAgICAgIGxpc3RlbmVyQWN0aW9uID0gMiAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLlJlcXVpcmVXYXRjaENvbm5lY3Rpb25Pbmx5ICovO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBzd2l0Y2ggKGxpc3RlbmVyQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaENvbm5lY3Rpb24gKi86XHJcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi86XHJcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qKiBlbmFibGVSZW1vdGVMaXN0ZW49ICovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLzpcclxuICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50TWFuYWdlckltcGwub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEluaXRpYWxpemF0aW9uIG9mIHF1ZXJ5ICcke3N0cmluZ2lmeVF1ZXJ5KGxpc3RlbmVyLnF1ZXJ5KX0nIGZhaWxlZGApO1xyXG4gICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5zZXQocXVlcnksIHF1ZXJ5SW5mbyk7XHJcbiAgICBxdWVyeUluZm8ubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXHJcbiAgICBsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUpO1xyXG4gICAgaWYgKHF1ZXJ5SW5mby52aWV3U25hcCkge1xyXG4gICAgICAgIGNvbnN0IHJhaXNlZEV2ZW50ID0gbGlzdGVuZXIub25WaWV3U25hcHNob3QocXVlcnlJbmZvLnZpZXdTbmFwKTtcclxuICAgICAgICBpZiAocmFpc2VkRXZlbnQpIHtcclxuICAgICAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5lci5xdWVyeTtcclxuICAgIGxldCBsaXN0ZW5lckFjdGlvbiA9IDMgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XHJcbiAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeUluZm8pIHtcclxuICAgICAgICBjb25zdCBpID0gcXVlcnlJbmZvLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyQWN0aW9uID0gbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKVxyXG4gICAgICAgICAgICAgICAgICAgID8gMCAvKiBMaXN0ZW5lclJlbW92YWxBY3Rpb24uVGVybWluYXRlTG9jYWxMaXN0ZW5BbmRSZXF1aXJlV2F0Y2hEaXNjb25uZWN0aW9uICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXJ5SW5mby5oYXNSZW1vdGVMaXN0ZW5lcnMoKSAmJlxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgbGlzdGVuZXIgaXMgdGhlIGxhc3Qgb25lIHRoYXQgc291cmNlZCBmcm9tIHdhdGNoLlxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBY3Rpb24gPSAyIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5SZXF1aXJlV2F0Y2hEaXNjb25uZWN0aW9uT25seSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobGlzdGVuZXJBY3Rpb24pIHtcclxuICAgICAgICBjYXNlIDAgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoRGlzY29ubmVjdGlvbiAqLzpcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJJbXBsLm9uVW5saXN0ZW4ocXVlcnksIFxyXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgY2FzZSAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi86XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vblVubGlzdGVuKHF1ZXJ5LCBcclxuICAgICAgICAgICAgLyoqIGRpc2FibGVSZW1vdGVMaXN0ZW49ICovIGZhbHNlKTtcclxuICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VySW1wbC5vbkxhc3RSZW1vdGVTdG9yZVVubGlzdGVuKHF1ZXJ5KTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZShldmVudE1hbmFnZXIsIHZpZXdTbmFwcykge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgbGV0IHJhaXNlZEV2ZW50ID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IHZpZXdTbmFwIG9mIHZpZXdTbmFwcykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdmlld1NuYXAucXVlcnk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vblZpZXdTbmFwc2hvdCh2aWV3U25hcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gdmlld1NuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJhaXNlZEV2ZW50KSB7XHJcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbldhdGNoRXJyb3IoZXZlbnRNYW5hZ2VyLCBxdWVyeSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5SW5mbykge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy4gTk9URTogV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHN5bmNFbmdpbmUudW5saXN0ZW4oKVxyXG4gICAgLy8gYWZ0ZXIgYW4gZXJyb3IuXHJcbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5KTtcclxufVxyXG5mdW5jdGlvbiBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKGV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmZvckVhY2goKF8sIHF1ZXJ5SW5mbykgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChyYWlzZWRFdmVudCkge1xyXG4gICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBvYnNlcnZlcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuYWRkKG9ic2VydmVyKTtcclxuICAgIC8vIEltbWVkaWF0ZWx5IGZpcmUgYW4gaW5pdGlhbCBldmVudCwgaW5kaWNhdGluZyBhbGwgZXhpc3RpbmcgbGlzdGVuZXJzXHJcbiAgICAvLyBhcmUgaW4tc3luYy5cclxuICAgIG9ic2VydmVyLm5leHQoKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBldmVudE1hbmFnZXJJbXBsLnNuYXBzaG90c0luU3luY0xpc3RlbmVycy5kZWxldGUob2JzZXJ2ZXIpO1xyXG59XHJcbi8vIENhbGwgYWxsIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gc2V0LlxyXG5mdW5jdGlvbiByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpIHtcclxuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQoKTtcclxuICAgIH0pO1xyXG59XHJcbnZhciBMaXN0ZW5lckRhdGFTb3VyY2U7XHJcbihmdW5jdGlvbiAoTGlzdGVuZXJEYXRhU291cmNlKSB7XHJcbiAgICAvKiogTGlzdGVuIHRvIGJvdGggY2FjaGUgYW5kIHNlcnZlciBjaGFuZ2VzICovXHJcbiAgICBMaXN0ZW5lckRhdGFTb3VyY2VbXCJEZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XHJcbiAgICAvKiogTGlzdGVuIHRvIGNoYW5nZXMgaW4gY2FjaGUgb25seSAqL1xyXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiQ2FjaGVcIl0gPSBcImNhY2hlXCI7XHJcbn0pKExpc3RlbmVyRGF0YVNvdXJjZSB8fCAoTGlzdGVuZXJEYXRhU291cmNlID0ge30pKTtcclxuLyoqXHJcbiAqIFF1ZXJ5TGlzdGVuZXIgdGFrZXMgYSBzZXJpZXMgb2YgaW50ZXJuYWwgdmlldyBzbmFwc2hvdHMgYW5kIGRldGVybWluZXNcclxuICogd2hlbiB0byByYWlzZSB0aGUgZXZlbnQuXHJcbiAqXHJcbiAqIEl0IHVzZXMgYW4gT2JzZXJ2ZXIgdG8gZGlzcGF0Y2ggZXZlbnRzLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlMaXN0ZW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcXVlcnlPYnNlcnZlciwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIgPSBxdWVyeU9ic2VydmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWwgc25hcHNob3RzIChlLmcuIGZyb20gY2FjaGUpIG1heSBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgd3JhcHBlZFxyXG4gICAgICAgICAqIG9ic2VydmVyLiBUaGlzIGZsYWcgaXMgc2V0IHRvIHRydWUgb25jZSB3ZSd2ZSBhY3R1YWxseSByYWlzZWQgYW4gZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNuYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIG5ldyBWaWV3U25hcHNob3QgdG8gdGhpcyBsaXN0ZW5lciwgcmFpc2luZyBhIHVzZXItZmFjaW5nIGV2ZW50XHJcbiAgICAgKiBpZiBhcHBsaWNhYmxlIChkZXBlbmRpbmcgb24gd2hhdCBjaGFuZ2VkLCB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbnRvXHJcbiAgICAgKiBtZXRhZGF0YS1vbmx5IGNoYW5nZXMsIGV0Yy4pLiBSZXR1cm5zIHRydWUgaWYgYSB1c2VyLWZhY2luZyBldmVudCB3YXNcclxuICAgICAqIGluZGVlZCByYWlzZWQuXHJcbiAgICAgKi9cclxuICAgIG9uVmlld1NuYXBzaG90KHNuYXApIHtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWV0YWRhdGEgb25seSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHNuYXAuZG9jQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS50eXBlICE9PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzLnB1c2goZG9jQ2hhbmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbmFwID0gbmV3IFZpZXdTbmFwc2hvdChzbmFwLnF1ZXJ5LCBzbmFwLmRvY3MsIHNuYXAub2xkRG9jcywgZG9jQ2hhbmdlcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuc3luY1N0YXRlQ2hhbmdlZCwgXHJcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyB0cnVlLCBzbmFwLmhhc0NhY2hlZFJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHNuYXAsIHRoaXMub25saW5lU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHNuYXApO1xyXG4gICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2hvdWxkUmFpc2VFdmVudChzbmFwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIubmV4dChzbmFwKTtcclxuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNuYXAgPSBzbmFwO1xyXG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcclxuICAgIH1cclxuICAgIG9uRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgd2hldGhlciBhIHNuYXBzaG90IHdhcyByYWlzZWQuICovXHJcbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xyXG4gICAgICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnNuYXAgJiZcclxuICAgICAgICAgICAgIXRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQodGhpcy5zbmFwLCBvbmxpbmVTdGF0ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXApO1xyXG4gICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcclxuICAgIH1cclxuICAgIHNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHNuYXAsIG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgLy8gQWx3YXlzIHJhaXNlIHRoZSBmaXJzdCBldmVudCB3aGVuIHdlJ3JlIHN5bmNlZFxyXG4gICAgICAgIGlmICghc25hcC5mcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsd2F5cyByYWlzZSBldmVudCBpZiBsaXN0ZW5pbmcgdG8gY2FjaGVcclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogV2UgY29uc2lkZXIgT25saW5lU3RhdGUuVW5rbm93biBhcyBvbmxpbmUgKGl0IHNob3VsZCBiZWNvbWUgT2ZmbGluZVxyXG4gICAgICAgIC8vIG9yIE9ubGluZSBpZiB3ZSB3YWl0IGxvbmcgZW5vdWdoKS5cclxuICAgICAgICBjb25zdCBtYXliZU9ubGluZSA9IG9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovO1xyXG4gICAgICAgIC8vIERvbid0IHJhaXNlIHRoZSBldmVudCBpZiB3ZSdyZSBvbmxpbmUsIGFyZW4ndCBzeW5jZWQgeWV0IChjaGVja2VkXHJcbiAgICAgICAgLy8gYWJvdmUpIGFuZCBhcmUgd2FpdGluZyBmb3IgYSBzeW5jLlxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FpdEZvclN5bmNXaGVuT25saW5lICYmIG1heWJlT25saW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmFpc2UgZGF0YSBmcm9tIGNhY2hlIGlmIHdlIGhhdmUgYW55IGRvY3VtZW50cywgaGF2ZSBjYWNoZWQgcmVzdWx0cyBiZWZvcmUsXHJcbiAgICAgICAgLy8gb3Igd2UgYXJlIG9mZmxpbmUuXHJcbiAgICAgICAgcmV0dXJuICghc25hcC5kb2NzLmlzRW1wdHkoKSB8fFxyXG4gICAgICAgICAgICBzbmFwLmhhc0NhY2hlZFJlc3VsdHMgfHxcclxuICAgICAgICAgICAgb25saW5lU3RhdGUgPT09IFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xyXG4gICAgfVxyXG4gICAgc2hvdWxkUmFpc2VFdmVudChzbmFwKSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBoYW5kbGUgaW5jbHVkZURvY3VtZW50TWV0YWRhdGFDaGFuZ2VzIGhlcmUgYmVjYXVzZVxyXG4gICAgICAgIC8vIHRoZSBNZXRhZGF0YSBvbmx5IGNoYW5nZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc3RyaXBwZWQgb3V0IGlmIG5lZWRlZC5cclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBvbmx5IGNoYW5nZXMgd2Ugd2lsbCBzZWUgYXJlIHRoZSBvbmVzIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIHByb3BhZ2F0ZS5cclxuICAgICAgICBpZiAoc25hcC5kb2NDaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdXcml0ZXNDaGFuZ2VkID0gdGhpcy5zbmFwICYmIHRoaXMuc25hcC5oYXNQZW5kaW5nV3JpdGVzICE9PSBzbmFwLmhhc1BlbmRpbmdXcml0ZXM7XHJcbiAgICAgICAgaWYgKHNuYXAuc3luY1N0YXRlQ2hhbmdlZCB8fCBoYXNQZW5kaW5nV3JpdGVzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPT09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlbmVyYWxseSB3ZSBzaG91bGQgaGF2ZSBoaXQgb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgYnV0IGl0J3MgcG9zc2libGVcclxuICAgICAgICAvLyB0byBnZXQgaGVyZSBpZiB0aGVyZSB3ZXJlIG9ubHkgbWV0YWRhdGEgZG9jQ2hhbmdlcyBhbmQgdGhleSBnb3RcclxuICAgICAgICAvLyBzdHJpcHBlZCBvdXQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmFpc2VJbml0aWFsRXZlbnQoc25hcCkge1xyXG4gICAgICAgIHNuYXAgPSBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHMoc25hcC5xdWVyeSwgc25hcC5kb2NzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcclxuICAgICAgICB0aGlzLnJhaXNlZEluaXRpYWxFdmVudCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW5zVG9SZW1vdGVTdG9yZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZSAhPT0gTGlzdGVuZXJEYXRhU291cmNlLkNhY2hlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHNldCBvZiBjaGFuZ2VzIHRvIHdoYXQgZG9jdW1lbnRzIGFyZSBjdXJyZW50bHkgaW4gdmlldyBhbmQgb3V0IG9mIHZpZXcgZm9yXHJcbiAqIGEgZ2l2ZW4gcXVlcnkuIFRoZXNlIGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlIExvY2FsU3RvcmUgYnkgdGhlIFZpZXcgKHZpYVxyXG4gKiB0aGUgU3luY0VuZ2luZSkgYW5kIGFyZSB1c2VkIHRvIHBpbiAvIHVucGluIGRvY3VtZW50cyBhcyBhcHByb3ByaWF0ZS5cclxuICovXHJcbmNsYXNzIExvY2FsVmlld0NoYW5nZXMge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgICAgICB0aGlzLmFkZGVkS2V5cyA9IGFkZGVkS2V5cztcclxuICAgICAgICB0aGlzLnJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVNuYXBzaG90KHRhcmdldElkLCB2aWV3U25hcHNob3QpIHtcclxuICAgICAgICBsZXQgYWRkZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBsZXQgcmVtb3ZlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHZpZXdTbmFwc2hvdC5kb2NDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jQ2hhbmdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkS2V5cyA9IGFkZGVkS2V5cy5hZGQoZG9jQ2hhbmdlLmRvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZXdDaGFuZ2VzKHRhcmdldElkLCB2aWV3U25hcHNob3QuZnJvbUNhY2hlLCBhZGRlZEtleXMsIHJlbW92ZWRLZXlzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgb2JqZWN0cyBmcm9tIGJ1bmRsZXMgdG8gbW9kZWwgb2JqZWN0cyBpbiB0aGUgU0RLLlxyXG4gKi9cclxuY2xhc3MgQnVuZGxlQ29udmVydGVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHRvRG9jdW1lbnRLZXkobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIEJ1bmRsZURvY3VtZW50IHRvIGEgTXV0YWJsZURvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICB0b011dGFibGVEb2N1bWVudChidW5kbGVkRG9jKSB7XHJcbiAgICAgICAgaWYgKGJ1bmRsZWREb2MubWV0YWRhdGEuZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tRG9jdW1lbnQodGhpcy5zZXJpYWxpemVyLCBidW5kbGVkRG9jLmRvY3VtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQodGhpcy50b0RvY3VtZW50S2V5KGJ1bmRsZWREb2MubWV0YWRhdGEubmFtZSksIHRoaXMudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlZERvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU25hcHNob3RWZXJzaW9uKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVZlcnNpb24odGltZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdG8gcHJvY2VzcyB0aGUgZWxlbWVudHMgZnJvbSBhIGJ1bmRsZSwgbG9hZCB0aGVtIGludG8gbG9jYWxcclxuICogc3RvcmFnZSBhbmQgcHJvdmlkZSBwcm9ncmVzcyB1cGRhdGUgd2hpbGUgbG9hZGluZy5cclxuICovXHJcbmNsYXNzIEJ1bmRsZUxvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihidW5kbGVNZXRhZGF0YSwgbG9jYWxTdG9yZSwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMuYnVuZGxlTWV0YWRhdGEgPSBidW5kbGVNZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgLyoqIEJhdGNoZWQgcXVlcmllcyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAvKiogQmF0Y2hlZCBkb2N1bWVudHMgdG8gYmUgc2F2ZWQgaW50byBzdG9yYWdlICovXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBbXTtcclxuICAgICAgICAvKiogVGhlIGNvbGxlY3Rpb24gZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoaXMgYnVuZGxlLiAqL1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gYnVuZGxlSW5pdGlhbFByb2dyZXNzKGJ1bmRsZU1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbGVtZW50IGZyb20gdGhlIGJ1bmRsZSB0byB0aGUgbG9hZGVyLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBuZXcgcHJvZ3Jlc3MgaWYgYWRkaW5nIHRoZSBlbGVtZW50IGxlYWRzIHRvIGEgbmV3IHByb2dyZXNzLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGVsZW1lbnQuYnl0ZUxlbmd0aDtcclxuICAgICAgICBsZXQgZG9jdW1lbnRzTG9hZGVkID0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5wdXNoKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHMucHVzaCh7IG1ldGFkYXRhOiBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSB9KTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5leGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICsrZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBzLmFkZChwYXRoLmdldChwYXRoLmxlbmd0aCAtIDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRzW3RoaXMuZG9jdW1lbnRzLmxlbmd0aCAtIDFdLmRvY3VtZW50ID1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudDtcclxuICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudHNMb2FkZWQgIT09IHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkID0gZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0UXVlcnlEb2N1bWVudE1hcHBpbmcoZG9jdW1lbnRzKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlEb2N1bWVudE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBidW5kbGVDb252ZXJ0ZXIgPSBuZXcgQnVuZGxlQ29udmVydGVySW1wbCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xyXG4gICAgICAgICAgICBpZiAoYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50S2V5ID0gYnVuZGxlQ29udmVydGVyLnRvRG9jdW1lbnRLZXkoYnVuZGxlRG9jLm1ldGFkYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeU5hbWUgb2YgYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleXMgPSAocXVlcnlEb2N1bWVudE1hcC5nZXQocXVlcnlOYW1lKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5RG9jdW1lbnRNYXAuc2V0KHF1ZXJ5TmFtZSwgZG9jdW1lbnRLZXlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcnlEb2N1bWVudE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBwcm9ncmVzcyB0byAnU3VjY2VzcycgYW5kIHJldHVybiB0aGUgdXBkYXRlZCBwcm9ncmVzcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY29tcGxldGUoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZERvY3MgPSBhd2FpdCBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKHRoaXMubG9jYWxTdG9yZSwgbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKSwgdGhpcy5kb2N1bWVudHMsIHRoaXMuYnVuZGxlTWV0YWRhdGEuaWQpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSB0aGlzLmdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKHRoaXMuZG9jdW1lbnRzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgdGhpcy5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeSh0aGlzLmxvY2FsU3RvcmUsIHEsIHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHEubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2dyZXNzLnRhc2tTdGF0ZSA9ICdTdWNjZXNzJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzcyxcclxuICAgICAgICAgICAgY2hhbmdlZENvbGxlY3Rpb25Hcm91cHM6IHRoaXMuY29sbGVjdGlvbkdyb3VwcyxcclxuICAgICAgICAgICAgY2hhbmdlZERvY3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbCBwcm9ncmVzcyBvZlxyXG4gKiBsb2FkaW5nIGEgYnVuZGxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxyXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogMCxcclxuICAgICAgICBieXRlc0xvYWRlZDogMCxcclxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXHJcbiAgICAgICAgdG90YWxCeXRlczogbWV0YWRhdGEudG90YWxCeXRlc1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRoYXQgdGhlIGxvYWRpbmdcclxuICogaGFzIHN1Y2NlZWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXNrU3RhdGU6ICdTdWNjZXNzJyxcclxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxyXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxyXG4gICAgICAgIHRvdGFsRG9jdW1lbnRzOiBtZXRhZGF0YS50b3RhbERvY3VtZW50cyxcclxuICAgICAgICB0b3RhbEJ5dGVzOiBtZXRhZGF0YS50b3RhbEJ5dGVzXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFkZGVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZW1vdmVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmlldyBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0aW5nIHRoZSBmaW5hbCBtZXJnZWQgdHJ1dGggb2Ygd2hhdCBkb2NzIGFyZSBpblxyXG4gKiBhIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyB0byBkb2NzLCBhbmQgYXBwbGllc1xyXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXHJcbiAqL1xyXG5jbGFzcyBWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcclxuICAgIC8qKiBEb2N1bWVudHMgaW5jbHVkZWQgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cclxuICAgIF9zeW5jZWREb2N1bWVudHMpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgdGhpcy5fc3luY2VkRG9jdW1lbnRzID0gX3N5bmNlZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmbGFnIHdoZXRoZXIgdGhlIHZpZXcgaXMgY3VycmVudCB3aXRoIHRoZSBiYWNrZW5kLiBBIHZpZXcgaXMgY29uc2lkZXJlZFxyXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XHJcbiAgICAgICAgICogbG9zZSBjb25zaXN0ZW5jeSB3aXRoaW4gdGhlIHdhdGNoIHN0cmVhbSAoZS5nLiBiZWNhdXNlIG9mIGFuIGV4aXN0ZW5jZVxyXG4gICAgICAgICAqIGZpbHRlciBtaXNtYXRjaCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIERvY3VtZW50cyBpbiB0aGUgdmlldyBidXQgbm90IGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgLyoqIERvY3VtZW50IEtleXMgdGhhdCBoYXZlIGxvY2FsIGNoYW5nZXMgKi9cclxuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBuZXcgRG9jdW1lbnRTZXQodGhpcy5kb2NDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiByZW1vdGUgZG9jdW1lbnRzIHRoYXQgdGhlIHNlcnZlciBoYXMgdG9sZCB1cyBiZWxvbmdzIHRvIHRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKiB0aGlzIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBzeW5jZWREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5bmNlZERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBkb2MgY2hhbmdlcywgYXBwbGllcyB0aGUgcXVlcnkgbGltaXQsIGFuZCBjb21wdXRlc1xyXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxyXG4gICAgICogbmVlZCB0byBnbyBiYWNrIHRvIHRoZSBsb2NhbCBjYWNoZSBmb3IgbW9yZSByZXN1bHRzLiBEb2VzIG5vdCBtYWtlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgdmlldy5cclxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0NoYW5nZXMgLSBJZiB0aGlzIGlzIGJlaW5nIGNhbGxlZCB3aXRoIGEgcmVmaWxsLCB0aGVuIHN0YXJ0XHJcbiAgICAgKiAgICAgICAgd2l0aCB0aGlzIHNldCBvZiBkb2NzIGFuZCBjaGFuZ2VzIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgdmlldy5cclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVEb2NDaGFuZ2VzKGRvY0NoYW5nZXMsIHByZXZpb3VzQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5jaGFuZ2VTZXRcclxuICAgICAgICAgICAgOiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKTtcclxuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5kb2N1bWVudFNldFxyXG4gICAgICAgICAgICA6IHRoaXMuZG9jdW1lbnRTZXQ7XHJcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXHJcbiAgICAgICAgICAgID8gcHJldmlvdXNDaGFuZ2VzLm11dGF0ZWRLZXlzXHJcbiAgICAgICAgICAgIDogdGhpcy5tdXRhdGVkS2V5cztcclxuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcclxuICAgICAgICBsZXQgbmVlZHNSZWZpbGwgPSBmYWxzZTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgbGFzdCBkb2MgaW4gYSAoZnVsbCkgbGltaXQuIFRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIHNvbWVcclxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcclxuICAgICAgICAvLyBtZWFuIHRoZXJlIGlzIHNvbWUgb3RoZXIgZG9jdW1lbnQgaW4gdGhlIGxvY2FsIGNhY2hlIHRoYXQgZWl0aGVyIHNob3VsZFxyXG4gICAgICAgIC8vIGNvbWUgKDEpIGJldHdlZW4gdGhlIG9sZCBsYXN0IGxpbWl0IGRvYyBhbmQgdGhlIG5ldyBsYXN0IGRvY3VtZW50LCBpbiB0aGVcclxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXHJcbiAgICAgICAgLy8gZGVsZXRlcy4gU28gd2Uga2VlcCB0aGlzIGRvYyBhdCB0aGUgb2xkIGxpbWl0IHRvIGNvbXBhcmUgdGhlIHVwZGF0ZXMgdG8uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXHJcbiAgICAgICAgLy8gc2V0KSwgYmVjYXVzZSB0aGVyZSB3aWxsIG9ubHkgYmUgYWRkcyAtLSBubyBkZWxldGVzIG9yIHVwZGF0ZXMuXHJcbiAgICAgICAgY29uc3QgbGFzdERvY0luTGltaXQgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovICYmXHJcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcclxuICAgICAgICAgICAgPyBvbGREb2N1bWVudFNldC5sYXN0KClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxyXG4gICAgICAgICAgICBvbGREb2N1bWVudFNldC5zaXplID09PSB0aGlzLnF1ZXJ5LmxpbWl0XHJcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQuZmlyc3QoKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgZG9jQ2hhbmdlcy5pbm9yZGVyVHJhdmVyc2FsKChrZXksIGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZERvYyA9IG9sZERvY3VtZW50U2V0LmdldChrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBxdWVyeU1hdGNoZXModGhpcy5xdWVyeSwgZW50cnkpID8gZW50cnkgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zID0gb2xkRG9jXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMubXV0YXRlZEtleXMuaGFzKG9sZERvYy5rZXkpXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zID0gbmV3RG9jXHJcbiAgICAgICAgICAgICAgICA/IG5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY29uc2lkZXIgY29tbWl0dGVkIG11dGF0aW9ucyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11dGF0ZWQgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGUgdmlldy5cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5tdXRhdGVkS2V5cy5oYXMobmV3RG9jLmtleSkgJiYgbmV3RG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucylcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VBcHBsaWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaGFuZ2VcclxuICAgICAgICAgICAgaWYgKG9sZERvYyAmJiBuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3NFcXVhbCA9IG9sZERvYy5kYXRhLmlzRXF1YWwobmV3RG9jLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2NzRXF1YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jOiBuZXdEb2NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3REb2NJbkxpbWl0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IobmV3RG9jLCBsYXN0RG9jSW5MaW1pdCkgPiAwKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0RG9jSW5MaW1pdCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGZpcnN0RG9jSW5MaW1pdCkgPCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkb2MgbW92ZWQgZnJvbSBpbnNpZGUgdGhlIGxpbWl0IHRvIG91dHNpZGUgdGhlIGxpbWl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCBtZWFucyB0aGVyZSBtYXkgYmUgc29tZSBvdGhlciBkb2MgaW4gdGhlIGxvY2FsIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyAhPT0gbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9sZERvYyAmJiBuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLywgZG9jOiBuZXdEb2MgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbGREb2MgJiYgIW5ld0RvYykge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdERvY0luTGltaXQgfHwgZmlyc3REb2NJbkxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkb2Mgd2FzIHJlbW92ZWQgZnJvbSBhIGZ1bGwgbGltaXQgcXVlcnkuIFdlJ2xsIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IGZyb20gdGhlIGxvY2FsIGNhY2hlIHRvIHNlZSBpZiB3ZSBrbm93IGFib3V0IHNvbWUgb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2MgdGhhdCBzaG91bGQgYmUgaW4gdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VBcHBsaWVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jdW1lbnRTZXQgPSBuZXdEb2N1bWVudFNldC5hZGQobmV3RG9jKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEcm9wIGRvY3VtZW50cyBvdXQgdG8gbWVldCBsaW1pdC9saW1pdFRvTGFzdCByZXF1aXJlbWVudC5cclxuICAgICAgICBpZiAodGhpcy5xdWVyeS5saW1pdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3aGlsZSAobmV3RG9jdW1lbnRTZXQuc2l6ZSA+IHRoaXMucXVlcnkubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZERvYyA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi9cclxuICAgICAgICAgICAgICAgICAgICA/IG5ld0RvY3VtZW50U2V0Lmxhc3QoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcclxuICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKG9sZERvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUob2xkRG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9jdW1lbnRTZXQ6IG5ld0RvY3VtZW50U2V0LFxyXG4gICAgICAgICAgICBjaGFuZ2VTZXQsXHJcbiAgICAgICAgICAgIG5lZWRzUmVmaWxsLFxyXG4gICAgICAgICAgICBtdXRhdGVkS2V5czogbmV3TXV0YXRlZEtleXNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSB7XHJcbiAgICAgICAgLy8gV2Ugc3VwcHJlc3MgdGhlIGluaXRpYWwgY2hhbmdlIGV2ZW50IGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIG1vZGlmaWVkIGFzXHJcbiAgICAgICAgLy8gcGFydCBvZiBhIHdyaXRlIGFja25vd2xlZGdtZW50IChlLmcuIHdoZW4gdGhlIHZhbHVlIG9mIGEgc2VydmVyIHRyYW5zZm9ybVxyXG4gICAgICAgIC8vIGlzIGFwcGxpZWQpIGFzIFdhdGNoIHdpbGwgc2VuZCB1cyB0aGUgc2FtZSBkb2N1bWVudCBhZ2Fpbi5cclxuICAgICAgICAvLyBCeSBzdXBwcmVzc2luZyB0aGUgZXZlbnQsIHdlIG9ubHkgcmFpc2UgdHdvIHVzZXIgdmlzaWJsZSBldmVudHMgKG9uZSB3aXRoXHJcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KSBpbnN0ZWFkIG9mIHRocmVlXHJcbiAgICAgICAgLy8gKG9uZSB3aXRoIGBoYXNQZW5kaW5nV3JpdGVzYCwgdGhlIG1vZGlmaWVkIGRvY3VtZW50IHdpdGhcclxuICAgICAgICAvLyBgaGFzUGVuZGluZ1dyaXRlc2AgYW5kIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQpLlxyXG4gICAgICAgIHJldHVybiAob2xkRG9jLmhhc0xvY2FsTXV0YXRpb25zICYmXHJcbiAgICAgICAgICAgIG5ld0RvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMgJiZcclxuICAgICAgICAgICAgIW5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gVmlld0RvY3VtZW50Q2hhbmdlcyBhbmQgb3B0aW9uYWxseSB1cGRhdGVzXHJcbiAgICAgKiBsaW1ibyBkb2NzIGFuZCBzeW5jIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIHRhcmdldCBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0gZG9jQ2hhbmdlcyAtIFRoZSBzZXQgb2YgY2hhbmdlcyB0byBtYWtlIHRvIHRoZSB2aWV3J3MgZG9jcy5cclxuICAgICAqIEBwYXJhbSBsaW1ib1Jlc29sdXRpb25FbmFibGVkIC0gV2hldGhlciB0byB1cGRhdGUgbGltYm8gZG9jdW1lbnRzIGJhc2VkIG9uXHJcbiAgICAgKiAgICAgICAgdGhpcyBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0Q2hhbmdlIC0gQSB0YXJnZXQgY2hhbmdlIHRvIGFwcGx5IGZvciBjb21wdXRpbmcgbGltYm8gZG9jcyBhbmRcclxuICAgICAqICAgICAgICBzeW5jIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHRhcmdldElzUGVuZGluZ1Jlc2V0IC0gV2hldGhlciB0aGUgdGFyZ2V0IGlzIHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvXHJcbiAgICAgKiAgICAgICAgZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC4gSWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBpdCBpcyB0cmVhdGVkXHJcbiAgICAgKiAgICAgICAgZXF1aXZhbGVudGx5IHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSBpT1MvQW5kcm9pZCBjbGllbnRzIGFsd2F5cyBjb21wdXRlIGxpbWJvIGRvY3VtZW50IGNoYW5nZXMuXHJcbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgbGltYm9SZXNvbHV0aW9uRW5hYmxlZCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCkge1xyXG4gICAgICAgIGNvbnN0IG9sZERvY3MgPSB0aGlzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBkb2NDaGFuZ2VzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xyXG4gICAgICAgIC8vIFNvcnQgY2hhbmdlcyBiYXNlZCBvbiB0eXBlIGFuZCBxdWVyeSBjb21wYXJhdG9yXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGRvY0NoYW5nZXMuY2hhbmdlU2V0LmdldENoYW5nZXMoKTtcclxuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVDaGFuZ2VUeXBlKGMxLnR5cGUsIGMyLnR5cGUpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IoYzEuZG9jLCBjMi5kb2MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSk7XHJcbiAgICAgICAgdGFyZ2V0SXNQZW5kaW5nUmVzZXQgPSB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gbnVsbCAmJiB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gdm9pZCAwID8gdGFyZ2V0SXNQZW5kaW5nUmVzZXQgOiBmYWxzZTtcclxuICAgICAgICBjb25zdCBsaW1ib0NoYW5nZXMgPSBsaW1ib1Jlc29sdXRpb25FbmFibGVkICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldFxyXG4gICAgICAgICAgICA/IHRoaXMudXBkYXRlTGltYm9Eb2N1bWVudHMoKVxyXG4gICAgICAgICAgICA6IFtdO1xyXG4gICAgICAgIC8vIFdlIGFyZSBhdCBzeW5jZWQgc3RhdGUgaWYgdGhlcmUgaXMgbm8gbGltYm8gZG9jcyBhcmUgd2FpdGluZyB0byBiZSByZXNvbHZlZCwgdmlldyBpcyBjdXJyZW50XHJcbiAgICAgICAgLy8gd2l0aCB0aGUgYmFja2VuZCwgYW5kIHRoZSBxdWVyeSBpcyBub3QgcGVuZGluZyB0byByZXNldCBkdWUgdG8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC5cclxuICAgICAgICBjb25zdCBzeW5jZWQgPSB0aGlzLmxpbWJvRG9jdW1lbnRzLnNpemUgPT09IDAgJiYgdGhpcy5jdXJyZW50ICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldDtcclxuICAgICAgICBjb25zdCBuZXdTeW5jU3RhdGUgPSBzeW5jZWQgPyAxIC8qIFN5bmNTdGF0ZS5TeW5jZWQgKi8gOiAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLztcclxuICAgICAgICBjb25zdCBzeW5jU3RhdGVDaGFuZ2VkID0gbmV3U3luY1N0YXRlICE9PSB0aGlzLnN5bmNTdGF0ZTtcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG5ld1N5bmNTdGF0ZTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgLy8gbm8gY2hhbmdlc1xyXG4gICAgICAgICAgICByZXR1cm4geyBsaW1ib0NoYW5nZXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHRoaXMucXVlcnksIGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQsIG9sZERvY3MsIGNoYW5nZXMsIGRvY0NoYW5nZXMubXV0YXRlZEtleXMsIG5ld1N5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHN5bmNTdGF0ZUNoYW5nZWQsIFxyXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gZmFsc2UsIHRhcmdldENoYW5nZVxyXG4gICAgICAgICAgICAgICAgPyB0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMFxyXG4gICAgICAgICAgICAgICAgOiBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDogc25hcCxcclxuICAgICAgICAgICAgICAgIGxpbWJvQ2hhbmdlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhbiBPbmxpbmVTdGF0ZSBjaGFuZ2UgdG8gdGhlIHZpZXcsIHBvdGVudGlhbGx5IGdlbmVyYXRpbmcgYVxyXG4gICAgICogVmlld0NoYW5nZSBpZiB0aGUgdmlldydzIHN5bmNTdGF0ZSBjaGFuZ2VzIGFzIGEgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCAmJiBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcclxuICAgICAgICAgICAgLy8gdG8gcmVmcmVzaCBvdXIgc3luY1N0YXRlIGFuZCBnZW5lcmF0ZSBhIFZpZXdDaGFuZ2UgYXMgYXBwcm9wcmlhdGUuIFdlXHJcbiAgICAgICAgICAgIC8vIGFyZSBndWFyYW50ZWVkIHRvIGdldCBhIG5ldyBUYXJnZXRDaGFuZ2UgdGhhdCBzZXRzIGBjdXJyZW50YCBiYWNrIHRvXHJcbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0OiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKSxcclxuICAgICAgICAgICAgICAgIG11dGF0ZWRLZXlzOiB0aGlzLm11dGF0ZWRLZXlzLFxyXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBlZmZlY3QsIGp1c3QgcmV0dXJuIGEgbm8tb3AgVmlld0NoYW5nZS5cclxuICAgICAgICAgICAgcmV0dXJuIHsgbGltYm9DaGFuZ2VzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBkb2MgZm9yIHRoZSBnaXZlbiBrZXkgc2hvdWxkIGJlIGluIGxpbWJvLlxyXG4gICAgICovXHJcbiAgICBzaG91bGRCZUluTGltYm8oa2V5KSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSBlbmQgc2F5cyBpdCdzIHBhcnQgb2YgdGhpcyBxdWVyeSwgaXQncyBub3QgaW4gbGltYm8uXHJcbiAgICAgICAgaWYgKHRoaXMuX3N5bmNlZERvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBkb2Vzbid0IHRoaW5rIGl0J3MgYSByZXN1bHQsIHNvIGl0IHNob3VsZG4ndCBiZSBpbiBsaW1iby5cclxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRTZXQuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWwgY2hhbmdlcyB0byB0aGUgZG9jLCB0aGV5IG1pZ2h0IGV4cGxhaW4gd2h5IHRoZSBzZXJ2ZXJcclxuICAgICAgICAvLyBkb2Vzbid0IGtub3cgdGhhdCBpdCdzIHBhcnQgb2YgdGhlIHF1ZXJ5LiBTbyBkb24ndCBwdXQgaXQgaW4gbGltYm8uXHJcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IElkZWFsbHksIHdlIHdvdWxkIG9ubHkgY29uc2lkZXIgY2hhbmdlcyB0aGF0IG1pZ2h0IGFjdHVhbGx5XHJcbiAgICAgICAgLy8gYWZmZWN0IHRoaXMgc3BlY2lmaWMgcXVlcnkuXHJcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTZXQuZ2V0KGtleSkuaGFzTG9jYWxNdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgaW4gbGltYm8uXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgc3luY2VkRG9jdW1lbnRzLCBjdXJyZW50LCBhbmQgbGltYm8gZG9jcyBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhbmdlLlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHdoaWNoIGRvY3MgYXJlIGluIGxpbWJvLlxyXG4gICAgICovXHJcbiAgICBhcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcclxuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiAodGhpcy5fc3luY2VkRG9jdW1lbnRzID0gdGhpcy5fc3luY2VkRG9jdW1lbnRzLmFkZChrZXkpKSk7XHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiAodGhpcy5fc3luY2VkRG9jdW1lbnRzID0gdGhpcy5fc3luY2VkRG9jdW1lbnRzLmRlbGV0ZShrZXkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHRhcmdldENoYW5nZS5jdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnRzKCkge1xyXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRldGVybWluZSBsaW1ibyBkb2N1bWVudHMgd2hlbiB3ZSdyZSBpbi1zeW5jIHdpdGggdGhlIHNlcnZlci5cclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8oa2xpbXQpOiBEbyB0aGlzIGluY3JlbWVudGFsbHkgc28gdGhhdCBpdCdzIG5vdCBxdWFkcmF0aWMgd2hlblxyXG4gICAgICAgIC8vIHVwZGF0aW5nIG1hbnkgZG9jdW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IG9sZExpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cztcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U2V0LmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQmVJbkxpbWJvKGRvYy5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cy5hZGQoZG9jLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEaWZmIHRoZSBuZXcgbGltYm8gZG9jcyB3aXRoIHRoZSBvbGQgbGltYm8gZG9jcy5cclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgb2xkTGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubGltYm9Eb2N1bWVudHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgUmVtb3ZlZExpbWJvRG9jdW1lbnQoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKCFvbGRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKG5ldyBBZGRlZExpbWJvRG9jdW1lbnQoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBpbi1tZW1vcnkgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldyB3aXRoIHRoZSBzdGF0ZSByZWFkIGZyb21cclxuICAgICAqIHBlcnNpc3RlbmNlLlxyXG4gICAgICpcclxuICAgICAqIFdlIHVwZGF0ZSB0aGUgcXVlcnkgdmlldyB3aGVuZXZlciBhIGNsaWVudCdzIHByaW1hcnkgc3RhdHVzIGNoYW5nZXM6XHJcbiAgICAgKiAtIFdoZW4gYSBjbGllbnQgdHJhbnNpdGlvbnMgZnJvbSBwcmltYXJ5IHRvIHNlY29uZGFyeSwgaXQgY2FuIG1pc3NcclxuICAgICAqICAgTG9jYWxTdG9yYWdlIHVwZGF0ZXMgYW5kIGl0cyBxdWVyeSB2aWV3cyBtYXkgdGVtcG9yYXJpbHkgbm90IGJlXHJcbiAgICAgKiAgIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzdGF0ZSBvbiBkaXNrLlxyXG4gICAgICogLSBGb3Igc2Vjb25kYXJ5IHRvIHByaW1hcnkgdHJhbnNpdGlvbnMsIHRoZSBjbGllbnQgbmVlZHMgdG8gdXBkYXRlIHRoZSBsaXN0XHJcbiAgICAgKiAgIG9mIGBzeW5jZWREb2N1bWVudHNgIHNpbmNlIHNlY29uZGFyeSBjbGllbnRzIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3c1xyXG4gICAgICogICBiYXNlZCBwdXJlbHkgb24gc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5kb2N1bWVudHMgLSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGFjY29yZGluZ1xyXG4gICAgICogdG8gdGhlIExvY2FsU3RvcmUuXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlSZXN1bHQucmVtb3RlS2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGVcclxuICAgICAqIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgYmFja2VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVmlld0NoYW5nZSB0aGF0IHJlc3VsdGVkIGZyb20gdGhpcyBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBzeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXM7XHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRoaXMuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXHJcbiAgICAgKiBhIGRvY3VtZW50IGFkZCBmb3IgZXZlcnkgZXhpc3RpbmcgZG9jdW1lbnQgYW5kIHRoZSBgZnJvbUNhY2hlYCBhbmRcclxuICAgICAqIGBoYXNQZW5kaW5nV3JpdGVzYCBzdGF0dXMgb2YgdGhlIGFscmVhZHkgZXN0YWJsaXNoZWQgdmlldy5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIGNvbXB1dGVJbml0aWFsU25hcHNob3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XHJcbiAgICBjb25zdCBvcmRlciA9IChjaGFuZ2UpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGNoYW5nZSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLzpcclxuICAgICAgICAgICAgICAgIC8vIEEgbWV0YWRhdGEgY2hhbmdlIGlzIGNvbnZlcnRlZCB0byBhIG1vZGlmaWVkIGNoYW5nZSBhdCB0aGUgcHVibGljXHJcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcclxuICAgICAgICAgICAgICAgIC8vIG1ldGFkYXRhIGFuZCBtb2RpZmllZCBjaGFuZ2VzIG11c3QgYmUgc29ydGVkIGVxdWl2YWxlbnRseS5cclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gb3JkZXIoYzEpIC0gb3JkZXIoYzIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckMyA9ICdTeW5jRW5naW5lJztcclxuLyoqXHJcbiAqIFF1ZXJ5VmlldyBjb250YWlucyBhbGwgb2YgdGhlIGRhdGEgdGhhdCBTeW5jRW5naW5lIG5lZWRzIHRvIGtlZXAgdHJhY2sgb2YgZm9yXHJcbiAqIGEgcGFydGljdWxhciBxdWVyeS5cclxuICovXHJcbmNsYXNzIFF1ZXJ5VmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHF1ZXJ5IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcXVlcnksIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0IG51bWJlciBjcmVhdGVkIGJ5IHRoZSBjbGllbnQgdGhhdCBpcyB1c2VkIGluIHRoZSB3YXRjaFxyXG4gICAgICogc3RyZWFtIHRvIGlkZW50aWZ5IHRoaXMgcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldElkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZpZXcgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgZmluYWwgbWVyZ2VkIHRydXRoIG9mIHdoYXRcclxuICAgICAqIGRvY3MgYXJlIGluIHRoZSBxdWVyeS4gSXQgZ2V0cyBub3RpZmllZCBvZiBsb2NhbCBhbmQgcmVtb3RlIGNoYW5nZXMsXHJcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0XHJcbiAgICAgKiBwb3NzaWJsZSByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgfVxyXG59XHJcbi8qKiBUcmFja3MgYSBsaW1ibyByZXNvbHV0aW9uLiAqL1xyXG5jbGFzcyBMaW1ib1Jlc29sdXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgb25jZSB3ZSd2ZSByZWNlaXZlZCBhIGRvY3VtZW50LiBUaGlzIGlzIHVzZWQgaW5cclxuICAgICAgICAgKiBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KCkgYW5kIHVsdGltYXRlbHkgdXNlZCBieSBXYXRjaENoYW5nZUFnZ3JlZ2F0b3IgdG9cclxuICAgICAgICAgKiBkZWNpZGUgd2hldGhlciBpdCBuZWVkcyB0byBtYW51ZmFjdHVyZSBhIGRlbGV0ZSBldmVudCBmb3IgdGhlIHRhcmdldCBvbmNlXHJcbiAgICAgICAgICogdGhlIHRhcmdldCBpcyBDVVJSRU5ULlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZWREb2N1bWVudCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgU3luY0VuZ2luZWAgY29vcmRpbmF0aW5nIHdpdGggb3RoZXIgcGFydHMgb2YgU0RLLlxyXG4gKlxyXG4gKiBUaGUgcGFydHMgb2YgU3luY0VuZ2luZSB0aGF0IGFjdCBhcyBhIGNhbGxiYWNrIHRvIFJlbW90ZVN0b3JlIG5lZWQgdG8gYmVcclxuICogcmVnaXN0ZXJlZCBpbmRpdmlkdWFsbHkuIFRoaXMgaXMgZG9uZSBpbiBgc3luY0VuZ2luZVdyaXRlKClgIGFuZFxyXG4gKiBgc3luY0VuZ2luZUxpc3RlbigpYCAoYXMgd2VsbCBhcyBgYXBwbHlQcmltYXJ5U3RhdGUoKWApIGFzIHRoZXNlIG1ldGhvZHNcclxuICogc2VydmUgYXMgZW50cnkgcG9pbnRzIHRvIFJlbW90ZVN0b3JlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICpcclxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcclxuICogdGhlIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBzbyB0aGV5IGFyZSBvbmx5IGFjY2Vzc2libGUgZnJvbSB0aGlzIG1vZHVsZS5cclxuICogVGhpcyBpcyB1c2VmdWwgdG8gaW1wbGVtZW50IG9wdGlvbmFsIGZlYXR1cmVzIChsaWtlIGJ1bmRsZXMpIGluIGZyZWVcclxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXHJcbiAqL1xyXG5jbGFzcyBTeW5jRW5naW5lSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBcclxuICAgIC8vIFBPUlRJTkcgTk9URTogTWFuYWdlcyBzdGF0ZSBzeW5jaHJvbml6YXRpb24gaW4gbXVsdGktdGFiIGVudmlyb25tZW50cy5cclxuICAgIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUgPSByZW1vdGVTdG9yZTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gc2hhcmVkQ2xpZW50U3RhdGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IGN1cnJlbnRVc2VyO1xyXG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMgPSBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucztcclxuICAgICAgICB0aGlzLnN5bmNFbmdpbmVMaXN0ZW5lciA9IHt9O1xyXG4gICAgICAgIHRoaXMucXVlcnlWaWV3c0J5UXVlcnkgPSBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xyXG4gICAgICAgIHRoaXMucXVlcmllc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBrZXlzIG9mIGRvY3VtZW50cyB0aGF0IGFyZSBpbiBsaW1ibyBmb3Igd2hpY2ggd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhXHJcbiAgICAgICAgICogbGltYm8gcmVzb2x1dGlvbiBxdWVyeS4gVGhlIHN0cmluZ3MgaW4gdGhpcyBzZXQgYXJlIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xyXG4gICAgICAgICAqIGBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKWAgd2hlcmUgYGtleWAgaXMgYSBgRG9jdW1lbnRLZXlgIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBgU2V0YCB0eXBlIHdhcyBjaG9zZW4gYmVjYXVzZSBpdCBwcm92aWRlcyBlZmZpY2llbnQgbG9va3VwIGFuZCByZW1vdmFsXHJcbiAgICAgICAgICogb2YgYXJiaXRyYXJ5IGVsZW1lbnRzIGFuZCBpdCBhbHNvIG1haW50YWlucyBpbnNlcnRpb24gb3JkZXIsIHByb3ZpZGluZyB0aGVcclxuICAgICAgICAgKiBkZXNpcmVkIHF1ZXVlLWxpa2UgRklGTyBzZW1hbnRpY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHRhcmdldCBJRCBmb3IgZWFjaCBkb2N1bWVudCB0aGF0IGlzIGluIGxpbWJvIHdpdGggYW5cclxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhbiBhY3RpdmUgbGltYm8gcmVzb2x1dGlvbiBmb3IgZWFjaFxyXG4gICAgICAgICAqIGFjdGl2ZSB0YXJnZXQgSUQgdGhhdCB3YXMgc3RhcnRlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgbGltYm8gcmVzb2x1dGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRSZWZzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xyXG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjb21wbGV0aW9uIGhhbmRsZXJzLCBpbmRleGVkIGJ5IFVzZXIgYW5kIEJhdGNoSWQuICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblVzZXJDYWxsYmFja3MgPSB7fTtcclxuICAgICAgICAvKiogU3RvcmVzIHVzZXIgY2FsbGJhY2tzIHdhaXRpbmcgZm9yIGFsbCBwZW5kaW5nIHdyaXRlcyB0byBiZSBhY2tub3dsZWRnZWQuICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubGltYm9UYXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclN5bmNFbmdpbmUoKTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcclxuICAgICAgICAvLyBUaGUgcHJpbWFyeSBzdGF0ZSBpcyBzZXQgdG8gYHRydWVgIG9yIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgRmlyZXN0b3JlXHJcbiAgICAgICAgLy8gc3RhcnR1cC4gSW4gdGhlIGludGVyaW0sIGEgY2xpZW50IHNob3VsZCBvbmx5IGJlIGNvbnNpZGVyZWQgcHJpbWFyeSBpZlxyXG4gICAgICAgIC8vIGBpc1ByaW1hcnlgIGlzIHRydWUuXHJcbiAgICAgICAgdGhpcy5faXNQcmltYXJ5Q2xpZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzUHJpbWFyeUNsaWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNQcmltYXJ5Q2xpZW50ID09PSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1N5bmNFbmdpbmUobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXHJcbi8vIFBPUlRJTkcgTk9URTogTWFuYWdlcyBzdGF0ZSBzeW5jaHJvbml6YXRpb24gaW4gbXVsdGktdGFiIGVudmlyb25tZW50cy5cclxuc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lID0gbmV3IFN5bmNFbmdpbmVJbXBsKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSkge1xyXG4gICAgICAgIHN5bmNFbmdpbmUuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3luY0VuZ2luZTtcclxufVxyXG4vKipcclxuICogSW5pdGlhdGVzIHRoZSBuZXcgbGlzdGVuLCByZXNvbHZlcyBwcm9taXNlIHdoZW4gbGlzdGVuIGVucXVldWVkIHRvIHRoZVxyXG4gKiBzZXJ2ZXIuIEFsbCB0aGUgc3Vic2VxdWVudCB2aWV3IHNuYXBzaG90cyBvciBlcnJvcnMgYXJlIHNlbnQgdG8gdGhlXHJcbiAqIHN1YnNjcmliZWQgaGFuZGxlcnMuIFJldHVybnMgdGhlIGluaXRpYWwgc25hcHNob3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSA9IHRydWUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XHJcbiAgICBsZXQgdmlld1NuYXBzaG90O1xyXG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeVZpZXcpIHtcclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFdpdGggTXVsdGktVGFiIFdlYiwgaXQgaXMgcG9zc2libGUgdGhhdCBhIHF1ZXJ5IHZpZXdcclxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyB3aGVuIEV2ZW50TWFuYWdlciBjYWxscyB1cyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXNcclxuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gdGhlIHByaW1hcnkgdGFiIGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHRoaXMgcXVlcnkgb25cclxuICAgICAgICAvLyBiZWhhbGYgb2YgYW5vdGhlciB0YWIgYW5kIHRoZSB1c2VyIG9mIHRoZSBwcmltYXJ5IGFsc28gc3RhcnRzIGxpc3RlbmluZ1xyXG4gICAgICAgIC8vIHRvIHRoZSBxdWVyeS4gRXZlbnRNYW5hZ2VyIHdpbGwgbm90IGhhdmUgYW4gYXNzaWduZWQgdGFyZ2V0IElEIGluIHRoaXNcclxuICAgICAgICAvLyBjYXNlIGFuZCBjYWxscyBgbGlzdGVuYCB0byBvYnRhaW4gdGhpcyBJRC5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRMb2NhbFF1ZXJ5VGFyZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgdmlld1NuYXBzaG90ID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld1NuYXBzaG90ID0gYXdhaXQgYWxsb2NhdGVUYXJnZXRBbmRNYXliZUxpc3RlbihzeW5jRW5naW5lSW1wbCwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlLCBcclxuICAgICAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIHRydWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdTbmFwc2hvdDtcclxufVxyXG4vKiogUXVlcnkgaGFzIGJlZW4gbGlzdGVuaW5nIHRvIHRoZSBjYWNoZSwgYW5kIHRyaWVzIHRvIGluaXRpYXRlIHRoZSByZW1vdGUgc3RvcmUgbGlzdGVuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIGF3YWl0IGFsbG9jYXRlVGFyZ2V0QW5kTWF5YmVMaXN0ZW4oc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCBcclxuICAgIC8qKiBzaG91bGRMaXN0ZW5Ub1JlbW90ZT0gKi8gdHJ1ZSwgXHJcbiAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIGZhbHNlKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIHNob3VsZEluaXRpYWxpemVWaWV3KSB7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcclxuICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgIC8vIFBPUlRJTkcgTk9URTogV2hlbiB0aGUgcXVlcnkgaXMgbGlzdGVuaW5nIHRvIGNhY2hlIG9ubHksIHdlIHNraXAgc2VuZGluZyBpdCBvdmVyIHRvIFdhdGNoIGJ5XHJcbiAgICAvLyBub3QgcmVnaXN0ZXJpbmcgaXQgaW4gc2hhcmVkIGNsaWVudCBzdGF0ZSwgYW5kIGRpcmVjdGx5IGNhbGN1bGF0ZSBpbml0aWFsIHNuYXBzaG90cyBhbmRcclxuICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcyBmcm9tIGNhY2hlLiBPdGhlcndpc2UsIHJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50XHJcbiAgICAvLyBhcyBhY3RpdmUgd2F0Y2ggdGFyZ2V0LlxyXG4gICAgY29uc3Qgc3RhdHVzID0gc2hvdWxkTGlzdGVuVG9SZW1vdGVcclxuICAgICAgICA/IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpXHJcbiAgICAgICAgOiAnbm90LWN1cnJlbnQnO1xyXG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcclxuICAgIGlmIChzaG91bGRJbml0aWFsaXplVmlldykge1xyXG4gICAgICAgIHZpZXdTbmFwc2hvdCA9IGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgdGFyZ2V0SWQsIHN0YXR1cyA9PT0gJ2N1cnJlbnQnLCB0YXJnZXREYXRhLnJlc3VtZVRva2VuKTtcclxuICAgIH1cclxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgc2hvdWxkTGlzdGVuVG9SZW1vdGUpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcclxuICogc25hcHNob3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBPbiBXZWIgb25seSwgd2UgaW5qZWN0IHRoZSBjb2RlIHRoYXQgcmVnaXN0ZXJzIG5ldyBMaW1ib1xyXG4gICAgLy8gdGFyZ2V0cyBiYXNlZCBvbiB2aWV3IGNoYW5nZXMuIFRoaXMgYWxsb3dzIHVzIHRvIG9ubHkgZGVwZW5kIG9uIExpbWJvXHJcbiAgICAvLyBjaGFuZ2VzIHdoZW4gdXNlciBjb2RlIGluY2x1ZGVzIHF1ZXJpZXMuXHJcbiAgICBzeW5jRW5naW5lSW1wbC5hcHBseURvY0NoYW5nZXMgPSAocXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCkgPT4gYXBwbHlEb2NDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcclxuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeSwgXHJcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xyXG4gICAgY29uc3QgdmlldyA9IG5ldyBWaWV3KHF1ZXJ5LCBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzKTtcclxuICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xyXG4gICAgY29uc3Qgc3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2UgPSBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50ICYmIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovLCByZXN1bWVUb2tlbik7XHJcbiAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxyXG4gICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50LCBzeW50aGVzaXplZFRhcmdldENoYW5nZSk7XHJcbiAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBRdWVyeVZpZXcocXVlcnksIHRhcmdldElkLCB2aWV3KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LnNldChxdWVyeSwgZGF0YSk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKS5wdXNoKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5zZXQodGFyZ2V0SWQsIFtxdWVyeV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XHJcbn1cclxuLyoqIFN0b3BzIGxpc3RlbmluZyB0byB0aGUgcXVlcnkuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSwgc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgLy8gT25seSBjbGVhbiB1cCB0aGUgcXVlcnkgdmlldyBhbmQgdGFyZ2V0IGlmIHRoaXMgaXMgdGhlIG9ubHkgcXVlcnkgbWFwcGVkXHJcbiAgICAvLyB0byB0aGUgdGFyZ2V0LlxyXG4gICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuc2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCwgcXVlcmllcy5maWx0ZXIocSA9PiAhcXVlcnlFcXVhbHMocSwgcXVlcnkpKSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBObyBvdGhlciBxdWVyaWVzIGFyZSBtYXBwZWQgdG8gdGhlIHRhcmdldCwgY2xlYW4gdXAgdGhlIHF1ZXJ5IGFuZCB0aGUgdGFyZ2V0LlxyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsb2NhbCBxdWVyeSB0YXJnZXQgZmlyc3QgdG8gYWxsb3cgdXMgdG8gdmVyaWZ5XHJcbiAgICAgICAgLy8gd2hldGhlciBhbnkgb3RoZXIgY2xpZW50IGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhpcyB0YXJnZXQuXHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFJlbWFpbnNBY3RpdmUgPSBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRSZW1haW5zQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXHJcbiAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5jbGVhclF1ZXJ5U3RhdGUocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRVbmxpc3RlblRvUmVtb3RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXHJcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKiogVW5saXN0ZW5zIHRvIHRoZSByZW1vdGUgc3RvcmUgd2hpbGUgc3RpbGwgbGlzdGVuaW5nIHRvIHRoZSBjYWNoZS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcclxuICAgIGNvbnN0IHF1ZXJpZXMgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmIHF1ZXJpZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBVbnJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzXHJcbiAgICAgICAgLy8gd2F0Y2ggdGFyZ2V0LlxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWF0ZXMgdGhlIHdyaXRlIG9mIGxvY2FsIG11dGF0aW9uIGJhdGNoIHdoaWNoIGludm9sdmVzIGFkZGluZyB0aGVcclxuICogd3JpdGVzIHRvIHRoZSBtdXRhdGlvbiBxdWV1ZSwgbm90aWZ5aW5nIHRoZSByZW1vdGUgc3RvcmUgYWJvdXQgbmV3XHJcbiAqIG11dGF0aW9ucyBhbmQgcmFpc2luZyBldmVudHMgZm9yIGFueSBjaGFuZ2VzIHRoaXMgd3JpdGUgY2F1c2VkLlxyXG4gKlxyXG4gKiBUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGNhbGwgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYWJvdmUgc3RlcHNcclxuICogaGF2ZSBjb21wbGV0ZWQsICpub3QqIHdoZW4gdGhlIHdyaXRlIHdhcyBhY2tlZCBieSB0aGUgYmFja2VuZC4gVGhlXHJcbiAqIHVzZXJDYWxsYmFjayBpcyByZXNvbHZlZCBvbmNlIHRoZSB3cml0ZSB3YXMgYWNrZWQvcmVqZWN0ZWQgYnkgdGhlXHJcbiAqIGJhY2tlbmQgKG9yIGZhaWxlZCBsb2NhbGx5IGZvciBhbnkgb3RoZXIgcmVhc29uKS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBiYXRjaCwgdXNlckNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZVdyaXRlTG9jYWxseShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkUGVuZGluZ011dGF0aW9uKHJlc3VsdC5iYXRjaElkKTtcclxuICAgICAgICBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYmF0Y2hJZCwgdXNlckNhbGxiYWNrKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmNoYW5nZXMpO1xyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcGVyc2lzdCB0aGUgbXV0YXRpb24sIHdlIHJlamVjdCB0aGUgdXNlciBjYWxsYmFjayBhbmRcclxuICAgICAgICAvLyBkb24ndCBzZW5kIHRoZSBtdXRhdGlvbi4gVGhlIHVzZXIgY2FuIHRoZW4gcmV0cnkgdGhlIHdyaXRlLlxyXG4gICAgICAgIGNvbnN0IGVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHBlcnNpc3Qgd3JpdGVgKTtcclxuICAgICAgICB1c2VyQ2FsbGJhY2sucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyBvbmUgcmVtb3RlIGV2ZW50IHRvIHRoZSBzeW5jIGVuZ2luZSwgbm90aWZ5aW5nIGFueSB2aWV3cyBvZiB0aGVcclxuICogY2hhbmdlcywgYW5kIHJlbGVhc2luZyBhbnkgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzIHRoYXQgd291bGQgYmVjb21lXHJcbiAqIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgc25hcHNob3QgdmVyc2lvbiB0aGUgcmVtb3RlIGV2ZW50IGNvbnRhaW5zLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZSwgcmVtb3RlRXZlbnQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUFwcGx5UmVtb3RlRXZlbnRUb0xvY2FsQ2FjaGUoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcmVtb3RlRXZlbnQpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBgcmVjZWl2ZWREb2N1bWVudGAgYXMgYXBwcm9wcmlhdGUgZm9yIGFueSBsaW1ibyB0YXJnZXRzLlxyXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgaWYgKGxpbWJvUmVzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpbWJvIHJlc29sdXRpb24gbG9va3VwLCBpdCdzIGZvciBhIHNpbmdsZSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IGNvdWxkIGJlIGFkZGVkLCBtb2RpZmllZCwgb3IgcmVtb3ZlZCwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPD1cclxuICAgICAgICAgICAgICAgICAgICAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGp1c3QgYSBDVVJSRU5UIHRhcmdldENoYW5nZSBvciBzaW1pbGFyLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYW4gT25saW5lU3RhdGUgY2hhbmdlIHRvIHRoZSBzeW5jIGVuZ2luZSBhbmQgbm90aWZpZXMgYW55IHZpZXdzIG9mXHJcbiAqIHRoZSBjaGFuZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShzeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgc291cmNlKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIC8vIElmIHdlIGFyZSB0aGUgc2Vjb25kYXJ5IGNsaWVudCwgd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlIHJlbW90ZSBzdG9yZSdzXHJcbiAgICAvLyBvbmxpbmUgc3RhdGUgKHRoZSBsb2NhbCBjbGllbnQgbWF5IGdvIG9mZmxpbmUsIGV2ZW4gdGhvdWdoIHRoZSBwcmltYXJ5XHJcbiAgICAvLyB0YWIgcmVtYWlucyBvbmxpbmUpIGFuZCBvbmx5IGFwcGx5IHRoZSBwcmltYXJ5IHRhYidzIG9ubGluZSBzdGF0ZSBmcm9tXHJcbiAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cclxuICAgIGlmICgoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXHJcbiAgICAgICAgc291cmNlID09PSAwIC8qIE9ubGluZVN0YXRlU291cmNlLlJlbW90ZVN0b3JlICovKSB8fFxyXG4gICAgICAgICghc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXHJcbiAgICAgICAgICAgIHNvdXJjZSA9PT0gMSAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5TaGFyZWRDbGllbnRTdGF0ZSAqLykpIHtcclxuICAgICAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgocXVlcnksIHF1ZXJ5VmlldykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gcXVlcnlWaWV3LnZpZXcuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpO1xyXG4gICAgICAgIGlmIChuZXdWaWV3U25hcHNob3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlamVjdHMgdGhlIGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldElELiBUaGlzIGNhbiBiZSB0cmlnZ2VyZWQgYnkgdGhlXHJcbiAqIGJhY2tlbmQgZm9yIGFueSBhY3RpdmUgdGFyZ2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3luY0VuZ2luZSAtIFRoZSBzeW5jIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cclxuICogQHBhcmFtIHRhcmdldElkIC0gVGhlIHRhcmdldElEIGNvcnJlc3BvbmRzIHRvIG9uZSBwcmV2aW91c2x5IGluaXRpYXRlZCBieSB0aGVcclxuICogdXNlciBhcyBwYXJ0IG9mIFRhcmdldERhdGEgcGFzc2VkIHRvIGxpc3RlbigpIG9uIFJlbW90ZVN0b3JlLlxyXG4gKiBAcGFyYW0gZXJyIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29uZGl0aW9uIHRoYXQgaGFzIGZvcmNlZCB0aGUgcmVqZWN0aW9uLlxyXG4gKiBOZWFybHkgYWx3YXlzIHRoaXMgd2lsbCBiZSBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHVzZXIgaXMgbm8gbG9uZ2VyXHJcbiAqIGF1dGhvcml6ZWQgdG8gc2VlIHRoZSBkYXRhIG1hdGNoaW5nIHRoZSB0YXJnZXQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0TGlzdGVuKHN5bmNFbmdpbmUsIHRhcmdldElkLCBlcnIpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsICdyZWplY3RlZCcsIGVycik7XHJcbiAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgIGNvbnN0IGxpbWJvS2V5ID0gbGltYm9SZXNvbHV0aW9uICYmIGxpbWJvUmVzb2x1dGlvbi5rZXk7XHJcbiAgICBpZiAobGltYm9LZXkpIHtcclxuICAgICAgICAvLyBUT0RPKGtsaW10KTogV2UgcmVhbGx5IG9ubHkgc2hvdWxkIGRvIHRoZSBmb2xsb3dpbmcgb24gcGVybWlzc2lvblxyXG4gICAgICAgIC8vIGRlbmllZCBlcnJvcnMsIGJ1dCB3ZSBkb24ndCBoYXZlIHRoZSBjYXVzZSBjb2RlIGhlcmUuXHJcbiAgICAgICAgLy8gSXQncyBhIGxpbWJvIGRvYy4gQ3JlYXRlIGEgc3ludGhldGljIGV2ZW50IHNheWluZyBpdCB3YXMgZGVsZXRlZC5cclxuICAgICAgICAvLyBUaGlzIGlzIGtpbmQgb2YgYSBoYWNrLiBJZGVhbGx5LCB3ZSB3b3VsZCBoYXZlIGEgbWV0aG9kIGluIHRoZSBsb2NhbFxyXG4gICAgICAgIC8vIHN0b3JlIHRvIHB1cmdlIGEgZG9jdW1lbnQuIEhvd2V2ZXIsIGl0IHdvdWxkIGJlIHRyaWNreSB0byBrZWVwIGFsbCBvZlxyXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzdG9yZSdzIGludmFyaWFudHMgd2l0aCBhbm90aGVyIG1ldGhvZC5cclxuICAgICAgICBsZXQgZG9jdW1lbnRVcGRhdGVzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICAvLyBUT0RPKGIvMjE3MTg5MjE2KTogVGhpcyBsaW1ibyBkb2N1bWVudCBzaG91bGQgaWRlYWxseSBoYXZlIGEgcmVhZCB0aW1lLFxyXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgcGlja2VkIHVwIGJ5IGFueSByZWFkLXRpbWUgYmFzZWQgc2NhbnMuIFRoZSBiYWNrZW5kLFxyXG4gICAgICAgIC8vIGhvd2V2ZXIsIGRvZXMgbm90IHNlbmQgYSByZWFkIHRpbWUgZm9yIHRhcmdldCByZW1vdmFscy5cclxuICAgICAgICBkb2N1bWVudFVwZGF0ZXMgPSBkb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGxpbWJvS2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChsaW1ib0tleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKSk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvS2V5KTtcclxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBSZW1vdGVFdmVudChTbmFwc2hvdFZlcnNpb24ubWluKCksIFxyXG4gICAgICAgIC8qIHRhcmdldENoYW5nZXM9ICovIG5ldyBNYXAoKSwgXHJcbiAgICAgICAgLyogdGFyZ2V0TWlzbWF0Y2hlcz0gKi8gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgZG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lQXBwbHlSZW1vdGVFdmVudChzeW5jRW5naW5lSW1wbCwgZXZlbnQpO1xyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgcXVlcnkgZmFpbGVkLCB3ZSB3b24ndCB3YW50IHRvIG1hbnVhbGx5IHVubGlzdGVuIHRvIGl0LlxyXG4gICAgICAgIC8vIFdlIG9ubHkgcmVtb3ZlIGl0IGZyb20gYm9va2tlZXBpbmcgYWZ0ZXIgd2Ugc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdGhlXHJcbiAgICAgICAgLy8gUmVtb3RlRXZlbnQuIElmIGBhcHBseVJlbW90ZUV2ZW50KClgIHRocm93cywgd2Ugd2FudCB0byByZS1saXN0ZW4gdG9cclxuICAgICAgICAvLyB0aGlzIHF1ZXJ5IHdoZW4gdGhlIFJlbW90ZVN0b3JlIHJlc3RhcnRzIHRoZSBXYXRjaCBzdHJlYW0sIHdoaWNoIHNob3VsZFxyXG4gICAgICAgIC8vIHJlLXRyaWdnZXIgdGhlIHRhcmdldCBmYWlsdXJlLlxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkucmVtb3ZlKGxpbWJvS2V5KTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcclxuICAgICAgICBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcclxuICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyBmYWxzZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycikpXHJcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVN1Y2Nlc3NmdWxXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbkJhdGNoUmVzdWx0KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IGJhdGNoSWQgPSBtdXRhdGlvbkJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlQWNrbm93bGVkZ2VCYXRjaChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBtdXRhdGlvbkJhdGNoUmVzdWx0KTtcclxuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxyXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0XHJcbiAgICAgICAgLy8gdXApLCBzbyB3ZSByYWlzZSB1c2VyIGNhbGxiYWNrcyBmaXJzdCBzbyB0aGF0IHRoZXkgY29uc2lzdGVudGx5IGhhcHBlblxyXG4gICAgICAgIC8vIGJlZm9yZSBsaXN0ZW4gZXZlbnRzLlxyXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIC8qZXJyb3I9Ki8gbnVsbCk7XHJcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ2Fja25vd2xlZGdlZCcpO1xyXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVJlamVjdEZhaWxlZFdyaXRlKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVSZWplY3RCYXRjaChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcclxuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxyXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0IHVwKSxcclxuICAgICAgICAvLyBzbyB3ZSByYWlzZSB1c2VyIGNhbGxiYWNrcyBmaXJzdCBzbyB0aGF0IHRoZXkgY29uc2lzdGVudGx5IGhhcHBlbiBiZWZvcmVcclxuICAgICAgICAvLyBsaXN0ZW4gZXZlbnRzLlxyXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yKTtcclxuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCAncmVqZWN0ZWQnLCBlcnJvcik7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgdXNlciBjYWxsYmFjayB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHBlbmRpbmcgbXV0YXRpb25zIGF0IHRoZSBtb21lbnQgb2YgY2FsbGluZ1xyXG4gKiBhcmUgYWNrbm93bGVkZ2VkIC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBpZiAoIWNhblVzZU5ldHdvcmsoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnVGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQuIFRoZSB0YXNrIHJldHVybmVkIGJ5ICcgK1xyXG4gICAgICAgICAgICBcIidhd2FpdFBlbmRpbmdXcml0ZXMoKScgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhlIG5ldHdvcmsgaXMgZW5hYmxlZC5cIik7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RCYXRjaElkID0gYXdhaXQgbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgaWYgKGhpZ2hlc3RCYXRjaElkID09PSBCQVRDSElEX1VOS05PV04pIHtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBwZW5kaW5nIHdyaXRlcyBhdCB0aGUgbW9tZW50LlxyXG4gICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5nZXQoaGlnaGVzdEJhdGNoSWQpIHx8IFtdO1xyXG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLnNldChoaWdoZXN0QmF0Y2hJZCwgY2FsbGJhY2tzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsICdJbml0aWFsaXphdGlvbiBvZiB3YWl0Rm9yUGVuZGluZ1dyaXRlcygpIG9wZXJhdGlvbiBmYWlsZWQnKTtcclxuICAgICAgICBjYWxsYmFjay5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUcmlnZ2VycyB0aGUgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoaXMgYmF0Y2ggaWQgdG8gZ2V0IGFja25vd2xlZGdlZCBieSBzZXJ2ZXIsXHJcbiAqIGlmIHRoZXJlIGFyZSBhbnkuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCkge1xyXG4gICAgKHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZ2V0KGJhdGNoSWQpIHx8IFtdKS5mb3JFYWNoKGNhbGxiYWNrID0+IHtcclxuICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZGVsZXRlKGJhdGNoSWQpO1xyXG59XHJcbi8qKiBSZWplY3QgYWxsIG91dHN0YW5kaW5nIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyB0byBjb21wbGV0ZS4gKi9cclxuZnVuY3Rpb24gcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFja3MgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2sucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuY2xlYXIoKTtcclxufVxyXG5mdW5jdGlvbiBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcclxuICAgIGlmICghbmV3Q2FsbGJhY2tzKSB7XHJcbiAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIG5ld0NhbGxiYWNrcyA9IG5ld0NhbGxiYWNrcy5pbnNlcnQoYmF0Y2hJZCwgY2FsbGJhY2spO1xyXG4gICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cclxuICAgICAgICBuZXdDYWxsYmFja3M7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmVzIG9yIHJlamVjdHMgdGhlIHVzZXIgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiBiYXRjaCBhbmQgdGhlbiBkaXNjYXJkc1xyXG4gKiBpdC5cclxuICovXHJcbmZ1bmN0aW9uIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZSwgYmF0Y2hJZCwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcclxuICAgIC8vIE5PVEU6IE11dGF0aW9ucyByZXN0b3JlZCBmcm9tIHBlcnNpc3RlbmNlIHdvbid0IGhhdmUgY2FsbGJhY2tzLCBzbyBpdCdzXHJcbiAgICAvLyBva2F5IGZvciB0aGVyZSB0byBiZSBubyBjYWxsYmFjayBmb3IgdGhpcyBJRC5cclxuICAgIGlmIChuZXdDYWxsYmFja3MpIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IG5ld0NhbGxiYWNrcy5nZXQoYmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MucmVtb3ZlKGJhdGNoSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV0gPVxyXG4gICAgICAgICAgICBuZXdDYWxsYmFja3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yID0gbnVsbCkge1xyXG4gICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvcihxdWVyeSwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIGNvbnN0IGxpbWJvS2V5cyA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZXNGb3JJZCh0YXJnZXRJZCk7XHJcbiAgICAgICAgbGltYm9LZXlzLmZvckVhY2gobGltYm9LZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0tleSk7XHJcbiAgICAgICAgICAgIGlmICghaXNSZWZlcmVuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSByZW1vdmVkIHRoZSBsYXN0IHJlZmVyZW5jZSBmb3IgdGhpcyBrZXlcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0tleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwga2V5KSB7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcclxuICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgdGFyZ2V0IGFscmVhZHkgZ290IHJlbW92ZWQgYmVjYXVzZSB0aGUgcXVlcnkgZmFpbGVkLiBJbiB0aGF0IGNhc2UsXHJcbiAgICAvLyB0aGUga2V5IHdvbid0IGV4aXN0IGluIGBsaW1ib1RhcmdldHNCeUtleWAuIE9ubHkgZG8gdGhlIGNsZWFudXAgaWYgd2Ugc3RpbGwgaGF2ZSB0aGUgdGFyZ2V0LlxyXG4gICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpO1xyXG4gICAgaWYgKGxpbWJvVGFyZ2V0SWQgPT09IG51bGwpIHtcclxuICAgICAgICAvLyBUaGlzIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkLCBiZWNhdXNlIHRoZSBxdWVyeSBmYWlsZWQuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgbGltYm9UYXJnZXRJZCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkucmVtb3ZlKGtleSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKGxpbWJvVGFyZ2V0SWQpO1xyXG4gICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGxpbWJvQ2hhbmdlcykge1xyXG4gICAgZm9yIChjb25zdCBsaW1ib0NoYW5nZSBvZiBsaW1ib0NoYW5nZXMpIHtcclxuICAgICAgICBpZiAobGltYm9DaGFuZ2UgaW5zdGFuY2VvZiBBZGRlZExpbWJvRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuYWRkUmVmZXJlbmNlKGxpbWJvQ2hhbmdlLmtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgUmVtb3ZlZExpbWJvRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnRG9jdW1lbnQgbm8gbG9uZ2VyIGluIGxpbWJvOiAnICsgbGltYm9DaGFuZ2Uua2V5KTtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMucmVtb3ZlUmVmZXJlbmNlKGxpbWJvQ2hhbmdlLmtleSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0NoYW5nZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCB0aGUgbGFzdCByZWZlcmVuY2UgZm9yIHRoaXMga2V5XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2Uua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSkge1xyXG4gICAgY29uc3Qga2V5ID0gbGltYm9DaGFuZ2Uua2V5O1xyXG4gICAgY29uc3Qga2V5U3RyaW5nID0ga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICBpZiAoIXN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpICYmXHJcbiAgICAgICAgIXN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5oYXMoa2V5U3RyaW5nKSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ05ldyBkb2N1bWVudCBpbiBsaW1ibzogJyArIGtleSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmFkZChrZXlTdHJpbmcpO1xyXG4gICAgICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdGFydHMgbGlzdGVucyBmb3IgZG9jdW1lbnRzIGluIGxpbWJvIHRoYXQgYXJlIGVucXVldWVkIGZvciByZXNvbHV0aW9uLFxyXG4gKiBzdWJqZWN0IHRvIGEgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCByZXNvbHV0aW9ucy5cclxuICpcclxuICogV2l0aG91dCBib3VuZGluZyB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMsIHRoZSBzZXJ2ZXIgY2FuIGZhaWxcclxuICogd2l0aCBcInJlc291cmNlIGV4aGF1c3RlZFwiIGVycm9ycyB3aGljaCBjYW4gbGVhZCB0byBwYXRob2xvZ2ljYWwgY2xpZW50XHJcbiAqIGJlaGF2aW9yIGFzIHNlZW4gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvMjY4My5cclxuICovXHJcbmZ1bmN0aW9uIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpIHtcclxuICAgIHdoaWxlIChzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuc2l6ZSA+IDAgJiZcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5zaXplIDxcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcclxuICAgICAgICBjb25zdCBrZXlTdHJpbmcgPSBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnNcclxuICAgICAgICAgICAgLnZhbHVlcygpXHJcbiAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmRlbGV0ZShrZXlTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhrZXlTdHJpbmcpKTtcclxuICAgICAgICBjb25zdCBsaW1ib1RhcmdldElkID0gc3luY0VuZ2luZUltcGwubGltYm9UYXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LnNldChsaW1ib1RhcmdldElkLCBuZXcgTGltYm9SZXNvbHV0aW9uKGtleSkpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID1cclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuaW5zZXJ0KGtleSwgbGltYm9UYXJnZXRJZCk7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIG5ldyBUYXJnZXREYXRhKHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSksIGxpbWJvVGFyZ2V0SWQsIFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZSwgY2hhbmdlcywgcmVtb3RlRXZlbnQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgbmV3U25hcHMgPSBbXTtcclxuICAgIGNvbnN0IGRvY0NoYW5nZXNJbkFsbFZpZXdzID0gW107XHJcbiAgICBjb25zdCBxdWVyaWVzUHJvY2Vzc2VkID0gW107XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IHNpbmNlIGBvbldhdGNoQ2hhbmdlKClgIG1pZ2h0IG5vdCBoYXZlIGJlZW4gYXNzaWduZWQgeWV0LlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmZvckVhY2goKF8sIHF1ZXJ5VmlldykgPT4ge1xyXG4gICAgICAgIHF1ZXJpZXNQcm9jZXNzZWQucHVzaChzeW5jRW5naW5lSW1wbFxyXG4gICAgICAgICAgICAuYXBwbHlEb2NDaGFuZ2VzKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpXHJcbiAgICAgICAgICAgIC50aGVuKHZpZXdTbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBjaGFuZ2VzLCBvciB3ZSBhcmUgaGFuZGxpbmcgYSBnbG9iYWwgc25hcHNob3QsIG5vdGlmeVxyXG4gICAgICAgICAgICAvLyBzZWNvbmRhcnkgY2xpZW50cyB0byB1cGRhdGUgcXVlcnkgc3RhdGUuXHJcbiAgICAgICAgICAgIGlmICh2aWV3U25hcHNob3QgfHwgcmVtb3RlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVRdWVyeVN0YXRlKHF1ZXJ5Vmlldy50YXJnZXRJZCwgKHZpZXdTbmFwc2hvdCA9PT0gbnVsbCB8fCB2aWV3U25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXdTbmFwc2hvdC5mcm9tQ2FjaGUpID8gJ25vdC1jdXJyZW50JyA6ICdjdXJyZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHZpZXdzIGlmIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcy5cclxuICAgICAgICAgICAgaWYgKCEhdmlld1NuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTbmFwcy5wdXNoKHZpZXdTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gTG9jYWxWaWV3Q2hhbmdlcy5mcm9tU25hcHNob3QocXVlcnlWaWV3LnRhcmdldElkLCB2aWV3U25hcHNob3QpO1xyXG4gICAgICAgICAgICAgICAgZG9jQ2hhbmdlc0luQWxsVmlld3MucHVzaChkb2NDaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocXVlcmllc1Byb2Nlc3NlZCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdTbmFwcyk7XHJcbiAgICBhd2FpdCBsb2NhbFN0b3JlTm90aWZ5TG9jYWxWaWV3Q2hhbmdlcyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBkb2NDaGFuZ2VzSW5BbGxWaWV3cyk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gYXBwbHlEb2NDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSB7XHJcbiAgICBsZXQgdmlld0RvY0NoYW5nZXMgPSBxdWVyeVZpZXcudmlldy5jb21wdXRlRG9jQ2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgIGlmICh2aWV3RG9jQ2hhbmdlcy5uZWVkc1JlZmlsbCkge1xyXG4gICAgICAgIC8vIFRoZSBxdWVyeSBoYXMgYSBsaW1pdCBhbmQgc29tZSBkb2NzIHdlcmUgcmVtb3ZlZCwgc28gd2UgbmVlZFxyXG4gICAgICAgIC8vIHRvIHJlLXJ1biB0aGUgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgc3RvcmUgdG8gbWFrZSBzdXJlIHdlXHJcbiAgICAgICAgLy8gZGlkbid0IGxvc2UgYW55IGdvb2QgZG9jcyB0aGF0IGhhZCBiZWVuIHBhc3QgdGhlIGxpbWl0LlxyXG4gICAgICAgIHZpZXdEb2NDaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVZpZXcucXVlcnksIFxyXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gZmFsc2UpLnRoZW4oKHsgZG9jdW1lbnRzIH0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGRvY3VtZW50cywgdmlld0RvY0NoYW5nZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgIGNvbnN0IHRhcmdldElzUGVuZGluZ1Jlc2V0ID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKSAhPSBudWxsO1xyXG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5Q2hhbmdlcyh2aWV3RG9jQ2hhbmdlcywgXHJcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHRhcmdldENoYW5nZSwgdGFyZ2V0SXNQZW5kaW5nUmVzZXQpO1xyXG4gICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3Q2hhbmdlLmxpbWJvQ2hhbmdlcyk7XHJcbiAgICByZXR1cm4gdmlld0NoYW5nZS5zbmFwc2hvdDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZShzeW5jRW5naW5lLCB1c2VyKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IHVzZXJDaGFuZ2VkID0gIXN5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcik7XHJcbiAgICBpZiAodXNlckNoYW5nZWQpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdVc2VyIGNoYW5nZS4gTmV3IHVzZXI6JywgdXNlci50b0tleSgpKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB1c2VyKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgLy8gRmFpbHMgdGFza3Mgd2FpdGluZyBmb3IgcGVuZGluZyB3cml0ZXMgcmVxdWVzdGVkIGJ5IHByZXZpb3VzIHVzZXIuXHJcbiAgICAgICAgcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBcIid3YWl0Rm9yUGVuZGluZ1dyaXRlcycgcHJvbWlzZSBpcyByZWplY3RlZCBkdWUgdG8gYSB1c2VyIGNoYW5nZS5cIik7XHJcbiAgICAgICAgLy8gVE9ETyhiLzExNDIyNjQxNyk6IENvbnNpZGVyIGNhbGxpbmcgdGhpcyBvbmx5IGluIHRoZSBwcmltYXJ5IHRhYi5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5oYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlc3VsdC5yZW1vdmVkQmF0Y2hJZHMsIHJlc3VsdC5hZGRlZEJhdGNoSWRzKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmFmZmVjdGVkRG9jdW1lbnRzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0UmVtb3RlS2V5c0ZvclRhcmdldChzeW5jRW5naW5lLCB0YXJnZXRJZCkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgIGlmIChsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRLZXlTZXQoKS5hZGQobGltYm9SZXNvbHV0aW9uLmtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQga2V5U2V0ID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKCFxdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlTZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgICAgICAgICBrZXlTZXQgPSBrZXlTZXQudW5pb25XaXRoKHF1ZXJ5Vmlldy52aWV3LnN5bmNlZERvY3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlTZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY29uY2lsZSB0aGUgbGlzdCBvZiBzeW5jZWQgZG9jdW1lbnRzIGluIGFuIGV4aXN0aW5nIHZpZXcgd2l0aCB0aG9zZVxyXG4gKiBmcm9tIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmUsIHF1ZXJ5Vmlldykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcclxuICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5zeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3U25hcHNob3QubGltYm9DaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3U25hcHNob3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBuZXdseSBjaGFuZ2VkIGRvY3VtZW50cyBmcm9tIHJlbW90ZSBkb2N1bWVudCBjYWNoZSBhbmQgcmFpc2VzXHJcbiAqIHNuYXBzaG90cyBpZiBuZWVkZWQuXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lU3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cyhzeW5jRW5naW5lLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKS50aGVuKGNoYW5nZXMgPT4gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpKTtcclxufVxyXG4vKiogQXBwbGllcyBhIG11dGF0aW9uIHN0YXRlIHRvIGFuIGV4aXN0aW5nIGJhdGNoLiAgKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5QmF0Y2hTdGF0ZShzeW5jRW5naW5lLCBiYXRjaElkLCBiYXRjaFN0YXRlLCBlcnJvcikge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBkb2N1bWVudHMgPSBhd2FpdCBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XHJcbiAgICBpZiAoZG9jdW1lbnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgLy8gQSB0aHJvdHRsZWQgdGFiIG1heSBub3QgaGF2ZSBzZWVuIHRoZSBtdXRhdGlvbiBiZWZvcmUgaXQgd2FzIGNvbXBsZXRlZFxyXG4gICAgICAgIC8vIGFuZCByZW1vdmVkIGZyb20gdGhlIG11dGF0aW9uIHF1ZXVlLCBpbiB3aGljaCBjYXNlIHdlIHdvbid0IGhhdmUgY2FjaGVkXHJcbiAgICAgICAgLy8gdGhlIGFmZmVjdGVkIGRvY3VtZW50cy4gSW4gdGhpcyBjYXNlIHdlIGNhbiBzYWZlbHkgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICAvLyBzaW5jZSB0aGF0IG1lYW5zIHdlIGRpZG4ndCBhcHBseSB0aGUgbXV0YXRpb24gbG9jYWxseSBhdCBhbGwgKGlmIHdlXHJcbiAgICAgICAgLy8gaGFkLCB3ZSB3b3VsZCBoYXZlIGNhY2hlZCB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzKSwgYW5kIHNvIHdlIHdpbGwganVzdFxyXG4gICAgICAgIC8vIHNlZSBhbnkgcmVzdWx0aW5nIGRvY3VtZW50IGNoYW5nZXMgdmlhIG5vcm1hbCByZW1vdGUgZG9jdW1lbnQgdXBkYXRlc1xyXG4gICAgICAgIC8vIGFzIGFwcGxpY2FibGUuXHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQ2Fubm90IGFwcGx5IG11dGF0aW9uIGJhdGNoIHdpdGggaWQ6ICcgKyBiYXRjaElkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgYXJlIHRoZSBwcmltYXJ5IGNsaWVudCwgd2UgbmVlZCB0byBzZW5kIHRoaXMgd3JpdGUgdG8gdGhlXHJcbiAgICAgICAgLy8gYmFja2VuZC4gU2Vjb25kYXJ5IGNsaWVudHMgd2lsbCBpZ25vcmUgdGhlc2Ugd3JpdGVzIHNpbmNlIHRoZWlyIHJlbW90ZVxyXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgZGlzYWJsZWQuXHJcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmF0Y2hTdGF0ZSA9PT0gJ2Fja25vd2xlZGdlZCcgfHwgYmF0Y2hTdGF0ZSA9PT0gJ3JlamVjdGVkJykge1xyXG4gICAgICAgIC8vIE5PVEU6IEJvdGggdGhlc2UgbWV0aG9kcyBhcmUgbm8tb3BzIGZvciBiYXRjaGVzIHRoYXQgb3JpZ2luYXRlZCBmcm9tXHJcbiAgICAgICAgLy8gb3RoZXIgY2xpZW50cy5cclxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBlcnJvciA/IGVycm9yIDogbnVsbCk7XHJcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xyXG4gICAgICAgIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgZG9jdW1lbnRzKTtcclxufVxyXG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVByaW1hcnlTdGF0ZShzeW5jRW5naW5lLCBpc1ByaW1hcnkpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIGlmIChpc1ByaW1hcnkgPT09IHRydWUgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIFNlY29uZGFyeSB0YWJzIG9ubHkgbWFpbnRhaW4gVmlld3MgZm9yIHRoZWlyIGxvY2FsIGxpc3RlbmVycyBhbmQgdGhlXHJcbiAgICAgICAgLy8gVmlld3MgaW50ZXJuYWwgc3RhdGUgbWF5IG5vdCBiZSAxMDAlIHBvcHVsYXRlZCAoaW4gcGFydGljdWxhclxyXG4gICAgICAgIC8vIHNlY29uZGFyeSB0YWJzIGRvbid0IHRyYWNrIHN5bmNlZERvY3VtZW50cywgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhlXHJcbiAgICAgICAgLy8gc2VydmVyIGNvbnNpZGVycyB0byBiZSBpbiB0aGUgdGFyZ2V0KS4gU28gd2hlbiBhIHNlY29uZGFyeSBiZWNvbWVzXHJcbiAgICAgICAgLy8gcHJpbWFyeSwgd2UgbmVlZCB0byBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCB2aWV3cyBmb3IgYWxsIHRhcmdldHNcclxuICAgICAgICAvLyBtYXRjaCB0aGUgc3RhdGUgb24gZGlzay5cclxuICAgICAgICBjb25zdCBhY3RpdmVUYXJnZXRzID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlUXVlcmllcyA9IGF3YWl0IHN5bmNocm9uaXplUXVlcnlWaWV3c0FuZFJhaXNlU25hcHNob3RzKHN5bmNFbmdpbmVJbXBsLCBhY3RpdmVUYXJnZXRzLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XHJcbiAgICAgICAgYXdhaXQgcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdHJ1ZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXREYXRhIG9mIGFjdGl2ZVF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUHJpbWFyeSA9PT0gZmFsc2UgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVUYXJnZXRzID0gW107XHJcbiAgICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcclxuICAgICAgICAgICAgICAgICAgICAvKmtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhPSovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF3YWl0IHA7XHJcbiAgICAgICAgYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMpO1xyXG4gICAgICAgIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgPSBmYWxzZTtcclxuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gcmVzZXRMaW1ib0RvY3VtZW50cyhzeW5jRW5naW5lKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcclxuICAgIH0pO1xyXG4gICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMucmVtb3ZlQWxsUmVmZXJlbmNlcygpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvbmNpbGUgdGhlIHF1ZXJ5IHZpZXdzIG9mIHRoZSBwcm92aWRlZCBxdWVyeSB0YXJnZXRzIHdpdGggdGhlIHN0YXRlIGZyb21cclxuICogcGVyc2lzdGVuY2UuIFJhaXNlcyBzbmFwc2hvdHMgZm9yIGFueSBjaGFuZ2VzIHRoYXQgYWZmZWN0IHRoZSBsb2NhbFxyXG4gKiBjbGllbnQgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgc3RhdGUgb2YgYWxsIHRhcmdldCdzIHF1ZXJ5IGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gVGhlIHN5bmMgZW5naW5lIGltcGxlbWVudGF0aW9uXHJcbiAqIEBwYXJhbSB0YXJnZXRzIC0gdGhlIGxpc3Qgb2YgdGFyZ2V0cyB3aXRoIHZpZXdzIHRoYXQgbmVlZCB0byBiZSByZWNvbXB1dGVkXHJcbiAqIEBwYXJhbSB0cmFuc2l0aW9uVG9QcmltYXJ5IC0gYHRydWVgIGlmZiB0aGUgdGFiIHRyYW5zaXRpb25zIGZyb20gYSBzZWNvbmRhcnlcclxuICogdGFiIHRvIGEgcHJpbWFyeSB0YWJcclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNocm9uaXplUXVlcnlWaWV3c0FuZFJhaXNlU25hcHNob3RzKHN5bmNFbmdpbmUsIHRhcmdldHMsIHRyYW5zaXRpb25Ub1ByaW1hcnkpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgY29uc3QgYWN0aXZlUXVlcmllcyA9IFtdO1xyXG4gICAgY29uc3QgbmV3Vmlld1NuYXBzaG90cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiB0YXJnZXRzKSB7XHJcbiAgICAgICAgbGV0IHRhcmdldERhdGE7XHJcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBxdWVyaWVzIHRoYXQgaGF2ZSBhIGxvY2FsIFZpZXcsIHdlIGZldGNoIHRoZWlyIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgLy8gZnJvbSBMb2NhbFN0b3JlIChhcyB0aGUgcmVzdW1lIHRva2VuIGFuZCB0aGUgc25hcHNob3QgdmVyc2lvblxyXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGNoYW5nZWQpIGFuZCByZWNvbmNpbGUgdGhlaXIgdmlld3Mgd2l0aCB0aGUgcGVyc2lzdGVkXHJcbiAgICAgICAgICAgIC8vIHN0YXRlICh0aGUgbGlzdCBvZiBzeW5jZWREb2N1bWVudHMgbWF5IGhhdmUgZ290dGVuIG91dCBvZiBzeW5jKS5cclxuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVRvVGFyZ2V0KHF1ZXJpZXNbMF0pKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IGF3YWl0IHN5bmNocm9uaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3KTtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld1NuYXBzaG90cy5wdXNoKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IG5ldmVyIGV4ZWN1dGVkIG9uIHRoaXMgY2xpZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIHRoZSB0YXJnZXQgaW4gTG9jYWxTdG9yZSBhbmQgaW5pdGlhbGl6ZSBhIG5ldyBWaWV3LlxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkKTtcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSwgdGFyZ2V0SWQsIFxyXG4gICAgICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVRdWVyaWVzLnB1c2godGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcclxuICAgIHJldHVybiBhY3RpdmVRdWVyaWVzO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5YCBvYmplY3QgZnJvbSB0aGUgc3BlY2lmaWVkIGBUYXJnZXRgLiBUaGVyZSBpcyBubyB3YXkgdG9cclxuICogb2J0YWluIHRoZSBvcmlnaW5hbCBgUXVlcnlgLCBzbyB3ZSBzeW50aGVzaXplIGEgYFF1ZXJ5YCBmcm9tIHRoZSBgVGFyZ2V0YFxyXG4gKiBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBzeW50aGVzaXplZCByZXN1bHQgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIGJ1dFxyXG4gKiBzaW5jZSB0aGUgc3ludGhlc2l6ZWQgYFF1ZXJ5YCBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgdGhlXHJcbiAqIG9yaWdpbmFsIG9uZSAob25seSB0aGUgcHJlc2VudGF0aW9uIG9mIHJlc3VsdHMgbWlnaHQgZGlmZmVyKSwgdGhlIHBvdGVudGlhbFxyXG4gKiBkaWZmZXJlbmNlIHdpbGwgbm90IGNhdXNlIGlzc3Vlcy5cclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHRhcmdldC5wYXRoLCB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLCB0YXJnZXQub3JkZXJCeSwgdGFyZ2V0LmZpbHRlcnMsIHRhcmdldC5saW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KTtcclxufVxyXG4vKiogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIHN5bmNFbmdpbmVHZXRBY3RpdmVDbGllbnRzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xyXG59XHJcbi8qKiBBcHBsaWVzIGEgcXVlcnkgdGFyZ2V0IGNoYW5nZSBmcm9tIGEgZGlmZmVyZW50IHRhYi4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUoc3luY0VuZ2luZSwgdGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgIC8vIElmIHdlIHJlY2VpdmUgYSB0YXJnZXQgc3RhdGUgbm90aWZpY2F0aW9uIHZpYSBXZWJTdG9yYWdlLCB3ZSBhcmVcclxuICAgICAgICAvLyBlaXRoZXIgYWxyZWFkeSBzZWNvbmRhcnkgb3IgYW5vdGhlciB0YWIgaGFzIHRha2VuIHRoZSBwcmltYXJ5IGxlYXNlLlxyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0lnbm9yaW5nIHVuZXhwZWN0ZWQgcXVlcnkgc3RhdGUgbm90aWZpY2F0aW9uLicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHF1ZXJ5ID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnY3VycmVudCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ25vdC1jdXJyZW50Jzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnlbMF0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bnRoZXNpemVkUmVtb3RlRXZlbnQgPSBSZW1vdGVFdmVudC5jcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgc3RhdGUgPT09ICdjdXJyZW50JywgQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcywgc3ludGhlc2l6ZWRSZW1vdGVFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcclxuICAgICAgICAgICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBZGRzIG9yIHJlbW92ZXMgV2F0Y2ggdGFyZ2V0cyBmb3IgcXVlcmllcyBmcm9tIGRpZmZlcmVudCB0YWJzLiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlKHN5bmNFbmdpbmUsIGFkZGVkLCByZW1vdmVkKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xyXG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBhZGRlZCkge1xyXG4gICAgICAgIC8vIEEgdGFyZ2V0IGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHJlbW90ZSBzdG9yZSBpZiBpdCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgdG9cclxuICAgICAgICAvLyBzaGFyZWRDbGllbnRTdGF0ZS5cclxuICAgICAgICBjb25zdCB0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5oYXModGFyZ2V0SWQpICYmXHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICh0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdBZGRpbmcgYW4gYWxyZWFkeSBhY3RpdmUgdGFyZ2V0ICcgKyB0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkKTtcclxuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldCk7XHJcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldERhdGEudGFyZ2V0SWQsIFxyXG4gICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiByZW1vdmVkKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0aWxsIGFjdGl2ZSBzaW5jZSB0aGUgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlblxyXG4gICAgICAgIC8vIHJlbW92ZWQgaWYgaXQgaGFzIGJlZW4gcmVqZWN0ZWQgYnkgdGhlIGJhY2tlbmQuXHJcbiAgICAgICAgaWYgKCFzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVsZWFzZSBxdWVyaWVzIHRoYXQgYXJlIHN0aWxsIGFjdGl2ZS5cclxuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXHJcbiAgICAgICAgLyoga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgKi8gZmFsc2UpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlSZW1vdGVFdmVudCA9XHJcbiAgICAgICAgc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCA9XHJcbiAgICAgICAgc3luY0VuZ2luZUdldFJlbW90ZUtleXNGb3JUYXJnZXQuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuID1cclxuICAgICAgICBzeW5jRW5naW5lUmVqZWN0TGlzdGVuLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UgPVxyXG4gICAgICAgIGV2ZW50TWFuYWdlck9uV2F0Y2hDaGFuZ2UuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbC5ldmVudE1hbmFnZXIpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvciA9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcclxuICAgIHJldHVybiBzeW5jRW5naW5lSW1wbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVN1Y2Nlc3NmdWxXcml0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5yZWplY3RGYWlsZWRXcml0ZSA9XHJcbiAgICAgICAgc3luY0VuZ2luZVJlamVjdEZhaWxlZFdyaXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgcmV0dXJuIHN5bmNFbmdpbmVJbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkcyBhIEZpcmVzdG9yZSBidW5kbGUgaW50byB0aGUgU0RLLiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aGVuXHJcbiAqIHRoZSBidW5kbGUgZmluaXNoZWQgbG9hZGluZy5cclxuICpcclxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBTeW5jRW5naW5lIHRvIHVzZS5cclxuICogQHBhcmFtIGJ1bmRsZVJlYWRlciAtIEJ1bmRsZSB0byBsb2FkIGludG8gdGhlIFNESy5cclxuICogQHBhcmFtIHRhc2sgLSBMb2FkQnVuZGxlVGFzayB1c2VkIHRvIHVwZGF0ZSB0aGUgbG9hZGluZyBwcm9ncmVzcyB0byBwdWJsaWMgQVBJLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY0VuZ2luZUxvYWRCdW5kbGUoc3luY0VuZ2luZSwgYnVuZGxlUmVhZGVyLCB0YXNrKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgIGxvYWRCdW5kbGVJbXBsKHN5bmNFbmdpbmVJbXBsLCBidW5kbGVSZWFkZXIsIHRhc2spLnRoZW4oY29sbGVjdGlvbkdyb3VwcyA9PiB7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUubm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIExvYWRzIGEgYnVuZGxlIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIGFmZmVjdGVkIGNvbGxlY3Rpb24gZ3JvdXBzLiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lLCByZWFkZXIsIHRhc2spIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCByZWFkZXIuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgICBjb25zdCBza2lwID0gYXdhaXQgbG9jYWxTdG9yZUhhc05ld2VyQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xyXG4gICAgICAgIGlmIChza2lwKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHJlYWRlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgoYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNldCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFzay5fdXBkYXRlUHJvZ3Jlc3MoYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSk7XHJcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEJ1bmRsZUxvYWRlcihtZXRhZGF0YSwgc3luY0VuZ2luZS5sb2NhbFN0b3JlLCByZWFkZXIuc2VyaWFsaXplcik7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBhd2FpdCByZWFkZXIubmV4dEVsZW1lbnQoKTtcclxuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gYXdhaXQgbG9hZGVyLmFkZFNpemVkRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrLl91cGRhdGVQcm9ncmVzcyhwcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIuY29tcGxldGUoKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCByZXN1bHQuY2hhbmdlZERvY3MsIFxyXG4gICAgICAgIC8qIHJlbW90ZUV2ZW50ICovIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgLy8gU2F2ZSBtZXRhZGF0YSwgc28gbG9hZGluZyB0aGUgc2FtZSBidW5kbGUgd2lsbCBza2lwLlxyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xyXG4gICAgICAgIHRhc2suX2NvbXBsZXRlV2l0aChyZXN1bHQucHJvZ3Jlc3MpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LmNoYW5nZWRDb2xsZWN0aW9uR3JvdXBzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nV2FybihMT0dfVEFHJDMsIGBMb2FkaW5nIGJ1bmRsZSBmYWlsZWQgd2l0aCAke2V9YCk7XHJcbiAgICAgICAgdGFzay5fZmFpbFdpdGgoZSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU2V0KCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIGluLW1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICogVXNlcyBFYWdlckdDIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICovXHJcbmNsYXNzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZShjZmcpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHRoaXMuY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gdGhpcy5jcmVhdGVQZXJzaXN0ZW5jZShjZmcpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc3RhcnQoKTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSB0aGlzLmNyZWF0ZUxvY2FsU3RvcmUoY2ZnKTtcclxuICAgICAgICB0aGlzLmdjU2NoZWR1bGVyID0gdGhpcy5jcmVhdGVHYXJiYWdlQ29sbGVjdGlvblNjaGVkdWxlcihjZmcsIHRoaXMubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIgPSB0aGlzLmNyZWF0ZUluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcsIHRoaXMubG9jYWxTdG9yZSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVHYXJiYWdlQ29sbGVjdGlvblNjaGVkdWxlcihjZmcsIGxvY2FsU3RvcmUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNyZWF0ZUluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcsIGxvY2FsU3RvcmUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNyZWF0ZUxvY2FsU3RvcmUoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVBlcnNpc3RlbmNlKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UGVyc2lzdGVuY2UoTWVtb3J5RWFnZXJEZWxlZ2F0ZS5mYWN0b3J5LCB0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgKF9hID0gdGhpcy5nY1NjaGVkdWxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcclxuICAgICAgICAoX2IgPSB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcclxuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnNodXRkb3duKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zaHV0ZG93bigpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhY2hlU2l6ZUJ5dGVzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVHYXJiYWdlQ29sbGVjdGlvblNjaGVkdWxlcihjZmcsIGxvY2FsU3RvcmUpIHtcclxuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUgaW5zdGFuY2VvZiBNZW1vcnlMcnVEZWxlZ2F0ZSk7XHJcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcclxuICAgICAgICByZXR1cm4gbmV3IExydVNjaGVkdWxlcihnYXJiYWdlQ29sbGVjdG9yLCBjZmcuYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcclxuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBMcnVQYXJhbXMud2l0aENhY2hlU2l6ZSh0aGlzLmNhY2hlU2l6ZUJ5dGVzKVxyXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UGVyc2lzdGVuY2UocCA9PiBNZW1vcnlMcnVEZWxlZ2F0ZS5mYWN0b3J5KHAsIGxydVBhcmFtcyksIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggSW5kZXhlZERCIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcywgZm9yY2VPd25lcnNoaXApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XHJcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xyXG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xyXG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcclxuICAgICAgICBhd2FpdCB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUodGhpcywgY2ZnKTtcclxuICAgICAgICAvLyBFbnF1ZXVlIHdyaXRlcyBmcm9tIGEgcHJldmlvdXMgc2Vzc2lvblxyXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xyXG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUpO1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBpbW1lZGlhdGVseSBjYWxsIHRoZSBsaXN0ZW5lciwgc28gd2UgbWFrZSBzdXJlIHRvXHJcbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cclxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnNldFByaW1hcnlTdGF0ZUxpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIgJiYgIXRoaXMuZ2NTY2hlZHVsZXIuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlciAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcclxuICAgICAgICByZXR1cm4gbmV3IExydVNjaGVkdWxlcihnYXJiYWdlQ29sbGVjdG9yLCBjZmcuYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCYWNrZmlsbGVyID0gbmV3IEluZGV4QmFja2ZpbGxlcihsb2NhbFN0b3JlLCB0aGlzLnBlcnNpc3RlbmNlKTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcuYXN5bmNRdWV1ZSwgaW5kZXhCYWNrZmlsbGVyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVBlcnNpc3RlbmNlKGNmZykge1xyXG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xyXG4gICAgICAgIGNvbnN0IGxydVBhcmFtcyA9IHRoaXMuY2FjaGVTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IExydVBhcmFtcy53aXRoQ2FjaGVTaXplKHRoaXMuY2FjaGVTaXplQnl0ZXMpXHJcbiAgICAgICAgICAgIDogTHJ1UGFyYW1zLkRFRkFVTFQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJQZXJzaXN0ZW5jZSh0aGlzLnN5bmNocm9uaXplVGFicywgcGVyc2lzdGVuY2VLZXksIGNmZy5jbGllbnRJZCwgbHJ1UGFyYW1zLCBjZmcuYXN5bmNRdWV1ZSwgZ2V0V2luZG93KCksIGdldERvY3VtZW50KCksIHRoaXMuc2VyaWFsaXplciwgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSwgISF0aGlzLmZvcmNlT3duZXJzaGlwKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U2hhcmVkQ2xpZW50U3RhdGUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBtdWx0aS10YWIgSW5kZXhlZERCXHJcbiAqIHBlcnNpc3RlbmNlLlxyXG4gKlxyXG4gKiBJbiB0aGUgbGVnYWN5IGNsaWVudCwgdGhpcyBwcm92aWRlciBpcyB1c2VkIHRvIHByb3ZpZGUgYm90aCBtdWx0aS10YWIgYW5kXHJcbiAqIG5vbi1tdWx0aS10YWIgcGVyc2lzdGVuY2Ugc2luY2Ugd2UgY2Fubm90IHRlbGwgYXQgYnVpbGQgdGltZSB3aGV0aGVyXHJcbiAqIGBzeW5jaHJvbml6ZVRhYnNgIHdpbGwgYmUgZW5hYmxlZC5cclxuICovXHJcbmNsYXNzIE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcykge1xyXG4gICAgICAgIHN1cGVyKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcywgLyogZm9yY2VPd25lcnNoaXA9ICovIGZhbHNlKTtcclxuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IGNhY2hlU2l6ZUJ5dGVzO1xyXG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XHJcbiAgICAgICAgYXdhaXQgc3VwZXIuaW5pdGlhbGl6ZShjZmcpO1xyXG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUgaW5zdGFuY2VvZiBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zeW5jRW5naW5lID0ge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlCYXRjaFN0YXRlOiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXHJcbiAgICAgICAgICAgICAgICBhcHBseVRhcmdldFN0YXRlOiBzeW5jRW5naW5lQXBwbHlUYXJnZXRTdGF0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgYXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlOiBzeW5jRW5naW5lQXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXHJcbiAgICAgICAgICAgICAgICBnZXRBY3RpdmVDbGllbnRzOiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cy5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgc3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50czogc3luY0VuZ2luZVN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMuYmluZChudWxsLCBzeW5jRW5naW5lKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBpbW1lZGlhdGVseSBjYWxsIHRoZSBsaXN0ZW5lciwgc28gd2UgbWFrZSBzdXJlIHRvXHJcbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cclxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnNldFByaW1hcnlTdGF0ZUxpc3RlbmVyKGFzeW5jIChpc1ByaW1hcnkpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSwgaXNQcmltYXJ5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1hcnkgJiYgIXRoaXMuZ2NTY2hlZHVsZXIuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjU2NoZWR1bGVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1hcnkgJiYgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKSB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XHJcbiAgICAgICAgaWYgKCFXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUuaXNBdmFpbGFibGUod2luZG93KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnSW5kZXhlZERCIHBlcnNpc3RlbmNlIGlzIG9ubHkgYXZhaWxhYmxlIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgTG9jYWxTdG9yYWdlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkLCBjZmcuZGF0YWJhc2VJbmZvLnBlcnNpc3RlbmNlS2V5KTtcclxuICAgICAgICByZXR1cm4gbmV3IFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSh3aW5kb3csIGNmZy5hc3luY1F1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgY2ZnLmNsaWVudElkLCBjZmcuaW5pdGlhbFVzZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhbmQgd2lyZXMgdGhlIGNvbXBvbmVudHMgdGhhdCBhcmUgbmVlZGVkIHRvIGludGVyZmFjZSB3aXRoIHRoZVxyXG4gKiBuZXR3b3JrLlxyXG4gKi9cclxuY2xhc3MgT25saW5lQ29tcG9uZW50UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZShvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsIGNmZykge1xyXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmUpIHtcclxuICAgICAgICAgICAgLy8gT25saW5lQ29tcG9uZW50UHJvdmlkZXIgbWF5IGdldCBpbml0aWFsaXplZCBtdWx0aXBsZSB0aW1lcyBpZlxyXG4gICAgICAgICAgICAvLyBtdWx0aS10YWIgcGVyc2lzdGVuY2UgaXMgdXNlZC5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIubG9jYWxTdG9yZTtcclxuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnNoYXJlZENsaWVudFN0YXRlO1xyXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gdGhpcy5jcmVhdGVEYXRhc3RvcmUoY2ZnKTtcclxuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gdGhpcy5jcmVhdGVSZW1vdGVTdG9yZShjZmcpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gdGhpcy5jcmVhdGVFdmVudE1hbmFnZXIoY2ZnKTtcclxuICAgICAgICB0aGlzLnN5bmNFbmdpbmUgPSB0aGlzLmNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBcclxuICAgICAgICAvKiBzdGFydEFzUHJpbWFyeT0qLyAhb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNocm9uaXplVGFicyk7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAxIC8qIE9ubGluZVN0YXRlU291cmNlLlNoYXJlZENsaWVudFN0YXRlICovKTtcclxuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5oYW5kbGVDcmVkZW50aWFsQ2hhbmdlID1cclxuICAgICAgICAgICAgc3luY0VuZ2luZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UuYmluZChudWxsLCB0aGlzLnN5bmNFbmdpbmUpO1xyXG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5zeW5jRW5naW5lLmlzUHJpbWFyeUNsaWVudCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudE1hbmFnZXIoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld0V2ZW50TWFuYWdlcigpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRGF0YXN0b3JlKGNmZykge1xyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb24oY2ZnLmRhdGFiYXNlSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0RhdGFzdG9yZShjZmcuYXV0aENyZWRlbnRpYWxzLCBjZmcuYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVSZW1vdGVTdG9yZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3UmVtb3RlU3RvcmUodGhpcy5sb2NhbFN0b3JlLCB0aGlzLmRhdGFzdG9yZSwgY2ZnLmFzeW5jUXVldWUsIG9ubGluZVN0YXRlID0+IHN5bmNFbmdpbmVBcHBseU9ubGluZVN0YXRlQ2hhbmdlKHRoaXMuc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIDAgLyogT25saW5lU3RhdGVTb3VyY2UuUmVtb3RlU3RvcmUgKi8pLCBuZXdDb25uZWN0aXZpdHlNb25pdG9yKCkpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlU3luY0VuZ2luZShjZmcsIHN0YXJ0QXNQcmltYXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1N5bmNFbmdpbmUodGhpcy5sb2NhbFN0b3JlLCB0aGlzLnJlbW90ZVN0b3JlLCB0aGlzLmV2ZW50TWFuYWdlciwgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSwgY2ZnLmluaXRpYWxVc2VyLCBjZmcubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMsIHN0YXJ0QXNQcmltYXJ5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgYXdhaXQgcmVtb3RlU3RvcmVTaHV0ZG93bih0aGlzLnJlbW90ZVN0b3JlKTtcclxuICAgICAgICAoX2EgPSB0aGlzLmRhdGFzdG9yZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIb3cgbWFueSBieXRlcyB0byByZWFkIGVhY2ggdGltZSB3aGVuIGBSZWFkYWJsZVN0cmVhbVJlYWRlci5yZWFkKClgIGlzXHJcbiAqIGNhbGxlZC4gT25seSBhcHBsaWNhYmxlIGZvciBieXRlIHN0cmVhbXMgdGhhdCB3ZSBjb250cm9sIChlLmcuIHRob3NlIGJhY2tlZFxyXG4gKiBieSBhbiBVSW50OEFycmF5KS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQllURVNfUEVSX1JFQUQgPSAxMDI0MDtcclxuLyoqXHJcbiAqIEJ1aWxkcyBhIGBCeXRlU3RyZWFtUmVhZGVyYCBmcm9tIGEgVUludDhBcnJheS5cclxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSBkYXRhIHNvdXJjZSB0byB1c2UuXHJcbiAqIEBwYXJhbSBieXRlc1BlclJlYWQgLSBIb3cgbWFueSBieXRlcyBlYWNoIGByZWFkKClgIGZyb20gdGhlIHJldHVybmVkIHJlYWRlclxyXG4gKiAgICAgICAgd2lsbCByZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVySGVscGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkID0gREVGQVVMVF9CWVRFU19QRVJfUkVBRCkge1xyXG4gICAgbGV0IHJlYWRGcm9tID0gMDtcclxuICAgIC8vIFRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyIGNoYW5nZWQuIFdlIHVzZVxyXG4gICAgLy8gYGFueWAgaGVyZSB0byBhbGxvdyB0aGlzIGNvZGUgdG8gY29tcGlsZSB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucy5cclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQyOTcwXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgY29uc3QgcmVhZGVyID0ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgYXN5bmMgcmVhZCgpIHtcclxuICAgICAgICAgICAgaWYgKHJlYWRGcm9tIDwgc291cmNlLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHJlYWRGcm9tLCByZWFkRnJvbSArIGJ5dGVzUGVyUmVhZCksXHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZWFkRnJvbSArPSBieXRlc1BlclJlYWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzeW5jIGNhbmNlbCgpIHsgfSxcclxuICAgICAgICByZWxlYXNlTG9jaygpIHsgfSxcclxuICAgICAgICBjbG9zZWQ6IFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlYWRlcjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGFyZ3VtZW50KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSAke2FyZ3VtZW50TmFtZX0uYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IHR3byBib29sZWFuIG9wdGlvbnMgYXJlIG5vdCBzZXQgYXQgdGhlIHNhbWUgdGltZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKG9wdGlvbk5hbWUxLCBhcmd1bWVudDEsIG9wdGlvbk5hbWUyLCBhcmd1bWVudDIpIHtcclxuICAgIGlmIChhcmd1bWVudDEgPT09IHRydWUgJiYgYXJndW1lbnQyID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYCR7b3B0aW9uTmFtZTF9IGFuZCAke29wdGlvbk5hbWUyfSBjYW5ub3QgYmUgdXNlZCB0b2dldGhlci5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGRvY3VtZW50IChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXQgY29udGFpbnNcclxuICogYW4gZXZlbiBudW1iZXJzIG9mIHNlZ21lbnRzKS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRG9jdW1lbnRQYXRoKHBhdGgpIHtcclxuICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGRvY3VtZW50IHJlZmVyZW5jZS4gRG9jdW1lbnQgcmVmZXJlbmNlcyBtdXN0IGhhdmUgYW4gZXZlbiBudW1iZXIgb2Ygc2VnbWVudHMsIGJ1dCAke3BhdGh9IGhhcyAke3BhdGgubGVuZ3RofS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGNvbGxlY3Rpb24gKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdFxyXG4gKiBjb250YWlucyBhbiBvZGQgbnVtYmVycyBvZiBzZWdtZW50cykuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKHBhdGgpIHtcclxuICAgIGlmIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiByZWZlcmVuY2UuIENvbGxlY3Rpb24gcmVmZXJlbmNlcyBtdXN0IGhhdmUgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgaXQncyBhIG5vbi1udWxsIG9iamVjdCB3aXRob3V0IGEgY3VzdG9tIHByb3RvdHlwZVxyXG4gKiAoaS5lLiBleGNsdWRlcyBBcnJheSwgRGF0ZSwgZXRjLikuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGlucHV0KSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBpbnB1dCAhPT0gbnVsbCAmJlxyXG4gICAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBPYmplY3QucHJvdG90eXBlIHx8XHJcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCkgPT09IG51bGwpKTtcclxufVxyXG4vKiogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIC8gdmFsdWUgb2YgdGhlIHByb3ZpZGVkIGlucHV0LiAqL1xyXG5mdW5jdGlvbiB2YWx1ZURlc2NyaXB0aW9uKGlucHV0KSB7XHJcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlucHV0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMjApIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBgJHtpbnB1dC5zdWJzdHJpbmcoMCwgMjApfS4uLmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgaW5wdXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbiBhcnJheSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjdXN0b21PYmplY3ROYW1lID0gdHJ5R2V0Q3VzdG9tT2JqZWN0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21PYmplY3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYGEgY3VzdG9tICR7Y3VzdG9tT2JqZWN0TmFtZX0gb2JqZWN0YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYW4gb2JqZWN0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiAnYSBmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKiB0cnkgdG8gZ2V0IHRoZSBjb25zdHJ1Y3RvciBuYW1lIGZvciBhbiBvYmplY3QuICovXHJcbmZ1bmN0aW9uIHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpIHtcclxuICAgIGlmIChpbnB1dC5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIENhc3RzIGBvYmpgIHRvIGBUYCwgb3B0aW9uYWxseSB1bndyYXBwaW5nIENvbXBhdCB0eXBlcyB0byBleHBvc2UgdGhlXHJcbiAqIHVuZGVybHlpbmcgaW5zdGFuY2UuIFRocm93cyBpZiAgYG9iamAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBUYC5cclxuICpcclxuICogVGhpcyBjYXN0IGlzIHVzZWQgaW4gdGhlIExpdGUgYW5kIEZ1bGwgU0RLIHRvIHZlcmlmeSBpbnN0YW5jZSB0eXBlcyBmb3JcclxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcHVibGljIEFQSS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBjYXN0KG9iaiwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmNvbnN0cnVjdG9yKSB7XHJcbiAgICBpZiAoJ19kZWxlZ2F0ZScgaW4gb2JqKSB7XHJcbiAgICAgICAgLy8gVW53cmFwIENvbXBhdCB0eXBlc1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgb2JqID0gb2JqLl9kZWxlZ2F0ZTtcclxuICAgIH1cclxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5uYW1lID09PSBvYmouY29uc3RydWN0b3IubmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgaW5zdGFuY2UuIERpZCB5b3UgcGFzcyBhICcgK1xyXG4gICAgICAgICAgICAgICAgYHJlZmVyZW5jZSBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBTREs/YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlRGVzY3JpcHRpb24ob2JqKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEV4cGVjdGVkIHR5cGUgJyR7Y29uc3RydWN0b3IubmFtZX0nLCBidXQgaXQgd2FzOiAke2Rlc2NyaXB0aW9ufWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZU51bWJlcihmdW5jdGlvbk5hbWUsIG4pIHtcclxuICAgIGlmIChuIDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgcmVxdWlyZXMgYSBwb3NpdGl2ZSBudW1iZXIsIGJ1dCBpdCB3YXM6ICR7bn0uYCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE9uIE5vZGUsIG9ubHkgc3VwcG9ydGVkIGRhdGEgc291cmNlIGlzIGEgYFVpbnQ4QXJyYXlgIGZvciBub3cuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXIoc291cmNlLCBieXRlc1BlclJlYWQpIHtcclxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYE5vZGVQbGF0Zm9ybS50b0J5dGVTdHJlYW1SZWFkZXIgZXhwZWN0cyBzb3VyY2UgdG8gYmUgVWludDhBcnJheSwgZ290ICR7dmFsdWVEZXNjcmlwdGlvbihzb3VyY2UpfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvQnl0ZVN0cmVhbVJlYWRlckhlbHBlcihzb3VyY2UsIGJ5dGVzUGVyUmVhZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLypcclxuICogQSB3cmFwcGVyIGltcGxlbWVudGF0aW9uIG9mIE9ic2VydmVyPFQ+IHRoYXQgd2lsbCBkaXNwYXRjaCBldmVudHNcclxuICogYXN5bmNocm9ub3VzbHkuIFRvIGFsbG93IGltbWVkaWF0ZSBzaWxlbmNpbmcsIGEgbXV0ZSBjYWxsIGlzIGFkZGVkIHdoaWNoXHJcbiAqIGNhdXNlcyBldmVudHMgc2NoZWR1bGVkIHRvIG5vIGxvbmdlciBiZSByYWlzZWQuXHJcbiAqL1xyXG5jbGFzcyBBc3luY09ic2VydmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUsIHdpbGwgbm90IHJhaXNlIGZ1dHVyZSBldmVudHMuIE5lY2Vzc2FyeSB0byBkZWFsIHdpdGhcclxuICAgICAgICAgKiBhc3luYyBkZXRhY2htZW50IG9mIGxpc3RlbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVFdmVudCh0aGlzLm9ic2VydmVyLm5leHQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVFdmVudCh0aGlzLm9ic2VydmVyLmVycm9yLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dFcnJvcignVW5jYXVnaHQgRXJyb3IgaW4gc25hcHNob3QgbGlzdGVuZXI6JywgZXJyb3IudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbXV0ZSgpIHtcclxuICAgICAgICB0aGlzLm11dGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNjaGVkdWxlRXZlbnQoZXZlbnRIYW5kbGVyLCBldmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tdXRlZCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb21wbGV0ZSBlbGVtZW50IGluIHRoZSBidW5kbGUgc3RyZWFtLCB0b2dldGhlciB3aXRoIHRoZSBieXRlIGxlbmd0aCBpdFxyXG4gKiBvY2N1cGllcyBpbiB0aGUgc3RyZWFtLlxyXG4gKi9cclxuY2xhc3MgU2l6ZWRCdW5kbGVFbGVtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHBheWxvYWQsIFxyXG4gICAgLy8gSG93IG1hbnkgYnl0ZXMgdGhpcyBlbGVtZW50IHRha2VzIHRvIHN0b3JlIGluIHRoZSBidW5kbGUuXHJcbiAgICBieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcclxuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaXNCdW5kbGVNZXRhZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gJ21ldGFkYXRhJyBpbiB0aGlzLnBheWxvYWQ7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgYnVuZGxlLlxyXG4gKlxyXG4gKiBUYWtlcyBhIGJ1bmRsZSBzdHJlYW0gb3IgYnVmZmVyLCBhbmQgcHJlc2VudHMgYWJzdHJhY3Rpb25zIHRvIHJlYWQgYnVuZGxlZFxyXG4gKiBlbGVtZW50cyBvdXQgb2YgdGhlIHVuZGVybHlpbmcgY29udGVudC5cclxuICovXHJcbmNsYXNzIEJ1bmRsZVJlYWRlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHJlYWRlciB0byByZWFkIGZyb20gdW5kZXJseWluZyBiaW5hcnkgYnVuZGxlIGRhdGEgc291cmNlLiAqL1xyXG4gICAgcmVhZGVyLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIgPSByZWFkZXI7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICAvKiogQ2FjaGVkIGJ1bmRsZSBtZXRhZGF0YS4gKi9cclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgYnVmZmVyIHRvIGhvbGQgYnVuZGxlIGNvbnRlbnQsIGFjY3VtdWxhdGluZyBpbmNvbXBsZXRlIGVsZW1lbnRcclxuICAgICAgICAgKiBjb250ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKTtcclxuICAgICAgICB0aGlzLnRleHREZWNvZGVyID0gbmV3VGV4dERlY29kZXIoKTtcclxuICAgICAgICAvLyBSZWFkIHRoZSBtZXRhZGF0YSAod2hpY2ggaXMgdGhlIGZpcnN0IGVsZW1lbnQpLlxyXG4gICAgICAgIHRoaXMubmV4dEVsZW1lbnRJbXBsKCkudGhlbihlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5pc0J1bmRsZU1ldGFkYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucmVzb2x2ZShlbGVtZW50LnBheWxvYWQubWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yZWplY3QobmV3IEVycm9yKGBUaGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYnVuZGxlIGlzIG5vdCBhIG1ldGFkYXRhLCBpdCBpc1xuICAgICAgICAgICAgICR7SlNPTi5zdHJpbmdpZnkoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnBheWxvYWQpfWApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGVycm9yID0+IHRoaXMubWV0YWRhdGEucmVqZWN0KGVycm9yKSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuY2FuY2VsKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRNZXRhZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbmV4dEVsZW1lbnQoKSB7XHJcbiAgICAgICAgLy8gTWFrZXMgc3VyZSBtZXRhZGF0YSBpcyByZWFkIGJlZm9yZSBwcm9jZWVkaW5nLlxyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0RWxlbWVudEltcGwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgZnJvbSB0aGUgaGVhZCBvZiBpbnRlcm5hbCBidWZmZXIsIGFuZCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tXHJcbiAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbSBpZiBhIGNvbXBsZXRlIGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLCB1bnRpbCBhblxyXG4gICAgICogZWxlbWVudChpbmNsdWRpbmcgdGhlIHByZWZpeGVkIGxlbmd0aCBhbmQgdGhlIEpTT04gc3RyaW5nKSBpcyBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBPbmNlIGEgY29tcGxldGUgZWxlbWVudCBpcyByZWFkLCBpdCBpcyBkcm9wcGVkIGZyb20gaW50ZXJuYWwgYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgZWl0aGVyIHRoZSBidW5kbGVkIGVsZW1lbnQsIG9yIG51bGwgaWYgd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2ZcclxuICAgICAqIHRoZSBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG5leHRFbGVtZW50SW1wbCgpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGhCdWZmZXIgPSBhd2FpdCB0aGlzLnJlYWRMZW5ndGgoKTtcclxuICAgICAgICBpZiAobGVuZ3RoQnVmZmVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhTdHJpbmcgPSB0aGlzLnRleHREZWNvZGVyLmRlY29kZShsZW5ndGhCdWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE51bWJlcihsZW5ndGhTdHJpbmcpO1xyXG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcihgbGVuZ3RoIHN0cmluZyAoJHtsZW5ndGhTdHJpbmd9KSBpcyBub3QgdmFsaWQgbnVtYmVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBhd2FpdCB0aGlzLnJlYWRKc29uU3RyaW5nKGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplZEJ1bmRsZUVsZW1lbnQoSlNPTi5wYXJzZShqc29uU3RyaW5nKSwgbGVuZ3RoQnVmZmVyLmxlbmd0aCArIGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKiogRmlyc3QgaW5kZXggb2YgJ3snIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyLiAqL1xyXG4gICAgaW5kZXhPZk9wZW5CcmFja2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5maW5kSW5kZXgodiA9PiB2ID09PSAneycuY2hhckNvZGVBdCgwKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyLCB1bnRpbCB0aGUgZmlyc3QgJ3snLCBhbmRcclxuICAgICAqIHJldHVybiB0aGUgY29udGVudC5cclxuICAgICAqXHJcbiAgICAgKiBJZiByZWFjaGVkIGVuZCBvZiB0aGUgc3RyZWFtLCByZXR1cm5zIGEgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhZExlbmd0aCgpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5pbmRleE9mT3BlbkJyYWNrZXQoKSA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IGF3YWl0IHRoaXMucHVsbE1vcmVEYXRhVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYW5kIHRoZXJlXHJcbiAgICAgICAgLy8gaGFwcGVucyB0byBiZSBubyBtb3JlIGRhdGEgdG8gcHJvY2Vzcy5cclxuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuaW5kZXhPZk9wZW5CcmFja2V0KCk7XHJcbiAgICAgICAgLy8gQnJva2Ugb3V0IG9mIHRoZSBsb29wIGJlY2F1c2UgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkLCBidXQgc3RpbGxcclxuICAgICAgICAvLyBjYW5ub3QgZmluZCBhbiBvcGVuIGJyYWNrZXQuXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBhIGxlbmd0aCBzdHJpbmcgaXMgZXhwZWN0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnNsaWNlKDAsIHBvc2l0aW9uKTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGxlbmd0aC5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKHBvc2l0aW9uKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBmcm9tIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGZyb20gdGhlIGludGVybmFsIGJ1ZmZlciwgZm9yIGEgc3BlY2lmaWVkXHJcbiAgICAgKiBudW1iZXIgb2YgYnl0ZXMsIHB1bGxpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlmIG5lZWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgcmVhZCBieXRlcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhZEpzb25TdHJpbmcobGVuZ3RoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gYXdhaXQgdGhpcy5wdWxsTW9yZURhdGFUb0J1ZmZlcigpO1xyXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKCdSZWFjaGVkIHRoZSBlbmQgb2YgYnVuZGxlIHdoZW4gbW9yZSBpcyBleHBlY3RlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGgpKTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGJ1ZmZlciB0byBkcm9wIHRoZSByZWFkIGpzb24gc3RyaW5nLlxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc2xpY2UobGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmFpc2VFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidW5kbGUgZm9ybWF0OiAke21lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1bGxzIG1vcmUgZGF0YSBmcm9tIHVuZGVybHlpbmcgc3RyZWFtIHRvIGludGVybmFsIGJ1ZmZlci5cclxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwdWxsTW9yZURhdGFUb0J1ZmZlcigpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlci5sZW5ndGggKyByZXN1bHQudmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQocmVzdWx0LnZhbHVlLCB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0J1bmRsZVJlYWRlcihyZWFkZXIsIHNlcmlhbGl6ZXIpIHtcclxuICAgIHJldHVybiBuZXcgQnVuZGxlUmVhZGVySW1wbChyZWFkZXIsIHNlcmlhbGl6ZXIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCB0cmFuc2FjdGlvbiBvYmplY3QgcmVzcG9uc2libGUgZm9yIGFjY3VtdWxhdGluZyB0aGUgbXV0YXRpb25zIHRvXHJcbiAqIHBlcmZvcm0gYW5kIHRoZSBiYXNlIHZlcnNpb25zIGZvciBhbnkgZG9jdW1lbnRzIHJlYWQuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbiQyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFzdG9yZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xyXG4gICAgICAgIC8vIFRoZSB2ZXJzaW9uIG9mIGVhY2ggZG9jdW1lbnQgdGhhdCB3YXMgcmVhZCBkdXJpbmcgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICB0aGlzLnJlYWRWZXJzaW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29tbWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBkZWZlcnJlZCB1c2FnZSBlcnJvciB0aGF0IG9jY3VycmVkIHByZXZpb3VzbHkgaW4gdGhpcyB0cmFuc2FjdGlvbiB0aGF0XHJcbiAgICAgICAgICogd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24gdG8gZmFpbCBvbmNlIGl0IGFjdHVhbGx5IGNvbW1pdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB3cml0dGVuIGluIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gdGhlcmUncyBtb3JlIHRoYW4gb25lIHdyaXRlIHRvIHRoZSBzYW1lIGtleSBpbiBhIHRyYW5zYWN0aW9uLCBhbnlcclxuICAgICAgICAgKiB3cml0ZXMgYWZ0ZXIgdGhlIGZpcnN0IGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBsb29rdXAoa2V5cykge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGaXJlc3RvcmUgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYWxsIHJlYWRzIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSBhbGwgd3JpdGVzLicpO1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGModGhpcy5kYXRhc3RvcmUsIGtleXMpO1xyXG4gICAgICAgIGRvY3MuZm9yRWFjaChkb2MgPT4gdGhpcy5yZWNvcmRWZXJzaW9uKGRvYykpO1xyXG4gICAgICAgIHJldHVybiBkb2NzO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMud3JpdGUoZGF0YS50b011dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShrZXksIGRhdGEpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlKGRhdGEudG9NdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uRm9yVXBkYXRlKGtleSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICB0aGlzLndyaXRlKG5ldyBEZWxldGVNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjb21taXQoKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bndyaXR0ZW4gPSB0aGlzLnJlYWRWZXJzaW9ucztcclxuICAgICAgICAvLyBGb3IgZWFjaCBtdXRhdGlvbiwgbm90ZSB0aGF0IHRoZSBkb2Mgd2FzIHdyaXR0ZW4uXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMuZm9yRWFjaChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHVud3JpdHRlbi5kZWxldGUobXV0YXRpb24ua2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEZvciBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgYnV0IG5vdCB3cml0dGVuIHRvLCB3ZSB3YW50IHRvIHBlcmZvcm1cclxuICAgICAgICAvLyBhIGB2ZXJpZnlgIG9wZXJhdGlvbi5cclxuICAgICAgICB1bndyaXR0ZW4uZm9yRWFjaCgoXywgcGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tUGF0aChwYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChuZXcgVmVyaWZ5TXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgaW52b2tlQ29tbWl0UnBjKHRoaXMuZGF0YXN0b3JlLCB0aGlzLm11dGF0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkVmVyc2lvbihkb2MpIHtcclxuICAgICAgICBsZXQgZG9jVmVyc2lvbjtcclxuICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIGRvY1ZlcnNpb24gPSBkb2MudmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIC8vIFJlcHJlc2VudCBhIGRlbGV0ZWQgZG9jIHVzaW5nIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cclxuICAgICAgICAgICAgZG9jVmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGRvYy5rZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nVmVyc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoIWRvY1ZlcnNpb24uaXNFcXVhbChleGlzdGluZ1ZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdpbGwgZmFpbCBubyBtYXR0ZXIgd2hhdC5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkFCT1JURUQsICdEb2N1bWVudCB2ZXJzaW9uIGNoYW5nZWQgYmV0d2VlbiB0d28gcmVhZHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZFZlcnNpb25zLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvY1ZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGlzIGRvY3VtZW50IHdoZW4gaXQgd2FzIHJlYWQgaW4gdGhpcyB0cmFuc2FjdGlvbixcclxuICAgICAqIGFzIGEgcHJlY29uZGl0aW9uLCBvciBubyBwcmVjb25kaXRpb24gaWYgaXQgd2FzIG5vdCByZWFkLlxyXG4gICAgICovXHJcbiAgICBwcmVjb25kaXRpb24oa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xyXG4gICAgICAgICAgICBpZiAodmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZSh2ZXJzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmVjb25kaXRpb24gZm9yIGEgZG9jdW1lbnQgaWYgdGhlIG9wZXJhdGlvbiBpcyBhbiB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGtleS50b1N0cmluZygpKTtcclxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSBhIGRvY3VtZW50IGlzIHdyaXR0ZW4sIHdlIHdhbnQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlXHJcbiAgICAgICAgLy8gcmVhZCB0aW1lIGFuZCBleGlzdGVuY2VcclxuICAgICAgICBpZiAoIXRoaXMud3JpdHRlbkRvY3MuaGFzKGtleS50b1N0cmluZygpKSAmJiB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QsIHNvIGZhaWwgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgdmFsaWRhdGVkIGxvY2FsbHkgYmVjYXVzZSB5b3UgY2FuJ3Qgc2VuZCBhXHJcbiAgICAgICAgICAgICAgICAvLyBwcmVjb25kaXRpb24gdGhhdCBhIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0IHdpdGhvdXQgY2hhbmdpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIGJhY2tlbmQgd3JpdGUgdG8gYmUgYW4gaW5zZXJ0LiBUaGlzIGlzIHRoZSByZXZlcnNlXHJcbiAgICAgICAgICAgICAgICAvLyBvZiB3aGF0IHdlIHdhbnQsIHNpbmNlIHdlIHdhbnQgdG8gYXNzZXJ0IHRoYXQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IGJ1dCB0aGVuIHNlbmQgdGhlIHVwZGF0ZSBhbmQgaGF2ZSBpdCBmYWlsLiBTaW5jZSB3ZSBjYW4ndFxyXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzcyB0aGF0IHRvIHRoZSBiYWNrZW5kLCB3ZSBoYXZlIHRvIHZhbGlkYXRlIGxvY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIGNhbiBjaGFuZ2Ugb25jZSB3ZSBjYW4gc2VuZCBzZXBhcmF0ZSB2ZXJpZnkgd3JpdGVzIGluIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHVwZGF0ZSBhIGRvY3VtZW50IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRG9jdW1lbnQgZXhpc3RzLCBiYXNlIHByZWNvbmRpdGlvbiBvbiBkb2N1bWVudCB1cGRhdGUgdGltZS5cclxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRG9jdW1lbnQgd2FzIG5vdCByZWFkLCBzbyB3ZSBqdXN0IHVzZSB0aGUgcHJlY29uZGl0aW9ucyBmb3IgYSBibGluZFxyXG4gICAgICAgICAgICAvLyB1cGRhdGUuXHJcbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyaXRlKG11dGF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcclxuICAgIH1cclxuICAgIGVuc3VyZUNvbW1pdE5vdENhbGxlZCgpIHtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJhbnNhY3Rpb25SdW5uZXIgZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBuZWVkZWQgdG8gcnVuIGFuZCByZXRyeSB0cmFuc2FjdGlvbnNcclxuICogd2l0aCBiYWNrb2ZmLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb25SdW5uZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgZGF0YXN0b3JlLCBvcHRpb25zLCB1cGRhdGVGdW5jdGlvbiwgZGVmZXJyZWQpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xyXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbiA9IHVwZGF0ZUZ1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBkZWZlcnJlZDtcclxuICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nID0gb3B0aW9ucy5tYXhBdHRlbXB0cztcclxuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMuYXN5bmNRdWV1ZSwgXCJ0cmFuc2FjdGlvbl9yZXRyeVwiIC8qIFRpbWVySWQuVHJhbnNhY3Rpb25SZXRyeSAqLyk7XHJcbiAgICB9XHJcbiAgICAvKiogUnVucyB0aGUgdHJhbnNhY3Rpb24gYW5kIHNldHMgdGhlIHJlc3VsdCBvbiBkZWZlcnJlZC4gKi9cclxuICAgIHJ1bigpIHtcclxuICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nIC09IDE7XHJcbiAgICAgICAgdGhpcy5ydW5XaXRoQmFja09mZigpO1xyXG4gICAgfVxyXG4gICAgcnVuV2l0aEJhY2tPZmYoKSB7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmJhY2tvZmZBbmRSdW4oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbiQyKHRoaXMuZGF0YXN0b3JlKTtcclxuICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB0aGlzLnRyeVJ1blVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHVzZXJQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb21taXQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29tbWl0RXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbkVycm9yKGNvbW1pdEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh1c2VyUHJvbWlzZUVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uRXJyb3IodXNlclByb21pc2VFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJ5UnVuVXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodXNlclByb21pc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UuY2F0Y2ggfHxcclxuICAgICAgICAgICAgICAgICF1c2VyUHJvbWlzZS50aGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChFcnJvcignVHJhbnNhY3Rpb24gY2FsbGJhY2sgbXVzdCByZXR1cm4gYSBQcm9taXNlJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IHJldHJ5IGVycm9ycyB0aHJvd24gYnkgdXNlciBwcm92aWRlZCB1cGRhdGVGdW5jdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPiAwICYmIHRoaXMuaXNSZXRyeWFibGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nIC09IDE7XHJcbiAgICAgICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVuV2l0aEJhY2tPZmYoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNSZXRyeWFibGVUcmFuc2FjdGlvbkVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAvLyBJbiB0cmFuc2FjdGlvbnMsIHRoZSBiYWNrZW5kIHdpbGwgZmFpbCBvdXRkYXRlZCByZWFkcyB3aXRoIEZBSUxFRF9QUkVDT05ESVRJT04gYW5kXHJcbiAgICAgICAgICAgIC8vIG5vbi1tYXRjaGluZyBkb2N1bWVudCB2ZXJzaW9ucyB3aXRoIEFCT1JURUQuIFRoZXNlIGVycm9ycyBzaG91bGQgYmUgcmV0cmllZC5cclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGVycm9yLmNvZGU7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29kZSA9PT0gJ2Fib3J0ZWQnIHx8XHJcbiAgICAgICAgICAgICAgICBjb2RlID09PSAnZmFpbGVkLXByZWNvbmRpdGlvbicgfHxcclxuICAgICAgICAgICAgICAgIGNvZGUgPT09ICdhbHJlYWR5LWV4aXN0cycgfHxcclxuICAgICAgICAgICAgICAgICFpc1Blcm1hbmVudEVycm9yKGNvZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckMiA9ICdGaXJlc3RvcmVDbGllbnQnO1xyXG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9MSU1CT19SRVNPTFVUSU9OUyA9IDEwMDtcclxuLyoqIERPTUV4Y2VwdGlvbiBlcnJvciBjb2RlIGNvbnN0YW50cy4gKi9cclxuY29uc3QgRE9NX0VYQ0VQVElPTl9JTlZBTElEX1NUQVRFID0gMTE7XHJcbmNvbnN0IERPTV9FWENFUFRJT05fQUJPUlRFRCA9IDIwO1xyXG5jb25zdCBET01fRVhDRVBUSU9OX1FVT1RBX0VYQ0VFREVEID0gMjI7XHJcbi8qKlxyXG4gKiBGaXJlc3RvcmVDbGllbnQgaXMgYSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBjb25zdHJ1Y3RzIGFuZCBvd25zIGFsbCBvZiB0aGUgLy9cclxuICogcGllY2VzIG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSAvL1xyXG4gKiBhc3luYyBxdWV1ZSB0aGF0IGlzIHNoYXJlZCBieSBhbGwgb2YgdGhlIG90aGVyIGNvbXBvbmVudHMgaW4gdGhlIHN5c3RlbS4gLy9cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXMgcXVldWUgcmVzcG9uc2libGUgZm9yIGFsbCBvZiBvdXIgaW50ZXJuYWwgcHJvY2Vzc2luZy4gV2hlblxyXG4gICAgICogd2UgZ2V0IGluY29taW5nIHdvcmsgZnJvbSB0aGUgdXNlciAodmlhIHB1YmxpYyBBUEkpIG9yIHRoZSBuZXR3b3JrXHJcbiAgICAgKiAoaW5jb21pbmcgR1JQQyBtZXNzYWdlcyksIHdlIHNob3VsZCBhbHdheXMgc2NoZWR1bGUgb250byB0aGlzIHF1ZXVlLlxyXG4gICAgICogVGhpcyBlbnN1cmVzIGFsbCBvZiBvdXIgd29yayBpcyBwcm9wZXJseSBzZXJpYWxpemVkIChlLmcuIHdlIGRvbid0XHJcbiAgICAgKiBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IG9wZXJhdGlvbiB3aGlsZSB0aGUgcHJldmlvdXMgb25lIGlzIHdhaXRpbmcgZm9yXHJcbiAgICAgKiBhbiBhc3luYyBJL08gdG8gY29tcGxldGUpLlxyXG4gICAgICovXHJcbiAgICBhc3luY1F1ZXVlLCBkYXRhYmFzZUluZm8pIHtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMgPSBhcHBDaGVja0NyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XHJcbiAgICAgICAgdGhpcy51c2VyID0gVXNlci5VTkFVVEhFTlRJQ0FURUQ7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IEF1dG9JZC5uZXdJZCgpO1xyXG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBhc3luYyAodXNlcikgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdSZWNlaXZlZCB1c2VyPScsIHVzZXIudWlkKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyKHVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBuZXdBcHBDaGVja1Rva2VuID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnUmVjZWl2ZWQgbmV3IGFwcCBjaGVjayB0b2tlbj0nLCBuZXdBcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIobmV3QXBwQ2hlY2tUb2tlbiwgdGhpcy51c2VyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBjb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFzeW5jUXVldWU6IHRoaXMuYXN5bmNRdWV1ZSxcclxuICAgICAgICAgICAgZGF0YWJhc2VJbmZvOiB0aGlzLmRhdGFiYXNlSW5mbyxcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGF1dGhDcmVkZW50aWFsczogdGhpcy5hdXRoQ3JlZGVudGlhbHMsXHJcbiAgICAgICAgICAgIGFwcENoZWNrQ3JlZGVudGlhbHM6IHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgaW5pdGlhbFVzZXI6IHRoaXMudXNlcixcclxuICAgICAgICAgICAgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnM6IE1BWF9DT05DVVJSRU5UX0xJTUJPX1JFU09MVVRJT05TXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHNldENyZWRlbnRpYWxDaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgfVxyXG4gICAgc2V0QXBwQ2hlY2tUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdGhhdCB0aGUgY2xpZW50IGhhcyBub3QgYmVlbiB0ZXJtaW5hdGVkLiBFbnN1cmVzIHRoYXQgb3RoZXIgbWV0aG9kcyBvbiAvL1xyXG4gICAgICogdGhpcyBjbGFzcyBjYW5ub3QgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGllbnQgaXMgdGVybWluYXRlZC4gLy9cclxuICAgICAqL1xyXG4gICAgdmVyaWZ5Tm90VGVybWluYXRlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5hc3luY1F1ZXVlLmlzU2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVudGVyUmVzdHJpY3RlZE1vZGUoKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25saW5lQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29ubGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2ZmbGluZUNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vZmZsaW5lQ29tcG9uZW50cy50ZXJtaW5hdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjcmVkZW50aWFscyBwcm92aWRlciBtdXN0IGJlIHRlcm1pbmF0ZWQgYWZ0ZXIgc2h1dHRpbmcgZG93biB0aGVcclxuICAgICAgICAgICAgICAgIC8vIFJlbW90ZVN0b3JlIGFzIGl0IHdpbGwgcHJldmVudCB0aGUgUmVtb3RlU3RvcmUgZnJvbSByZXRyaWV2aW5nIGF1dGhcclxuICAgICAgICAgICAgICAgIC8vIHRva2Vucy5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuc2h1dGRvd24oKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gc2h1dGRvd24gcGVyc2lzdGVuY2VgKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmaXJlc3RvcmVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXInKTtcclxuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjbGllbnQuY29uZmlndXJhdGlvbjtcclxuICAgIGF3YWl0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgbGV0IGN1cnJlbnRVc2VyID0gY29uZmlndXJhdGlvbi5pbml0aWFsVXNlcjtcclxuICAgIGNsaWVudC5zZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIoYXN5bmMgKHVzZXIpID0+IHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcikpIHtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2Uob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmUsIHVzZXIpO1xyXG4gICAgICAgICAgICBjdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBXaGVuIGEgdXNlciBjYWxscyBjbGVhclBlcnNpc3RlbmNlKCkgaW4gb25lIGNsaWVudCwgYWxsIG90aGVyIGNsaWVudHNcclxuICAgIC8vIG5lZWQgdG8gYmUgdGVybWluYXRlZCB0byBhbGxvdyB0aGUgZGVsZXRlIHRvIHN1Y2NlZWQuXHJcbiAgICBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucGVyc2lzdGVuY2Uuc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKCkgPT4gY2xpZW50LnRlcm1pbmF0ZSgpKTtcclxuICAgIGNsaWVudC5fb2ZmbGluZUNvbXBvbmVudHMgPSBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlcikge1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUudmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpO1xyXG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gYXdhaXQgZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xyXG4gICAgYXdhaXQgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZShvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsIGNsaWVudC5jb25maWd1cmF0aW9uKTtcclxuICAgIC8vIFRoZSBDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIgb2YgdGhlIG9ubGluZSBjb21wb25lbnQgcHJvdmlkZXIgdGFrZXNcclxuICAgIC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgb2ZmbGluZSBjb21wb25lbnQgcHJvdmlkZXIuXHJcbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKHVzZXIgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XHJcbiAgICBjbGllbnQuc2V0QXBwQ2hlY2tUb2tlbkNoYW5nZUxpc3RlbmVyKChfLCB1c2VyKSA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcclxuICAgIGNsaWVudC5fb25saW5lQ29tcG9uZW50cyA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNpZGVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVycm9yIGFsbG93cyB1cyB0byBncmFjZWZ1bGx5IGRpc2FibGVcclxuICogcGVyc2lzdGVuY2UgKGFzIG9wcG9zZWQgdG8gY3Jhc2hpbmcgdGhlIGNsaWVudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlcnJvcikge1xyXG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OIHx8XHJcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IENvZGUuVU5JTVBMRU1FTlRFRCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgZmV3IGtub3duIGNpcmN1bXN0YW5jZXMgd2hlcmUgd2UgY2FuIG9wZW4gSW5kZXhlZERiIGJ1dFxyXG4gICAgICAgIC8vIHRyeWluZyB0byByZWFkL3dyaXRlIHdpbGwgZmFpbCAoZS5nLiBxdW90YSBleGNlZWRlZCkuIEZvclxyXG4gICAgICAgIC8vIHdlbGwtdW5kZXJzdG9vZCBjYXNlcywgd2UgYXR0ZW1wdCB0byBkZXRlY3QgdGhlc2UgYW5kIHRoZW4gZ3JhY2VmdWxseVxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgLy8gTk9URTogUmF0aGVyIHRoYW4gY29udGludWUgdG8gYWRkIHRvIHRoaXMgbGlzdCwgd2UgY291bGQgZGVjaWRlIHRvXHJcbiAgICAgICAgLy8gYWx3YXlzIGZhbGwgYmFjaywgd2l0aCB0aGUgcmlzayB0aGF0IHdlIG1pZ2h0IGFjY2lkZW50YWxseSBoaWRlIGVycm9yc1xyXG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhY3R1YWwgU0RLIGJ1Z3MuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAvLyBXaGVuIHRoZSBicm93c2VyIGlzIG91dCBvZiBxdW90YSB3ZSBjb3VsZCBnZXQgZWl0aGVyIHF1b3RhIGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gb3IgYW4gYWJvcnRlZCBlcnJvciBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZXJyb3IgaGFwcGVuZWQgZHVyaW5nXHJcbiAgICAgICAgLy8gc2NoZW1hIG1pZ3JhdGlvbi5cclxuICAgICAgICBlcnJvci5jb2RlID09PSBET01fRVhDRVBUSU9OX1FVT1RBX0VYQ0VFREVEIHx8XHJcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fQUJPUlRFRCB8fFxyXG4gICAgICAgICAgICAvLyBGaXJlZm94IFByaXZhdGUgQnJvd3NpbmcgbW9kZSBkaXNhYmxlcyBJbmRleGVkRGIgYW5kIHJldHVybnNcclxuICAgICAgICAgICAgLy8gSU5WQUxJRF9TVEFURSBmb3IgYW55IHVzYWdlLlxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBET01fRVhDRVBUSU9OX0lOVkFMSURfU1RBVEUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KSB7XHJcbiAgICBpZiAoIWNsaWVudC5fb2ZmbGluZUNvbXBvbmVudHMpIHtcclxuICAgICAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIHVzZXIgcHJvdmlkZWQgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nV2FybignRXJyb3IgdXNpbmcgdXNlciBwcm92aWRlZCBjYWNoZS4gRmFsbGluZyBiYWNrIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdtZW1vcnkgY2FjaGU6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIGRlZmF1bHQgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsaWVudC5fb2ZmbGluZUNvbXBvbmVudHM7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpIHtcclxuICAgIGlmICghY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyLl9vbmxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgZGVmYXVsdCBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBlcnNpc3RlbmNlKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucGVyc2lzdGVuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvY2FsU3RvcmUoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5sb2NhbFN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRSZW1vdGVTdG9yZShjbGllbnQpIHtcclxuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucmVtb3RlU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFN5bmNFbmdpbmUoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLnN5bmNFbmdpbmUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldERhdGFzdG9yZShjbGllbnQpIHtcclxuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMuZGF0YXN0b3JlKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBnZXRFdmVudE1hbmFnZXIoY2xpZW50KSB7XHJcbiAgICBjb25zdCBvbmxpbmVDb21wb25lbnRQcm92aWRlciA9IGF3YWl0IGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KTtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmV2ZW50TWFuYWdlcjtcclxuICAgIGV2ZW50TWFuYWdlci5vbkxpc3RlbiA9IHN5bmNFbmdpbmVMaXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcclxuICAgIGV2ZW50TWFuYWdlci5vblVubGlzdGVuID0gc3luY0VuZ2luZVVubGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XHJcbiAgICBldmVudE1hbmFnZXIub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuID0gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XHJcbiAgICBldmVudE1hbmFnZXIub25MYXN0UmVtb3RlU3RvcmVVbmxpc3RlbiA9IHRyaWdnZXJSZW1vdGVTdG9yZVVubGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XHJcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyO1xyXG59XHJcbi8qKiBFbmFibGVzIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gYW5kIHJlLWVucXVldWVzIGFsbCBwZW5kaW5nIG9wZXJhdGlvbnMuICovXHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEVuYWJsZU5ldHdvcmsoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2UgPSBhd2FpdCBnZXRQZXJzaXN0ZW5jZShjbGllbnQpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcclxuICAgICAgICBwZXJzaXN0ZW5jZS5zZXROZXR3b3JrRW5hYmxlZCh0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlU3RvcmVFbmFibGVOZXR3b3JrKHJlbW90ZVN0b3JlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKiBEaXNhYmxlcyB0aGUgbmV0d29yayBjb25uZWN0aW9uLiBQZW5kaW5nIG9wZXJhdGlvbnMgd2lsbCBub3QgY29tcGxldGUuICovXHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudERpc2FibGVOZXR3b3JrKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gYXdhaXQgZ2V0UGVyc2lzdGVuY2UoY2xpZW50KTtcclxuICAgICAgICBjb25zdCByZW1vdGVTdG9yZSA9IGF3YWl0IGdldFJlbW90ZVN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVTdG9yZURpc2FibGVOZXR3b3JrKHJlbW90ZVN0b3JlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHdyaXRlcyB0aGF0IHdlcmUgcGVuZGluZyBhdCB0aGUgdGltZVxyXG4gKiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHJlY2VpdmVkIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuIEFuIGFja25vd2xlZGdlbWVudFxyXG4gKiBjYW4gYmUgZWl0aGVyIGFjY2VwdGFuY2Ugb3IgcmVqZWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50V2FpdEZvclBlbmRpbmdXcml0ZXMoY2xpZW50KSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gc3luY0VuZ2luZVJlZ2lzdGVyUGVuZGluZ1dyaXRlc0NhbGxiYWNrKHN5bmNFbmdpbmUsIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50TGlzdGVuKGNsaWVudCwgcXVlcnksIG9wdGlvbnMsIG9ic2VydmVyKSB7XHJcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBRdWVyeUxpc3RlbmVyKHF1ZXJ5LCB3cmFwcGVkT2JzZXJ2ZXIsIG9wdGlvbnMpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xyXG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlclVubGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudEZyb21Mb2NhbENhY2hlKGNsaWVudCwgZG9jS2V5KSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBrZXksIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiByZWFkRG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgY2xpZW50LmFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZVF1ZXJ5RnJvbUNhY2hlKGxvY2FsU3RvcmUsIHF1ZXJ5LCBkZWZlcnJlZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50UnVuQWdncmVnYXRlUXVlcnkoY2xpZW50LCBxdWVyeSwgYWdncmVnYXRlcykge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIEltcGxlbWVudCBhbmQgY2FsbCBleGVjdXRlQWdncmVnYXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyLCBzaW1pbGFyXHJcbiAgICAgICAgLy8gdG8gdGhlIGltcGxlbWVudGF0aW9uIGluIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXJcclxuICAgICAgICAvLyBhYm92ZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oYi8yNzc2MjgzODQpOiBjaGVjayBgY2FuVXNlTmV0d29yaygpYCBhbmQgaGFuZGxlIG11bHRpLXRhYi5cclxuICAgICAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFdyaXRlKGNsaWVudCwgbXV0YXRpb25zKSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gc3luY0VuZ2luZVdyaXRlKHN5bmNFbmdpbmUsIG11dGF0aW9ucywgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihjbGllbnQsIG9ic2VydmVyKSB7XHJcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gYWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XHJcbiAgICAgICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCB3cmFwcGVkT2JzZXJ2ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogVGFrZXMgYW4gdXBkYXRlRnVuY3Rpb24gaW4gd2hpY2ggYSBzZXQgb2YgcmVhZHMgYW5kIHdyaXRlcyBjYW4gYmUgcGVyZm9ybWVkXHJcbiAqIGF0b21pY2FsbHkuIEluIHRoZSB1cGRhdGVGdW5jdGlvbiwgdGhlIGNsaWVudCBjYW4gcmVhZCBhbmQgd3JpdGUgdmFsdWVzXHJcbiAqIHVzaW5nIHRoZSBzdXBwbGllZCB0cmFuc2FjdGlvbiBvYmplY3QuIEFmdGVyIHRoZSB1cGRhdGVGdW5jdGlvbiwgYWxsXHJcbiAqIGNoYW5nZXMgd2lsbCBiZSBjb21taXR0ZWQuIElmIGEgcmV0cnlhYmxlIGVycm9yIG9jY3VycyAoZXg6IHNvbWUgb3RoZXJcclxuICogY2xpZW50IGhhcyBjaGFuZ2VkIGFueSBvZiB0aGUgZGF0YSByZWZlcmVuY2VkKSwgdGhlbiB0aGUgdXBkYXRlRnVuY3Rpb25cclxuICogd2lsbCBiZSBjYWxsZWQgYWdhaW4gYWZ0ZXIgYSBiYWNrb2ZmLiBJZiB0aGUgdXBkYXRlRnVuY3Rpb24gc3RpbGwgZmFpbHNcclxuICogYWZ0ZXIgYWxsIHJldHJpZXMsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVqZWN0ZWQuXHJcbiAqXHJcbiAqIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgcGFzc2VkIHRvIHRoZSB1cGRhdGVGdW5jdGlvbiBjb250YWlucyBtZXRob2RzIGZvclxyXG4gKiBhY2Nlc3NpbmcgZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucy4gVW5saWtlIG90aGVyIGRhdGFzdG9yZSBhY2Nlc3MsIGRhdGFcclxuICogYWNjZXNzZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBub3QgcmVmbGVjdCBsb2NhbCBjaGFuZ2VzIHRoYXQgaGF2ZSBub3RcclxuICogYmVlbiBjb21taXR0ZWQuIEZvciB0aGlzIHJlYXNvbiwgaXQgaXMgcmVxdWlyZWQgdGhhdCBhbGwgcmVhZHMgYXJlXHJcbiAqIHBlcmZvcm1lZCBiZWZvcmUgYW55IHdyaXRlcy4gVHJhbnNhY3Rpb25zIG11c3QgYmUgcGVyZm9ybWVkIHdoaWxlIG9ubGluZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFRyYW5zYWN0aW9uKGNsaWVudCwgdXBkYXRlRnVuY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhc3RvcmUgPSBhd2FpdCBnZXREYXRhc3RvcmUoY2xpZW50KTtcclxuICAgICAgICBuZXcgVHJhbnNhY3Rpb25SdW5uZXIoY2xpZW50LmFzeW5jUXVldWUsIGRhdGFzdG9yZSwgb3B0aW9ucywgdXBkYXRlRnVuY3Rpb24sIGRlZmVycmVkKS5ydW4oKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgcmVzdWx0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gYXdhaXQgbG9jYWxTdG9yZVJlYWREb2N1bWVudChsb2NhbFN0b3JlLCBkb2NLZXkpO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShkb2N1bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgZnJvbSBjYWNoZS4gKEhvd2V2ZXIsIHRoaXMgZG9jdW1lbnQgbWF5ICcgK1xyXG4gICAgICAgICAgICAgICAgXCJleGlzdCBvbiB0aGUgc2VydmVyLiBSdW4gYWdhaW4gd2l0aG91dCBzZXR0aW5nICdzb3VyY2UnIGluIFwiICtcclxuICAgICAgICAgICAgICAgICd0aGUgR2V0T3B0aW9ucyB0byBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSAnICtcclxuICAgICAgICAgICAgICAgICdzZXJ2ZXIuKScpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIGdldCBkb2N1bWVudCAnJHtkb2NLZXl9IGZyb20gY2FjaGVgKTtcclxuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEgbGF0ZW5jeS1jb21wZW5zYXRlZCBkb2N1bWVudCBmcm9tIHRoZSBiYWNrZW5kIHZpYSBhXHJcbiAqIFNuYXBzaG90TGlzdGVuZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWFkRG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgYXN5bmNRdWV1ZSwga2V5LCBvcHRpb25zLCByZXN1bHQpIHtcclxuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcclxuICAgICAgICBuZXh0OiAoc25hcCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgcXVlcnkgZmlyc3QgYmVmb3JlIHBhc3NpbmcgZXZlbnQgdG8gdXNlciB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyB1c2VyIGFjdGlvbnMgYWZmZWN0aW5nIHRoZSBub3cgc3RhbGUgcXVlcnkuXHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IHNuYXAuZG9jcy5oYXMoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdHMgJiYgc25hcC5mcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oZGltb25kKTogSWYgd2UncmUgb25saW5lIGFuZCB0aGUgZG9jdW1lbnQgZG9lc24ndFxyXG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgdGhlbiB3ZSByZXNvbHZlIHdpdGggYSBkb2MuZXhpc3RzIHNldCB0byBmYWxzZS4gSWZcclxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUgaG93ZXZlciwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoaXNcclxuICAgICAgICAgICAgICAgIC8vIGNhc2UuIFR3byBvcHRpb25zOiAxKSBDYWNoZSB0aGUgbmVnYXRpdmUgcmVzcG9uc2UgZnJvbVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlciBzbyB3ZSBjYW4gZGVsaXZlciB0aGF0IGV2ZW4gd2hlbiB5b3UncmVcclxuICAgICAgICAgICAgICAgIC8vIG9mZmxpbmUgMikgQWN0dWFsbHkgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoZSBvbmxpbmUgY2FzZVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudCBiZWNhdXNlIHRoZSBjbGllbnQgaXMgb2ZmbGluZS4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXhpc3RzICYmXHJcbiAgICAgICAgICAgICAgICBzbmFwLmZyb21DYWNoZSAmJlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2UgPT09ICdzZXJ2ZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudCBmcm9tIHNlcnZlci4gKEhvd2V2ZXIsIHRoaXMgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGRvZXMgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhvdXQgc2V0dGluZyBzb3VyY2UgdG8gXCJzZXJ2ZXJcIiB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmV0cmlldmUgdGhlIGNhY2hlZCBkb2N1bWVudC4pJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBlID0+IHJlc3VsdC5yZWplY3QoZSlcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihuZXdRdWVyeUZvclBhdGgoa2V5LnBhdGgpLCB3cmFwcGVkT2JzZXJ2ZXIsIHtcclxuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiB0cnVlLFxyXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVRdWVyeUZyb21DYWNoZShsb2NhbFN0b3JlLCBxdWVyeSwgcmVzdWx0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgXHJcbiAgICAgICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyB0cnVlKTtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcocXVlcnksIHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXMpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSB2aWV3LmFwcGx5Q2hhbmdlcyh2aWV3RG9jQ2hhbmdlcywgXHJcbiAgICAgICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gZmFsc2UpO1xyXG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBleGVjdXRlIHF1ZXJ5ICcke3F1ZXJ5fSBhZ2FpbnN0IGNhY2hlYCk7XHJcbiAgICAgICAgcmVzdWx0LnJlamVjdChmaXJlc3RvcmVFcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgcXVlcnkgc25hcHNob3QgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxyXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZXhlY3V0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIHF1ZXJ5LCBvcHRpb25zLCByZXN1bHQpIHtcclxuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcclxuICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBxdWVyeSBmaXJzdCBiZWZvcmUgcGFzc2luZyBldmVudCB0byB1c2VyIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IGV2ZW50TWFuYWdlclVubGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpKTtcclxuICAgICAgICAgICAgaWYgKHNuYXBzaG90LmZyb21DYWNoZSAmJiBvcHRpb25zLnNvdXJjZSA9PT0gJ3NlcnZlcicpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50cyBmcm9tIHNlcnZlci4gKEhvd2V2ZXIsIHRoZXNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudHMgbWF5IGV4aXN0IGluIHRoZSBsb2NhbCBjYWNoZS4gUnVuIGFnYWluICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JldHJpZXZlIHRoZSBjYWNoZWQgZG9jdW1lbnRzLiknKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShzbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBlID0+IHJlc3VsdC5yZWplY3QoZSlcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCB7XHJcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogdHJ1ZSxcclxuICAgICAgICB3YWl0Rm9yU3luY1doZW5PbmxpbmU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZGF0YWJhc2VJZCwgZGF0YSwgcmVzdWx0VGFzaykge1xyXG4gICAgY29uc3QgcmVhZGVyID0gY3JlYXRlQnVuZGxlUmVhZGVyKGRhdGEsIG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCkpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgc3luY0VuZ2luZUxvYWRCdW5kbGUoYXdhaXQgZ2V0U3luY0VuZ2luZShjbGllbnQpLCByZWFkZXIsIHJlc3VsdFRhc2spO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0TmFtZWRRdWVyeShjbGllbnQsIHF1ZXJ5TmFtZSkge1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4gbG9jYWxTdG9yZUdldE5hbWVkUXVlcnkoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpLCBxdWVyeU5hbWUpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgc2VyaWFsaXplcikge1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29udGVudCA9IG5ld1RleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udGVudCA9IGRhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3QnVuZGxlUmVhZGVyKHRvQnl0ZVN0cmVhbVJlYWRlcihjb250ZW50KSwgc2VyaWFsaXplcik7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50U2V0SW5kZXhDb25maWd1cmF0aW9uKGNsaWVudCwgaW5kZXhlcykge1xyXG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgaW5kZXhlcyk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoY2xpZW50LCBpc0VuYWJsZWQpIHtcclxuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZVNldEluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIGlzRW5hYmxlZCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnREZWxldGVBbGxGaWVsZEluZGV4ZXMoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVEZWxldGVBbGxGaWVsZEluZGV4ZXMoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYEV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9uc2Agb2JqZWN0cyBmb3IgZXF1YWxpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb25nUG9sbGluZ09wdGlvbnNFcXVhbChvcHRpb25zMSwgb3B0aW9uczIpIHtcclxuICAgIHJldHVybiBvcHRpb25zMS50aW1lb3V0U2Vjb25kcyA9PT0gb3B0aW9uczIudGltZW91dFNlY29uZHM7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYEV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9uc2Agd2l0aCB0aGUgc2FtZVxyXG4gKiBvcHRpb24gdmFsdWVzIGFzIHRoZSBnaXZlbiBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNsb25lID0ge307XHJcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2xvbmUudGltZW91dFNlY29uZHMgPSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckMSA9ICdDb21wb25lbnRQcm92aWRlcic7XHJcbi8qKlxyXG4gKiBBbiBpbnN0YW5jZSBtYXAgdGhhdCBlbnN1cmVzIG9ubHkgb25lIERhdGFzdG9yZSBleGlzdHMgcGVyIEZpcmVzdG9yZVxyXG4gKiBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IGRhdGFzdG9yZUluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGNvbXBvbmVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBpbnN0YW5jZS4gTXVzdCBiZSBjYWxsZWRcclxuICogd2hlbiB0aGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgaXMgdGVybWluYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNvbXBvbmVudHMoZmlyZXN0b3JlKSB7XHJcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBkYXRhc3RvcmVJbnN0YW5jZXMuZ2V0KGZpcmVzdG9yZSk7XHJcbiAgICBpZiAoZGF0YXN0b3JlKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQxLCAnUmVtb3ZpbmcgRGF0YXN0b3JlJyk7XHJcbiAgICAgICAgZGF0YXN0b3JlSW5zdGFuY2VzLmRlbGV0ZShmaXJlc3RvcmUpO1xyXG4gICAgICAgIGRhdGFzdG9yZS50ZXJtaW5hdGUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYWtlRGF0YWJhc2VJbmZvKGRhdGFiYXNlSWQsIGFwcElkLCBwZXJzaXN0ZW5jZUtleSwgc2V0dGluZ3MpIHtcclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2VJbmZvKGRhdGFiYXNlSWQsIGFwcElkLCBwZXJzaXN0ZW5jZUtleSwgc2V0dGluZ3MuaG9zdCwgc2V0dGluZ3Muc3NsLCBzZXR0aW5ncy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nLCBzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcsIGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKHNldHRpbmdzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyksIHNldHRpbmdzLnVzZUZldGNoU3RyZWFtcyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gc2V0dGluZ3MoKSBkZWZhdWx0czpcclxuY29uc3QgREVGQVVMVF9IT1NUID0gJ2ZpcmVzdG9yZS5nb29nbGVhcGlzLmNvbSc7XHJcbmNvbnN0IERFRkFVTFRfU1NMID0gdHJ1ZTtcclxuLy8gVGhlIG1pbmltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgaGFyZGNvZGVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSB2YWx1ZSBoZXJlXHJcbi8vIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdmFsdWUgdXNlZCBieSB0aGUgc2VydmVyLCBhcyB0aGUgc2VydmVyIHdpbGxcclxuLy8gc2lsZW50bHkgaWdub3JlIGEgdmFsdWUgYmVsb3cgdGhlIG1pbmltdW0gYW5kIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdC5cclxuLy8gR29vZ2xlcnMgc2VlIGIvMjY2ODY4ODcxIGZvciByZWxldmFudCBkaXNjdXNzaW9uLlxyXG5jb25zdCBNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUyA9IDU7XHJcbi8vIE5vIG1heGltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgY29uZmlndXJlZCBpbiB0aGUgc2VydmVyLCBhbmQgZGVmYXVsdHMgdG9cclxuLy8gMzAgc2Vjb25kcywgd2hpY2ggaXMgd2hhdCBXYXRjaCBhcHBlYXJzIHRvIHVzZS5cclxuLy8gR29vZ2xlcnMgc2VlIGIvMjY2ODY4ODcxIGZvciByZWxldmFudCBkaXNjdXNzaW9uLlxyXG5jb25zdCBNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUyA9IDMwO1xyXG4vLyBXaGV0aGVyIGxvbmctcG9sbGluZyBhdXRvLWRldGVjdGVkIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cclxuY29uc3QgREVGQVVMVF9BVVRPX0RFVEVDVF9MT05HX1BPTExJTkcgPSB0cnVlO1xyXG4vKipcclxuICogQSBjb25jcmV0ZSB0eXBlIGRlc2NyaWJpbmcgYWxsIHRoZSB2YWx1ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB2aWEgYVxyXG4gKiB1c2VyLXN1cHBsaWVkIGBGaXJlc3RvcmVTZXR0aW5nc2Agb2JqZWN0LiBUaGlzIGlzIGEgc2VwYXJhdGUgdHlwZSBzbyB0aGF0XHJcbiAqIGRlZmF1bHRzIGNhbiBiZSBzdXBwbGllZCBhbmQgdGhlIHZhbHVlIGNhbiBiZSBjaGVja2VkIGZvciBlcXVhbGl0eS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZVNldHRpbmdzSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmhvc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3NsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwiQ2FuJ3QgcHJvdmlkZSBzc2wgb3B0aW9uIGlmIGhvc3Qgb3B0aW9uIGlzIG5vdCBzZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gREVGQVVMVF9IT1NUO1xyXG4gICAgICAgICAgICB0aGlzLnNzbCA9IERFRkFVTFRfU1NMO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gc2V0dGluZ3MuaG9zdDtcclxuICAgICAgICAgICAgdGhpcy5zc2wgPSAoX2EgPSBzZXR0aW5ncy5zc2wpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfU1NMO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gc2V0dGluZ3MuY3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gISFzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMubG9jYWxDYWNoZSA9IHNldHRpbmdzLmxvY2FsQ2FjaGU7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgIT09IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEICYmXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0ICR7TFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFU31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKCdleHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nJywgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgJ2V4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyk7XHJcbiAgICAgICAgdGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nID0gISFzZXR0aW5ncy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nO1xyXG4gICAgICAgIGlmICh0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgY29lcmNlIHRoZSB2YWx1ZSB0byBib29sZWFuIGV2ZW4gdGhvdWdoXHJcbiAgICAgICAgICAgIC8vIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIGhhcyBuYXJyb3dlZCB0aGUgdHlwZSB0byBib29sZWFuIGFscmVhZHkuXHJcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBQb2ludGxlc3NCb29sZWFuRXhwcmVzc2lvbkpTXHJcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID1cclxuICAgICAgICAgICAgICAgICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyA9IGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKChfYiA9IHNldHRpbmdzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pO1xyXG4gICAgICAgIHZhbGlkYXRlTG9uZ1BvbGxpbmdPcHRpb25zKHRoaXMuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKTtcclxuICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9ICEhc2V0dGluZ3MudXNlRmV0Y2hTdHJlYW1zO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ob3N0ID09PSBvdGhlci5ob3N0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3NsID09PSBvdGhlci5zc2wgJiZcclxuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9PT0gb3RoZXIuY3JlZGVudGlhbHMgJiZcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9PT0gb3RoZXIuY2FjaGVTaXplQnl0ZXMgJiZcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nID09PVxyXG4gICAgICAgICAgICAgICAgb3RoZXIuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyAmJlxyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9PT1cclxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyAmJlxyXG4gICAgICAgICAgICBsb25nUG9sbGluZ09wdGlvbnNFcXVhbCh0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucywgb3RoZXIuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPT09IG90aGVyLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgJiZcclxuICAgICAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPT09IG90aGVyLnVzZUZldGNoU3RyZWFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnMob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChpc05hTihvcHRpb25zLnRpbWVvdXRTZWNvbmRzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgaW52YWxpZCBsb25nIHBvbGxpbmcgdGltZW91dDogYCArXHJcbiAgICAgICAgICAgICAgICBgJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSAobXVzdCBub3QgYmUgTmFOKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyA8IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiAke29wdGlvbnMudGltZW91dFNlY29uZHN9IGAgK1xyXG4gICAgICAgICAgICAgICAgYChtaW5pbXVtIGFsbG93ZWQgdmFsdWUgaXMgJHtNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EU30pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzID4gTUFYX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gYCArXHJcbiAgICAgICAgICAgICAgICBgKG1heGltdW0gYWxsb3dlZCB2YWx1ZSBpcyAke01BWF9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTfSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBDbG91ZCBGaXJlc3RvcmUgc2VydmljZSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXHJcbiAqL1xyXG5jbGFzcyBGaXJlc3RvcmUkMSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2F1dGhDcmVkZW50aWFscywgX2FwcENoZWNrQ3JlZGVudGlhbHMsIF9kYXRhYmFzZUlkLCBfYXBwKSB7XHJcbiAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gX2F1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLl9hcHBDaGVja0NyZWRlbnRpYWxzID0gX2FwcENoZWNrQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5fZGF0YWJhc2VJZCA9IF9kYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuX2FwcCA9IF9hcHA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEgRmlyZXN0b3JlIG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUtbGl0ZSc7XHJcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAnKGxpdGUpJztcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoe30pO1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEZpcmVzdG9yZWAgc2VydmljZVxyXG4gICAgICogaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBhcHAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hcHApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgXCJGaXJlc3RvcmUgd2FzIG5vdCBpbml0aWFsaXplZCB1c2luZyB0aGUgRmlyZWJhc2UgU0RLLiAnYXBwJyBpcyBcIiArXHJcbiAgICAgICAgICAgICAgICAnbm90IGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9pbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3NGcm96ZW47XHJcbiAgICB9XHJcbiAgICBnZXQgX3Rlcm1pbmF0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9zZXRTZXR0aW5ncyhzZXR0aW5ncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5nc0Zyb3plbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgaXRzIHNldHRpbmdzIGNhbiBubyBsb25nZXIgJyArXHJcbiAgICAgICAgICAgICAgICAnYmUgY2hhbmdlZC4gWW91IGNhbiBvbmx5IG1vZGlmeSBzZXR0aW5ncyBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXHJcbiAgICAgICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IEZpcmVzdG9yZVNldHRpbmdzSW1wbChzZXR0aW5ncyk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKHNldHRpbmdzLmNyZWRlbnRpYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgX2ZyZWV6ZVNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGVybWluYXRlVGFzaykge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVUYXNrID0gdGhpcy5fdGVybWluYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBGaXJlc3RvcmVgIGluc3RhbmNlLiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFwcDogdGhpcy5fYXBwLFxyXG4gICAgICAgICAgICBkYXRhYmFzZUlkOiB0aGlzLl9kYXRhYmFzZUlkLFxyXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5fc2V0dGluZ3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXJtaW5hdGVzIGFsbCBjb21wb25lbnRzIHVzZWQgYnkgdGhpcyBjbGllbnQuIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIG1ldGhvZCB0byBjbGVhbiB1cCB0aGVpciBvd24gZGVwZW5kZW5jaWVzLCBidXQgbXVzdCBhbHNvIGNhbGwgdGhpc1xyXG4gICAgICogbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgZXZlciBjYWxsZWQgb25jZS5cclxuICAgICAqL1xyXG4gICAgX3Rlcm1pbmF0ZSgpIHtcclxuICAgICAgICByZW1vdmVDb21wb25lbnRzKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoaXMgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgRmlyZXN0b3JlIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55XHJcbiAqIG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgdG8gY29uZmlndXJlIHRvIGNvbm5lY3QgdG8gdGhlXHJcbiAqIGVtdWxhdG9yLlxyXG4gKiBAcGFyYW0gaG9zdCAtIHRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KS5cclxuICogQHBhcmFtIHBvcnQgLSB0aGUgZW11bGF0b3IgcG9ydCAoZXg6IDkwMDApLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2NrVXNlclRva2VuIC0gdGhlIG1vY2sgYXV0aCB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKiBTZWN1cml0eSBSdWxlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihmaXJlc3RvcmUsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSQxKTtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9nZXRTZXR0aW5ncygpO1xyXG4gICAgY29uc3QgbmV3SG9zdFNldHRpbmcgPSBgJHtob3N0fToke3BvcnR9YDtcclxuICAgIGlmIChzZXR0aW5ncy5ob3N0ICE9PSBERUZBVUxUX0hPU1QgJiYgc2V0dGluZ3MuaG9zdCAhPT0gbmV3SG9zdFNldHRpbmcpIHtcclxuICAgICAgICBsb2dXYXJuKCdIb3N0IGhhcyBiZWVuIHNldCBpbiBib3RoIHNldHRpbmdzKCkgYW5kIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcigpLCBlbXVsYXRvciBob3N0ICcgK1xyXG4gICAgICAgICAgICAnd2lsbCBiZSB1c2VkLicpO1xyXG4gICAgfVxyXG4gICAgZmlyZXN0b3JlLl9zZXRTZXR0aW5ncyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKSwgeyBob3N0OiBuZXdIb3N0U2V0dGluZywgc3NsOiBmYWxzZSB9KSk7XHJcbiAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgbGV0IHRva2VuO1xyXG4gICAgICAgIGxldCB1c2VyO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tb2NrVXNlclRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcclxuICAgICAgICAgICAgdXNlciA9IFVzZXIuTU9DS19VU0VSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTGV0IGNyZWF0ZU1vY2tVc2VyVG9rZW4gdmFsaWRhdGUgZmlyc3QgKGNhdGNoZXMgY29tbW9uIG1pc3Rha2VzIGxpa2VcclxuICAgICAgICAgICAgLy8gaW52YWxpZCBmaWVsZCBcInVpZFwiIGFuZCBtaXNzaW5nIGZpZWxkIFwic3ViXCIgLyBcInVzZXJfaWRcIi4pXHJcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgICAgICBjb25zdCB1aWQgPSBvcHRpb25zLm1vY2tVc2VyVG9rZW4uc3ViIHx8IG9wdGlvbnMubW9ja1VzZXJUb2tlbi51c2VyX2lkO1xyXG4gICAgICAgICAgICBpZiAoIXVpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVzZXIgPSBuZXcgVXNlcih1aWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscyA9IG5ldyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKG5ldyBPQXV0aFRva2VuKHRva2VuLCB1c2VyKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5YCByZWZlcnMgdG8gYSBxdWVyeSB3aGljaCB5b3UgY2FuIHJlYWQgb3IgbGlzdGVuIHRvLiBZb3UgY2FuIGFsc29cclxuICogY29uc3RydWN0IHJlZmluZWQgYFF1ZXJ5YCBvYmplY3RzIGJ5IGFkZGluZyBmaWx0ZXJzIGFuZCBvcmRlcmluZy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5IHtcclxuICAgIC8vIFRoaXMgaXMgdGhlIGxpdGUgdmVyc2lvbiBvZiB0aGUgUXVlcnkgY2xhc3MgaW4gdGhlIG1haW4gU0RLLlxyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgY29udmVydGVyLCBfcXVlcnkpIHtcclxuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcclxuICAgICAgICB0aGlzLl9xdWVyeSA9IF9xdWVyeTtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWVyeSc7XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XHJcbiAgICB9XHJcbiAgICB3aXRoQ29udmVydGVyKGNvbnZlcnRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5maXJlc3RvcmUsIGNvbnZlcnRlciwgdGhpcy5fcXVlcnkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBEb2N1bWVudFJlZmVyZW5jZWAgcmVmZXJzIHRvIGEgZG9jdW1lbnQgbG9jYXRpb24gaW4gYSBGaXJlc3RvcmUgZGF0YWJhc2VcclxuICogYW5kIGNhbiBiZSB1c2VkIHRvIHdyaXRlLCByZWFkLCBvciBsaXN0ZW4gdG8gdGhlIGxvY2F0aW9uLiBUaGUgZG9jdW1lbnQgYXRcclxuICogdGhlIHJlZmVyZW5jZWQgbG9jYXRpb24gbWF5IG9yIG1heSBub3QgZXhpc3QuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudFJlZmVyZW5jZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcclxuICAgIC8qKlxyXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRlciwgX2tleSkge1xyXG4gICAgICAgIHRoaXMuY29udmVydGVyID0gY29udmVydGVyO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgRmlyZXN0b3JlIHJlZmVyZW5jZS4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnZG9jdW1lbnQnO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9wYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRvY3VtZW50J3MgaWRlbnRpZmllciB3aXRoaW4gaXRzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IChyZWxhdGl2ZVxyXG4gICAgICogdG8gdGhlIHJvb3Qgb2YgdGhlIGRhdGFiYXNlKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sbGVjdGlvbiB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgYmVsb25ncyB0by5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIHRoaXMuY29udmVydGVyLCB0aGlzLl9rZXkucGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgfVxyXG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX2tleSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYENvbGxlY3Rpb25SZWZlcmVuY2VgIG9iamVjdCBjYW4gYmUgdXNlZCBmb3IgYWRkaW5nIGRvY3VtZW50cywgZ2V0dGluZ1xyXG4gKiBkb2N1bWVudCByZWZlcmVuY2VzLCBhbmQgcXVlcnlpbmcgZm9yIGRvY3VtZW50cyAodXNpbmcge0BsaW5rIChxdWVyeToxKX0pLlxyXG4gKi9cclxuY2xhc3MgQ29sbGVjdGlvblJlZmVyZW5jZSBleHRlbmRzIFF1ZXJ5IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUsIGNvbnZlcnRlciwgX3BhdGgpIHtcclxuICAgICAgICBzdXBlcihmaXJlc3RvcmUsIGNvbnZlcnRlciwgbmV3UXVlcnlGb3JQYXRoKF9wYXRoKSk7XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbGxlY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uJ3MgaWRlbnRpZmllci4gKi9cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcclxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeS5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmluZyBgRG9jdW1lbnRSZWZlcmVuY2VgIGlmIHRoaXMgaXMgYVxyXG4gICAgICogc3ViY29sbGVjdGlvbi4gSWYgdGhpcyBpc24ndCBhIHN1YmNvbGxlY3Rpb24sIHRoZSByZWZlcmVuY2UgaXMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gdGhpcy5fcGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgXHJcbiAgICAgICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KHBhcmVudFBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoQ29udmVydGVyKGNvbnZlcnRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9wYXRoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb2xsZWN0aW9uKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnY29sbGVjdGlvbicsICdwYXRoJywgcGF0aCk7XHJcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xyXG4gICAgICAgIHZhbGlkYXRlQ29sbGVjdGlvblBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcclxuICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXHJcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XHJcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZShwYXJlbnQuZmlyZXN0b3JlLCBcclxuICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyhmaXJlc3RvcmVsaXRlKTogQ29uc2lkZXIgdXNpbmcgRXJyb3JGYWN0b3J5IC1cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYFF1ZXJ5YCBpbnN0YW5jZSB0aGF0IGluY2x1ZGVzIGFsbCBkb2N1bWVudHMgaW4gdGhlXHJcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxyXG4gKiBnaXZlbiBgY29sbGVjdGlvbklkYC5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbklkIC0gSWRlbnRpZmllcyB0aGUgY29sbGVjdGlvbnMgdG8gcXVlcnkgb3Zlci4gRXZlcnlcclxuICogY29sbGVjdGlvbiBvciBzdWJjb2xsZWN0aW9uIHdpdGggdGhpcyBJRCBhcyB0aGUgbGFzdCBzZWdtZW50IG9mIGl0cyBwYXRoXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGBRdWVyeWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUkMSk7XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2NvbGxlY3Rpb25Hcm91cCcsICdjb2xsZWN0aW9uIGlkJywgY29sbGVjdGlvbklkKTtcclxuICAgIGlmIChjb2xsZWN0aW9uSWQuaW5kZXhPZignLycpID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBjb2xsZWN0aW9uIElEICcke2NvbGxlY3Rpb25JZH0nIHBhc3NlZCB0byBmdW5jdGlvbiBgICtcclxuICAgICAgICAgICAgYGNvbGxlY3Rpb25Hcm91cCgpLiBDb2xsZWN0aW9uIElEcyBtdXN0IG5vdCBjb250YWluICcvJy5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUXVlcnkoZmlyZXN0b3JlLCBcclxuICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3UXVlcnlGb3JDb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKSk7XHJcbn1cclxuZnVuY3Rpb24gZG9jKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIC8vIFdlIGFsbG93IG9taXNzaW9uIG9mICdwYXRoU3RyaW5nJyBidXQgZXhwbGljaXRseSBwcm9oaWJpdCBwYXNzaW5nIGluIGJvdGhcclxuICAgIC8vICd1bmRlZmluZWQnIGFuZCAnbnVsbCcuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHBhdGggPSBBdXRvSWQubmV3SWQoKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnZG9jJywgJ3BhdGgnLCBwYXRoKTtcclxuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUkMSkge1xyXG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgsIC4uLnBhdGhTZWdtZW50cyk7XHJcbiAgICAgICAgdmFsaWRhdGVEb2N1bWVudFBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudCwgXHJcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkoYWJzb2x1dGVQYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcclxuICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXHJcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XHJcbiAgICAgICAgdmFsaWRhdGVEb2N1bWVudFBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudC5maXJlc3RvcmUsIHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UgPyBwYXJlbnQuY29udmVydGVyIDogbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHJlZmVyZW5jZXMgYXJlIGVxdWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIHNhbWVcclxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmRXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGxlZnQgPSBnZXRNb2R1bGFySW5zdGFuY2UobGVmdCk7XHJcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XHJcbiAgICBpZiAoKGxlZnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSB8fFxyXG4gICAgICAgIGxlZnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSAmJlxyXG4gICAgICAgIChyaWdodCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcclxuICAgICAgICByZXR1cm4gKGxlZnQuZmlyZXN0b3JlID09PSByaWdodC5maXJlc3RvcmUgJiZcclxuICAgICAgICAgICAgbGVmdC5wYXRoID09PSByaWdodC5wYXRoICYmXHJcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHF1ZXJpZXMgcG9pbnQgdG8gdGhlIHNhbWUgY29sbGVjdGlvbiBhbmQgYXBwbHlcclxuICogdGhlIHNhbWUgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWZ0IC0gQSBgUXVlcnlgIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXHJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5RXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGxlZnQgPSBnZXRNb2R1bGFySW5zdGFuY2UobGVmdCk7XHJcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XHJcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFF1ZXJ5ICYmIHJpZ2h0IGluc3RhbmNlb2YgUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gKGxlZnQuZmlyZXN0b3JlID09PSByaWdodC5maXJlc3RvcmUgJiZcclxuICAgICAgICAgICAgcXVlcnlFcXVhbHMobGVmdC5fcXVlcnksIHJpZ2h0Ll9xdWVyeSkgJiZcclxuICAgICAgICAgICAgbGVmdC5jb252ZXJ0ZXIgPT09IHJpZ2h0LmNvbnZlcnRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyA9ICdBc3luY1F1ZXVlJztcclxuY2xhc3MgQXN5bmNRdWV1ZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gVGhlIGxhc3QgcHJvbWlzZSBpbiB0aGUgcXVldWUuXHJcbiAgICAgICAgdGhpcy50YWlsID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgLy8gQSBsaXN0IG9mIHJldHJ5YWJsZSBvcGVyYXRpb25zLiBSZXRyeWFibGUgb3BlcmF0aW9ucyBhcmUgcnVuIGluIG9yZGVyIGFuZFxyXG4gICAgICAgIC8vIHJldHJpZWQgd2l0aCBiYWNrb2ZmLlxyXG4gICAgICAgIHRoaXMucmV0cnlhYmxlT3BzID0gW107XHJcbiAgICAgICAgLy8gSXMgdGhpcyBBc3luY1F1ZXVlIGJlaW5nIHNodXQgZG93bj8gT25jZSBpdCBpcyBzZXQgdG8gdHJ1ZSwgaXQgd2lsbCBub3RcclxuICAgICAgICAvLyBiZSBjaGFuZ2VkIGFnYWluLlxyXG4gICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gZmFsc2U7XHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBzY2hlZHVsZWQgdG8gYmUgcXVldWVkIGluIHRoZSBmdXR1cmUuIE9wZXJhdGlvbnMgYXJlXHJcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgYXJlIHJ1biBvciBjYW5jZWxlZC5cclxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zID0gW107XHJcbiAgICAgICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XHJcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hpbGUgdGhlcmUncyBhbiBvdXRzdGFuZGluZyBBc3luY1F1ZXVlIG9wZXJhdGlvbiwgdXNlZCBmb3JcclxuICAgICAgICAvLyBhc3NlcnRpb24gc2FuaXR5LWNoZWNrcy5cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAvLyBFbmFibGVkIGR1cmluZyBzaHV0ZG93biBvbiBTYWZhcmkgdG8gcHJldmVudCBmdXR1cmUgYWNjZXNzIHRvIEluZGV4ZWREQi5cclxuICAgICAgICB0aGlzLnNraXBOb25SZXN0cmljdGVkVGFza3MgPSBmYWxzZTtcclxuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxyXG4gICAgICAgIHRoaXMudGltZXJJZHNUb1NraXAgPSBbXTtcclxuICAgICAgICAvLyBCYWNrb2ZmIHRpbWVyIHVzZWQgdG8gc2NoZWR1bGUgcmV0cmllcyBmb3IgcmV0cnlhYmxlIG9wZXJhdGlvbnNcclxuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMsIFwiYXN5bmNfcXVldWVfcmV0cnlcIiAvKiBUaW1lcklkLkFzeW5jUXVldWVSZXRyeSAqLyk7XHJcbiAgICAgICAgLy8gVmlzaWJpbGl0eSBoYW5kbGVyIHRoYXQgdHJpZ2dlcnMgYW4gaW1tZWRpYXRlIHJldHJ5IG9mIGFsbCByZXRyeWFibGVcclxuICAgICAgICAvLyBvcGVyYXRpb25zLiBNZWFudCB0byBzcGVlZCB1cCByZWNvdmVyeSB3aGVuIHdlIHJlZ2FpbiBmaWxlIHN5c3RlbSBhY2Nlc3NcclxuICAgICAgICAvLyBhZnRlciBwYWdlIGNvbWVzIGludG8gZm9yZWdyb3VuZC5cclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuc2tpcEJhY2tvZmYoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzU2h1dHRpbmdEb3duKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NodXR0aW5nRG93bjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cclxuICAgICAqIHdlIGlnbm9yZSB0aGUgUHJvbWlzZSByZXN1bHQpLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlQW5kRm9yZ2V0KG9wKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZShvcCk7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChvcCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZUludGVybmFsKG9wKTtcclxuICAgIH1cclxuICAgIGVudGVyUmVzdHJpY3RlZE1vZGUocHVyZ2VFeGlzdGluZ1Rhc2tzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NodXR0aW5nRG93bikge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IHB1cmdlRXhpc3RpbmdUYXNrcyB8fCBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlKG9wKSB7XHJcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIFByb21pc2UgdGhhdCB3ZSBjYW4gcmV0dXJuIHRvIHRoZSBjYWxsZWUuIFRoaXNcclxuICAgICAgICAvLyBhbGxvd3MgdXMgdG8gcmV0dXJuIGEgXCJoYW5naW5nIFByb21pc2VcIiBvbmx5IHRvIHRoZSBjYWxsZWUgYW5kIHN0aWxsXHJcbiAgICAgICAgLy8gYWR2YW5jZSB0aGUgcXVldWUgZXZlbiB3aGVuIHRoZSBvcGVyYXRpb24gaXMgbm90IHJ1bi5cclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZUludGVybmFsKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2h1dHRpbmdEb3duICYmIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHJlc29sdmUgJ3Rhc2snXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AoKS50aGVuKHRhc2sucmVzb2x2ZSwgdGFzay5yZWplY3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFzay5wcm9taXNlO1xyXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gdGFzay5wcm9taXNlKTtcclxuICAgIH1cclxuICAgIGVucXVldWVSZXRyeWFibGUob3ApIHtcclxuICAgICAgICB0aGlzLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5wdXNoKG9wKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlOZXh0T3AoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB0aGUgbmV4dCBvcGVyYXRpb24gZnJvbSB0aGUgcmV0cnlhYmxlIHF1ZXVlLiBJZiB0aGUgb3BlcmF0aW9uIGZhaWxzLFxyXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZXRyeU5leHRPcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXRyeWFibGVPcHNbMF0oKTtcclxuICAgICAgICAgICAgdGhpcy5yZXRyeWFibGVPcHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUcsICdPcGVyYXRpb24gZmFpbGVkIHdpdGggcmV0cnlhYmxlIGVycm9yOiAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlOyAvLyBGYWlsdXJlIHdpbGwgYmUgaGFuZGxlZCBieSBBc3luY1F1ZXVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmV0cnlhYmxlT3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgb3BlcmF0aW9ucywgd2UgcmUtc2NoZWR1bGUgYHJldHJ5TmV4dE9wKClgLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXHJcbiAgICAgICAgICAgIC8vIHRoZWlyIGluaXRpYWwgYXR0ZW1wdCBzaW5jZSB3ZSBkb24ndCBrbm93IHdoZXRoZXIgdGhleSBhcmUgYWxyZWFkeVxyXG4gICAgICAgICAgICAvLyBlbnF1ZXVlZC4gSWYsIGZvciBleGFtcGxlLCBgb3AxYCwgYG9wMmAsIGBvcDNgIGFyZSBlbnF1ZXVlZCBhbmQgYG9wMWBcclxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBlbnF1ZXVlZCBjYWxscyB0byBgcmV0cnlOZXh0T3AoKWAuIGBvcDMoKWAgd2lsbCB0aGVuIHJ1biBpbiB0aGVcclxuICAgICAgICAgICAgLy8gY2FsbCBzY2hlZHVsZWQgaGVyZS5cclxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxyXG4gICAgICAgICAgICAvLyBuZXcgYmFja29mZiBvbiBldmVyeSBjYWxsLCB0aGVyZSBpcyBvbmx5IGV2ZXIgYSBzaW5nbGUgYWRkaXRpb25hbFxyXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gaW4gdGhlIHF1ZXVlLlxyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bigoKSA9PiB0aGlzLnJldHJ5TmV4dE9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVucXVldWVJbnRlcm5hbChvcCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1RhaWwgPSB0aGlzLnRhaWwudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBvcCgpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWx1cmUgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdJTlRFUk5BTCBVTkhBTkRMRUQgRVJST1I6ICcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhpcy50YWlsIGJlY29tZXMgYSByZWplY3RlZCBQcm9taXNlIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYWxsIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gY2hhaW4gKHZpYSAudGhlbikgd2lsbCBqdXN0IHNob3J0LWNpcmN1aXRcclxuICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdGhlIHJlamVjdGVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG5ld1RhaWw7XHJcbiAgICAgICAgcmV0dXJuIG5ld1RhaWw7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlQWZ0ZXJEZWxheSh0aW1lcklkLCBkZWxheU1zLCBvcCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XHJcbiAgICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IgdGltZXJJZHMgdGhhdCBoYXZlIGJlZW4gb3ZlcnJpZGVuLlxyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySWRzVG9Ta2lwLmluZGV4T2YodGltZXJJZCkgPiAtMSkge1xyXG4gICAgICAgICAgICBkZWxheU1zID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVsYXllZE9wID0gRGVsYXllZE9wZXJhdGlvbi5jcmVhdGVBbmRTY2hlZHVsZSh0aGlzLCB0aW1lcklkLCBkZWxheU1zLCBvcCwgcmVtb3ZlZE9wID0+IHRoaXMucmVtb3ZlRGVsYXllZE9wZXJhdGlvbihyZW1vdmVkT3ApKTtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnB1c2goZGVsYXllZE9wKTtcclxuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xyXG4gICAgfVxyXG4gICAgdmVyaWZ5Tm90RmFpbGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZhaWx1cmUpIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdhaXRzIHVudGlsIGFsbCBjdXJyZW50bHkgcXVldWVkIHRhc2tzIGFyZSBmaW5pc2hlZCBleGVjdXRpbmcuIERlbGF5ZWRcclxuICAgICAqIG9wZXJhdGlvbnMgYXJlIG5vdCBydW4uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGRyYWluKCkge1xyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcclxuICAgICAgICAvLyBvcGVyYXRpb25zLiBLZWVwIGRyYWluaW5nIHRoZSBxdWV1ZSB1bnRpbCB0aGUgdGFpbCBpcyBubyBsb25nZXIgYWR2YW5jZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggaW5kaWNhdGVzIHRoYXQgbm8gbW9yZSBuZXcgb3BlcmF0aW9ucyB3ZXJlIGVucXVldWVkIGFuZCB0aGF0IGFsbFxyXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cclxuICAgICAgICBsZXQgY3VycmVudFRhaWw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjdXJyZW50VGFpbCA9IHRoaXMudGFpbDtcclxuICAgICAgICAgICAgYXdhaXQgY3VycmVudFRhaWw7XHJcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudFRhaWwgIT09IHRoaXMudGFpbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciBUZXN0czogRGV0ZXJtaW5lIGlmIGEgZGVsYXllZCBvcGVyYXRpb24gd2l0aCBhIHBhcnRpY3VsYXIgVGltZXJJZFxyXG4gICAgICogZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBjb250YWluc0RlbGF5ZWRPcGVyYXRpb24odGltZXJJZCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3AudGltZXJJZCA9PT0gdGltZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IFJ1bnMgc29tZSBvciBhbGwgZGVsYXllZCBvcGVyYXRpb25zIGVhcmx5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXN0VGltZXJJZCAtIERlbGF5ZWQgb3BlcmF0aW9ucyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoaXMgVGltZXJJZFxyXG4gICAgICogd2lsbCBiZSBkcmFpbmVkLiBQYXNzIFRpbWVySWQuQWxsIHRvIHJ1biBhbGwgZGVsYXllZCBvcGVyYXRpb25zLlxyXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgb3BlcmF0aW9ucyBoYXZlIGJlZW4gcnVuLlxyXG4gICAgICovXHJcbiAgICBydW5BbGxEZWxheWVkT3BlcmF0aW9uc1VudGlsKGxhc3RUaW1lcklkKSB7XHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWluKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJ1biBvcHMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSdkIHJ1biBpZiB0aGV5IHJhbiBuYXR1cmFsbHkuXHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS50YXJnZXRUaW1lTXMgLSBiLnRhcmdldFRpbWVNcyk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgb3Auc2tpcERlbGF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWVySWQgIT09IFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IFNraXAgYWxsIHN1YnNlcXVlbnQgZGVsYXlzIGZvciBhIHRpbWVyIGlkLlxyXG4gICAgICovXHJcbiAgICBza2lwRGVsYXlzRm9yVGltZXJJZCh0aW1lcklkKSB7XHJcbiAgICAgICAgdGhpcy50aW1lcklkc1RvU2tpcC5wdXNoKHRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbGxlZCBvbmNlIGEgRGVsYXllZE9wZXJhdGlvbiBpcyBydW4gb3IgY2FuY2VsZWQuICovXHJcbiAgICByZW1vdmVEZWxheWVkT3BlcmF0aW9uKG9wKSB7XHJcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLmluZGV4T2Yob3ApO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdBc3luY1F1ZXVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBc3luY1F1ZXVlSW1wbCgpO1xyXG59XHJcbi8qKlxyXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxyXG4gKiBUaGlzIHJldHVybnMgZXhwZWN0ZWQgb3V0cHV0IG9mIG1lc3NhZ2UgKyBzdGFjayB3aGVuIGF2YWlsYWJsZS5cclxuICogQHBhcmFtIGVycm9yIC0gRXJyb3Igb3IgRmlyZXN0b3JlRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJyc7XHJcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcclxuICAgICAgICBpZiAoZXJyb3Iuc3RhY2suaW5jbHVkZXMoZXJyb3IubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgKyAnXFxuJyArIGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB0YXNrIG9mIGxvYWRpbmcgYSBGaXJlc3RvcmUgYnVuZGxlLiBJdCBwcm92aWRlcyBwcm9ncmVzcyBvZiBidW5kbGVcclxuICogbG9hZGluZywgYXMgd2VsbCBhcyB0YXNrIGNvbXBsZXRpb24gYW5kIGVycm9yIGV2ZW50cy5cclxuICpcclxuICogVGhlIEFQSSBpcyBjb21wYXRpYmxlIHdpdGggYFByb21pc2U8TG9hZEJ1bmRsZVRhc2tQcm9ncmVzcz5gLlxyXG4gKi9cclxuY2xhc3MgTG9hZEJ1bmRsZVRhc2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxyXG4gICAgICAgICAgICB0b3RhbEJ5dGVzOiAwLFxyXG4gICAgICAgICAgICB0b3RhbERvY3VtZW50czogMCxcclxuICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgIGRvY3VtZW50c0xvYWRlZDogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBmdW5jdGlvbnMgdG8gbGlzdGVuIHRvIGJ1bmRsZSBsb2FkaW5nIHByb2dyZXNzIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBuZXh0IC0gQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBwcm9ncmVzcyB1cGRhdGUgZnJvbSBidW5kbGUgbG9hZGluZy4gVHlwaWNhbGx5IGBuZXh0YCBjYWxscyBvY2N1clxyXG4gICAgICogICBlYWNoIHRpbWUgYSBGaXJlc3RvcmUgZG9jdW1lbnQgaXMgbG9hZGVkIGZyb20gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBlcnJvciAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuIFRoZSB0YXNrIGFib3J0cyBhZnRlciByZXBvcnRpbmcgdGhlXHJcbiAgICAgKiAgIGVycm9yLCBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgdXBkYXRlcyBhZnRlciB0aGlzLlxyXG4gICAgICogQHBhcmFtIGNvbXBsZXRlIC0gQ2FsbGVkIHdoZW4gdGhlIGxvYWRpbmcgdGFzayBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgb25Qcm9ncmVzcyhuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyID0ge1xyXG4gICAgICAgICAgICBuZXh0LFxyXG4gICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi5jYXRjaGAgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy5cclxuICAgICAqL1xyXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnByb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudHMgdGhlIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+LnRoZW5gIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBDYWxsZWQgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxvYWRpbmcgdGFzayB3aXRoIGEgZmluYWwgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHVwZGF0ZS5cclxuICAgICAqICAgVGhlIHVwZGF0ZSB3aWxsIGFsd2F5cyBoYXZlIGl0cyBgdGFza1N0YXRlYCBzZXQgdG8gYFwiU3VjY2Vzc1wiYC5cclxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy5cclxuICAgICAqL1xyXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnByb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgY29tcGxldGVkLCB3aXRoIGEgcHJvdmlkZWRcclxuICAgICAqIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2NvbXBsZXRlV2l0aChwcm9ncmVzcykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKTtcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVzb2x2ZShwcm9ncmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgZmFpbGVkLCB3aXRoIGEgcHJvdmlkZWRcclxuICAgICAqIGBFcnJvcmAgYXMgdGhlIHJlYXNvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZmFpbFdpdGgoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MudGFza1N0YXRlID0gJ0Vycm9yJztcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCh0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyBhIHByb2dyZXNzIHVwZGF0ZSBvZiBsb2FkaW5nIGEgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIHByb2dyZXNzIC0gVGhlIG5ldyBwcm9ncmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dChwcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb25zdGFudCB1c2VkIHRvIGluZGljYXRlIHRoZSBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZC5cclxuICogU2V0IHRoaXMgdmFsdWUgYXMgdGhlIGBjYWNoZVNpemVCeXRlc2Agb24gdGhlIHNldHRpbmdzIHBhc3NlZCB0byB0aGVcclxuICoge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBDQUNIRV9TSVpFX1VOTElNSVRFRCA9IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEO1xyXG4vKipcclxuICogVGhlIENsb3VkIEZpcmVzdG9yZSBzZXJ2aWNlIGludGVyZmFjZS5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgdXNlIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZSBleHRlbmRzIEZpcmVzdG9yZSQxIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApIHtcclxuICAgICAgICBzdXBlcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIHtAbGluayBGaXJlc3RvcmV9IG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUnO1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3QXN5bmNRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlS2V5ID0gKGFwcCA9PT0gbnVsbCB8fCBhcHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcC5uYW1lKSB8fCAnW0RFRkFVTFRdJztcclxuICAgIH1cclxuICAgIF90ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9maXJlc3RvcmVDbGllbnQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGNsaWVudCBtdXN0IGJlIGluaXRpYWxpemVkIHRvIGVuc3VyZSB0aGF0IGFsbCBzdWJzZXF1ZW50IEFQSVxyXG4gICAgICAgICAgICAvLyB1c2FnZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxyXG4gICAgICAgICAgICBjb25maWd1cmVGaXJlc3RvcmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9maXJlc3RvcmVDbGllbnQudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBGaXJlc3RvcmV9IHdpdGggdGhlIHByb3ZpZGVkIHNldHRpbmdzLlxyXG4gKiBDYW4gb25seSBiZSBjYWxsZWQgYmVmb3JlIGFueSBvdGhlciBmdW5jdGlvbiwgaW5jbHVkaW5nXHJcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcclxuICogZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gd2l0aCB3aGljaCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbFxyXG4gKiBiZSBhc3NvY2lhdGVkLlxyXG4gKiBAcGFyYW0gc2V0dGluZ3MgLSBBIHNldHRpbmdzIG9iamVjdCB0byBjb25maWd1cmUgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZS5cclxuICogQHJldHVybnMgQSBuZXdseSBpbml0aWFsaXplZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVGaXJlc3RvcmUoYXBwLCBzZXR0aW5ncywgZGF0YWJhc2VJZCkge1xyXG4gICAgaWYgKCFkYXRhYmFzZUlkKSB7XHJcbiAgICAgICAgZGF0YWJhc2VJZCA9IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2ZpcmVzdG9yZScpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoZGF0YWJhc2VJZCkpIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICAgICAgaWRlbnRpZmllcjogZGF0YWJhc2VJZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoZGF0YWJhc2VJZCk7XHJcbiAgICAgICAgaWYgKGRlZXBFcXVhbChpbml0aWFsU2V0dGluZ3MsIHNldHRpbmdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdpbml0aWFsaXplRmlyZXN0b3JlKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICAnc2FtZSBvcHRpb25zIGFzIHdoZW4gaXQgd2FzIG9yaWdpbmFsbHkgY2FsbGVkLCBvciBjYWxsIGdldEZpcmVzdG9yZSgpIHRvIHJldHVybiB0aGUnICtcclxuICAgICAgICAgICAgICAgICcgYWxyZWFkeSBpbml0aWFsaXplZCBpbnN0YW5jZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIHNldHRpbmdzLmxvY2FsQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZSBhbmQgY2FjaGVTaXplQnl0ZXMgY2Fubm90IGJlIHNwZWNpZmllZCBhdCB0aGUgc2FtZSB0aW1lIGFzIGNhY2hlU2l6ZUJ5dGVzIHdpbGxgICtcclxuICAgICAgICAgICAgYGJlIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHNwZWNpZnkgdGhlIGNhY2hlIHNpemUgaW4gdGhlIGNhY2hlIG9iamVjdGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gQ0FDSEVfU0laRV9VTkxJTUlURUQgJiZcclxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGVTaXplQnl0ZXMgbXVzdCBiZSBhdCBsZWFzdCAke0xSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVN9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7XHJcbiAgICAgICAgb3B0aW9uczogc2V0dGluZ3MsXHJcbiAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBkYXRhYmFzZUlkXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRGaXJlc3RvcmUoYXBwT3JEYXRhYmFzZUlkLCBvcHRpb25hbERhdGFiYXNlSWQpIHtcclxuICAgIGNvbnN0IGFwcCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdvYmplY3QnID8gYXBwT3JEYXRhYmFzZUlkIDogZ2V0QXBwKCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZUlkID0gdHlwZW9mIGFwcE9yRGF0YWJhc2VJZCA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IGFwcE9yRGF0YWJhc2VJZFxyXG4gICAgICAgIDogb3B0aW9uYWxEYXRhYmFzZUlkIHx8IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcclxuICAgIGNvbnN0IGRiID0gX2dldFByb3ZpZGVyKGFwcCwgJ2ZpcmVzdG9yZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogZGF0YWJhc2VJZFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRiLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdmaXJlc3RvcmUnKTtcclxuICAgICAgICBpZiAoZW11bGF0b3IpIHtcclxuICAgICAgICAgICAgY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKGRiLCAuLi5lbXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKSB7XHJcbiAgICBpZiAoIWZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50KSB7XHJcbiAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XHJcbiAgICB9XHJcbiAgICBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudC52ZXJpZnlOb3RUZXJtaW5hdGVkKCk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQ7XHJcbn1cclxuZnVuY3Rpb24gY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IGRhdGFiYXNlSW5mbyA9IG1ha2VEYXRhYmFzZUluZm8oZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCAoKF9hID0gZmlyZXN0b3JlLl9hcHApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zLmFwcElkKSB8fCAnJywgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSwgc2V0dGluZ3MpO1xyXG4gICAgZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQgPSBuZXcgRmlyZXN0b3JlQ2xpZW50KGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX2FwcENoZWNrQ3JlZGVudGlhbHMsIGZpcmVzdG9yZS5fcXVldWUsIGRhdGFiYXNlSW5mbyk7XHJcbiAgICBpZiAoKChfYiA9IHNldHRpbmdzLmxvY2FsQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSAmJlxyXG4gICAgICAgICgoX2MgPSBzZXR0aW5ncy5sb2NhbENhY2hlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyKSkge1xyXG4gICAgICAgIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICBfb2ZmbGluZUtpbmQ6IHNldHRpbmdzLmxvY2FsQ2FjaGUua2luZCxcclxuICAgICAgICAgICAgX29mZmxpbmU6IHNldHRpbmdzLmxvY2FsQ2FjaGUuX29mZmxpbmVDb21wb25lbnRQcm92aWRlcixcclxuICAgICAgICAgICAgX29ubGluZTogc2V0dGluZ3MubG9jYWxDYWNoZS5fb25saW5lQ29tcG9uZW50UHJvdmlkZXJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgcGVyc2lzdGVudCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cclxuICpcclxuICogT24gZmFpbHVyZSwgYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXHJcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHkgdGhpcyBjYW4gZmFpbCwgd2hpY2ggY2FuIGJlXHJcbiAqIGlkZW50aWZpZWQgYnkgdGhlIGBjb2RlYCBvbiB0aGUgZXJyb3IuXHJcbiAqXHJcbiAqICAgKiBmYWlsZWQtcHJlY29uZGl0aW9uOiBUaGUgYXBwIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGJyb3dzZXIgdGFiLlxyXG4gKiAgICogdW5pbXBsZW1lbnRlZDogVGhlIGJyb3dzZXIgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIG9mZmxpbmUgcGVyc2lzdGVuY2VcclxuICogICAgIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgZXZlbiBhZnRlciBhIGZhaWx1cmUsIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB3aWxsIHJlbWFpblxyXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gKlxyXG4gKiBOb3RlOiBgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGFueSBvdGhlciBmdW5jdGlvbnNcclxuICogKG90aGVyIHRoYW4ge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0gb3JcclxuICoge0BsaW5rIGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2V9LlxyXG4gKlxyXG4gKiBQZXJzaXN0ZW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXHJcbiAqIHBlcnNpc3RlbmNlLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlcHJlc2VudHMgc3VjY2Vzc2Z1bGx5IGVuYWJsaW5nIHBlcnNpc3RlbnQgc3RvcmFnZS5cclxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XHJcbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYCB0byBhbiBpbnN0YW5jZSBvZiBgUGVyc2lzdGVudExvY2FsQ2FjaGVgIHRvXHJcbiAqIHR1cm4gb24gSW5kZXhlZERiIGNhY2hlLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2hlbiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWBcclxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUsIHBlcnNpc3RlbmNlU2V0dGluZ3MpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgdmVyaWZ5Tm90SW5pdGlhbGl6ZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGlmIChjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnU0RLIGNhY2hlIGlzIGFscmVhZHkgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG4gICAgbG9nV2FybignZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UoKSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZSwgJyArXHJcbiAgICAgICAgJ3lvdSBjYW4gdXNlIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgaW5zdGVhZC4nKTtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xyXG4gICAgY29uc3Qgb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKTtcclxuICAgIGNvbnN0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBJbmRleGVkRGJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCBwZXJzaXN0ZW5jZVNldHRpbmdzID09PSBudWxsIHx8IHBlcnNpc3RlbmNlU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcnNpc3RlbmNlU2V0dGluZ3MuZm9yY2VPd25lcnNoaXApO1xyXG4gICAgcmV0dXJuIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcik7XHJcbn1cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGVuYWJsZSBtdWx0aS10YWIgcGVyc2lzdGVudCBzdG9yYWdlLCBpZiBwb3NzaWJsZS4gSWYgZW5hYmxlZFxyXG4gKiBhY3Jvc3MgYWxsIHRhYnMsIGFsbCBvcGVyYXRpb25zIHNoYXJlIGFjY2VzcyB0byBsb2NhbCBwZXJzaXN0ZW5jZSwgaW5jbHVkaW5nXHJcbiAqIHNoYXJlZCBleGVjdXRpb24gb2YgcXVlcmllcyBhbmQgbGF0ZW5jeS1jb21wZW5zYXRlZCBsb2NhbCBkb2N1bWVudCB1cGRhdGVzXHJcbiAqIGFjcm9zcyBhbGwgY29ubmVjdGVkIGluc3RhbmNlcy5cclxuICpcclxuICogT24gZmFpbHVyZSwgYGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgd2lsbCByZWplY3QgdGhlIHByb21pc2Ugb3JcclxuICogdGhyb3cgYW4gZXhjZXB0aW9uLiBUaGVyZSBhcmUgc2V2ZXJhbCByZWFzb25zIHdoeSB0aGlzIGNhbiBmYWlsLCB3aGljaCBjYW4gYmVcclxuICogaWRlbnRpZmllZCBieSB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cclxuICpcclxuICogICAqIGZhaWxlZC1wcmVjb25kaXRpb246IFRoZSBhcHAgaXMgYWxyZWFkeSBvcGVuIGluIGFub3RoZXIgYnJvd3NlciB0YWIgYW5kXHJcbiAqICAgICBtdWx0aS10YWIgaXMgbm90IGVuYWJsZWQuXHJcbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxyXG4gKiAgICAgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXHJcbiAqIHVzYWJsZSwgaG93ZXZlciBvZmZsaW5lIHBlcnNpc3RlbmNlIHdpbGwgYmUgZGlzYWJsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXByZXNlbnRzIHN1Y2Nlc3NmdWxseSBlbmFibGluZyBwZXJzaXN0ZW50XHJcbiAqIHN0b3JhZ2UuXHJcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIEluc3RlYWQsIHNldFxyXG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xyXG4gKiB0dXJuIG9uIGluZGV4ZWRkYiBjYWNoZS4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdoZW4gYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgXHJcbiAqIGlzIGFscmVhZHkgc3BlY2lmaWVkIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgdmVyaWZ5Tm90SW5pdGlhbGl6ZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGlmIChjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnU0RLIGNhY2hlIGlzIGFscmVhZHkgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG4gICAgbG9nV2FybignZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLCAnICtcclxuICAgICAgICAneW91IGNhbiB1c2UgYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCBpbnN0ZWFkLicpO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBvbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyk7XHJcbiAgICByZXR1cm4gc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlciwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKTtcclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGJvdGggdGhlIGBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJgIGFuZCBgT25saW5lQ29tcG9uZW50UHJvdmlkZXJgLlxyXG4gKiBJZiB0aGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYSByZWNvdmVyYWJsZSBlcnJvciAoc2VlXHJcbiAqIGBjYW5SZWNvdmVyRnJvbUluZGV4ZWREYkVycm9yKClgIGJlbG93KSwgdGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVqZWN0ZWRcclxuICogYnV0IHRoZSBjbGllbnQgcmVtYWlucyB1c2FibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW5jZVByb3ZpZGVycyhjbGllbnQsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcclxuICAgIGNvbnN0IHBlcnNpc3RlbmNlUmVzdWx0ID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWVcclxuICAgICAgICAuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlcik7XHJcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlUmVzdWx0LnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICBpZiAoIWNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nV2FybignRXJyb3IgZW5hYmxpbmcgaW5kZXhlZGRiIGNhY2hlLiBGYWxsaW5nIGJhY2sgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAnbWVtb3J5IGNhY2hlOiAnICtcclxuICAgICAgICAgICAgICAgIGVycm9yKTtcclxuICAgICAgICAgICAgcGVyc2lzdGVuY2VSZXN1bHQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKCgpID0+IHBlcnNpc3RlbmNlUmVzdWx0LnByb21pc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIHBlcnNpc3RlbnQgc3RvcmFnZS4gVGhpcyBpbmNsdWRlcyBwZW5kaW5nIHdyaXRlcyBhbmQgY2FjaGVkXHJcbiAqIGRvY3VtZW50cy5cclxuICpcclxuICogTXVzdCBiZSBjYWxsZWQgd2hpbGUgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIGlzIG5vdCBzdGFydGVkIChhZnRlciB0aGUgYXBwIGlzXHJcbiAqIHRlcm1pbmF0ZWQgb3Igd2hlbiB0aGUgYXBwIGlzIGZpcnN0IGluaXRpYWxpemVkKS4gT24gc3RhcnR1cCwgdGhpcyBmdW5jdGlvblxyXG4gKiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgZnVuY3Rpb25zIChvdGhlciB0aGFuIHtAbGlua1xyXG4gKiBpbml0aWFsaXplRmlyZXN0b3JlfSBvciB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0pKS4gSWYgdGhlIHtAbGluayBGaXJlc3RvcmV9XHJcbiAqIGluc3RhbmNlIGlzIHN0aWxsIHJ1bm5pbmcsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IgY29kZVxyXG4gKiBvZiBgZmFpbGVkLXByZWNvbmRpdGlvbmAuXHJcbiAqXHJcbiAqIE5vdGU6IGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIGlzIHByaW1hcmlseSBpbnRlbmRlZCB0byBoZWxwIHdyaXRlXHJcbiAqIHJlbGlhYmxlIHRlc3RzIHRoYXQgdXNlIENsb3VkIEZpcmVzdG9yZS4gSXQgdXNlcyBhbiBlZmZpY2llbnQgbWVjaGFuaXNtIGZvclxyXG4gKiBkcm9wcGluZyBleGlzdGluZyBkYXRhIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHNlY3VyZWx5IG92ZXJ3cml0ZSBvclxyXG4gKiBvdGhlcndpc2UgbWFrZSBjYWNoZWQgZGF0YSB1bnJlY292ZXJhYmxlLiBGb3IgYXBwbGljYXRpb25zIHRoYXQgYXJlIHNlbnNpdGl2ZVxyXG4gKiB0byB0aGUgZGlzY2xvc3VyZSBvZiBjYWNoZWQgZGF0YSBpbiBiZXR3ZWVuIHVzZXIgc2Vzc2lvbnMsIHdlIHN0cm9uZ2x5XHJcbiAqIHJlY29tbWVuZCBub3QgZW5hYmxpbmcgcGVyc2lzdGVuY2UgYXQgYWxsLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGNsZWFyIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UgaXNcclxuICogY2xlYXJlZC4gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcclxuICAgIGlmIChmaXJlc3RvcmUuX2luaXRpYWxpemVkICYmICFmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnUGVyc2lzdGVuY2UgY2FuIG9ubHkgYmUgY2xlYXJlZCBiZWZvcmUgYSBGaXJlc3RvcmUgaW5zdGFuY2UgaXMgJyArXHJcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBvciBhZnRlciBpdCBpcyB0ZXJtaW5hdGVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGZpcmVzdG9yZS5fcXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGluZGV4ZWREYkNsZWFyUGVyc2lzdGVuY2UoaW5kZXhlZERiU3RvcmFnZVByZWZpeChmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXkpKTtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBmb3IgdGhlIGFjdGl2ZSB1c2VyIGhhdmUgYmVlblxyXG4gKiBhY2tub3dsZWRnZWQgYnkgdGhlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyB3cml0ZXMuXHJcbiAqIE90aGVyd2lzZSwgdGhlIHByb21pc2Ugd2FpdHMgZm9yIGFsbCBwcmV2aW91c2x5IGlzc3VlZCB3cml0ZXMgKGluY2x1ZGluZ1xyXG4gKiB0aG9zZSB3cml0dGVuIGluIGEgcHJldmlvdXMgYXBwIHNlc3Npb24pLCBidXQgaXQgZG9lcyBub3Qgd2FpdCBmb3Igd3JpdGVzXHJcbiAqIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvclxyXG4gKiBhZGRpdGlvbmFsIHdyaXRlcywgY2FsbCBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgYWdhaW4uXHJcbiAqXHJcbiAqIEFueSBvdXRzdGFuZGluZyBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgcHJvbWlzZXMgYXJlIHJlamVjdGVkIGR1cmluZyB1c2VyXHJcbiAqIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHdoZW4gYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBoYXZlIGJlZW5cclxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gd2FpdEZvclBlbmRpbmdXcml0ZXMoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZS1lbmFibGVzIHVzZSBvZiB0aGUgbmV0d29yayBmb3IgdGhpcyB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBhZnRlciBhIHByaW9yXHJcbiAqIGNhbGwgdG8ge0BsaW5rIGRpc2FibGVOZXR3b3JrfS5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGVuYWJsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmFibGVOZXR3b3JrKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNhYmxlcyBuZXR3b3JrIHVzYWdlIGZvciB0aGlzIGluc3RhbmNlLiBJdCBjYW4gYmUgcmUtZW5hYmxlZCB2aWEge0BsaW5rXHJcbiAqIGVuYWJsZU5ldHdvcmt9LiBXaGlsZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCwgYW55IHNuYXBzaG90IGxpc3RlbmVycyxcclxuICogYGdldERvYygpYCBvciBgZ2V0RG9jcygpYCBjYWxscyB3aWxsIHJldHVybiByZXN1bHRzIGZyb20gY2FjaGUsIGFuZCBhbnkgd3JpdGVcclxuICogb3BlcmF0aW9ucyB3aWxsIGJlIHF1ZXVlZCB1bnRpbCB0aGUgbmV0d29yayBpcyByZXN0b3JlZC5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGRpc2FibGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBUZXJtaW5hdGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cclxuICpcclxuICogQWZ0ZXIgY2FsbGluZyBgdGVybWluYXRlKClgIG9ubHkgdGhlIGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIGZ1bmN0aW9uXHJcbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuXHJcbiAqXHJcbiAqIFRvIHJlc3RhcnQgYWZ0ZXIgdGVybWluYXRpb24sIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBGaXJlYmFzZUZpcmVzdG9yZSB3aXRoXHJcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cclxuICpcclxuICogVGVybWluYXRpb24gZG9lcyBub3QgY2FuY2VsIGFueSBwZW5kaW5nIHdyaXRlcywgYW5kIGFueSBwcm9taXNlcyB0aGF0IGFyZVxyXG4gKiBhd2FpdGluZyBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3aWxsIG5vdCBiZSByZXNvbHZlZC4gSWYgeW91IGhhdmVcclxuICogcGVyc2lzdGVuY2UgZW5hYmxlZCwgdGhlIG5leHQgdGltZSB5b3Ugc3RhcnQgdGhpcyBpbnN0YW5jZSwgaXQgd2lsbCByZXN1bWVcclxuICogc2VuZGluZyB0aGVzZSB3cml0ZXMgdG8gdGhlIHNlcnZlci5cclxuICpcclxuICogTm90ZTogVW5kZXIgbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBpcyBub3QgcmVxdWlyZWQuIFRoaXNcclxuICogZnVuY3Rpb24gaXMgdXNlZnVsIG9ubHkgd2hlbiB5b3Ugd2FudCB0byBmb3JjZSB0aGlzIGluc3RhbmNlIHRvIHJlbGVhc2UgYWxsXHJcbiAqIG9mIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB0b1xyXG4gKiBlbnN1cmUgdGhhdCBhbGwgbG9jYWwgc3RhdGUgaXMgZGVzdHJveWVkIGJldHdlZW4gdGVzdCBydW5zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluc3RhbmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxyXG4gKiB0ZXJtaW5hdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdGVybWluYXRlKGZpcmVzdG9yZSkge1xyXG4gICAgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShmaXJlc3RvcmUuYXBwLCAnZmlyZXN0b3JlJywgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLmRhdGFiYXNlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmUuX2RlbGV0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkcyBhIEZpcmVzdG9yZSBidW5kbGUgaW50byB0aGUgbG9jYWwgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gbG9hZCBidW5kbGVzIGZvci5cclxuICogQHBhcmFtIGJ1bmRsZURhdGEgLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBidW5kbGUgdG8gYmUgbG9hZGVkLiBWYWxpZFxyXG4gKiBvYmplY3RzIGFyZSBgQXJyYXlCdWZmZXJgLCBgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5gIG9yIGBzdHJpbmdgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBMb2FkQnVuZGxlVGFza2Agb2JqZWN0LCB3aGljaCBub3RpZmllcyBjYWxsZXJzIHdpdGggcHJvZ3Jlc3NcclxuICogdXBkYXRlcywgYW5kIGNvbXBsZXRpb24gb3IgZXJyb3IgZXZlbnRzLiBJdCBjYW4gYmUgdXNlZCBhcyBhXHJcbiAqIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+YC5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRCdW5kbGUoZmlyZXN0b3JlLCBidW5kbGVEYXRhKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHJlc3VsdFRhc2sgPSBuZXcgTG9hZEJ1bmRsZVRhc2soKTtcclxuICAgIGZpcmVzdG9yZUNsaWVudExvYWRCdW5kbGUoY2xpZW50LCBmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGJ1bmRsZURhdGEsIHJlc3VsdFRhc2spO1xyXG4gICAgcmV0dXJuIHJlc3VsdFRhc2s7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIGEgRmlyZXN0b3JlIHtAbGluayBRdWVyeX0gZnJvbSBsb2NhbCBjYWNoZSwgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW5cclxuICogbmFtZS5cclxuICpcclxuICogVGhlIG5hbWVkIHF1ZXJpZXMgYXJlIHBhY2thZ2VkICBpbnRvIGJ1bmRsZXMgb24gdGhlIHNlcnZlciBzaWRlIChhbG9uZ1xyXG4gKiB3aXRoIHJlc3VsdGluZyBkb2N1bWVudHMpLCBhbmQgbG9hZGVkIHRvIGxvY2FsIGNhY2hlIHVzaW5nIGBsb2FkQnVuZGxlYC4gT25jZVxyXG4gKiBpbiBsb2NhbCBjYWNoZSwgdXNlIHRoaXMgbWV0aG9kIHRvIGV4dHJhY3QgYSB7QGxpbmsgUXVlcnl9IGJ5IG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gcmVhZCB0aGUgcXVlcnkgZnJvbS5cclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgUXVlcnkgb3IgYG51bGxgLlxyXG4gKi9cclxuZnVuY3Rpb24gbmFtZWRRdWVyeShmaXJlc3RvcmUsIG5hbWUpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldE5hbWVkUXVlcnkoY2xpZW50LCBuYW1lKS50aGVuKG5hbWVkUXVlcnkgPT4ge1xyXG4gICAgICAgIGlmICghbmFtZWRRdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShmaXJlc3RvcmUsIG51bGwsIG5hbWVkUXVlcnkucXVlcnkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdmVyaWZ5Tm90SW5pdGlhbGl6ZWQoZmlyZXN0b3JlKSB7XHJcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCB8fCBmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgcGVyc2lzdGVuY2UgY2FuIG5vIGxvbmdlciBiZSAnICtcclxuICAgICAgICAgICAgJ2VuYWJsZWQuIFlvdSBjYW4gb25seSBlbmFibGUgcGVyc2lzdGVuY2UgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xyXG4gICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJGaXJlc3RvcmUodmFyaWFudCwgdXNlRmV0Y2hTdHJlYW1zID0gdHJ1ZSkge1xyXG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdmaXJlc3RvcmUnLCAoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogZGF0YWJhc2VJZCwgb3B0aW9uczogc2V0dGluZ3MgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlSW5zdGFuY2UgPSBuZXcgRmlyZXN0b3JlKG5ldyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJykpLCBkYXRhYmFzZUlkRnJvbUFwcChhcHAsIGRhdGFiYXNlSWQpLCBhcHApO1xyXG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7IHVzZUZldGNoU3RyZWFtcyB9LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgZmlyZXN0b3JlSW5zdGFuY2UuX3NldFNldHRpbmdzKHNldHRpbmdzKTtcclxuICAgICAgICByZXR1cm4gZmlyZXN0b3JlSW5zdGFuY2U7XHJcbiAgICB9LCAnUFVCTElDJykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24kMSwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFnZ3JlZ2F0ZSB0eXBlLlxyXG4gKi9cclxuY2xhc3MgQWdncmVnYXRlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGlhcywgYWdncmVnYXRlVHlwZSwgZmllbGRQYXRoKSB7XHJcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRlVHlwZSA9IGFnZ3JlZ2F0ZVR5cGU7XHJcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWdncmVnYXRpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGJ5IEZpcmVzdG9yZS5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuY2xhc3MgQWdncmVnYXRlRmllbGQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgQWdncmVnYXRlRmllbGQ8VD5cclxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdGVUeXBlIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBhZ2dyZWdhdGlvbiBvcGVyYXRpb24gdG8gcGVyZm9ybS5cclxuICAgICAqIEBwYXJhbSBfaW50ZXJuYWxGaWVsZFBhdGggT3B0aW9uYWxseSBzcGVjaWZpZXMgdGhlIGZpZWxkIHRoYXQgaXMgYWdncmVnYXRlZC5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhZ2dyZWdhdGVUeXBlID0gJ2NvdW50JywgX2ludGVybmFsRmllbGRQYXRoKSB7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxGaWVsZFBhdGggPSBfaW50ZXJuYWxGaWVsZFBhdGg7XHJcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZUZpZWxkJztcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZVR5cGUgPSBhZ2dyZWdhdGVUeXBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgcmVzdWx0cyBvZiBleGVjdXRpbmcgYW4gYWdncmVnYXRpb24gcXVlcnkuXHJcbiAqL1xyXG5jbGFzcyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgX3VzZXJEYXRhV3JpdGVyLCBfZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcclxuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlUXVlcnlTbmFwc2hvdCc7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbnMgcGVyZm9ybWVkIG92ZXIgdGhlIHVuZGVybHlpbmdcclxuICAgICAqIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBrZXlzIG9mIHRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aG9zZSBvZiB0aGVcclxuICAgICAqIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3Qgc3BlY2lmaWVkIHRvIHRoZSBhZ2dyZWdhdGlvbiBtZXRob2QsIGFuZCB0aGUgdmFsdWVzXHJcbiAgICAgKiB3aWxsIGJlIHRoZSBjb3JyZXNwb25kaW5nIGFnZ3JlZ2F0aW9uIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiBxdWVyeS5cclxuICAgICAqL1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydE9iamVjdE1hcCh0aGlzLl9kYXRhKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAqL1xyXG5jbGFzcyBCeXRlcyB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZVN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2J5dGVTdHJpbmcgPSBieXRlU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmcsIGNvbnZlcnRpbmcgaXQgdG9cclxuICAgICAqIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBiYXNlNjQgLSBUaGUgQmFzZTY0IHN0cmluZyB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXMoQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmFpbGVkIHRvIGNvbnN0cnVjdCBkYXRhIGZyb20gQmFzZTY0IHN0cmluZzogJyArIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBVaW50OEFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBVaW50OEFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KGFycmF5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgYnl0ZXMgYXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0Jhc2U2NCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b0Jhc2U2NCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGluIGEgbmV3IGBVaW50OEFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVWludDhBcnJheSBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b1VpbnQ4QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9VaW50OEFycmF5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICdCeXRlcyhiYXNlNjQ6ICcgKyB0aGlzLnRvQmFzZTY0KCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBCeXRlc2Agb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgQnl0ZXNgIG9iamVjdCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcuaXNFcXVhbChvdGhlci5fYnl0ZVN0cmluZyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYEZpZWxkUGF0aGAgcmVmZXJzIHRvIGEgZmllbGQgaW4gYSBkb2N1bWVudC4gVGhlIHBhdGggbWF5IGNvbnNpc3Qgb2YgYVxyXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcclxuICogbGlzdCBvZiBmaWVsZCBuYW1lcyAocmVmZXJyaW5nIHRvIGEgbmVzdGVkIGZpZWxkIGluIHRoZSBkb2N1bWVudCkuXHJcbiAqXHJcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxyXG4gKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXHJcbiAqL1xyXG5jbGFzcyBGaWVsZFBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYEZpZWxkUGF0aGAgZnJvbSB0aGUgcHJvdmlkZWQgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcclxuICAgICAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyAtIEEgbGlzdCBvZiBmaWVsZCBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uZmllbGROYW1lcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGZpZWxkIG5hbWUgYXQgYXJndW1lbnQgJChpICsgMSkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaWVsZCBuYW1lcyBtdXN0IG5vdCBiZSBlbXB0eS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhdGggPSBuZXcgRmllbGRQYXRoJDEoZmllbGROYW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBGaWVsZFBhdGhgIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUGF0aC5pc0VxdWFsKG90aGVyLl9pbnRlcm5hbFBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCBzZW50aW5lbCBgRmllbGRQYXRoYCB0byByZWZlciB0byB0aGUgSUQgb2YgYSBkb2N1bWVudC5cclxuICogSXQgY2FuIGJlIHVzZWQgaW4gcXVlcmllcyB0byBzb3J0IG9yIGZpbHRlciBieSB0aGUgZG9jdW1lbnQgSUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudElkKCkge1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoRE9DVU1FTlRfS0VZX05BTUUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTZW50aW5lbCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIHdyaXRpbmcgZG9jdW1lbnQgZmllbGRzIHdpdGggYHNldCgpYFxyXG4gKiBvciBgdXBkYXRlKClgLlxyXG4gKi9cclxuY2xhc3MgRmllbGRWYWx1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBfbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWMgQVBJIGVuZHBvaW50IHRoYXQgcmV0dXJucyB0aGlzIGNsYXNzLlxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZE5hbWUgPSBfbWV0aG9kTmFtZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljIGxvY2F0aW9uIGluIEZpcmVzdG9yZS4gVGhlXHJcbiAqIGxvY2F0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGxhdGl0dWRlL2xvbmdpdHVkZSBwYWlyLlxyXG4gKlxyXG4gKiBMYXRpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTkwLCA5MF0uXHJcbiAqIExvbmdpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTE4MCwgMTgwXS5cclxuICovXHJcbmNsYXNzIEdlb1BvaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgYEdlb1BvaW50YCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbGF0aXR1ZGUgYW5kXHJcbiAgICAgKiBsb25naXR1ZGUgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIGFzIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAuXHJcbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcclxuICAgICAgICBpZiAoIWlzRmluaXRlKGxhdGl0dWRlKSB8fCBsYXRpdHVkZSA8IC05MCB8fCBsYXRpdHVkZSA+IDkwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMYXRpdHVkZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTkwIGFuZCA5MCwgYnV0IHdhczogJyArIGxhdGl0dWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsb25naXR1ZGUpIHx8IGxvbmdpdHVkZSA8IC0xODAgfHwgbG9uZ2l0dWRlID4gMTgwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdMb25naXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MCwgYnV0IHdhczogJyArIGxvbmdpdHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhdCA9IGxhdGl0dWRlO1xyXG4gICAgICAgIHRoaXMuX2xvbmcgPSBsb25naXR1ZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBsYXRpdHVkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIG9mIHRoaXMgYEdlb1BvaW50YCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxvbmdpdHVkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgR2VvUG9pbnRgIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ID09PSBvdGhlci5fbGF0ICYmIHRoaXMuX2xvbmcgPT09IG90aGVyLl9sb25nO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEdlb1BvaW50LiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiB0aGlzLl9sYXQsIGxvbmdpdHVkZTogdGhpcy5fbG9uZyB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBwcml2YXRlIHRvIEpTIGNvbnN1bWVycyBvZiBvdXIgQVBJLCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHByZWZpeGVkXHJcbiAgICAgKiB3aXRoIGFuIHVuZGVyc2NvcmUuXHJcbiAgICAgKi9cclxuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5fbGF0LCBvdGhlci5fbGF0KSB8fFxyXG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xvbmcsIG90aGVyLl9sb25nKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUkVTRVJWRURfRklFTERfUkVHRVggPSAvXl9fLipfXyQvO1xyXG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGRvY3VtZW50IGRhdGEgKGUuZy4gZm9yIGEgc2V0RGF0YSBjYWxsKS4gKi9cclxuY2xhc3MgUGFyc2VkU2V0RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICB0b011dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmllbGRNYXNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgXCJ1cGRhdGVcIiBkYXRhIChpLmUuIGZvciBhbiB1cGRhdGVEYXRhIGNhbGwpLiAqL1xyXG5jbGFzcyBQYXJzZWRVcGRhdGVEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIFxyXG4gICAgLy8gVGhlIGZpZWxkTWFzayBkb2VzIG5vdCBpbmNsdWRlIGRvY3VtZW50IHRyYW5zZm9ybXMuXHJcbiAgICBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICB0b011dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdGhpcy5kYXRhLCB0aGlzLmZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNXcml0ZShkYXRhU291cmNlKSB7XHJcbiAgICBzd2l0Y2ggKGRhdGFTb3VyY2UpIHtcclxuICAgICAgICBjYXNlIDAgLyogVXNlckRhdGFTb3VyY2UuU2V0ICovOiAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICBjYXNlIDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgICAgIGNhc2UgMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGNhc2UgMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLzpcclxuICAgICAgICBjYXNlIDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBcImNvbnRleHRcIiBvYmplY3QgcGFzc2VkIGFyb3VuZCB3aGlsZSBwYXJzaW5nIHVzZXIgZGF0YS4gKi9cclxuY2xhc3MgUGFyc2VDb250ZXh0SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGEgUGFyc2VDb250ZXh0IHdpdGggdGhlIGdpdmVuIHNvdXJjZSBhbmQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3MgLSBUaGUgc2V0dGluZ3MgZm9yIHRoZSBwYXJzZXIuXHJcbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSBJRCBvZiB0aGUgRmlyZXN0b3JlIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgc2VyaWFsaXplciB0byB1c2UgdG8gZ2VuZXJhdGUgdGhlIFZhbHVlIHByb3RvLlxyXG4gICAgICogQHBhcmFtIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgLSBXaGV0aGVyIHRvIGlnbm9yZSB1bmRlZmluZWQgcHJvcGVydGllc1xyXG4gICAgICogcmF0aGVyIHRoYW4gdGhyb3cuXHJcbiAgICAgKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgdHJhbnNmb3JtcyBlbmNvdW50ZXJlZFxyXG4gICAgICogd2hpbGUgcGFyc2luZyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSBmaWVsZE1hc2sgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCBwYXRocyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXHJcbiAgICAgKiB0aGUgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdywgc28gcGF0aCBjYW4gYmVcclxuICAgICAqIG51bGwgdG8gaW5kaWNhdGUgdGhlIGNvbnRleHQgcmVwcmVzZW50cyBhbnkgbG9jYXRpb24gd2l0aGluIGFuIGFycmF5IChpblxyXG4gICAgICogd2hpY2ggY2FzZSBjZXJ0YWluIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsgYW5kIGVycm9ycyB3aWxsIGJlIHNvbWV3aGF0XHJcbiAgICAgKiBjb21wcm9taXNlZCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBkYXRhYmFzZUlkLCBzZXJpYWxpemVyLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBmaWVsZFRyYW5zZm9ybXMsIGZpZWxkTWFzaykge1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICAvLyBNaW5vciBoYWNrOiBJZiBmaWVsZFRyYW5zZm9ybXMgaXMgdW5kZWZpbmVkLCB3ZSBhc3N1bWUgdGhpcyBpcyBhblxyXG4gICAgICAgIC8vIGV4dGVybmFsIGNhbGwgYW5kIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhlIGVudGlyZSBwYXRoLlxyXG4gICAgICAgIGlmIChmaWVsZFRyYW5zZm9ybXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcyB8fCBbXTtcclxuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzayB8fCBbXTtcclxuICAgIH1cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YVNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5kYXRhU291cmNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgY29udGV4dCB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3Mgb3ZlcndyaXR0ZW4uICovXHJcbiAgICBjb250ZXh0V2l0aChjb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZXR0aW5ncyksIGNvbmZpZ3VyYXRpb24pLCB0aGlzLmRhdGFiYXNlSWQsIHRoaXMuc2VyaWFsaXplciwgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCB0aGlzLmZpZWxkVHJhbnNmb3JtcywgdGhpcy5maWVsZE1hc2spO1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGQoZmllbGQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoU2VnbWVudChmaWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICBjaGlsZENvbnRleHRGb3JGaWVsZFBhdGgoZmllbGQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICBjaGlsZENvbnRleHRGb3JBcnJheShpbmRleCkge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFdlIGRvbid0IHN1cHBvcnQgYXJyYXkgcGF0aHMgcmlnaHQgbm93OyBzbyBtYWtlIHBhdGhcclxuICAgICAgICAvLyB1bmRlZmluZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiB1bmRlZmluZWQsIGFycmF5RWxlbWVudDogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUVycm9yKHJlYXNvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvcihyZWFzb24sIHRoaXMuc2V0dGluZ3MubWV0aG9kTmFtZSwgdGhpcy5zZXR0aW5ncy5oYXNDb252ZXJ0ZXIgfHwgZmFsc2UsIHRoaXMucGF0aCwgdGhpcy5zZXR0aW5ncy50YXJnZXREb2MpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgJ3RydWUnIGlmICdmaWVsZFBhdGgnIHdhcyB0cmF2ZXJzZWQgd2hlbiBjcmVhdGluZyB0aGlzIGNvbnRleHQuICovXHJcbiAgICBjb250YWlucyhmaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmllbGRNYXNrLmZpbmQoZmllbGQgPT4gZmllbGRQYXRoLmlzUHJlZml4T2YoZmllbGQpKSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zLmZpbmQodHJhbnNmb3JtID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKHRyYW5zZm9ybS5maWVsZCkpICE9PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoKCkge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFJlbW92ZSBudWxsIGNoZWNrIG9uY2Ugd2UgaGF2ZSBwcm9wZXIgcGF0aHMgZm9yIGZpZWxkc1xyXG4gICAgICAgIC8vIHdpdGhpbiBhcnJheXMuXHJcbiAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aFNlZ21lbnQodGhpcy5wYXRoLmdldChpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU2VnbWVudChzZWdtZW50KSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBtdXN0IG5vdCBiZSBlbXB0eScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNXcml0ZSh0aGlzLmRhdGFTb3VyY2UpICYmIFJFU0VSVkVEX0ZJRUxEX1JFR0VYLnRlc3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcignRG9jdW1lbnQgZmllbGRzIGNhbm5vdCBiZWdpbiBhbmQgZW5kIHdpdGggXCJfX1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgZm9yIHBhcnNpbmcgcmF3IHVzZXIgaW5wdXQgKHByb3ZpZGVkIHZpYSB0aGUgQVBJKSBpbnRvIGludGVybmFsIG1vZGVsXHJcbiAqIGNsYXNzZXMuXHJcbiAqL1xyXG5jbGFzcyBVc2VyRGF0YVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXIgfHwgbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRvcC1sZXZlbCBwYXJzZSBjb250ZXh0LiAqL1xyXG4gICAgY3JlYXRlQ29udGV4dChkYXRhU291cmNlLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGhhc0NvbnZlcnRlciA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcclxuICAgICAgICAgICAgZGF0YVNvdXJjZSxcclxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcclxuICAgICAgICAgICAgdGFyZ2V0RG9jLFxyXG4gICAgICAgICAgICBwYXRoOiBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKSxcclxuICAgICAgICAgICAgYXJyYXlFbGVtZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgaGFzQ29udmVydGVyXHJcbiAgICAgICAgfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKSB7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XHJcbiAgICByZXR1cm4gbmV3IFVzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgISFzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKTtcclxufVxyXG4vKiogUGFyc2UgZG9jdW1lbnQgZGF0YSBmcm9tIGEgc2V0KCkgY2FsbC4gKi9cclxuZnVuY3Rpb24gcGFyc2VTZXREYXRhKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGlucHV0LCBoYXNDb252ZXJ0ZXIsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQob3B0aW9ucy5tZXJnZSB8fCBvcHRpb25zLm1lcmdlRmllbGRzXHJcbiAgICAgICAgPyAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovXHJcbiAgICAgICAgOiAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIpO1xyXG4gICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgbGV0IGZpZWxkTWFzaztcclxuICAgIGxldCBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICBpZiAob3B0aW9ucy5tZXJnZSkge1xyXG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2soY29udGV4dC5maWVsZE1hc2spO1xyXG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5tZXJnZUZpZWxkcykge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZpZWxkUGF0aHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN0cmluZ09yRmllbGRQYXRoIG9mIG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgc3RyaW5nT3JGaWVsZFBhdGgsIHRhcmdldERvYyk7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5jb250YWlucyhmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRmllbGQgJyR7ZmllbGRQYXRofScgaXMgc3BlY2lmaWVkIGluIHlvdXIgZmllbGQgbWFzayBidXQgbWlzc2luZyBmcm9tIHlvdXIgaW5wdXQgZGF0YS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZpZWxkTWFza0NvbnRhaW5zKHZhbGlkYXRlZEZpZWxkUGF0aHMsIGZpZWxkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZEZpZWxkUGF0aHMucHVzaChmaWVsZFBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2sodmFsaWRhdGVkRmllbGRQYXRocyk7XHJcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybSA9PiBmaWVsZE1hc2suY292ZXJzKHRyYW5zZm9ybS5maWVsZCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmllbGRNYXNrID0gbnVsbDtcclxuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGFyc2VkU2V0RGF0YShuZXcgT2JqZWN0VmFsdWUodXBkYXRlRGF0YSksIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKTtcclxufVxyXG5jbGFzcyBEZWxldGVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTm8gdHJhbnNmb3JtIHRvIGFkZCBmb3IgYSBkZWxldGUsIGJ1dCB3ZSBuZWVkIHRvIGFkZCBpdCB0byBvdXJcclxuICAgICAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dGhpcy5fbWV0aG9kTmFtZX0oKSBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbCBgICtcclxuICAgICAgICAgICAgICAgICdvZiB5b3VyIHVwZGF0ZSBkYXRhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGRuJ3QgZW5jb3VudGVyIGRlbGV0ZSBzZW50aW5lbHMgZm9yIHF1ZXJpZXMgb3Igbm9uLW1lcmdlIHNldCgpIGNhbGxzLlxyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2Fubm90IGJlIHVzZWQgd2l0aCBzZXQoKSB1bmxlc3MgeW91IHBhc3MgYCArXHJcbiAgICAgICAgICAgICAgICAne21lcmdlOnRydWV9Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2hpbGQgY29udGV4dCBmb3IgcGFyc2luZyBTZXJpYWxpemFibGVGaWVsZFZhbHVlcy5cclxuICpcclxuICogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjYWxsaW5nIGBQYXJzZUNvbnRleHQuY29udGV4dFdpdGhgIGJlY2F1c2UgaXQga2VlcHNcclxuICogdGhlIGZpZWxkVHJhbnNmb3JtcyBhbmQgZmllbGRNYXNrIHNlcGFyYXRlLlxyXG4gKlxyXG4gKiBUaGUgY3JlYXRlZCBjb250ZXh0IGhhcyBpdHMgYGRhdGFTb3VyY2VgIHNldCB0byBgVXNlckRhdGFTb3VyY2UuQXJndW1lbnRgLlxyXG4gKiBBbHRob3VnaCB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgd2l0aCB3cml0ZXMsIGFueSBlbGVtZW50cyBpbiB0aGVzZSBGaWVsZFZhbHVlc1xyXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgd3JpdGVzIHNpbmNlIHRoZXkgY2Fubm90IGNvbnRhaW4gYW55IEZpZWxkVmFsdWUgc2VudGluZWxzLFxyXG4gKiBldGMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFZhbHVlIC0gVGhlIHNlbnRpbmVsIEZpZWxkVmFsdWUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIGNoaWxkXHJcbiAqICAgICBjb250ZXh0LlxyXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBwYXJlbnQgY29udGV4dC5cclxuICogQHBhcmFtIGFycmF5RWxlbWVudCAtIFdoZXRoZXIgb3Igbm90IHRoZSBGaWVsZFZhbHVlIGhhcyBhbiBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KGZpZWxkVmFsdWUsIGNvbnRleHQsIGFycmF5RWxlbWVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHRJbXBsKHtcclxuICAgICAgICBkYXRhU291cmNlOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLFxyXG4gICAgICAgIHRhcmdldERvYzogY29udGV4dC5zZXR0aW5ncy50YXJnZXREb2MsXHJcbiAgICAgICAgbWV0aG9kTmFtZTogZmllbGRWYWx1ZS5fbWV0aG9kTmFtZSxcclxuICAgICAgICBhcnJheUVsZW1lbnRcclxuICAgIH0sIGNvbnRleHQuZGF0YWJhc2VJZCwgY29udGV4dC5zZXJpYWxpemVyLCBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpO1xyXG59XHJcbmNsYXNzIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wRmllbGRWYWx1ZUltcGw7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcclxuICAgIH1cclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcclxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbihwYXJzZWRFbGVtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKHRoaXMuX2VsZW1lbnRzLCBvdGhlci5fZWxlbWVudHMpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcclxuICAgIH1cclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcclxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24ocGFyc2VkRWxlbWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCAmJlxyXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX29wZXJhbmQpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9vcGVyYW5kID0gX29wZXJhbmQ7XHJcbiAgICB9XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbnVtZXJpY0luY3JlbWVudCA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKGNvbnRleHQuc2VyaWFsaXplciwgdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB0aGlzLl9vcGVyYW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIG51bWVyaWNJbmNyZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwgJiZcclxuICAgICAgICAgICAgdGhpcy5fb3BlcmFuZCA9PT0gb3RoZXIuX29wZXJhbmQpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGFuIHVwZGF0ZSgpIGNhbGwuICovXHJcbmZ1bmN0aW9uIHBhcnNlVXBkYXRlRGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XHJcbiAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdEYXRhIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzOicsIGNvbnRleHQsIGlucHV0KTtcclxuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgIGZvckVhY2goaW5wdXQsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwga2V5LCB0YXJnZXREb2MpO1xyXG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxyXG4gICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChwYXRoKTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbCkge1xyXG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cclxuICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbHVlLCBjaGlsZENvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEuc2V0KHBhdGgsIHBhcnNlZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWFzayA9IG5ldyBGaWVsZE1hc2soZmllbGRNYXNrUGF0aHMpO1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcclxufVxyXG4vKiogUGFyc2UgdXBkYXRlIGRhdGEgZnJvbSBhIGxpc3Qgb2YgZmllbGQvdmFsdWUgYXJndW1lbnRzLiAqL1xyXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVZhcmFyZ3ModXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgZmllbGQsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlckRhdGFSZWFkZXIuY3JlYXRlQ29udGV4dCgxIC8qIFVzZXJEYXRhU291cmNlLlVwZGF0ZSAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jKTtcclxuICAgIGNvbnN0IGtleXMgPSBbZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgZmllbGQsIHRhcmdldERvYyldO1xyXG4gICAgY29uc3QgdmFsdWVzID0gW3ZhbHVlXTtcclxuICAgIGlmIChtb3JlRmllbGRzQW5kVmFsdWVzLmxlbmd0aCAlIDIgIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW4gbnVtYmVyIGAgK1xyXG4gICAgICAgICAgICAnb2YgYXJndW1lbnRzIHRoYXQgYWx0ZXJuYXRlIGJldHdlZW4gZmllbGQgbmFtZXMgYW5kIHZhbHVlcy4nKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIGtleXMucHVzaChmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBtb3JlRmllbGRzQW5kVmFsdWVzW2ldKSk7XHJcbiAgICAgICAgdmFsdWVzLnB1c2gobW9yZUZpZWxkc0FuZFZhbHVlc1tpICsgMV0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmllbGRNYXNrUGF0aHMgPSBbXTtcclxuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xyXG4gICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIHRvIHBpY2sgdGhlIGxhc3QgdmFsdWUgZm9yIGEgZmllbGQgaWYgdGhlXHJcbiAgICAvLyB1c2VyIHNwZWNpZmllZCB0aGUgZmllbGQgbXVsdGlwbGUgdGltZXMuXHJcbiAgICBmb3IgKGxldCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIGlmICghZmllbGRNYXNrQ29udGFpbnMoZmllbGRNYXNrUGF0aHMsIGtleXNbaV0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICAgICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgZmllbGQgbWFzaywgYnV0IGRvbid0IGFkZCBhbnl0aGluZyB0byB1cGRhdGVEYXRhLlxyXG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbHVlLCBjaGlsZENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEuc2V0KHBhdGgsIHBhcnNlZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG1hc2sgPSBuZXcgRmllbGRNYXNrKGZpZWxkTWFza1BhdGhzKTtcclxuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIGEgXCJxdWVyeSB2YWx1ZVwiIChlLmcuIHZhbHVlIGluIGEgd2hlcmUgZmlsdGVyIG9yIGEgdmFsdWUgaW4gYSBjdXJzb3JcclxuICogYm91bmQpLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWxsb3dBcnJheXMgLSBXaGV0aGVyIHRoZSBxdWVyeSB2YWx1ZSBpcyBhbiBhcnJheSB0aGF0IG1heSBkaXJlY3RseVxyXG4gKiBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlLmcuIHRoZSBvcGVyYW5kIG9mIGFuIGBpbmAgcXVlcnkpLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VRdWVyeVZhbHVlKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCBpbnB1dCwgYWxsb3dBcnJheXMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoYWxsb3dBcnJheXMgPyA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8gOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLCBtZXRob2ROYW1lKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRGF0YShpbnB1dCwgY29udGV4dCk7XHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdXNlciBkYXRhIHRvIFByb3RvYnVmIFZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIGlucHV0IC0gRGF0YSB0byBiZSBwYXJzZWQuXHJcbiAqIEBwYXJhbSBjb250ZXh0IC0gQSBjb250ZXh0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcGF0aCBiZWluZyBwYXJzZWQsXHJcbiAqIHRoZSBzb3VyY2Ugb2YgdGhlIGRhdGEgYmVpbmcgcGFyc2VkLCBldGMuXHJcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHZhbHVlIHdhcyBhIEZpZWxkVmFsdWUgc2VudGluZWxcclxuICogdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgcGFyc2VkIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgIC8vIFVud3JhcCB0aGUgQVBJIHR5cGUgZnJvbSB0aGUgQ29tcGF0IFNESy4gVGhpcyB3aWxsIHJldHVybiB0aGUgQVBJIHR5cGVcclxuICAgIC8vIGZyb20gZmlyZXN0b3JlLWV4cC5cclxuICAgIGlucHV0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGlucHV0KTtcclxuICAgIGlmIChsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ1Vuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOicsIGNvbnRleHQsIGlucHV0KTtcclxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSB7XHJcbiAgICAgICAgLy8gRmllbGRWYWx1ZXMgdXN1YWxseSBwYXJzZSBpbnRvIHRyYW5zZm9ybXMgKGV4Y2VwdCBkZWxldGVGaWVsZCgpKVxyXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSB0aGlzIGZpZWxkIGluIG91ciBwYXJzZWQgZGF0YVxyXG4gICAgICAgIC8vIChhcyBkb2luZyBzbyB3aWxsIG92ZXJ3cml0ZSB0aGUgZmllbGQgZGlyZWN0bHkgcHJpb3IgdG8gdGhlIHRyYW5zZm9ybVxyXG4gICAgICAgIC8vIHRyeWluZyB0byB0cmFuc2Zvcm0gaXQpLiBTbyB3ZSBkb24ndCBhZGQgdGhpcyBsb2NhdGlvbiB0b1xyXG4gICAgICAgIC8vIGNvbnRleHQuZmllbGRNYXNrIGFuZCB3ZSByZXR1cm4gbnVsbCBhcyBvdXIgcGFyc2luZyByZXN1bHQuXHJcbiAgICAgICAgcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpIHtcclxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgdW5kZWZpbmVkIGl0IGNhbiBuZXZlciBwYXJ0aWNpcGF0ZSBpbiB0aGUgZmllbGRNYXNrLCBzb1xyXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSB0aGlzIGJlbG93LiBJZiBgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllc2AgaXMgZmFsc2UsXHJcbiAgICAgICAgLy8gYHBhcnNlU2NhbGFyVmFsdWVgIHdpbGwgcmVqZWN0IGFuIHVuZGVmaW5lZCB2YWx1ZS5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElmIGNvbnRleHQucGF0aCBpcyBudWxsIHdlIGFyZSBpbnNpZGUgYW4gYXJyYXkgYW5kIHdlIGRvbid0IHN1cHBvcnRcclxuICAgICAgICAvLyBmaWVsZCBtYXNrIHBhdGhzIG1vcmUgZ3JhbnVsYXIgdGhhbiB0aGUgdG9wLWxldmVsIGFycmF5LlxyXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGgpIHtcclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBJbmNsdWRlIHRoZSBwYXRoIGNvbnRhaW5pbmcgdGhlIGFycmF5IGluIHRoZSBlcnJvclxyXG4gICAgICAgICAgICAvLyBtZXNzYWdlLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBJTiBxdWVyaWVzLCB0aGUgcGFyc2VkIGRhdGEgaXMgYW4gYXJyYXkgKHJlcHJlc2VudGluZ1xyXG4gICAgICAgICAgICAvLyB0aGUgc2V0IG9mIHZhbHVlcyB0byBiZSBpbmNsdWRlZCBmb3IgdGhlIElOIHF1ZXJ5KSB0aGF0IG1heSBkaXJlY3RseVxyXG4gICAgICAgICAgICAvLyBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlYWNoIHJlcHJlc2VudGluZyBhbiBpbmRpdmlkdWFsIGZpZWxkXHJcbiAgICAgICAgICAgIC8vIHZhbHVlKSwgc28gd2UgZGlzYWJsZSB0aGlzIHZhbGlkYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNldHRpbmdzLmFycmF5RWxlbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhU291cmNlICE9PSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ05lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheShpbnB1dCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTY2FsYXJWYWx1ZShpbnB1dCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaiwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZmllbGRzID0ge307XHJcbiAgICBpZiAoaXNFbXB0eShvYmopKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IG9iamVjdCwgd2UgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIHVwZGF0ZVxyXG4gICAgICAgIC8vIG1hc2sgdG8gZW5zdXJlIHRoYXQgdGhlIHNlcnZlciBjcmVhdGVzIGEgbWFwIGVudHJ5LlxyXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGggJiYgY29udGV4dC5wYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvckVhY2gob2JqLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsLCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckZpZWxkKGtleSkpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSBwYXJzZWRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbWFwVmFsdWU6IHsgZmllbGRzIH0gfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUFycmF5KGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGxldCBlbnRyeUluZGV4ID0gMDtcclxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcclxuICAgICAgICBsZXQgcGFyc2VkRW50cnkgPSBwYXJzZURhdGEoZW50cnksIGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yQXJyYXkoZW50cnlJbmRleCkpO1xyXG4gICAgICAgIGlmIChwYXJzZWRFbnRyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgaW5jbHVkZSBudWxscyBpbiB0aGUgYXJyYXkgZm9yIGZpZWxkcyBiZWluZyByZXBsYWNlZCB3aXRoIGFcclxuICAgICAgICAgICAgLy8gc2VudGluZWwuXHJcbiAgICAgICAgICAgIHBhcnNlZEVudHJ5ID0geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWRFbnRyeSk7XHJcbiAgICAgICAgZW50cnlJbmRleCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXMgfSB9O1xyXG59XHJcbi8qKlxyXG4gKiBcIlBhcnNlc1wiIHRoZSBwcm92aWRlZCBGaWVsZFZhbHVlSW1wbCwgYWRkaW5nIGFueSBuZWNlc3NhcnkgdHJhbnNmb3JtcyB0b1xyXG4gKiBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAvLyBTZW50aW5lbHMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggd3JpdGVzLCBhbmQgbm90IHdpdGhpbiBhcnJheXMuXHJcbiAgICBpZiAoIWlzV3JpdGUoY29udGV4dC5kYXRhU291cmNlKSkge1xyXG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dmFsdWUuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHVwZGF0ZSgpIGFuZCBzZXQoKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0LnBhdGgpIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluc2lkZSBhcnJheXNgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtID0gdmFsdWUuX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCk7XHJcbiAgICBpZiAoZmllbGRUcmFuc2Zvcm0pIHtcclxuICAgICAgICBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5wdXNoKGZpZWxkVHJhbnNmb3JtKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIHBhcnNlIGEgc2NhbGFyIHZhbHVlIChpLmUuIG5vdCBhbiBPYmplY3QsIEFycmF5LCBvciBGaWVsZFZhbHVlKVxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVNjYWxhclZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB0b051bWJlcihjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21EYXRlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogdG9UaW1lc3RhbXAoY29udGV4dC5zZXJpYWxpemVyLCB0aW1lc3RhbXApXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZXN0YW1wKSB7XHJcbiAgICAgICAgLy8gRmlyZXN0b3JlIGJhY2tlbmQgdHJ1bmNhdGVzIHByZWNpc2lvbiBkb3duIHRvIG1pY3Jvc2Vjb25kcy4gVG8gZW5zdXJlXHJcbiAgICAgICAgLy8gb2ZmbGluZSBtb2RlIHdvcmtzIHRoZSBzYW1lIHdpdGggcmVnYXJkcyB0byB0cnVuY2F0aW9uLCBwZXJmb3JtIHRoZVxyXG4gICAgICAgIC8vIHRydW5jYXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgYmFja2VuZCB0byBkbyB0aGF0LlxyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAodmFsdWUuc2Vjb25kcywgTWF0aC5mbG9vcih2YWx1ZS5uYW5vc2Vjb25kcyAvIDEwMDApICogMTAwMCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEdlb1BvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2VvUG9pbnRWYWx1ZToge1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IHZhbHVlLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiB2YWx1ZS5sb25naXR1ZGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogdG9CeXRlcyhjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlLl9ieXRlU3RyaW5nKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xyXG4gICAgICAgIGNvbnN0IHRoaXNEYiA9IGNvbnRleHQuZGF0YWJhc2VJZDtcclxuICAgICAgICBjb25zdCBvdGhlckRiID0gdmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkO1xyXG4gICAgICAgIGlmICghb3RoZXJEYi5pc0VxdWFsKHRoaXNEYikpIHtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcignRG9jdW1lbnQgcmVmZXJlbmNlIGlzIGZvciBkYXRhYmFzZSAnICtcclxuICAgICAgICAgICAgICAgIGAke290aGVyRGIucHJvamVjdElkfS8ke290aGVyRGIuZGF0YWJhc2V9IGJ1dCBzaG91bGQgYmUgYCArXHJcbiAgICAgICAgICAgICAgICBgZm9yIGRhdGFiYXNlICR7dGhpc0RiLnByb2plY3RJZH0vJHt0aGlzRGIuZGF0YWJhc2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiB0b1Jlc291cmNlTmFtZSh2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQgfHwgY29udGV4dC5kYXRhYmFzZUlkLCB2YWx1ZS5fa2V5LnBhdGgpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYFVuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOiAke3ZhbHVlRGVzY3JpcHRpb24odmFsdWUpfWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxyXG4gKiBpbnRvIGEgc3RydWN0LiBOb3JtYWwgY2xhc3MvcHJvdG90eXBlIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCB0byBsb29rIGxpa2VcclxuICogSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHN0cnVjdCB2YWx1ZS4gQXJyYXlzLCBEYXRlcyxcclxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXHJcbiAqIHRvIHNwZWNpZmljIEZpZWxkVmFsdWUgdHlwZXMgb3RoZXIgdGhhbiBPYmplY3RWYWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBUaW1lc3RhbXApICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEdlb1BvaW50KSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBCeXRlcykgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVBsYWluT2JqZWN0KG1lc3NhZ2UsIGNvbnRleHQsIGlucHV0KSB7XHJcbiAgICBpZiAoIWxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHx8ICFpc1BsYWluT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCk7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSAnYW4gb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAvLyBNYXNzYWdlIHRoZSBlcnJvciBpZiBpdCB3YXMgYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKG1lc3NhZ2UgKyAnIGEgY3VzdG9tIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyAnICsgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRoYXQgY2FsbHMgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpIGJ1dCB3cmFwcyBhbnkgZXJyb3IgdGhyb3duLlxyXG4gKi9cclxuZnVuY3Rpb24gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICAvLyBJZiByZXF1aXJlZCwgcmVwbGFjZSB0aGUgRmllbGRQYXRoIENvbXBhdCBjbGFzcyB3aXRoIHdpdGggdGhlIGZpcmVzdG9yZS1leHBcclxuICAgIC8vIEZpZWxkUGF0aC5cclxuICAgIHBhdGggPSBnZXRNb2R1bGFySW5zdGFuY2UocGF0aCk7XHJcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnRmllbGQgcGF0aCBhcmd1bWVudHMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciAnO1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG1ldGhvZE5hbWUsIFxyXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWF0Y2hlcyBhbnkgY2hhcmFjdGVycyBpbiBhIGZpZWxkIHBhdGggc3RyaW5nIHRoYXQgYXJlIHJlc2VydmVkLlxyXG4gKi9cclxuY29uc3QgRklFTERfUEFUSF9SRVNFUlZFRCA9IG5ldyBSZWdFeHAoJ1t+XFxcXCovXFxcXFtcXFxcXV0nKTtcclxuLyoqXHJcbiAqIFdyYXBzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IHRoZSBtZXRob2QgdGhhdFxyXG4gKiB3YXMgdGhyb3duLlxyXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWNseSB2aXNpYmxlIG1ldGhvZCBuYW1lXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIGZvcm0gb2YgYSBmaWVsZCBwYXRoIHdoaWNoIHdpbGwgYmVcclxuICogc3BsaXQgb24gZG90cy5cclxuICogQHBhcmFtIHRhcmdldERvYyAtIFRoZSBkb2N1bWVudCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWVsZCBwYXRoIHdpbGwgYmVcclxuICogZXZhbHVhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcclxuICAgIGNvbnN0IGZvdW5kID0gcGF0aC5zZWFyY2goRklFTERfUEFUSF9SRVNFUlZFRCk7XHJcbiAgICBpZiAoZm91bmQgPj0gMCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIGAgK1xyXG4gICAgICAgICAgICBgJ34nLCAnKicsICcvJywgJ1snLCBvciAnXSdgLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoKC4uLnBhdGguc3BsaXQoJy4nKSkuX2ludGVybmFsUGF0aDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBgICtcclxuICAgICAgICAgICAgYGJlZ2luIHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2AsIG1ldGhvZE5hbWUsIFxyXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihyZWFzb24sIG1ldGhvZE5hbWUsIGhhc0NvbnZlcnRlciwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICBjb25zdCBoYXNQYXRoID0gcGF0aCAmJiAhcGF0aC5pc0VtcHR5KCk7XHJcbiAgICBjb25zdCBoYXNEb2N1bWVudCA9IHRhcmdldERvYyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIGNhbGxlZCB3aXRoIGludmFsaWQgZGF0YWA7XHJcbiAgICBpZiAoaGFzQ29udmVydGVyKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSAnICh2aWEgYHRvRmlyZXN0b3JlKClgKSc7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9ICcuICc7XHJcbiAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcclxuICAgIGlmIChoYXNQYXRoIHx8IGhhc0RvY3VtZW50KSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyAoZm91bmQnO1xyXG4gICAgICAgIGlmIChoYXNQYXRoKSB7XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZmllbGQgJHtwYXRofWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNEb2N1bWVudCkge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGRvY3VtZW50ICR7dGFyZ2V0RG9jfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcpJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlICsgcmVhc29uICsgZGVzY3JpcHRpb24pO1xyXG59XHJcbi8qKiBDaGVja3MgYGhheXN0YWNrYCBpZiBGaWVsZFBhdGggYG5lZWRsZWAgaXMgcHJlc2VudC4gUnVucyBpbiBPKG4pLiAqL1xyXG5mdW5jdGlvbiBmaWVsZE1hc2tDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICByZXR1cm4gaGF5c3RhY2suc29tZSh2ID0+IHYuaXNFcXVhbChuZWVkbGUpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxyXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cclxuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcclxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cclxuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U25hcHNob3QkMSB7XHJcbiAgICAvLyBOb3RlOiBUaGlzIGNsYXNzIGlzIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiB0aGUgRG9jdW1lbnRTbmFwc2hvdCBpblxyXG4gICAgLy8gdGhlIGxlZ2FjeSBTREsuIFRoZSBjaGFuZ2VzIGFyZTpcclxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RNZXRhZGF0YS5cclxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RPcHRpb25zLlxyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdXNlckRhdGFXcml0ZXIsIF9rZXksIF9kb2N1bWVudCwgX2NvbnZlcnRlcikge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdXNlckRhdGFXcml0ZXIgPSBfdXNlckRhdGFXcml0ZXI7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcclxuICAgICAgICB0aGlzLl9jb252ZXJ0ZXIgPSBfY29udmVydGVyO1xyXG4gICAgfVxyXG4gICAgLyoqIFByb3BlcnR5IG9mIHRoZSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwcm92aWRlcyB0aGUgZG9jdW1lbnQncyBJRC4gKi9cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBEb2N1bWVudFJlZmVyZW5jZWAgZm9yIHRoZSBkb2N1bWVudCBpbmNsdWRlZCBpbiB0aGUgYERvY3VtZW50U25hcHNob3RgLlxyXG4gICAgICovXHJcbiAgICBnZXQgcmVmKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl9jb252ZXJ0ZXIsIHRoaXMuX2tleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpZ25hbHMgd2hldGhlciBvciBub3QgdGhlIGRvY3VtZW50IGF0IHRoZSBzbmFwc2hvdCdzIGxvY2F0aW9uIGV4aXN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBkb2N1bWVudCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGV4aXN0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZlxyXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBvciBgdW5kZWZpbmVkYFxyXG4gICAgICogaWYgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxyXG4gICAgICAgICAgICAvLyBpZiBhIGNvbnZlcnRlciBoYXMgYmVlbiBwcm92aWRlZC5cclxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgdGhpcy5fa2V5LCB0aGlzLl9kb2N1bWVudCwgXHJcbiAgICAgICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0ZXIuZnJvbUZpcmVzdG9yZShzbmFwc2hvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHRoaXMuX2RvY3VtZW50LmRhdGEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBvciBmaWVsZCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCAoZm9yIGV4YW1wbGUgJ2Zvbycgb3IgJ2Zvby5iYXInKSB0byBhIHNwZWNpZmljXHJcbiAgICAgKiBmaWVsZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcclxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGdldChmaWVsZFBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnRG9jdW1lbnRTbmFwc2hvdC5nZXQnLCBmaWVsZFBhdGgpKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UgYXMgcGFydCBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdFxyXG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcclxuICogc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcclxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxyXG4gKiBgZXhpc3RzYCBwcm9wZXJ0eSB3aWxsIGFsd2F5cyBiZSB0cnVlIGFuZCBgZGF0YSgpYCB3aWxsIG5ldmVyIHJldHVyblxyXG4gKiAndW5kZWZpbmVkJy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCQxIGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCQxIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBgZnJvbURvdFNlcGFyYXRlZFN0cmluZygpYCBidXQgd3JhcHMgYW55IGVycm9yIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudChtZXRob2ROYW1lLCBhcmcpIHtcclxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGFyZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gYXJnLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXJnLl9kZWxlZ2F0ZS5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSGFzRXhwbGljaXRPcmRlckJ5Rm9yTGltaXRUb0xhc3QocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5saW1pdFR5cGUgPT09IFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovICYmXHJcbiAgICAgICAgcXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOSU1QTEVNRU5URUQsICdsaW1pdFRvTGFzdCgpIHF1ZXJpZXMgcmVxdWlyZSBzcGVjaWZ5aW5nIGF0IGxlYXN0IG9uZSBvcmRlckJ5KCkgY2xhdXNlJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGBBcHBsaWFibGVDb25zdHJhaW50YCBpcyBhbiBhYnN0cmFjdGlvbiBvZiBhIGNvbnN0cmFpbnQgdGhhdCBjYW4gYmUgYXBwbGllZFxyXG4gKiB0byBhIEZpcmVzdG9yZSBxdWVyeS5cclxuICovXHJcbmNsYXNzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSxcclxuICoge0BsaW5rIG9yZGVyQnl9LCB7QGxpbmsgKHN0YXJ0QXQ6MSl9LCB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9LCB7QGxpbmtcclxuICogKGVuZEJlZm9yZToxKX0sIHtAbGluayAoZW5kQXQ6MSl9LCB7QGxpbmsgbGltaXR9LCB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxyXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcclxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb25zdHJhaW50IGV4dGVuZHMgQXBwbGlhYmxlQ29uc3RyYWludCB7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnkocXVlcnksIHF1ZXJ5Q29uc3RyYWludCwgLi4uYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIGxldCBxdWVyeUNvbnN0cmFpbnRzID0gW107XHJcbiAgICBpZiAocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgQXBwbGlhYmxlQ29uc3RyYWludCkge1xyXG4gICAgICAgIHF1ZXJ5Q29uc3RyYWludHMucHVzaChxdWVyeUNvbnN0cmFpbnQpO1xyXG4gICAgfVxyXG4gICAgcXVlcnlDb25zdHJhaW50cyA9IHF1ZXJ5Q29uc3RyYWludHMuY29uY2F0KGFkZGl0aW9uYWxRdWVyeUNvbnN0cmFpbnRzKTtcclxuICAgIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50cyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5ID0gY29uc3RyYWludC5fYXBwbHkocXVlcnkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5O1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcclxuICogYSBGaXJlc3RvcmUgcXVlcnkgYnkgZmlsdGVyaW5nIG9uIG9uZSBvciBtb3JlIGRvY3VtZW50IGZpZWxkcy5cclxuICogYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSBhbmQgY2FuIHRoZW5cclxuICogYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnNcclxuICogdGhpcyBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XHJcbiAgICAgICAgdGhpcy5fb3AgPSBfb3A7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICd3aGVyZSc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZShfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludChfZmllbGQsIF9vcCwgX3ZhbHVlKTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX3BhcnNlKHF1ZXJ5KTtcclxuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcikpO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBuZXdRdWVyeUZpbHRlcihxdWVyeS5fcXVlcnksICd3aGVyZScsIHJlYWRlciwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCB0aGlzLl9maWVsZCwgdGhpcy5fb3AsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGVuZm9yY2VzIHRoYXQgZG9jdW1lbnRzXHJcbiAqIG11c3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFuZCB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgc2F0aXNmeSB0aGVcclxuICogcmVsYXRpb24gY29uc3RyYWludCBwcm92aWRlZC5cclxuICpcclxuICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIHRvIGNvbXBhcmVcclxuICogQHBhcmFtIG9wU3RyIC0gVGhlIG9wZXJhdGlvbiBzdHJpbmcgKGUuZyBcIiZsdDtcIiwgXCImbHQ7PVwiLCBcIj09XCIsIFwiJmx0O1wiLFxyXG4gKiAgIFwiJmx0Oz1cIiwgXCIhPVwiKS5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciBjb21wYXJpc29uXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0uXHJcbiAqL1xyXG5mdW5jdGlvbiB3aGVyZShmaWVsZFBhdGgsIG9wU3RyLCB2YWx1ZSkge1xyXG4gICAgY29uc3Qgb3AgPSBvcFN0cjtcclxuICAgIGNvbnN0IGZpZWxkID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50KCd3aGVyZScsIGZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShmaWVsZCwgb3AsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50c1xyXG4gKiByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeSBieSBwZXJmb3JtaW5nIHRoZSBsb2dpY2FsIE9SIG9yIEFORCBvZiBtdWx0aXBsZVxyXG4gKiB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9cyBvciB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fXMuXHJcbiAqIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgb3J9IG9yXHJcbiAqIHtAbGluayBhbmR9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XHJcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGUgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBBcHBsaWFibGVDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlDb25zdHJhaW50cyA9IF9xdWVyeUNvbnN0cmFpbnRzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCh0eXBlLCBfcXVlcnlDb25zdHJhaW50cyk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzID0gdGhpcy5fcXVlcnlDb25zdHJhaW50c1xyXG4gICAgICAgICAgICAubWFwKHF1ZXJ5Q29uc3RyYWludCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUNvbnN0cmFpbnQuX3BhcnNlKHF1ZXJ5KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKHBhcnNlZEZpbHRlciA9PiBwYXJzZWRGaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRmlsdGVyc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocGFyc2VkRmlsdGVycywgdGhpcy5fZ2V0T3BlcmF0b3IoKSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXIgPSB0aGlzLl9wYXJzZShxdWVyeSk7XHJcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlci5nZXRGaWx0ZXJzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZXhpc3RpbmcgcXVlcnkgaWYgbm90IGFkZGluZyBhbnkgbW9yZSBmaWx0ZXJzIChlLmcuIGFuIGVtcHR5XHJcbiAgICAgICAgICAgIC8vIGNvbXBvc2l0ZSBmaWx0ZXIpLlxyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgcGFyc2VkRmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcikpO1xyXG4gICAgfVxyXG4gICAgX2dldFF1ZXJ5Q29uc3RyYWludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHM7XHJcbiAgICB9XHJcbiAgICBfZ2V0T3BlcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FuZCcgPyBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLyA6IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgZGlzanVuY3Rpb24gb2ZcclxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBkaXNqdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxyXG4gKiBzYXRpc2ZpZXMgYW55IG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxyXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGRpc2p1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxyXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXHJcbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3IoLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgLy8gT25seSBzdXBwb3J0IFF1ZXJ5RmlsdGVyQ29uc3RyYWludHNcclxuICAgIHF1ZXJ5Q29uc3RyYWludHMuZm9yRWFjaChxdWVyeUNvbnN0cmFpbnQgPT4gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoJ29yJywgcXVlcnlDb25zdHJhaW50KSk7XHJcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovLCBxdWVyeUNvbnN0cmFpbnRzKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgY29uanVuY3Rpb24gb2ZcclxuICogdGhlIGdpdmVuIGZpbHRlciBjb25zdHJhaW50cy4gQSBjb25qdW5jdGlvbiBmaWx0ZXIgaW5jbHVkZXMgYSBkb2N1bWVudCBpZiBpdFxyXG4gKiBzYXRpc2ZpZXMgYWxsIG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIE9wdGlvbmFsLiBUaGUgbGlzdCBvZlxyXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGNvbmp1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxyXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXHJcbiAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHtAbGluayBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gYW5kKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXHJcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdhbmQnLCBxdWVyeUNvbnN0cmFpbnQpKTtcclxuICAgIHJldHVybiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLywgcXVlcnlDb25zdHJhaW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gc29ydCB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXHJcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZ1xyXG4gKiB7QGxpbmsgb3JkZXJCeX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcclxuICogaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgLlxyXG4gKlxyXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgb3JkZXJCeSBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50IGluXHJcbiAqIHRoZSBxdWVyeSByZXN1bHQuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeU9yZGVyQnlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maWVsZCwgX2RpcmVjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnknO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDb25zdHJhaW50KF9maWVsZCwgX2RpcmVjdGlvbik7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBvcmRlckJ5ID0gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fZmllbGQsIHRoaXMuX2RpcmVjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgb3JkZXJCeSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9IHRoYXQgc29ydHMgdGhlIHF1ZXJ5IHJlc3VsdCBieSB0aGVcclxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXHJcbiAqXHJcbiAqIE5vdGU6IERvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgd2lsbCBub3QgYmUgcHJlc2VudFxyXG4gKiBpbiB0aGUgcXVlcnkgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIGZpZWxkIHRvIHNvcnQgYnkuXHJcbiAqIEBwYXJhbSBkaXJlY3Rpb25TdHIgLSBPcHRpb25hbCBkaXJlY3Rpb24gdG8gc29ydCBieSAoJ2FzYycgb3IgJ2Rlc2MnKS4gSWZcclxuICogbm90IHNwZWNpZmllZCwgb3JkZXIgd2lsbCBiZSBhc2NlbmRpbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeU9yZGVyQnlDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnkoZmllbGRQYXRoLCBkaXJlY3Rpb25TdHIgPSAnYXNjJykge1xyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyO1xyXG4gICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnb3JkZXJCeScsIGZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gUXVlcnlPcmRlckJ5Q29uc3RyYWludC5fY3JlYXRlKHBhdGgsIGRpcmVjdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5TGltaXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XHJcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5LlxyXG4gKiBgUXVlcnlMaW1pdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgbGltaXR9IG9yXHJcbiAqIHtAbGluayBsaW1pdFRvTGFzdH0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcclxuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5TGltaXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5TGltaXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgICAgIHRoaXMuX2xpbWl0VHlwZSA9IF9saW1pdFR5cGU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRDb25zdHJhaW50KHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhMaW1pdChxdWVyeS5fcXVlcnksIHRoaXMuX2xpbWl0LCB0aGlzLl9saW1pdFR5cGUpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nXHJcbiAqIGRvY3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0KGxpbWl0KSB7XHJcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdCcsIGxpbWl0KTtcclxuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdCcsIGxpbWl0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgbGFzdCBtYXRjaGluZ1xyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIFlvdSBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGBvcmRlckJ5YCBjbGF1c2UgZm9yIGBsaW1pdFRvTGFzdGAgcXVlcmllcyxcclxuICogb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBkdXJpbmcgZXhlY3V0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuLlxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoJ2xpbWl0VG9MYXN0JywgbGltaXQpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5TGltaXRDb25zdHJhaW50Ll9jcmVhdGUoJ2xpbWl0VG9MYXN0JywgbGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlTdGFydEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhXHJcbiAqIHJlc3VsdCBzZXQgcmV0dXJuZWQgYnkgYSBGaXJlc3RvcmUgcXVlcnkuXHJcbiAqIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChzdGFydEF0OjEpfSBvclxyXG4gKiB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGFcclxuICogbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXHJcbiAgICB0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fZG9jT3JGaWVsZHMgPSBfZG9jT3JGaWVsZHM7XHJcbiAgICAgICAgdGhpcy5faW5jbHVzaXZlID0gX2luY2x1c2l2ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0QXQoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBRdWVyeVN0YXJ0QXRDb25zdHJhaW50Ll9jcmVhdGUoJ3N0YXJ0QXQnLCBkb2NPckZpZWxkcywgXHJcbiAgICAvKmluY2x1c2l2ZT0qLyB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBzdGFydEFmdGVyKC4uLmRvY09yRmllbGRzKSB7XHJcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEFmdGVyJywgZG9jT3JGaWVsZHMsIFxyXG4gICAgLyppbmNsdXNpdmU9Ki8gZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUVuZEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBlbmQgb2YgYVxyXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxyXG4gKiBgUXVlcnlFbmRBdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgKGVuZEF0OjEpfSBvclxyXG4gKiB7QGxpbmsgKGVuZEJlZm9yZToxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcclxuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5RW5kQXRDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xyXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xyXG4gICAgICAgIHRoaXMuX2luY2x1c2l2ZSA9IF9pbmNsdXNpdmU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBib3VuZCA9IG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIHRoaXMudHlwZSwgdGhpcy5fZG9jT3JGaWVsZHMsIHRoaXMuX2luY2x1c2l2ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoRW5kQXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuZEJlZm9yZSguLi5kb2NPckZpZWxkcykge1xyXG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEJlZm9yZScsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBlbmRBdCguLi5kb2NPckZpZWxkcykge1xyXG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEF0JywgZG9jT3JGaWVsZHMsIFxyXG4gICAgLyppbmNsdXNpdmU9Ki8gdHJ1ZSk7XHJcbn1cclxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBib3VuZCBmcm9tIGEgZG9jdW1lbnQgb3IgZmllbGRzICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzLCBpbmNsdXNpdmUpIHtcclxuICAgIGRvY09yRmllbGRzWzBdID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY09yRmllbGRzWzBdKTtcclxuICAgIGlmIChkb2NPckZpZWxkc1swXSBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QkMSkge1xyXG4gICAgICAgIHJldHVybiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5Ll9xdWVyeSwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2NPckZpZWxkc1swXS5fZG9jdW1lbnQsIGluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihxdWVyeS5maXJlc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgcmVhZGVyLCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdRdWVyeUZpbHRlcihxdWVyeSwgbWV0aG9kTmFtZSwgZGF0YVJlYWRlciwgZGF0YWJhc2VJZCwgZmllbGRQYXRoLCBvcCwgdmFsdWUpIHtcclxuICAgIGxldCBmaWVsZFZhbHVlO1xyXG4gICAgaWYgKGZpZWxkUGF0aC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fCBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgUXVlcnkuIFlvdSBjYW4ndCBwZXJmb3JtICcke29wfScgcXVlcmllcyBvbiBkb2N1bWVudElkKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRGlzanVuY3RpdmVGaWx0ZXJFbGVtZW50cyh2YWx1ZSwgb3ApO1xyXG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VMaXN0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTGlzdC5wdXNoKHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCBhcnJheVZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXM6IHJlZmVyZW5jZUxpc3QgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHxcclxuICAgICAgICAgICAgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovIHx8XHJcbiAgICAgICAgICAgIG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZSwgXHJcbiAgICAgICAgLyogYWxsb3dBcnJheXM9ICovIG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbHRlciA9IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWVsZFBhdGgsIG9wLCBmaWVsZFZhbHVlKTtcclxuICAgIHJldHVybiBmaWx0ZXI7XHJcbn1cclxuZnVuY3Rpb24gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5LCBmaWVsZFBhdGgsIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgIT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgc3RhcnRBdCgpIG9yIHN0YXJ0QWZ0ZXIoKSBiZWZvcmUgJyArXHJcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5lbmRBdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBlbmRBdCgpIG9yIGVuZEJlZm9yZSgpIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ2NhbGxpbmcgb3JkZXJCeSgpLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3JkZXJCeSA9IG5ldyBPcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uKTtcclxuICAgIHJldHVybiBvcmRlckJ5O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBgQm91bmRgIGZyb20gYSBxdWVyeSBhbmQgYSBkb2N1bWVudC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBgQm91bmRgIHdpbGwgYWx3YXlzIGluY2x1ZGUgdGhlIGtleSBvZiB0aGUgZG9jdW1lbnRcclxuICogYW5kIHNvIG9ubHkgdGhlIHByb3ZpZGVkIGRvY3VtZW50IHdpbGwgY29tcGFyZSBlcXVhbCB0byB0aGUgcmV0dXJuZWRcclxuICogcG9zaXRpb24uXHJcbiAqXHJcbiAqIFdpbGwgdGhyb3cgaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGNvbnRhaW4gYWxsIGZpZWxkcyBvZiB0aGUgb3JkZXIgYnlcclxuICogb2YgdGhlIHF1ZXJ5IG9yIGlmIGFueSBvZiB0aGUgZmllbGRzIGluIHRoZSBvcmRlciBieSBhcmUgYW4gdW5jb21taXR0ZWRcclxuICogc2VydmVyIHRpbWVzdGFtcC5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jdW1lbnQocXVlcnksIGRhdGFiYXNlSWQsIG1ldGhvZE5hbWUsIGRvYywgaW5jbHVzaXZlKSB7XHJcbiAgICBpZiAoIWRvYykge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLk5PVF9GT1VORCwgYENhbid0IHVzZSBhIERvY3VtZW50U25hcHNob3QgdGhhdCBkb2Vzbid0IGV4aXN0IGZvciBgICtcclxuICAgICAgICAgICAgYCR7bWV0aG9kTmFtZX0oKS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcclxuICAgIC8vIEJlY2F1c2UgcGVvcGxlIGV4cGVjdCB0byBjb250aW51ZS9lbmQgYSBxdWVyeSBhdCB0aGUgZXhhY3QgZG9jdW1lbnRcclxuICAgIC8vIHByb3ZpZGVkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgaW1wbGljaXQgc29ydCBvcmRlciByYXRoZXIgdGhhbiB0aGUgZXhwbGljaXRcclxuICAgIC8vIHNvcnQgb3JkZXIsIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGNvbnRhaW4gdGhlIGRvY3VtZW50IGtleS4gVGhhdCB3YXlcclxuICAgIC8vIHRoZSBwb3NpdGlvbiBiZWNvbWVzIHVuYW1iaWd1b3VzIGFuZCB0aGUgcXVlcnkgY29udGludWVzL2VuZHMgZXhhY3RseSBhdFxyXG4gICAgLy8gdGhlIHByb3ZpZGVkIGRvY3VtZW50LiBXaXRob3V0IHRoZSBrZXkgKGJ5IHVzaW5nIHRoZSBleHBsaWNpdCBzb3J0XHJcbiAgICAvLyBvcmRlcnMpLCBtdWx0aXBsZSBkb2N1bWVudHMgY291bGQgbWF0Y2ggdGhlIHBvc2l0aW9uLCB5aWVsZGluZyBkdXBsaWNhdGVcclxuICAgIC8vIHJlc3VsdHMuXHJcbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcclxuICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGRvYy5rZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeS5maWVsZCk7XHJcbiAgICAgICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkIFwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeS5maWVsZCArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGlzIGFuIHVuY29tbWl0dGVkIHNlcnZlciB0aW1lc3RhbXAuIChTaW5jZSB0aGUgdmFsdWUgb2YgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3RoaXMgZmllbGQgaXMgdW5rbm93biwgeW91IGNhbm5vdCBzdGFydC9lbmQgYSBxdWVyeSB3aXRoIGl0LiknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkICcke2ZpZWxkfScgKHVzZWQgYXMgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBvcmRlckJ5KSBkb2VzIG5vdCBleGlzdC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYSBsaXN0IG9mIGZpZWxkIHZhbHVlcyB0byBhIGBCb3VuZGAgZm9yIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRmllbGRzKHF1ZXJ5LCBkYXRhYmFzZUlkLCBkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZXMsIGluY2x1c2l2ZSkge1xyXG4gICAgLy8gVXNlIGV4cGxpY2l0IG9yZGVyIGJ5J3MgYmVjYXVzZSBpdCBoYXMgdG8gbWF0Y2ggdGhlIHF1ZXJ5IHRoZSB1c2VyIG1hZGVcclxuICAgIGNvbnN0IG9yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnk7XHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IG9yZGVyQnkubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCB0byAke21ldGhvZE5hbWV9KCkuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIG51bWJlciBvZiBhcmd1bWVudHMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGAgK1xyXG4gICAgICAgICAgICBgbnVtYmVyIG9mIG9yZGVyQnkoKSBjbGF1c2VzYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIEV4cGVjdGVkIGEgc3RyaW5nIGZvciBkb2N1bWVudCBJRCBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHttZXRob2ROYW1lfSgpLCBidXQgZ290IGEgJHt0eXBlb2YgcmF3VmFsdWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiByYXdWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYW5kIG9yZGVyaW5nIGJ5IGRvY3VtZW50SWQoKSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgYmUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAnJHtyYXdWYWx1ZX0nIGNvbnRhaW5zIGEgc2xhc2guYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmF3VmFsdWUpKTtcclxuICAgICAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYW5kIG9yZGVyaW5nIGJ5IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgcmVzdWx0IGluIGEgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHZhbGlkIGRvY3VtZW50IHBhdGgsIGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgY29udGFpbnMgYW4gb2RkIG51bWJlciBgICtcclxuICAgICAgICAgICAgICAgICAgICBgb2Ygc2VnbWVudHMuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHBhdGgpO1xyXG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gocmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gcGFyc2VRdWVyeVZhbHVlKGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHdyYXBwZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogUGFyc2VzIHRoZSBnaXZlbiBgZG9jdW1lbnRJZFZhbHVlYCBpbnRvIGEgYFJlZmVyZW5jZVZhbHVlYCwgdGhyb3dpbmdcclxuICogYXBwcm9wcmlhdGUgZXJyb3JzIGlmIHRoZSB2YWx1ZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgYERvY3VtZW50UmVmZXJlbmNlYFxyXG4gKiBvciBgc3RyaW5nYCwgb3IgaWYgdGhlIHN0cmluZyBpcyBtYWxmb3JtZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgZG9jdW1lbnRJZFZhbHVlKSB7XHJcbiAgICBkb2N1bWVudElkVmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jdW1lbnRJZFZhbHVlKTtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZFZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChkb2N1bWVudElkVmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIHdpdGggZG9jdW1lbnRJZCgpLCB5b3UgJyArXHJcbiAgICAgICAgICAgICAgICAnbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9jdW1lbnQgSUQsIGJ1dCBpdCB3YXMgYW4gZW1wdHkgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpICYmIGRvY3VtZW50SWRWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBieSBgICtcclxuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgYCcke2RvY3VtZW50SWRWYWx1ZX0nIGNvbnRhaW5zIGEgJy8nIGNoYXJhY3Rlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoZG9jdW1lbnRJZFZhbHVlKSk7XHJcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBieSBgICtcclxuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwcm92aWRlZCBtdXN0IHJlc3VsdCBpbiBhIHZhbGlkIGRvY3VtZW50IHBhdGgsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgaGFzIGFuIG9kZCBudW1iZXIgb2Ygc2VnbWVudHMgKCR7cGF0aC5sZW5ndGh9KS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKGRhdGFiYXNlSWQsIG5ldyBEb2N1bWVudEtleShwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudElkVmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2N1bWVudElkVmFsdWUuX2tleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHZhbGlkIGAgK1xyXG4gICAgICAgICAgICBgc3RyaW5nIG9yIGEgRG9jdW1lbnRSZWZlcmVuY2UsIGJ1dCBpdCB3YXM6IGAgK1xyXG4gICAgICAgICAgICBgJHt2YWx1ZURlc2NyaXB0aW9uKGRvY3VtZW50SWRWYWx1ZSl9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGludG8gYSBkaXNqdW5jdGl2ZSBmaWx0ZXIgc2F0aXNmaWVzIGFsbFxyXG4gKiBhcnJheSByZXF1aXJlbWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wZXJhdG9yKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIFF1ZXJ5LiBBIG5vbi1lbXB0eSBhcnJheSBpcyByZXF1aXJlZCBmb3IgJyArXHJcbiAgICAgICAgICAgIGAnJHtvcGVyYXRvci50b1N0cmluZygpfScgZmlsdGVycy5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYW4gb3BlcmF0b3IsIHJldHVybnMgdGhlIHNldCBvZiBvcGVyYXRvcnMgdGhhdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGl0LlxyXG4gKlxyXG4gKiBUaGlzIGlzIG5vdCBhIGNvbXByZWhlbnNpdmUgY2hlY2ssIGFuZCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSByZW1vdmVkIGluIHRoZVxyXG4gKiBsb25nIHRlcm0uIFZhbGlkYXRpb25zIHNob3VsZCBvY2N1ciBpbiB0aGUgRmlyZXN0b3JlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIE9wZXJhdG9ycyBpbiBhIHF1ZXJ5IG11c3QgYWRoZXJlIHRvIHRoZSBmb2xsb3dpbmcgc2V0IG9mIHJ1bGVzOlxyXG4gKiAxLiBPbmx5IG9uZSBpbmVxdWFsaXR5IHBlciBxdWVyeS5cclxuICogMi4gYE5PVF9JTmAgY2Fubm90IGJlIHVzZWQgd2l0aCBhcnJheSwgZGlzanVuY3RpdmUsIG9yIGBOT1RfRVFVQUxgIG9wZXJhdG9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbmZsaWN0aW5nT3BzKG9wKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXTtcclxuICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxyXG4gICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxyXG4gICAgICAgICAgICByZXR1cm4gW1wibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXTtcclxuICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sXHJcbiAgICAgICAgICAgICAgICBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sXHJcbiAgICAgICAgICAgICAgICBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyxcclxuICAgICAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVOZXdGaWVsZEZpbHRlcihxdWVyeSwgZmllbGRGaWx0ZXIpIHtcclxuICAgIGNvbnN0IGNvbmZsaWN0aW5nT3AgPSBmaW5kT3BJbnNpZGVGaWx0ZXJzKHF1ZXJ5LmZpbHRlcnMsIGNvbmZsaWN0aW5nT3BzKGZpZWxkRmlsdGVyLm9wKSk7XHJcbiAgICBpZiAoY29uZmxpY3RpbmdPcCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGl0J3MgYSBkdXBsaWNhdGUgb3AgdG8gZ2l2ZSBhIHNsaWdodGx5IGNsZWFyZXIgZXJyb3IgbWVzc2FnZS5cclxuICAgICAgICBpZiAoY29uZmxpY3RpbmdPcCA9PT0gZmllbGRGaWx0ZXIub3ApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgJyArXHJcbiAgICAgICAgICAgICAgICBgJyR7ZmllbGRGaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSAnJHtmaWVsZEZpbHRlci5vcC50b1N0cmluZygpfScgZmlsdGVycyBgICtcclxuICAgICAgICAgICAgICAgIGB3aXRoICcke2NvbmZsaWN0aW5nT3AudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgIGxldCB0ZXN0UXVlcnkgPSBxdWVyeTtcclxuICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xyXG4gICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2Ygc3ViRmlsdGVycykge1xyXG4gICAgICAgIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIodGVzdFF1ZXJ5LCBzdWJGaWx0ZXIpO1xyXG4gICAgICAgIHRlc3RRdWVyeSA9IHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcclxuICAgIH1cclxufVxyXG4vLyBDaGVja3MgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBmaWx0ZXIgb3BlcmF0b3JzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWx0ZXJzIGFuZFxyXG4vLyByZXR1cm5zIHRoZSBmaXJzdCBvbmUgdGhhdCBpcywgb3IgbnVsbCBpZiBub25lIGFyZS5cclxuZnVuY3Rpb24gZmluZE9wSW5zaWRlRmlsdGVycyhmaWx0ZXJzLCBvcGVyYXRvcnMpIHtcclxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpIHtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGZpZWxkRmlsdGVyLm9wKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXIub3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludChmdW5jdGlvbk5hbWUsIHF1ZXJ5Q29uc3RyYWludCkge1xyXG4gICAgaWYgKCEocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQpICYmXHJcbiAgICAgICAgIShxdWVyeUNvbnN0cmFpbnQgaW5zdGFuY2VvZiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIEFwcGxpYWJsZUNvbnN0cmFpbnRzIGNyZWF0ZWQgd2l0aCBhIGNhbGwgdG8gJ3doZXJlKC4uLiknLCAnb3IoLi4uKScsIG9yICdhbmQoLi4uKScuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUNvbnN0cmFpbnRBcnJheShxdWVyeUNvbnN0cmFpbnQpIHtcclxuICAgIGNvbnN0IGNvbXBvc2l0ZUZpbHRlckNvdW50ID0gcXVlcnlDb25zdHJhaW50LmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyIGluc3RhbmNlb2YgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KS5sZW5ndGg7XHJcbiAgICBjb25zdCBmaWVsZEZpbHRlckNvdW50ID0gcXVlcnlDb25zdHJhaW50LmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyIGluc3RhbmNlb2YgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQpLmxlbmd0aDtcclxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJDb3VudCA+IDEgfHxcclxuICAgICAgICAoY29tcG9zaXRlRmlsdGVyQ291bnQgPiAwICYmIGZpZWxkRmlsdGVyQ291bnQgPiAwKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkUXVlcnkuIFdoZW4gdXNpbmcgY29tcG9zaXRlIGZpbHRlcnMsIHlvdSBjYW5ub3QgdXNlICcgK1xyXG4gICAgICAgICAgICAnbW9yZSB0aGFuIG9uZSBmaWx0ZXIgYXQgdGhlIHRvcCBsZXZlbC4gQ29uc2lkZXIgbmVzdGluZyB0aGUgbXVsdGlwbGUgJyArXHJcbiAgICAgICAgICAgICdmaWx0ZXJzIHdpdGhpbiBhbiBgYW5kKC4uLilgIHN0YXRlbWVudC4gRm9yIGV4YW1wbGU6ICcgK1xyXG4gICAgICAgICAgICAnY2hhbmdlIGBxdWVyeShxdWVyeSwgd2hlcmUoLi4uKSwgb3IoLi4uKSlgIHRvICcgK1xyXG4gICAgICAgICAgICAnYHF1ZXJ5KHF1ZXJ5LCBhbmQod2hlcmUoLi4uKSwgb3IoLi4uKSkpYC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29udmVydHMgRmlyZXN0b3JlJ3MgaW50ZXJuYWwgdHlwZXMgdG8gdGhlIEphdmFTY3JpcHQgdHlwZXMgdGhhdCB3ZSBleHBvc2VcclxuICogdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XHJcbiAgICBjb252ZXJ0VmFsdWUodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yID0gJ25vbmUnKSB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlT3JkZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJvb2xlYW5WYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVOdW1iZXIodmFsdWUuaW50ZWdlclZhbHVlIHx8IHZhbHVlLmRvdWJsZVZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAodmFsdWUudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlO1xyXG4gICAgICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRCeXRlcyhub3JtYWxpemVCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpKTtcclxuICAgICAgICAgICAgY2FzZSA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0R2VvUG9pbnQodmFsdWUuZ2VvUG9pbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRBcnJheSh2YWx1ZS5hcnJheVZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XHJcbiAgICAgICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdCh2YWx1ZS5tYXBWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnZlcnRPYmplY3QobWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdE1hcChtYXBWYWx1ZS5maWVsZHMsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRPYmplY3RNYXAoZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGZvckVhY2goZmllbGRzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNvbnZlcnRHZW9Qb2ludCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR2VvUG9pbnQobm9ybWFsaXplTnVtYmVyKHZhbHVlLmxhdGl0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHZhbHVlLmxvbmdpdHVkZSkpO1xyXG4gICAgfVxyXG4gICAgY29udmVydEFycmF5KGFycmF5VmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgcmV0dXJuIChhcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkubWFwKHZhbHVlID0+IHRoaXMuY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikpO1xyXG4gICAgfVxyXG4gICAgY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcclxuICAgICAgICBzd2l0Y2ggKHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRWYWx1ZShwcmV2aW91c1ZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VzdGltYXRlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAoZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnZlcnRUaW1lc3RhbXAodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKG5vcm1hbGl6ZWRWYWx1ZS5zZWNvbmRzLCBub3JtYWxpemVkVmFsdWUubmFub3MpO1xyXG4gICAgfVxyXG4gICAgY29udmVydERvY3VtZW50S2V5KG5hbWUsIGV4cGVjdGVkRGF0YWJhc2VJZCkge1xyXG4gICAgICAgIGNvbnN0IHJlc291cmNlUGF0aCA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoaXNWYWxpZFJlc291cmNlTmFtZShyZXNvdXJjZVBhdGgpKTtcclxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gbmV3IERhdGFiYXNlSWQocmVzb3VyY2VQYXRoLmdldCgxKSwgcmVzb3VyY2VQYXRoLmdldCgzKSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHJlc291cmNlUGF0aC5wb3BGaXJzdCg1KSk7XHJcbiAgICAgICAgaWYgKCFkYXRhYmFzZUlkLmlzRXF1YWwoZXhwZWN0ZWREYXRhYmFzZUlkKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPKGIvNjQxMzAyMDIpOiBTb21laG93IHN1cHBvcnQgZm9yZWlnbiByZWZlcmVuY2VzLlxyXG4gICAgICAgICAgICBsb2dFcnJvcihgRG9jdW1lbnQgJHtrZXl9IGNvbnRhaW5zIGEgZG9jdW1lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgcmVmZXJlbmNlIHdpdGhpbiBhIGRpZmZlcmVudCBkYXRhYmFzZSAoYCArXHJcbiAgICAgICAgICAgICAgICBgJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vJHtkYXRhYmFzZUlkLmRhdGFiYXNlfSkgd2hpY2ggaXMgbm90IGAgK1xyXG4gICAgICAgICAgICAgICAgYHN1cHBvcnRlZC4gSXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVmZXJlbmNlIGluIHRoZSBjdXJyZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYGRhdGFiYXNlICgke2V4cGVjdGVkRGF0YWJhc2VJZC5wcm9qZWN0SWR9LyR7ZXhwZWN0ZWREYXRhYmFzZUlkLmRhdGFiYXNlfSkgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29udmVydHMgY3VzdG9tIG1vZGVsIG9iamVjdCBvZiB0eXBlIFQgaW50byBgRG9jdW1lbnREYXRhYCBieSBhcHBseWluZyB0aGVcclxuICogY29udmVydGVyIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gY29udmVydGluZyB1c2VyIG9iamVjdHMgdG8gYERvY3VtZW50RGF0YWBcclxuICogYmVjYXVzZSB3ZSB3YW50IHRvIHByb3ZpZGUgdGhlIHVzZXIgd2l0aCBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSBpZlxyXG4gKiB0aGVpciBgc2V0KClgIG9yIGZhaWxzIGR1ZSB0byBpbnZhbGlkIGRhdGEgb3JpZ2luYXRpbmcgZnJvbSBhIGB0b0ZpcmVzdG9yZSgpYFxyXG4gKiBjYWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKGNvbnZlcnRlciwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcclxuICAgIGlmIChjb252ZXJ0ZXIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5tZXJnZSB8fCBvcHRpb25zLm1lcmdlRmllbGRzKSkge1xyXG4gICAgICAgICAgICAvLyBDYXN0IHRvIGBhbnlgIGluIG9yZGVyIHRvIHNhdGlzZnkgdGhlIHVuaW9uIHR5cGUgY29uc3RyYWludCBvblxyXG4gICAgICAgICAgICAvLyB0b0ZpcmVzdG9yZSgpLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udmVydGVkVmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcclxufVxyXG5jbGFzcyBMaXRlVXNlckRhdGFXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0Qnl0ZXMoYnl0ZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKGJ5dGVzKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRSZWZlcmVuY2UobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY29udmVydERvY3VtZW50S2V5KG5hbWUsIHRoaXMuZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBZ2dyZWdhdGVGaWVsZCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBzdW0gb2ZcclxuICogYSBzcGVjaWZpZWQgZmllbGQgb3ZlciBhIHJhbmdlIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxyXG4gKiBAcGFyYW0gZmllbGQgU3BlY2lmaWVzIHRoZSBmaWVsZCB0byBzdW0gYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3VtKGZpZWxkKSB7XHJcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdzdW0nLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQkMSgnc3VtJywgZmllbGQpKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGF2ZXJhZ2Ugb2ZcclxuICogYSBzcGVjaWZpZWQgZmllbGQgb3ZlciBhIHJhbmdlIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxyXG4gKiBAcGFyYW0gZmllbGQgU3BlY2lmaWVzIHRoZSBmaWVsZCB0byBhdmVyYWdlIGFjcm9zcyB0aGUgcmVzdWx0IHNldC5cclxuICovXHJcbmZ1bmN0aW9uIGF2ZXJhZ2UoZmllbGQpIHtcclxuICAgIHJldHVybiBuZXcgQWdncmVnYXRlRmllbGQoJ2F2ZycsIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKCdhdmVyYWdlJywgZmllbGQpKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvdW50IG9mXHJcbiAqIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdjb3VudCcpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gJ0FnZ3JlZ2F0ZUZpZWxkYCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCBDb21wYXJlIHRoaXMgQWdncmVnYXRlRmllbGQgdG8gdGhlIGByaWdodGAuXHJcbiAqIEBwYXJhbSByaWdodCBDb21wYXJlIHRoaXMgQWdncmVnYXRlRmllbGQgdG8gdGhlIGBsZWZ0YC5cclxuICovXHJcbmZ1bmN0aW9uIGFnZ3JlZ2F0ZUZpZWxkRXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKGxlZnQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVGaWVsZCAmJlxyXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQWdncmVnYXRlRmllbGQgJiZcclxuICAgICAgICBsZWZ0LmFnZ3JlZ2F0ZVR5cGUgPT09IHJpZ2h0LmFnZ3JlZ2F0ZVR5cGUgJiZcclxuICAgICAgICAoKF9hID0gbGVmdC5faW50ZXJuYWxGaWVsZFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5vbmljYWxTdHJpbmcoKSkgPT09XHJcbiAgICAgICAgICAgICgoX2IgPSByaWdodC5faW50ZXJuYWxGaWVsZFBhdGgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5vbmljYWxTdHJpbmcoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBmb3IgZXF1YWxpdHkuXHJcbiAqXHJcbiAqIFR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGFyZSBjb25zaWRlcmVkIFwiZXF1YWxcIiBpZiB0aGV5IGhhdmVcclxuICogdW5kZXJseWluZyBxdWVyaWVzIHRoYXQgY29tcGFyZSBlcXVhbCwgYW5kIHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWZ0IC0gVGhlIGZpcnN0IGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0gcmlnaHQgLSBUaGUgc2Vjb25kIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byBjb21wYXJlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIFwiZXF1YWxcIiwgYXMgZGVmaW5lZCBhYm92ZSwgb3IgYGZhbHNlYFxyXG4gKiBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZ2dyZWdhdGVRdWVyeVNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiAocXVlcnlFcXVhbChsZWZ0LnF1ZXJ5LCByaWdodC5xdWVyeSkgJiYgZGVlcEVxdWFsKGxlZnQuZGF0YSgpLCByaWdodC5kYXRhKCkpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BhcnRpYWxPYnNlcnZlcihvYmopIHtcclxuICAgIHJldHVybiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIFsnbmV4dCcsICdlcnJvcicsICdjb21wbGV0ZSddKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhbiBvYmplY3QgYW5kIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBvZiB0aGUgc3BlY2lmaWVkXHJcbiAqIG1ldGhvZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYmplY3QgPSBvYmo7XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWV0YWRhdGEgYWJvdXQgYSBzbmFwc2hvdCwgZGVzY3JpYmluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYXBzaG90LlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RNZXRhZGF0YSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoaGFzUGVuZGluZ1dyaXRlcywgZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nV3JpdGVzID0gaGFzUGVuZGluZ1dyaXRlcztcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBTbmFwc2hvdE1ldGFkYXRhYCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9PT0gb3RoZXIuaGFzUGVuZGluZ1dyaXRlcyAmJlxyXG4gICAgICAgICAgICB0aGlzLmZyb21DYWNoZSA9PT0gb3RoZXIuZnJvbUNhY2hlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxyXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cclxuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcclxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cclxuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U25hcHNob3QgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90JDEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgbWV0YWRhdGEsIGNvbnZlcnRlcikge1xyXG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBrZXksIGRvY3VtZW50LCBjb252ZXJ0ZXIpO1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlSW1wbCA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkYXRhIGV4aXN0cy4gVHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV4aXN0cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdmFsdWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cclxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxyXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tXHJcbiAgICAgKiB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wcyB0aGF0XHJcbiAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxyXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBvciBgdW5kZWZpbmVkYCBpZlxyXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxyXG4gICAgICAgICAgICAvLyBpZiBhIGNvbnZlcnRlciBoYXMgYmVlbiBwcm92aWRlZC5cclxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIHRoaXMubWV0YWRhdGEsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlLCBvcHRpb25zLnNlcnZlclRpbWVzdGFtcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBvciBmaWVsZCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIGEgYHNlcnZlclRpbWVzdGFtcCgpYCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2V0IHRvXHJcbiAgICAgKiBpdHMgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBieVxyXG4gICAgICogcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xyXG4gICAgICogZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgdGhlIGZpZWxkIGlzIHJldHJpZXZlZFxyXG4gICAgICogZnJvbSB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wc1xyXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxyXG4gICAgICogZmllbGQgZXhpc3RzIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZ2V0KGZpZWxkUGF0aCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UgYXMgcGFydCBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdFxyXG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcclxuICogc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcclxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxyXG4gKiBgZXhpc3RzYCBwcm9wZXJ0eSB3aWxsIGFsd2F5cyBiZSB0cnVlIGFuZCBgZGF0YSgpYCB3aWxsIG5ldmVyIHJldHVyblxyXG4gKiAndW5kZWZpbmVkJy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCBleHRlbmRzIERvY3VtZW50U25hcHNob3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgYHNlcnZlclRpbWVzdGFtcCgpYCB2YWx1ZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxyXG4gICAgICogc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIGJ5IHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgZGF0YSBpcyByZXRyaWV2ZWQgZnJvbVxyXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxyXG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEob3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5U25hcHNob3RgIGNvbnRhaW5zIHplcm8gb3IgbW9yZSBgRG9jdW1lbnRTbmFwc2hvdGAgb2JqZWN0c1xyXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50cyBjYW4gYmUgYWNjZXNzZWQgYXMgYW5cclxuICogYXJyYXkgdmlhIHRoZSBgZG9jc2AgcHJvcGVydHkgb3IgZW51bWVyYXRlZCB1c2luZyB0aGUgYGZvckVhY2hgIG1ldGhvZC4gVGhlXHJcbiAqIG51bWJlciBvZiBkb2N1bWVudHMgY2FuIGJlIGRldGVybWluZWQgdmlhIHRoZSBgZW1wdHlgIGFuZCBgc2l6ZWBcclxuICogcHJvcGVydGllcy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5U25hcHNob3Qge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF91c2VyRGF0YVdyaXRlciwgcXVlcnksIF9zbmFwc2hvdCkge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdXNlckRhdGFXcml0ZXIgPSBfdXNlckRhdGFXcml0ZXI7XHJcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSBfc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBTbmFwc2hvdE1ldGFkYXRhKF9zbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBfc25hcHNob3QuZnJvbUNhY2hlKTtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBkb2NzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4gcmVzdWx0LnB1c2goZG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90LmRvY3Muc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBUcnVlIGlmIHRoZXJlIGFyZSBubyBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCBhIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGZvclxyXG4gICAgICogZWFjaCBkb2N1bWVudCBpbiB0aGUgc25hcHNob3QuXHJcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFRoZSBgdGhpc2AgYmluZGluZyBmb3IgdGhlIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdGhpcy5fc25hcHNob3QuZG9jcy5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKHRoaXMuX3NuYXBzaG90Lm11dGF0ZWRLZXlzLmhhcyhkb2Mua2V5KSwgdGhpcy5fc25hcHNob3QuZnJvbUNhY2hlKSwgdGhpcy5xdWVyeS5jb252ZXJ0ZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZG9jdW1lbnRzIGNoYW5nZXMgc2luY2UgdGhlIGxhc3Qgc25hcHNob3QuIElmIHRoaXNcclxuICAgICAqIGlzIHRoZSBmaXJzdCBzbmFwc2hvdCwgYWxsIGRvY3VtZW50cyB3aWxsIGJlIGluIHRoZSBsaXN0IGFzICdhZGRlZCdcclxuICAgICAqIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBgU25hcHNob3RMaXN0ZW5PcHRpb25zYCB0aGF0IGNvbnRyb2wgd2hldGhlciBtZXRhZGF0YS1vbmx5XHJcbiAgICAgKiBjaGFuZ2VzIChpLmUuIG9ubHkgYERvY3VtZW50U25hcHNob3QubWV0YWRhdGFgIGNoYW5nZWQpIHNob3VsZCB0cmlnZ2VyXHJcbiAgICAgKiBzbmFwc2hvdCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGRvY0NoYW5nZXMob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9ICEhb3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xyXG4gICAgICAgIGlmIChpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICYmIHRoaXMuX3NuYXBzaG90LmV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUbyBpbmNsdWRlIG1ldGFkYXRhIGNoYW5nZXMgd2l0aCB5b3VyIGRvY3VtZW50IGNoYW5nZXMsIHlvdSBtdXN0ICcgK1xyXG4gICAgICAgICAgICAgICAgJ2Fsc28gcGFzcyB7IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6dHJ1ZSB9IHRvIG9uU25hcHNob3QoKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRDaGFuZ2VzIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICE9PSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBjaGFuZ2VzRnJvbVNuYXBzaG90KHRoaXMsIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzSW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDYWxjdWxhdGVzIHRoZSBhcnJheSBvZiBgRG9jdW1lbnRDaGFuZ2VgcyBmb3IgYSBnaXZlbiBgVmlld1NuYXBzaG90YC4gKi9cclxuZnVuY3Rpb24gY2hhbmdlc0Zyb21TbmFwc2hvdChxdWVyeVNuYXBzaG90LCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzLm1hcChjaGFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XHJcbiAgICAgICAgICAgIGNoYW5nZS5kb2M7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgb2xkSW5kZXg6IC0xLFxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4KytcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEEgYERvY3VtZW50U2V0YCB0aGF0IGlzIHVwZGF0ZWQgaW5jcmVtZW50YWxseSBhcyBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIHVzZVxyXG4gICAgICAgIC8vIHRvIGxvb2t1cCB0aGUgaW5kZXggb2YgYSBkb2N1bWVudC5cclxuICAgICAgICBsZXQgaW5kZXhUcmFja2VyID0gcXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcztcclxuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZG9jQ2hhbmdlc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGNoYW5nZSA9PiBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzIHx8IGNoYW5nZS50eXBlICE9PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8pXHJcbiAgICAgICAgICAgIC5tYXAoY2hhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xyXG4gICAgICAgICAgICBsZXQgb2xkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgbGV0IG5ld0luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgICAgIGluZGV4VHJhY2tlciA9IGluZGV4VHJhY2tlci5kZWxldGUoY2hhbmdlLmRvYy5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGluZGV4VHJhY2tlciA9IGluZGV4VHJhY2tlci5hZGQoY2hhbmdlLmRvYyk7XHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogcmVzdWx0Q2hhbmdlVHlwZShjaGFuZ2UudHlwZSksXHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBvbGRJbmRleCxcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzdWx0Q2hhbmdlVHlwZSh0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdhZGRlZCc7XHJcbiAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnbW9kaWZpZWQnO1xyXG4gICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAncmVtb3ZlZCc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vLyBUT0RPKGZpcmVzdG9yZWV4cCk6IEFkZCB0ZXN0cyBmb3Igc25hcHNob3RFcXVhbCB3aXRoIGRpZmZlcmVudCBzbmFwc2hvdFxyXG4vLyBtZXRhZGF0YVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBzbmFwc2hvdHMgYXJlIGVxdWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHJpZ2h0IC0gQSBzbmFwc2hvdCB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzbmFwc2hvdHMgYXJlIGVxdWFsLlxyXG4gKi9cclxuZnVuY3Rpb24gc25hcHNob3RFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCkge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5fZmlyZXN0b3JlID09PSByaWdodC5fZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIGxlZnQuX2tleS5pc0VxdWFsKHJpZ2h0Ll9rZXkpICYmXHJcbiAgICAgICAgICAgIChsZWZ0Ll9kb2N1bWVudCA9PT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyByaWdodC5fZG9jdW1lbnQgPT09IG51bGxcclxuICAgICAgICAgICAgICAgIDogbGVmdC5fZG9jdW1lbnQuaXNFcXVhbChyaWdodC5fZG9jdW1lbnQpKSAmJlxyXG4gICAgICAgICAgICBsZWZ0Ll9jb252ZXJ0ZXIgPT09IHJpZ2h0Ll9jb252ZXJ0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIFF1ZXJ5U25hcHNob3QgJiYgcmlnaHQgaW5zdGFuY2VvZiBRdWVyeVNuYXBzaG90KSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0Ll9maXJlc3RvcmUgPT09IHJpZ2h0Ll9maXJlc3RvcmUgJiZcclxuICAgICAgICAgICAgcXVlcnlFcXVhbChsZWZ0LnF1ZXJ5LCByaWdodC5xdWVyeSkgJiZcclxuICAgICAgICAgICAgbGVmdC5tZXRhZGF0YS5pc0VxdWFsKHJpZ2h0Lm1ldGFkYXRhKSAmJlxyXG4gICAgICAgICAgICBsZWZ0Ll9zbmFwc2hvdC5pc0VxdWFsKHJpZ2h0Ll9zbmFwc2hvdCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBOb3RlOiBgZ2V0RG9jKClgIGF0dGVtcHRzIHRvIHByb3ZpZGUgdXAtdG8tZGF0ZSBkYXRhIHdoZW4gcG9zc2libGUgYnkgd2FpdGluZ1xyXG4gKiBmb3IgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBpdCBtYXkgcmV0dXJuIGNhY2hlZCBkYXRhIG9yIGZhaWwgaWYgeW91IGFyZVxyXG4gKiBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsIGludm9rZVxyXG4gKiB7QGxpbmsgZ2V0RG9jRnJvbUNhY2hlfSBvciB7QGxpbmsgZ2V0RG9jRnJvbVNlcnZlcn0uXHJcbiAqXHJcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIG9mIHRoZSBkb2N1bWVudCB0byBmZXRjaC5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcclxuICogY3VycmVudCBkb2N1bWVudCBjb250ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvYyhyZWZlcmVuY2UpIHtcclxuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcmVmZXJlbmNlLl9rZXkpLnRoZW4oc25hcHNob3QgPT4gY29udmVydFRvRG9jU25hcHNob3QoZmlyZXN0b3JlLCByZWZlcmVuY2UsIHNuYXBzaG90KSk7XHJcbn1cclxuY2xhc3MgRXhwVXNlckRhdGFXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0Qnl0ZXMoYnl0ZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKGJ5dGVzKTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRSZWZlcmVuY2UobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY29udmVydERvY3VtZW50S2V5KG5hbWUsIHRoaXMuZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSBjYWNoZS5cclxuICogUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgZG9jdW1lbnQgaXMgbm90IGN1cnJlbnRseSBjYWNoZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcclxuICogY3VycmVudCBkb2N1bWVudCBjb250ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvY0Zyb21DYWNoZShyZWZlcmVuY2UpIHtcclxuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihkb2MgPT4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmZXJlbmNlLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoZG9jICE9PSBudWxsICYmIGRvYy5oYXNMb2NhbE11dGF0aW9ucywgXHJcbiAgICAvKiBmcm9tQ2FjaGU9ICovIHRydWUpLCByZWZlcmVuY2UuY29udmVydGVyKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSB0aGUgc2VydmVyLlxyXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcclxuICogY3VycmVudCBkb2N1bWVudCBjb250ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvY0Zyb21TZXJ2ZXIocmVmZXJlbmNlKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHJlZmVyZW5jZS5fa2V5LCB7XHJcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xyXG4gICAgfSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcclxufVxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgLlxyXG4gKlxyXG4gKiBOb3RlOiBgZ2V0RG9jcygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5XHJcbiAqIHdhaXRpbmcgZm9yIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQgbWF5IHJldHVybiBjYWNoZWQgZGF0YSBvciBmYWlsIGlmXHJcbiAqIHlvdSBhcmUgb2ZmbGluZSBhbmQgdGhlIHNlcnZlciBjYW5ub3QgYmUgcmVhY2hlZC4gVG8gc3BlY2lmeSB0aGlzIGJlaGF2aW9yLFxyXG4gKiBpbnZva2Uge0BsaW5rIGdldERvY3NGcm9tQ2FjaGV9IG9yIHtAbGluayBnZXREb2NzRnJvbVNlcnZlcn0uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvY3MocXVlcnkpIHtcclxuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnkpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XHJcbn1cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIGNhY2hlLlxyXG4gKiBSZXR1cm5zIGFuIGVtcHR5IHJlc3VsdCBzZXQgaWYgbm8gZG9jdW1lbnRzIG1hdGNoaW5nIHRoZSBxdWVyeSBhcmUgY3VycmVudGx5XHJcbiAqIGNhY2hlZC5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jc0Zyb21DYWNoZShxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzRnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XHJcbn1cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIHRoZVxyXG4gKiBzZXJ2ZXIuIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jc0Zyb21TZXJ2ZXIocXVlcnkpIHtcclxuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnksIHtcclxuICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXHJcbiAgICB9KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xyXG59XHJcbmZ1bmN0aW9uIHNldERvYyhyZWZlcmVuY2UsIGRhdGEsIG9wdGlvbnMpIHtcclxuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWZlcmVuY2UuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKGRhdGFSZWFkZXIsICdzZXREb2MnLCByZWZlcmVuY2UuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZmVyZW5jZS5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgbXV0YXRpb24gPSBwYXJzZWQudG9NdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XHJcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlRG9jKHJlZmVyZW5jZSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCAuLi5tb3JlRmllbGRzQW5kVmFsdWVzKSB7XHJcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSk7XHJcbiAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxyXG4gICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgbGV0IHBhcnNlZDtcclxuICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3MoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKGRhdGFSZWFkZXIsICd1cGRhdGVEb2MnLCByZWZlcmVuY2UuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXV0YXRpb24gPSBwYXJzZWQudG9NdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLmV4aXN0cyh0cnVlKSk7XHJcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XHJcbn1cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBzcGVjaWZpZWQgYERvY3VtZW50UmVmZXJlbmNlYC5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBkZWxldGUuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHlcclxuICogZGVsZXRlZCBmcm9tIHRoZSBiYWNrZW5kIChub3RlIHRoYXQgaXQgd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVEb2MocmVmZXJlbmNlKSB7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBtdXRhdGlvbnMgPSBbbmV3IERlbGV0ZU11dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKV07XHJcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKTtcclxufVxyXG4vKipcclxuICogQWRkIGEgbmV3IGRvY3VtZW50IHRvIHNwZWNpZmllZCBgQ29sbGVjdGlvblJlZmVyZW5jZWAgd2l0aCB0aGUgZ2l2ZW4gZGF0YSxcclxuICogYXNzaWduaW5nIGl0IGEgZG9jdW1lbnQgSUQgYXV0b21hdGljYWxseS5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uIHRvIGFkZCB0aGlzIGRvY3VtZW50IHRvLlxyXG4gKiBAcGFyYW0gZGF0YSAtIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIGZvciB0aGUgbmV3IGRvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50UmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGVcclxuICogbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBiYWNrZW5kIChOb3RlIHRoYXQgaXRcclxuICogd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGREb2MocmVmZXJlbmNlLCBkYXRhKSB7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBkb2NSZWYgPSBkb2MocmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEpO1xyXG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKGRhdGFSZWFkZXIsICdhZGREb2MnLCBkb2NSZWYuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZmVyZW5jZS5jb252ZXJ0ZXIgIT09IG51bGwsIHt9KTtcclxuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24oZG9jUmVmLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpKTtcclxuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKS50aGVuKCgpID0+IGRvY1JlZik7XHJcbn1cclxuZnVuY3Rpb24gb25TbmFwc2hvdChyZWZlcmVuY2UsIC4uLmFyZ3MpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgcmVmZXJlbmNlID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZmVyZW5jZSk7XHJcbiAgICBsZXQgb3B0aW9ucyA9IHtcclxuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBmYWxzZSxcclxuICAgICAgICBzb3VyY2U6ICdkZWZhdWx0J1xyXG4gICAgfTtcclxuICAgIGxldCBjdXJyQXJnID0gMDtcclxuICAgIGlmICh0eXBlb2YgYXJnc1tjdXJyQXJnXSA9PT0gJ29iamVjdCcgJiYgIWlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyckFyZ10pKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbY3VyckFyZ107XHJcbiAgICAgICAgY3VyckFyZysrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0ge1xyXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyxcclxuICAgICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlXHJcbiAgICB9O1xyXG4gICAgaWYgKGlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyckFyZ10pKSB7XHJcbiAgICAgICAgY29uc3QgdXNlck9ic2VydmVyID0gYXJnc1tjdXJyQXJnXTtcclxuICAgICAgICBhcmdzW2N1cnJBcmddID0gKF9hID0gdXNlck9ic2VydmVyLm5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMV0gPSAoX2IgPSB1c2VyT2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMl0gPSAoX2MgPSB1c2VyT2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICBsZXQgZmlyZXN0b3JlO1xyXG4gICAgbGV0IGludGVybmFsUXVlcnk7XHJcbiAgICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IG5ld1F1ZXJ5Rm9yUGF0aChyZWZlcmVuY2UuX2tleS5wYXRoKTtcclxuICAgICAgICBvYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbY3VyckFyZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1cnJBcmcgKyAyXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IGNhc3QocmVmZXJlbmNlLCBRdWVyeSk7XHJcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IHF1ZXJ5Ll9xdWVyeTtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbY3VyckFyZ10obmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBhcmdzW2N1cnJBcmcgKyAxXSxcclxuICAgICAgICAgICAgY29tcGxldGU6IGFyZ3NbY3VyckFyZyArIDJdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHJlZmVyZW5jZS5fcXVlcnkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudExpc3RlbihjbGllbnQsIGludGVybmFsUXVlcnksIGludGVybmFsT3B0aW9ucywgb2JzZXJ2ZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uU25hcHNob3RzSW5TeW5jKGZpcmVzdG9yZSwgYXJnKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IG9ic2VydmVyID0gaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnKVxyXG4gICAgICAgID8gYXJnXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGFyZ1xyXG4gICAgICAgIH07XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50QWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoY2xpZW50LCBvYnNlcnZlcik7XHJcbn1cclxuLyoqXHJcbiAqIExvY2FsbHkgd3JpdGVzIGBtdXRhdGlvbnNgIG9uIHRoZSBhc3luYyBxdWV1ZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEge0BsaW5rIFZpZXdTbmFwc2hvdH0gdGhhdCBjb250YWlucyB0aGUgc2luZ2xlIGRvY3VtZW50IHNwZWNpZmllZCBieSBgcmVmYFxyXG4gKiB0byBhIHtAbGluayBEb2N1bWVudFNuYXBzaG90fS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmLCBzbmFwc2hvdCkge1xyXG4gICAgY29uc3QgZG9jID0gc25hcHNob3QuZG9jcy5nZXQocmVmLl9rZXkpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShzbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBzbmFwc2hvdC5mcm9tQ2FjaGUpLCByZWYuY29udmVydGVyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnlcclxuICogd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNvdW50IHRoZSBkb2N1bWVudHMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcclxuICogZmluYWwgY291bnQsIG5vdCB0aGUgZG9jdW1lbnRzJyBkYXRhLCBpcyBkb3dubG9hZGVkLiBUaGlzIGZ1bmN0aW9uIGNhblxyXG4gKiBjb3VudCB0aGUgZG9jdW1lbnRzIGluIGNhc2VzIHdoZXJlIHRoZSByZXN1bHQgc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG9cclxuICogZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBwcmVzZW50ZWQsIHVuYWx0ZXJlZCwgd2l0aG91dFxyXG4gKiBjb25zaWRlcmluZyBhbnkgbG9jYWwgc3RhdGUuIFRoYXQgaXMsIGRvY3VtZW50cyBpbiB0aGUgbG9jYWwgY2FjaGUgYXJlIG5vdFxyXG4gKiB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIG5laXRoZXIgYXJlIGxvY2FsIG1vZGlmaWNhdGlvbnMgbm90IHlldFxyXG4gKiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2VydmVyLiBQcmV2aW91c2x5LWRvd25sb2FkZWQgcmVzdWx0cywgaWYgYW55LCBhcmUgbm90XHJcbiAqIHVzZWQuIEV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvbiBuZWNlc3NhcmlseSBpbnZvbHZlcyBhIHJvdW5kIHRyaXAgdG9cclxuICogdGhlIHNlcnZlci5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IHNpemUgaXMgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBjb3VudDsgdGhlIGNvdW50IGNhbiBiZVxyXG4gKiByZXRyaWV2ZWQgZnJvbSBgc25hcHNob3QuZGF0YSgpLmNvdW50YCwgd2hlcmUgYHNuYXBzaG90YCBpcyB0aGVcclxuICogYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIHdoaWNoIHRoZSByZXR1cm5lZCBQcm9taXNlIHJlc29sdmVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q291bnRGcm9tU2VydmVyKHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBjb3VudFF1ZXJ5U3BlYyA9IHtcclxuICAgICAgICBjb3VudDogY291bnQoKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBjb3VudFF1ZXJ5U3BlYyk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmllZCBhZ2dyZWdhdGlvbnMgb3ZlciB0aGUgZG9jdW1lbnRzIGluIHRoZSByZXN1bHRcclxuICogc2V0IG9mIHRoZSBnaXZlbiBxdWVyeSB3aXRob3V0IGFjdHVhbGx5IGRvd25sb2FkaW5nIHRoZSBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcclxuICogZmluYWwgYWdncmVnYXRpb24gdmFsdWVzLCBub3QgdGhlIGRvY3VtZW50cycgZGF0YSwgYXJlIGRvd25sb2FkZWQuIFRoaXNcclxuICogZnVuY3Rpb24gY2FuIHBlcmZvcm0gYWdncmVnYXRpb25zIG9mIHRoZSBkb2N1bWVudHMgaW4gY2FzZXMgd2hlcmUgdGhlIHJlc3VsdFxyXG4gKiBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0byBkb3dubG9hZCBlbnRpcmVseSAodGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHByZXNlbnRlZCwgdW5hbHRlcmVkLCB3aXRob3V0XHJcbiAqIGNvbnNpZGVyaW5nIGFueSBsb2NhbCBzdGF0ZS4gVGhhdCBpcywgZG9jdW1lbnRzIGluIHRoZSBsb2NhbCBjYWNoZSBhcmUgbm90XHJcbiAqIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiwgbmVpdGhlciBhcmUgbG9jYWwgbW9kaWZpY2F0aW9ucyBub3QgeWV0XHJcbiAqIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzZXJ2ZXIuIFByZXZpb3VzbHktZG93bmxvYWRlZCByZXN1bHRzLCBpZiBhbnksIGFyZSBub3RcclxuICogdXNlZC4gRXZlcnkgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIG5lY2Vzc2FyaWx5IGludm9sdmVzIGEgcm91bmQgdHJpcCB0b1xyXG4gKiB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIHJlc3VsdCBzZXQgaXMgYWdncmVnYXRlZCBvdmVyLlxyXG4gKiBAcGFyYW0gYWdncmVnYXRlU3BlYyBBbiBgQWdncmVnYXRlU3BlY2Agb2JqZWN0IHRoYXQgc3BlY2lmaWVzIHRoZSBhZ2dyZWdhdGVzXHJcbiAqIHRvIHBlcmZvcm0gb3ZlciB0aGUgcmVzdWx0IHNldC4gVGhlIEFnZ3JlZ2F0ZVNwZWMgc3BlY2lmaWVzIGFsaWFzZXMgZm9yIGVhY2hcclxuICogYWdncmVnYXRlLCB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgYWdncmVnYXRlIHJlc3VsdC5cclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBhZ2dyZWdhdGVTbmFwc2hvdCA9IGF3YWl0IGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIocXVlcnksIHtcclxuICogICBjb3VudE9mRG9jczogY291bnQoKSxcclxuICogICB0b3RhbEhvdXJzOiBzdW0oJ2hvdXJzJyksXHJcbiAqICAgYXZlcmFnZVNjb3JlOiBhdmVyYWdlKCdzY29yZScpXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBjb25zdCBjb3VudE9mRG9jczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmNvdW50T2ZEb2NzO1xyXG4gKiBjb25zdCB0b3RhbEhvdXJzOiBudW1iZXIgPSBhZ2dyZWdhdGVTbmFwc2hvdC5kYXRhKCkudG90YWxIb3VycztcclxuICogY29uc3QgYXZlcmFnZVNjb3JlOiBudW1iZXIgfCBudWxsID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmF2ZXJhZ2VTY29yZTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGludGVybmFsQWdncmVnYXRlcyA9IG1hcFRvQXJyYXkoYWdncmVnYXRlU3BlYywgKGFnZ3JlZ2F0ZSwgYWxpYXMpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUltcGwoYWxpYXMsIGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlLCBhZ2dyZWdhdGUuX2ludGVybmFsRmllbGRQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gUnVuIHRoZSBhZ2dyZWdhdGlvbiBhbmQgY29udmVydCB0aGUgcmVzdWx0c1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCBpbnRlcm5hbEFnZ3JlZ2F0ZXMpLnRoZW4oYWdncmVnYXRlUmVzdWx0ID0+IGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb3JlIGFnZ3JlZ3JhdGlvbiByZXN1bHQgdG8gYW4gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgXHJcbiAqIHRoYXQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBjb25zdW1lci5cclxuICogQHBhcmFtIHF1ZXJ5XHJcbiAqIEBwYXJhbSBhZ2dyZWdhdGVSZXN1bHQgQ29yZSBhZ2dyZWdhdGlvbiByZXN1bHRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkge1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBuZXcgQWdncmVnYXRlUXVlcnlTbmFwc2hvdChxdWVyeSwgdXNlckRhdGFXcml0ZXIsIGFnZ3JlZ2F0ZVJlc3VsdCk7XHJcbiAgICByZXR1cm4gcXVlcnlTbmFwc2hvdDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlMb2NhbENhY2hlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnknO1xyXG4gICAgICAgIHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKCk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5nYXJiYWdlQ29sbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5nYXJiYWdlQ29sbGVjdG9yLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMua2luZCA9ICdwZXJzaXN0ZW50JztcclxuICAgICAgICBsZXQgdGFiTWFuYWdlcjtcclxuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLnRhYk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MudGFiTWFuYWdlci5faW5pdGlhbGl6ZShzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBzZXR0aW5ncy50YWJNYW5hZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFiTWFuYWdlciA9IHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHRhYk1hbmFnZXIuX2luaXRpYWxpemUoc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IHRhYk1hbmFnZXIuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IHRhYk1hbmFnZXIuX29mZmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBNZW1vcnlFYWdlckdhYmFnZUNvbGxlY3RvckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5raW5kID0gJ21lbW9yeUVhZ2VyJztcclxuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTWVtb3J5THJ1R2FiYWdlQ29sbGVjdG9ySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVNpemUpIHtcclxuICAgICAgICB0aGlzLmtpbmQgPSAnbWVtb3J5THJ1JztcclxuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2FjaGVTaXplKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yYC4gVGhpcyBpcyBhbHNvIHRoZVxyXG4gKiBkZWZhdWx0IGdhcmJhZ2UgY29sbGVjdG9yIHVubGVzcyBpdCBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZW1vcnlFYWdlckdhcmJhZ2VDb2xsZWN0b3IoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1lbW9yeUVhZ2VyR2FiYWdlQ29sbGVjdG9ySW1wbCgpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yYC5cclxuICpcclxuICogQSB0YXJnZXQgc2l6ZSBjYW4gYmUgc3BlY2lmaWVkIGFzIHBhcnQgb2YgdGhlIHNldHRpbmcgcGFyYW1ldGVyLiBUaGVcclxuICogY29sbGVjdG9yIHdpbGwgc3RhcnQgZGVsZXRpbmcgZG9jdW1lbnRzIG9uY2UgdGhlIGNhY2hlIHNpemUgZXhjZWVkc1xyXG4gKiB0aGUgZ2l2ZW4gc2l6ZS4gVGhlIGRlZmF1bHQgY2FjaGUgc2l6ZSBpcyA0ME1CICg0MCAqIDEwMjQgKiAxMDI0IGJ5dGVzKS5cclxuICovXHJcbmZ1bmN0aW9uIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgIHJldHVybiBuZXcgTWVtb3J5THJ1R2FiYWdlQ29sbGVjdG9ySW1wbChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cclxuICogYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCB0byB0ZWxsIHRoZSBTREsgd2hpY2ggY2FjaGUgbGF5ZXIgdG8gdXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVtb3J5TG9jYWxDYWNoZShzZXR0aW5ncykge1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cclxuICogYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCB0byB0ZWxsIHRoZSBTREsgd2hpY2ggY2FjaGUgbGF5ZXIgdG8gdXNlLlxyXG4gKlxyXG4gKiBQZXJzaXN0ZW50IGNhY2hlIGNhbm5vdCBiZSB1c2VkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cclxuICovXHJcbmZ1bmN0aW9uIHBlcnNpc3RlbnRMb2NhbENhY2hlKHNldHRpbmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XHJcbn1cclxuY2xhc3MgU2luZ2xlVGFiTWFuYWdlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZm9yY2VPd25lcnNoaXApIHtcclxuICAgICAgICB0aGlzLmZvcmNlT3duZXJzaGlwID0gZm9yY2VPd25lcnNoaXA7XHJcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnRTaW5nbGVUYWInO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemUoc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBJbmRleGVkRGJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIodGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcywgdGhpcy5mb3JjZU93bmVyc2hpcCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTXVsdGlUYWJNYW5hZ2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmtpbmQgPSAnUGVyc2lzdGVudE11bHRpcGxlVGFiJztcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKTtcclxuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBuZXcgTXVsdGlUYWJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIodGhpcy5fb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyYC5cclxuICpcclxuICogQHBhcmFtIHNldHRpbmdzIENvbmZpZ3VyZXMgdGhlIGNyZWF0ZWQgdGFiIG1hbmFnZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBwZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcihzZXR0aW5ncykge1xyXG4gICAgcmV0dXJuIG5ldyBTaW5nbGVUYWJNYW5hZ2VySW1wbChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuZm9yY2VPd25lcnNoaXApO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyYC5cclxuICovXHJcbmZ1bmN0aW9uIHBlcnNpc3RlbnRNdWx0aXBsZVRhYk1hbmFnZXIoKSB7XHJcbiAgICByZXR1cm4gbmV3IE11bHRpVGFiTWFuYWdlckltcGwoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX1RSQU5TQUNUSU9OX09QVElPTlMgPSB7XHJcbiAgICBtYXhBdHRlbXB0czogNVxyXG59O1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5tYXhBdHRlbXB0cyA8IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTWF4IGF0dGVtcHRzIG11c3QgYmUgYXQgbGVhc3QgMScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHdyaXRlIGJhdGNoLCB1c2VkIHRvIHBlcmZvcm0gbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxyXG4gKlxyXG4gKiBBIGBXcml0ZUJhdGNoYCBvYmplY3QgY2FuIGJlIGFjcXVpcmVkIGJ5IGNhbGxpbmcge0BsaW5rIHdyaXRlQmF0Y2h9LiBJdFxyXG4gKiBwcm92aWRlcyBtZXRob2RzIGZvciBhZGRpbmcgd3JpdGVzIHRvIHRoZSB3cml0ZSBiYXRjaC4gTm9uZSBvZiB0aGUgd3JpdGVzXHJcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcclxuICogY2FsbGVkLlxyXG4gKi9cclxuY2xhc3MgV3JpdGVCYXRjaCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX2NvbW1pdEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX2NvbW1pdEhhbmRsZXIgPSBfY29tbWl0SGFuZGxlcjtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XHJcbiAgICB9XHJcbiAgICBzZXQoZG9jdW1lbnRSZWYsIGRhdGEsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2guc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMucHVzaChwYXJzZWQudG9NdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgbGV0IHBhcnNlZDtcclxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1dyaXRlQmF0Y2gudXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zLnB1c2gocGFyc2VkLnRvTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGBXcml0ZUJhdGNoYCBpbnN0YW5jZS4gVXNlZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBkZWxldGUoZG9jdW1lbnRSZWYpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbnMgPSB0aGlzLl9tdXRhdGlvbnMuY29uY2F0KG5ldyBEZWxldGVNdXRhdGlvbihyZWYuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21taXRzIGFsbCBvZiB0aGUgd3JpdGVzIGluIHRoaXMgd3JpdGUgYmF0Y2ggYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHJlc3VsdCBvZiB0aGVzZSB3cml0ZXMgd2lsbCBvbmx5IGJlIHJlZmxlY3RlZCBpbiBkb2N1bWVudCByZWFkcyB0aGF0XHJcbiAgICAgKiBvY2N1ciBhZnRlciB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy4gSWYgdGhlIGNsaWVudCBpcyBvZmZsaW5lLCB0aGVcclxuICAgICAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXHJcbiAgICAgKiB1bnRpbCB0aGUgY2xpZW50IGlzIG9ubGluZSwgdXNlIHRoZSBmdWxsIEZpcmVzdG9yZSBTREsuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuXHJcbiAgICAgKiBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byB0aGUgYmFja2VuZCBhcyBhbiBhdG9taWMgdW5pdCAobm90ZSB0aGF0IGl0IHdvbid0XHJcbiAgICAgKiByZXNvbHZlIHdoaWxlIHlvdSdyZSBvZmZsaW5lKS5cclxuICAgICAqL1xyXG4gICAgY29tbWl0KCkge1xyXG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbW1pdHRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX211dGF0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21taXRIYW5kbGVyKHRoaXMuX211dGF0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIF92ZXJpZnlOb3RDb21taXR0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbW1pdHRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnQSB3cml0ZSBiYXRjaCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgY29tbWl0KCkgJyArXHJcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gY2FsbGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgZmlyZXN0b3JlKSB7XHJcbiAgICBkb2N1bWVudFJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2N1bWVudFJlZik7XHJcbiAgICBpZiAoZG9jdW1lbnRSZWYuZmlyZXN0b3JlICE9PSBmaXJlc3RvcmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUHJvdmlkZWQgZG9jdW1lbnQgcmVmZXJlbmNlIGlzIGZyb20gYSBkaWZmZXJlbnQgRmlyZXN0b3JlIGluc3RhbmNlLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50UmVmO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFRPRE8obXJzY2htaWR0KSBDb25zaWRlciB1c2luZyBgQmFzZVRyYW5zYWN0aW9uYCBhcyB0aGUgYmFzZSBjbGFzcyBpbiB0aGVcclxuLy8gbGVnYWN5IFNESy5cclxuLyoqXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGEgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcclxuICogdGhlIG1ldGhvZHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnRleHQuIFNlZVxyXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24kMSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IF90cmFuc2FjdGlvbjtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSByZWFkLlxyXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQoZG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBMaXRlVXNlckRhdGFXcml0ZXIodGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24ubG9va3VwKFtyZWYuX2tleV0pLnRoZW4oZG9jcyA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZG9jcyB8fCBkb2NzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIHJlZi5jb252ZXJ0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvYy5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIG51bGwsIHJlZi5jb252ZXJ0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQoZG9jdW1lbnRSZWYsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24uc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi5zZXQocmVmLl9rZXksIHBhcnNlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxyXG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcclxuICAgICAgICBsZXQgcGFyc2VkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24udXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnVwZGF0ZShyZWYuX2tleSwgcGFyc2VkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uZGVsZXRlKHJlZi5fa2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSByZWZlcmVuY2UgdG8gYSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogVGhlIGBUcmFuc2FjdGlvbmAgb2JqZWN0IHBhc3NlZCB0byBhIHRyYW5zYWN0aW9uJ3MgYHVwZGF0ZUZ1bmN0aW9uYCBwcm92aWRlc1xyXG4gKiB0aGUgbWV0aG9kcyB0byByZWFkIGFuZCB3cml0ZSBkYXRhIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dC4gU2VlXHJcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uJDEge1xyXG4gICAgLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBzYW1lIGxvZ2ljIGFzIHRoZSBUcmFuc2FjdGlvbiBBUEkgaW4gdGhlIExpdGUgU0RLXHJcbiAgICAvLyBidXQgaXMgc3ViY2xhc3NlZCBpbiBvcmRlciB0byByZXR1cm4gaXRzIG93biBEb2N1bWVudFNuYXBzaG90IHR5cGVzLlxyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZWQgYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIGBEb2N1bWVudFNuYXBzaG90YCB3aXRoIHRoZSByZWFkIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldChkb2N1bWVudFJlZikge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyXHJcbiAgICAgICAgICAgIC5nZXQoZG9jdW1lbnRSZWYpXHJcbiAgICAgICAgICAgIC50aGVuKGxpdGVEb2N1bWVudFNuYXBzaG90ID0+IG5ldyBEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZi5fa2V5LCBsaXRlRG9jdW1lbnRTbmFwc2hvdC5fZG9jdW1lbnQsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKFxyXG4gICAgICAgIC8qIGhhc1BlbmRpbmdXcml0ZXM9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBmcm9tQ2FjaGU9ICovIGZhbHNlKSwgcmVmLmNvbnZlcnRlcikpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgZ2l2ZW4gYHVwZGF0ZUZ1bmN0aW9uYCBhbmQgdGhlbiBhdHRlbXB0cyB0byBjb21taXQgdGhlIGNoYW5nZXNcclxuICogYXBwbGllZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLiBJZiBhbnkgZG9jdW1lbnQgcmVhZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIGhhcyBjaGFuZ2VkLCBDbG91ZCBGaXJlc3RvcmUgcmV0cmllcyB0aGUgYHVwZGF0ZUZ1bmN0aW9uYC4gSWYgaXQgZmFpbHMgdG9cclxuICogY29tbWl0IGFmdGVyIDUgYXR0ZW1wdHMsIHRoZSB0cmFuc2FjdGlvbiBmYWlscy5cclxuICpcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGlzIDUwMC5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBGaXJlc3RvcmUgZGF0YWJhc2UgdG8gcnVuIHRoaXNcclxuICogdHJhbnNhY3Rpb24gYWdhaW5zdC5cclxuICogQHBhcmFtIHVwZGF0ZUZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBjb250ZXh0LlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyB0b1xyXG4gKiBjb21taXQuXHJcbiAqIEByZXR1cm5zIElmIHRoZSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IG9yIHdhcyBleHBsaWNpdGx5IGFib3J0ZWRcclxuICogKHRoZSBgdXBkYXRlRnVuY3Rpb25gIHJldHVybmVkIGEgZmFpbGVkIHByb21pc2UpLCB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGVcclxuICogYHVwZGF0ZUZ1bmN0aW9uIGBpcyByZXR1cm5lZCBoZXJlLiBPdGhlcndpc2UsIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQsIGFcclxuICogcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGZhaWx1cmUgZXJyb3IgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5UcmFuc2FjdGlvbihmaXJlc3RvcmUsIHVwZGF0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyksIG9wdGlvbnMpO1xyXG4gICAgdmFsaWRhdGVUcmFuc2FjdGlvbk9wdGlvbnMob3B0aW9uc1dpdGhEZWZhdWx0cyk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCBpbnRlcm5hbFRyYW5zYWN0aW9uID0+IHVwZGF0ZUZ1bmN0aW9uKG5ldyBUcmFuc2FjdGlvbihmaXJlc3RvcmUsIGludGVybmFsVHJhbnNhY3Rpb24pKSwgb3B0aW9uc1dpdGhEZWZhdWx0cyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzZW50aW5lbCBmb3IgdXNlIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSBvclxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IHdpdGggYHttZXJnZTogdHJ1ZX1gIHRvIG1hcmsgYSBmaWVsZCBmb3IgZGVsZXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVGaWVsZCgpIHtcclxuICAgIHJldHVybiBuZXcgRGVsZXRlRmllbGRWYWx1ZUltcGwoJ2RlbGV0ZUZpZWxkJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzZW50aW5lbCB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRvXHJcbiAqIGluY2x1ZGUgYSBzZXJ2ZXItZ2VuZXJhdGVkIHRpbWVzdGFtcCBpbiB0aGUgd3JpdHRlbiBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCgnc2VydmVyVGltZXN0YW1wJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHVuaW9uIHRoZSBnaXZlbiBlbGVtZW50cyB3aXRoIGFueSBhcnJheVxyXG4gKiB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBzZXJ2ZXIuIEVhY2ggc3BlY2lmaWVkIGVsZW1lbnQgdGhhdCBkb2Vzbid0XHJcbiAqIGFscmVhZHkgZXhpc3QgaW4gdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC4gSWYgdGhlIGZpZWxkIGJlaW5nXHJcbiAqIG1vZGlmaWVkIGlzIG5vdCBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBhcnJheVxyXG4gKiBjb250YWluaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmllZCBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHVuaW9uIGludG8gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcclxuICogYHVwZGF0ZURvYygpYC5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5VW5pb24oLi4uZWxlbWVudHMpIHtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxyXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cclxuICAgIHJldHVybiBuZXcgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsKCdhcnJheVVuaW9uJywgZWxlbWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIChzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiB1cGRhdGVEb2M6MX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHJlbW92ZSB0aGUgZ2l2ZW4gZWxlbWVudHMgZnJvbSBhbnlcclxuICogYXJyYXkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBBbGwgaW5zdGFuY2VzIG9mIGVhY2ggZWxlbWVudFxyXG4gKiBzcGVjaWZpZWQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGFycmF5LiBJZiB0aGUgZmllbGQgYmVpbmcgbW9kaWZpZWQgaXMgbm90XHJcbiAqIGFscmVhZHkgYW4gYXJyYXkgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIGFuIGVtcHR5IGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudHMgLSBUaGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcclxuICogYHVwZGF0ZURvYygpYFxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlSZW1vdmUoLi4uZWxlbWVudHMpIHtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxyXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cclxuICAgIHJldHVybiBuZXcgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCgnYXJyYXlSZW1vdmUnLCBlbGVtZW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIGluY3JlbWVudCB0aGUgZmllbGQncyBjdXJyZW50IHZhbHVlIGJ5XHJcbiAqIHRoZSBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogSWYgZWl0aGVyIHRoZSBvcGVyYW5kIG9yIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIHVzZXMgZmxvYXRpbmcgcG9pbnRcclxuICogcHJlY2lzaW9uLCBhbGwgYXJpdGhtZXRpYyBmb2xsb3dzIElFRUUgNzU0IHNlbWFudGljcy4gSWYgYm90aCB2YWx1ZXMgYXJlXHJcbiAqIGludGVnZXJzLCB2YWx1ZXMgb3V0c2lkZSBvZiBKYXZhU2NyaXB0J3Mgc2FmZSBudW1iZXIgcmFuZ2VcclxuICogKGBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUmAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCkgYXJlIGFsc28gc3ViamVjdCB0b1xyXG4gKiBwcmVjaXNpb24gbG9zcy4gRnVydGhlcm1vcmUsIG9uY2UgcHJvY2Vzc2VkIGJ5IHRoZSBGaXJlc3RvcmUgYmFja2VuZCwgYWxsXHJcbiAqIGludGVnZXIgb3BlcmF0aW9ucyBhcmUgY2FwcGVkIGJldHdlZW4gLTJeNjMgYW5kIDJeNjMtMS5cclxuICpcclxuICogSWYgdGhlIGN1cnJlbnQgZmllbGQgdmFsdWUgaXMgbm90IG9mIHR5cGUgYG51bWJlcmAsIG9yIGlmIHRoZSBmaWVsZCBkb2VzIG5vdFxyXG4gKiB5ZXQgZXhpc3QsIHRoZSB0cmFuc2Zvcm1hdGlvbiBzZXRzIHRoZSBmaWVsZCB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBuIC0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBieS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWBcclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudChuKSB7XHJcbiAgICByZXR1cm4gbmV3IE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCgnaW5jcmVtZW50Jywgbik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cml0ZSBiYXRjaCwgdXNlZCBmb3IgcGVyZm9ybWluZyBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGVcclxuICogYXRvbWljIG9wZXJhdGlvbi4gVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHtAbGluayBXcml0ZUJhdGNofVxyXG4gKiBpcyA1MDAuXHJcbiAqXHJcbiAqIFVubGlrZSB0cmFuc2FjdGlvbnMsIHdyaXRlIGJhdGNoZXMgYXJlIHBlcnNpc3RlZCBvZmZsaW5lIGFuZCB0aGVyZWZvcmUgYXJlXHJcbiAqIHByZWZlcmFibGUgd2hlbiB5b3UgZG9uJ3QgbmVlZCB0byBjb25kaXRpb24geW91ciB3cml0ZXMgb24gcmVhZCBkYXRhLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIHtAbGluayBXcml0ZUJhdGNofSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgZXhlY3V0ZSBtdWx0aXBsZVxyXG4gKiB3cml0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZUJhdGNoKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gbmV3IFdyaXRlQmF0Y2goZmlyZXN0b3JlLCBtdXRhdGlvbnMgPT4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0SW5kZXhDb25maWd1cmF0aW9uKGZpcmVzdG9yZSwganNvbk9yQ29uZmlndXJhdGlvbikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBpZiAoIWNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlciB8fFxyXG4gICAgICAgICgoX2EgPSBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fb2ZmbGluZUtpbmQpID09PSAnbWVtb3J5Jykge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogV2UgZG9uJ3QgcmV0dXJuIGFuIGVycm9yIGlmIHRoZSB1c2VyIGhhcyBub3QgZW5hYmxlZFxyXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIHNpbmNlIGBlbmFibGVJbmRleGVkZGJQZXJzaXN0ZW5jZSgpYCBjYW4gZmFpbCBvbiB0aGUgV2ViLlxyXG4gICAgICAgIGxvZ1dhcm4oJ0Nhbm5vdCBlbmFibGUgaW5kZXhlcyB3aGVuIHBlcnNpc3RlbmNlIGlzIGRpc2FibGVkJyk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IHBhcnNlSW5kZXhlcyhqc29uT3JDb25maWd1cmF0aW9uKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRTZXRJbmRleENvbmZpZ3VyYXRpb24oY2xpZW50LCBwYXJzZWRJbmRleGVzKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUluZGV4ZXMoanNvbk9yQ29uZmlndXJhdGlvbikge1xyXG4gICAgY29uc3QgaW5kZXhDb25maWd1cmF0aW9uID0gdHlwZW9mIGpzb25PckNvbmZpZ3VyYXRpb24gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyB0cnlQYXJzZUpzb24oanNvbk9yQ29uZmlndXJhdGlvbilcclxuICAgICAgICA6IGpzb25PckNvbmZpZ3VyYXRpb247XHJcbiAgICBjb25zdCBwYXJzZWRJbmRleGVzID0gW107XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleENvbmZpZ3VyYXRpb24uaW5kZXhlcykpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cCA9IHRyeUdldFN0cmluZyhpbmRleCwgJ2NvbGxlY3Rpb25Hcm91cCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleC5maWVsZHMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aFN0cmluZyA9IHRyeUdldFN0cmluZyhmaWVsZCwgJ2ZpZWxkUGF0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoJ3NldEluZGV4Q29uZmlndXJhdGlvbicsIGZpZWxkUGF0aFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmFycmF5Q29uZmlnID09PSAnQ09OVEFJTlMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnQVNDRU5ESU5HJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQub3JkZXIgPT09ICdERVNDRU5ESU5HJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMucHVzaChuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIGNvbGxlY3Rpb25Hcm91cCwgc2VnbWVudHMsIEluZGV4U3RhdGUuZW1wdHkoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRJbmRleGVzO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihqc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmFpbGVkIHRvIHBhcnNlIEpTT046ICcgKyAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cnlHZXRTdHJpbmcoZGF0YSwgcHJvcGVydHkpIHtcclxuICAgIGlmICh0eXBlb2YgZGF0YVtwcm9wZXJ0eV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01pc3Npbmcgc3RyaW5nIHZhbHVlIGZvcjogJyArIHByb3BlcnR5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhW3Byb3BlcnR5XTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyYCBmb3IgY29uZmlndXJpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIHVzZWRcclxuICogZm9yIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cclxuICpcclxuICogVG8gdXNlLCBjYWxsIGBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoKWAgdG8gZ2V0IGFuIGluc3RhbmNlLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfY2xpZW50KSB7XHJcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gX2NsaWVudDtcclxuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgUGVyc2lzdGVudENhY2hlIEluZGV4IE1hbmFnZXIgdXNlZCBieSB0aGUgZ2l2ZW4gYEZpcmVzdG9yZWBcclxuICogb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIFRoZSBgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyYCBpbnN0YW5jZSwgb3IgYG51bGxgIGlmIGxvY2FsXHJcbiAqIHBlcnNpc3RlbnQgc3RvcmFnZSBpcyBub3QgaW4gdXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyKGZpcmVzdG9yZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjYWNoZWRJbnN0YW5jZSA9IHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlLmdldChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKGNhY2hlZEluc3RhbmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZEluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKCgoX2EgPSBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fb2ZmbGluZUtpbmQpICE9PSAncGVyc2lzdGVudCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihjbGllbnQpO1xyXG4gICAgcGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyQnlGaXJlc3RvcmUuc2V0KGZpcmVzdG9yZSwgaW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBFbmFibGVzIHRoZSBTREsgdG8gY3JlYXRlIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBhdXRvbWF0aWNhbGx5IGZvciBsb2NhbFxyXG4gKiBxdWVyeSBleGVjdXRpb24gd2hlbiB0aGUgU0RLIGJlbGlldmVzIGNhY2hlIGluZGV4ZXMgY2FuIGhlbHAgaW1wcm92ZVxyXG4gKiBwZXJmb3JtYW5jZS5cclxuICpcclxuICogVGhpcyBmZWF0dXJlIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbihpbmRleE1hbmFnZXIpIHtcclxuICAgIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIHRydWUpO1xyXG59XHJcbi8qKlxyXG4gKiBTdG9wcyBjcmVhdGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgYXV0b21hdGljYWxseSBmb3IgbG9jYWwgcXVlcnlcclxuICogZXhlY3V0aW9uLiBUaGUgaW5kZXhlcyB3aGljaCBoYXZlIGJlZW4gY3JlYXRlZCBieSBjYWxsaW5nXHJcbiAqIGBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbigpYCBzdGlsbCB0YWtlIGVmZmVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRpc2FibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbihpbmRleE1hbmFnZXIpIHtcclxuICAgIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGZhbHNlKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzLlxyXG4gKlxyXG4gKiBQbGVhc2Ugbm90ZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyBkZWxldGVzIGluZGV4ZXMgZ2VuZXJhdGVkIGJ5XHJcbiAqIGBzZXRJbmRleENvbmZpZ3VyYXRpb24oKWAsIHdoaWNoIGlzIGRlcHJlY2F0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVBbGxQZXJzaXN0ZW50Q2FjaGVJbmRleGVzKGluZGV4TWFuYWdlcikge1xyXG4gICAgaW5kZXhNYW5hZ2VyLl9jbGllbnQudmVyaWZ5Tm90VGVybWluYXRlZCgpO1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcyhpbmRleE1hbmFnZXIuX2NsaWVudCk7XHJcbiAgICBwcm9taXNlXHJcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1ZygnZGVsZXRpbmcgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBzdWNjZWVkZWQnKSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gbG9nV2FybignZGVsZXRpbmcgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBmYWlsZWQnLCBlcnJvcikpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGlzRW5hYmxlZCkge1xyXG4gICAgaW5kZXhNYW5hZ2VyLl9jbGllbnQudmVyaWZ5Tm90VGVybWluYXRlZCgpO1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IGZpcmVzdG9yZUNsaWVudFNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIuX2NsaWVudCwgaXNFbmFibGVkKTtcclxuICAgIHByb21pc2VcclxuICAgICAgICAudGhlbihfID0+IGxvZ0RlYnVnKGBzZXR0aW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXggYXV0byBjcmVhdGlvbiBgICtcclxuICAgICAgICBgaXNFbmFibGVkPSR7aXNFbmFibGVkfSBzdWNjZWVkZWRgKSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gbG9nV2Fybihgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXHJcbiAgICAgICAgYGlzRW5hYmxlZD0ke2lzRW5hYmxlZH0gZmFpbGVkYCwgZXJyb3IpKTtcclxufVxyXG4vKipcclxuICogTWFwcyBgRmlyZXN0b3JlYCBpbnN0YW5jZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZ1xyXG4gKiBgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyYCBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIFVzZSBhIGBXZWFrTWFwYCBzbyB0aGF0IHRoZSBtYXBwaW5nIHdpbGwgYmUgYXV0b21hdGljYWxseSBkcm9wcGVkIHdoZW4gdGhlXHJcbiAqIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIGdhcmJhZ2UgY29sbGVjdGVkLiBUaGlzIGVtdWxhdGVzIGEgcHJpdmF0ZSBtZW1iZXJcclxuICogYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vZ29vLmdsZS80NTR5dnVnLlxyXG4gKi9cclxuY29uc3QgcGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyQnlGaXJlc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGVzdGluZyBob29rcyBmb3IgdXNlIGJ5IEZpcmVzdG9yZSdzIGludGVncmF0aW9uIHRlc3Qgc3VpdGUgdG8gcmVhY2ggaW50byB0aGVcclxuICogU0RLIGludGVybmFscyB0byB2YWxpZGF0ZSBsb2dpYyBhbmQgYmVoYXZpb3IgdGhhdCBpcyBub3QgdmlzaWJsZSBmcm9tIHRoZVxyXG4gKiBwdWJsaWMgQVBJIHN1cmZhY2UuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgVGVzdGluZ0hvb2tzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjcmVhdGVkJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIG5vdGlmaWVkIHdoZW4gYW4gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaFxyXG4gICAgICogb2NjdXJzIGluIHRoZSBXYXRjaCBsaXN0ZW4gc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZWxhdGl2ZSBvcmRlciBpbiB3aGljaCBjYWxsYmFja3MgYXJlIG5vdGlmaWVkIGlzIHVuc3BlY2lmaWVkOyBkbyBub3RcclxuICAgICAqIHJlbHkgb24gYW55IHBhcnRpY3VsYXIgb3JkZXJpbmcuIElmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCBtdWx0aXBsZVxyXG4gICAgICogdGltZXMgdGhlbiBpdCB3aWxsIGJlIG5vdGlmaWVkIG11bHRpcGxlIHRpbWVzLCBvbmNlIHBlciByZWdpc3RyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgdW5yZWdpc3RlcnMgdGhlIGdpdmVuIGNhbGxiYWNrOyBvbmx5XHJcbiAgICAgKiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gZG9lcyBhbnl0aGluZzsgYWxsIHN1YnNlcXVlbnRcclxuICAgICAqIGludm9jYXRpb25zIGRvIG5vdGhpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIFRlc3RpbmdIb29rc1NwaUltcGwuaW5zdGFuY2Uub25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjayk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBgVGVzdGluZ0hvb2tzU3BpYC5cclxuICovXHJcbmNsYXNzIFRlc3RpbmdIb29rc1NwaUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmICghdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSA9IG5ldyBUZXN0aW5nSG9va3NTcGlJbXBsKCk7XHJcbiAgICAgICAgICAgIHNldFRlc3RpbmdIb29rc1NwaSh0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgbm90aWZ5T25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChpbmZvKSB7XHJcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhpbmZvKSk7XHJcbiAgICB9XHJcbiAgICBvbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBTeW1ib2woKTtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZDtcclxuICAgICAgICBjYWxsYmFja3Muc2V0KGlkLCBjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbGxiYWNrcy5kZWxldGUoaWQpO1xyXG4gICAgfVxyXG59XHJcbmxldCB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UgPSBudWxsO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5yZWdpc3RlckZpcmVzdG9yZSgnbm9kZScpO1xuXG5leHBvcnQgeyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyLCBBZ2dyZWdhdGVGaWVsZCwgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCwgQnl0ZXMsIENBQ0hFX1NJWkVfVU5MSU1JVEVELCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSwgRG9jdW1lbnRTbmFwc2hvdCwgRmllbGRQYXRoLCBGaWVsZFZhbHVlLCBGaXJlc3RvcmUsIEZpcmVzdG9yZUVycm9yLCBHZW9Qb2ludCwgTG9hZEJ1bmRsZVRhc2ssIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgUXVlcnksIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgUXVlcnlDb25zdHJhaW50LCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUXVlcnlMaW1pdENvbnN0cmFpbnQsIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIFF1ZXJ5U25hcHNob3QsIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFNuYXBzaG90TWV0YWRhdGEsIFRpbWVzdGFtcCwgVHJhbnNhY3Rpb24sIFdyaXRlQmF0Y2gsIEF1dG9JZCBhcyBfQXV0b0lkLCBCeXRlU3RyaW5nIGFzIF9CeXRlU3RyaW5nLCBEYXRhYmFzZUlkIGFzIF9EYXRhYmFzZUlkLCBEb2N1bWVudEtleSBhcyBfRG9jdW1lbnRLZXksIEVtcHR5QXBwQ2hlY2tUb2tlblByb3ZpZGVyIGFzIF9FbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciwgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciBhcyBfRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgRmllbGRQYXRoJDEgYXMgX0ZpZWxkUGF0aCwgVGVzdGluZ0hvb2tzIGFzIF9UZXN0aW5nSG9va3MsIGNhc3QgYXMgX2Nhc3QsIGRlYnVnQXNzZXJ0IGFzIF9kZWJ1Z0Fzc2VydCwgaXNCYXNlNjRBdmFpbGFibGUgYXMgX2lzQmFzZTY0QXZhaWxhYmxlLCBsb2dXYXJuIGFzIF9sb2dXYXJuLCB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyIGFzIF92YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyLCBhZGREb2MsIGFnZ3JlZ2F0ZUZpZWxkRXF1YWwsIGFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RFcXVhbCwgYW5kLCBhcnJheVJlbW92ZSwgYXJyYXlVbmlvbiwgYXZlcmFnZSwgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSwgY29sbGVjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IsIGNvdW50LCBkZWxldGVBbGxQZXJzaXN0ZW50Q2FjaGVJbmRleGVzLCBkZWxldGVEb2MsIGRlbGV0ZUZpZWxkLCBkaXNhYmxlTmV0d29yaywgZGlzYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBkb2MsIGRvY3VtZW50SWQsIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVOZXR3b3JrLCBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbiwgZW5kQXQsIGVuZEJlZm9yZSwgZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZCwgZXhlY3V0ZVdyaXRlLCBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyLCBnZXRDb3VudEZyb21TZXJ2ZXIsIGdldERvYywgZ2V0RG9jRnJvbUNhY2hlLCBnZXREb2NGcm9tU2VydmVyLCBnZXREb2NzLCBnZXREb2NzRnJvbUNhY2hlLCBnZXREb2NzRnJvbVNlcnZlciwgZ2V0RmlyZXN0b3JlLCBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIGluY3JlbWVudCwgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgbGltaXQsIGxpbWl0VG9MYXN0LCBsb2FkQnVuZGxlLCBtZW1vcnlFYWdlckdhcmJhZ2VDb2xsZWN0b3IsIG1lbW9yeUxvY2FsQ2FjaGUsIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3IsIG5hbWVkUXVlcnksIG9uU25hcHNob3QsIG9uU25hcHNob3RzSW5TeW5jLCBvciwgb3JkZXJCeSwgcGVyc2lzdGVudExvY2FsQ2FjaGUsIHBlcnNpc3RlbnRNdWx0aXBsZVRhYk1hbmFnZXIsIHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyLCBxdWVyeSwgcXVlcnlFcXVhbCwgcmVmRXF1YWwsIHJ1blRyYW5zYWN0aW9uLCBzZXJ2ZXJUaW1lc3RhbXAsIHNldERvYywgc2V0SW5kZXhDb25maWd1cmF0aW9uLCBzZXRMb2dMZXZlbCwgc25hcHNob3RFcXVhbCwgc3RhcnRBZnRlciwgc3RhcnRBdCwgc3VtLCB0ZXJtaW5hdGUsIHVwZGF0ZURvYywgd2FpdEZvclBlbmRpbmdXcml0ZXMsIHdoZXJlLCB3cml0ZUJhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A container for all of the Logger instances\r\n */\r\nconst instances = [];\r\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\r\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\r\n})(LogLevel || (LogLevel = {}));\r\nconst levelStringToEnum = {\r\n    'debug': LogLevel.DEBUG,\r\n    'verbose': LogLevel.VERBOSE,\r\n    'info': LogLevel.INFO,\r\n    'warn': LogLevel.WARN,\r\n    'error': LogLevel.ERROR,\r\n    'silent': LogLevel.SILENT\r\n};\r\n/**\r\n * The default log level\r\n */\r\nconst defaultLogLevel = LogLevel.INFO;\r\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\r\nconst ConsoleMethod = {\r\n    [LogLevel.DEBUG]: 'log',\r\n    [LogLevel.VERBOSE]: 'log',\r\n    [LogLevel.INFO]: 'info',\r\n    [LogLevel.WARN]: 'warn',\r\n    [LogLevel.ERROR]: 'error'\r\n};\r\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\r\nconst defaultLogHandler = (instance, logType, ...args) => {\r\n    if (logType < instance.logLevel) {\r\n        return;\r\n    }\r\n    const now = new Date().toISOString();\r\n    const method = ConsoleMethod[logType];\r\n    if (method) {\r\n        console[method](`[${now}]  ${instance.name}:`, ...args);\r\n    }\r\n    else {\r\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\r\n    }\r\n};\r\nclass Logger {\r\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */\r\n    constructor(name) {\r\n        this.name = name;\r\n        /**\r\n         * The log level of the given Logger instance.\r\n         */\r\n        this._logLevel = defaultLogLevel;\r\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */\r\n        this._logHandler = defaultLogHandler;\r\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */\r\n        this._userLogHandler = null;\r\n        /**\r\n         * Capture the current instance for later use\r\n         */\r\n        instances.push(this);\r\n    }\r\n    get logLevel() {\r\n        return this._logLevel;\r\n    }\r\n    set logLevel(val) {\r\n        if (!(val in LogLevel)) {\r\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\r\n        }\r\n        this._logLevel = val;\r\n    }\r\n    // Workaround for setter/getter having to be the same type.\r\n    setLogLevel(val) {\r\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\r\n    }\r\n    get logHandler() {\r\n        return this._logHandler;\r\n    }\r\n    set logHandler(val) {\r\n        if (typeof val !== 'function') {\r\n            throw new TypeError('Value assigned to `logHandler` must be a function');\r\n        }\r\n        this._logHandler = val;\r\n    }\r\n    get userLogHandler() {\r\n        return this._userLogHandler;\r\n    }\r\n    set userLogHandler(val) {\r\n        this._userLogHandler = val;\r\n    }\r\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\r\n    debug(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\r\n        this._logHandler(this, LogLevel.DEBUG, ...args);\r\n    }\r\n    log(...args) {\r\n        this._userLogHandler &&\r\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\r\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\r\n    }\r\n    info(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\r\n        this._logHandler(this, LogLevel.INFO, ...args);\r\n    }\r\n    warn(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\r\n        this._logHandler(this, LogLevel.WARN, ...args);\r\n    }\r\n    error(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\r\n        this._logHandler(this, LogLevel.ERROR, ...args);\r\n    }\r\n}\r\nfunction setLogLevel(level) {\r\n    instances.forEach(inst => {\r\n        inst.setLogLevel(level);\r\n    });\r\n}\r\nfunction setUserLogHandler(logCallback, options) {\r\n    for (const instance of instances) {\r\n        let customLogLevel = null;\r\n        if (options && options.level) {\r\n            customLogLevel = levelStringToEnum[options.level];\r\n        }\r\n        if (logCallback === null) {\r\n            instance.userLogHandler = null;\r\n        }\r\n        else {\r\n            instance.userLogHandler = (instance, level, ...args) => {\r\n                const message = args\r\n                    .map(arg => {\r\n                    if (arg == null) {\r\n                        return null;\r\n                    }\r\n                    else if (typeof arg === 'string') {\r\n                        return arg;\r\n                    }\r\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\r\n                        return arg.toString();\r\n                    }\r\n                    else if (arg instanceof Error) {\r\n                        return arg.message;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            return JSON.stringify(arg);\r\n                        }\r\n                        catch (ignored) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                })\r\n                    .filter(arg => arg)\r\n                    .join(' ');\r\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\r\n                    logCallback({\r\n                        level: LogLevel[level].toLowerCase(),\r\n                        message,\r\n                        args,\r\n                        type: instance.name\r\n                    });\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWJsZS1xdWl6Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz84Zjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\r\nconst CONSTANTS = {\r\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */\r\n    NODE_CLIENT: false,\r\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */\r\n    NODE_ADMIN: false,\r\n    /**\r\n     * Firebase SDK Version\r\n     */\r\n    SDK_VERSION: '${JSCORE_VERSION}'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\r\nconst assert = function (assertion, message) {\r\n    if (!assertion) {\r\n        throw assertionError(message);\r\n    }\r\n};\r\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\r\nconst assertionError = function (message) {\r\n    return new Error('Firebase Database (' +\r\n        CONSTANTS.SDK_VERSION +\r\n        ') INTERNAL ASSERT FAILED: ' +\r\n        message);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst stringToByteArray$1 = function (str) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if ((c & 0xfc00) === 0xd800 &&\r\n            i + 1 < str.length &&\r\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n            // Surrogate Pair\r\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\r\nconst byteArrayToString = function (bytes) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let pos = 0, c = 0;\r\n    while (pos < bytes.length) {\r\n        const c1 = bytes[pos++];\r\n        if (c1 < 128) {\r\n            out[c++] = String.fromCharCode(c1);\r\n        }\r\n        else if (c1 > 191 && c1 < 224) {\r\n            const c2 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n        }\r\n        else if (c1 > 239 && c1 < 365) {\r\n            // Surrogate Pair\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            const c4 = bytes[pos++];\r\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\r\n                0x10000;\r\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n        }\r\n        else {\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n        }\r\n    }\r\n    return out.join('');\r\n};\r\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\r\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\r\n// Static lookup maps, lazily populated by init_()\r\nconst base64 = {\r\n    /**\r\n     * Maps bytes to characters.\r\n     */\r\n    byteToCharMap_: null,\r\n    /**\r\n     * Maps characters to bytes.\r\n     */\r\n    charToByteMap_: null,\r\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */\r\n    byteToCharMapWebSafe_: null,\r\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */\r\n    charToByteMapWebSafe_: null,\r\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */\r\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\r\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */\r\n    get ENCODED_VALS() {\r\n        return this.ENCODED_VALS_BASE + '+/=';\r\n    },\r\n    /**\r\n     * Our websafe alphabet.\r\n     */\r\n    get ENCODED_VALS_WEBSAFE() {\r\n        return this.ENCODED_VALS_BASE + '-_.';\r\n    },\r\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */\r\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\r\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeByteArray(input, webSafe) {\r\n        if (!Array.isArray(input)) {\r\n            throw Error('encodeByteArray takes an array as a parameter');\r\n        }\r\n        this.init_();\r\n        const byteToCharMap = webSafe\r\n            ? this.byteToCharMapWebSafe_\r\n            : this.byteToCharMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length; i += 3) {\r\n            const byte1 = input[i];\r\n            const haveByte2 = i + 1 < input.length;\r\n            const byte2 = haveByte2 ? input[i + 1] : 0;\r\n            const haveByte3 = i + 2 < input.length;\r\n            const byte3 = haveByte3 ? input[i + 2] : 0;\r\n            const outByte1 = byte1 >> 2;\r\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\r\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\r\n            let outByte4 = byte3 & 0x3f;\r\n            if (!haveByte3) {\r\n                outByte4 = 64;\r\n                if (!haveByte2) {\r\n                    outByte3 = 64;\r\n                }\r\n            }\r\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\r\n        }\r\n        return output.join('');\r\n    },\r\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return btoa(input);\r\n        }\r\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */\r\n    decodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return atob(input);\r\n        }\r\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */\r\n    decodeStringToByteArray(input, webSafe) {\r\n        this.init_();\r\n        const charToByteMap = webSafe\r\n            ? this.charToByteMapWebSafe_\r\n            : this.charToByteMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length;) {\r\n            const byte1 = charToByteMap[input.charAt(i++)];\r\n            const haveByte2 = i < input.length;\r\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\r\n            ++i;\r\n            const haveByte3 = i < input.length;\r\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            const haveByte4 = i < input.length;\r\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\r\n                throw new DecodeBase64StringError();\r\n            }\r\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\r\n            output.push(outByte1);\r\n            if (byte3 !== 64) {\r\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\r\n                output.push(outByte2);\r\n                if (byte4 !== 64) {\r\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\r\n                    output.push(outByte3);\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    },\r\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */\r\n    init_() {\r\n        if (!this.byteToCharMap_) {\r\n            this.byteToCharMap_ = {};\r\n            this.charToByteMap_ = {};\r\n            this.byteToCharMapWebSafe_ = {};\r\n            this.charToByteMapWebSafe_ = {};\r\n            // We want quick mappings back and forth, so we precompute two maps.\r\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\r\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\r\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\r\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\r\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\r\n                // Be forgiving when decoding and correctly decode both encodings.\r\n                if (i >= this.ENCODED_VALS_BASE.length) {\r\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\r\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass DecodeBase64StringError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'DecodeBase64StringError';\r\n    }\r\n}\r\n/**\r\n * URL-safe base64 encoding\r\n */\r\nconst base64Encode = function (str) {\r\n    const utf8Bytes = stringToByteArray$1(str);\r\n    return base64.encodeByteArray(utf8Bytes, true);\r\n};\r\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\r\nconst base64urlEncodeWithoutPadding = function (str) {\r\n    // Use base64url encoding and remove padding in the end (dot characters).\r\n    return base64Encode(str).replace(/\\./g, '');\r\n};\r\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\r\nconst base64Decode = function (str) {\r\n    try {\r\n        return base64.decodeString(str, true);\r\n    }\r\n    catch (e) {\r\n        console.error('base64Decode failed: ', e);\r\n    }\r\n    return null;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\r\nfunction deepCopy(value) {\r\n    return deepExtend(undefined, value);\r\n}\r\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\r\nfunction deepExtend(target, source) {\r\n    if (!(source instanceof Object)) {\r\n        return source;\r\n    }\r\n    switch (source.constructor) {\r\n        case Date:\r\n            // Treat Dates like scalars; if the target date object had any child\r\n            // properties - they will be lost!\r\n            const dateValue = source;\r\n            return new Date(dateValue.getTime());\r\n        case Object:\r\n            if (target === undefined) {\r\n                target = {};\r\n            }\r\n            break;\r\n        case Array:\r\n            // Always copy the array source and overwrite the target.\r\n            target = [];\r\n            break;\r\n        default:\r\n            // Not a plain Object - treat it as a scalar.\r\n            return source;\r\n    }\r\n    for (const prop in source) {\r\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\r\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\r\n            continue;\r\n        }\r\n        target[prop] = deepExtend(target[prop], source[prop]);\r\n    }\r\n    return target;\r\n}\r\nfunction isValidKey(key) {\r\n    return key !== '__proto__';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */\r\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    throw new Error('Unable to locate global object.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\r\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */\r\nconst getDefaultsFromEnvVariable = () => {\r\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\r\n        return;\r\n    }\r\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\r\n    if (defaultsJsonString) {\r\n        return JSON.parse(defaultsJsonString);\r\n    }\r\n};\r\nconst getDefaultsFromCookie = () => {\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    let match;\r\n    try {\r\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\r\n    }\r\n    catch (e) {\r\n        // Some environments such as Angular Universal SSR have a\r\n        // `document` object but error on accessing `document.cookie`.\r\n        return;\r\n    }\r\n    const decoded = match && base64Decode(match[1]);\r\n    return decoded && JSON.parse(decoded);\r\n};\r\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */\r\nconst getDefaults = () => {\r\n    try {\r\n        return (getDefaultsFromGlobal() ||\r\n            getDefaultsFromEnvVariable() ||\r\n            getDefaultsFromCookie());\r\n    }\r\n    catch (e) {\r\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */\r\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\r\n        return;\r\n    }\r\n};\r\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\r\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\r\n    const host = getDefaultEmulatorHost(productName);\r\n    if (!host) {\r\n        return undefined;\r\n    }\r\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\r\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\r\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\r\n    }\r\n    // eslint-disable-next-line no-restricted-globals\r\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\r\n    if (host[0] === '[') {\r\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\r\n        return [host.substring(1, separatorIndex - 1), port];\r\n    }\r\n    else {\r\n        return [host.substring(0, separatorIndex), port];\r\n    }\r\n};\r\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */\r\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\r\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */\r\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.reject = () => { };\r\n        this.resolve = () => { };\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */\r\n    wrapCallback(callback) {\r\n        return (error, value) => {\r\n            if (error) {\r\n                this.reject(error);\r\n            }\r\n            else {\r\n                this.resolve(value);\r\n            }\r\n            if (typeof callback === 'function') {\r\n                // Attaching noop handler just in case developer wasn't expecting\r\n                // promises\r\n                this.promise.catch(() => { });\r\n                // Some of our callbacks don't expect a value and our own tests\r\n                // assert that the parameter length is 1\r\n                if (callback.length === 1) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    callback(error, value);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction createMockUserToken(token, projectId) {\r\n    if (token.uid) {\r\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\r\n    }\r\n    // Unsecured JWTs use \"none\" as the algorithm.\r\n    const header = {\r\n        alg: 'none',\r\n        type: 'JWT'\r\n    };\r\n    const project = projectId || 'demo-project';\r\n    const iat = token.iat || 0;\r\n    const sub = token.sub || token.user_id;\r\n    if (!sub) {\r\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n    }\r\n    const payload = Object.assign({ \r\n        // Set all required fields to decent defaults\r\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\r\n            sign_in_provider: 'custom',\r\n            identities: {}\r\n        } }, token);\r\n    // Unsecured JWTs use the empty string as a signature.\r\n    const signature = '';\r\n    return [\r\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\r\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\r\n        signature\r\n    ].join('.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\r\nfunction getUA() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        typeof navigator['userAgent'] === 'string') {\r\n        return navigator['userAgent'];\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\r\nfunction isMobileCordova() {\r\n    return (typeof window !== 'undefined' &&\r\n        // @ts-ignore Setting up an broadly applicable index signature for Window\r\n        // just to deal with this case would probably be a bad idea.\r\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\r\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\r\n}\r\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */\r\n// Node detection logic from: https://github.com/iliakan/detect-node/\r\nfunction isNode() {\r\n    var _a;\r\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\r\n    if (forceEnvironment === 'node') {\r\n        return true;\r\n    }\r\n    else if (forceEnvironment === 'browser') {\r\n        return false;\r\n    }\r\n    try {\r\n        return (Object.prototype.toString.call(global.process) === '[object process]');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Detect Browser Environment\r\n */\r\nfunction isBrowser() {\r\n    return typeof self === 'object' && self.self === self;\r\n}\r\nfunction isBrowserExtension() {\r\n    const runtime = typeof chrome === 'object'\r\n        ? chrome.runtime\r\n        : typeof browser === 'object'\r\n            ? browser.runtime\r\n            : undefined;\r\n    return typeof runtime === 'object' && runtime.id !== undefined;\r\n}\r\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\r\nfunction isReactNative() {\r\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\r\n}\r\n/** Detects Electron apps. */\r\nfunction isElectron() {\r\n    return getUA().indexOf('Electron/') >= 0;\r\n}\r\n/** Detects Internet Explorer. */\r\nfunction isIE() {\r\n    const ua = getUA();\r\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\r\n}\r\n/** Detects Universal Windows Platform apps. */\r\nfunction isUWP() {\r\n    return getUA().indexOf('MSAppHost/') >= 0;\r\n}\r\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\r\nfunction isNodeSdk() {\r\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\r\n}\r\n/** Returns true if we are running in Safari. */\r\nfunction isSafari() {\r\n    return (!isNode() &&\r\n        !!navigator.userAgent &&\r\n        navigator.userAgent.includes('Safari') &&\r\n        !navigator.userAgent.includes('Chrome'));\r\n}\r\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\r\nfunction isIndexedDBAvailable() {\r\n    try {\r\n        return typeof indexedDB === 'object';\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\r\nfunction validateIndexedDBOpenable() {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            let preExist = true;\r\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\r\n            const request = self.indexedDB.open(DB_CHECK_NAME);\r\n            request.onsuccess = () => {\r\n                request.result.close();\r\n                // delete database only when it doesn't pre-exist\r\n                if (!preExist) {\r\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\r\n                }\r\n                resolve(true);\r\n            };\r\n            request.onupgradeneeded = () => {\r\n                preExist = false;\r\n            };\r\n            request.onerror = () => {\r\n                var _a;\r\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\r\n            };\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\r\nfunction areCookiesEnabled() {\r\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\r\nconst ERROR_NAME = 'FirebaseError';\r\n// Based on code from:\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\r\nclass FirebaseError extends Error {\r\n    constructor(\r\n    /** The error code for this error. */\r\n    code, message, \r\n    /** Custom data for this error. */\r\n    customData) {\r\n        super(message);\r\n        this.code = code;\r\n        this.customData = customData;\r\n        /** The custom name for all FirebaseErrors. */\r\n        this.name = ERROR_NAME;\r\n        // Fix For ES5\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, FirebaseError.prototype);\r\n        // Maintains proper stack trace for where our error was thrown.\r\n        // Only available on V8.\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\r\n        }\r\n    }\r\n}\r\nclass ErrorFactory {\r\n    constructor(service, serviceName, errors) {\r\n        this.service = service;\r\n        this.serviceName = serviceName;\r\n        this.errors = errors;\r\n    }\r\n    create(code, ...data) {\r\n        const customData = data[0] || {};\r\n        const fullCode = `${this.service}/${code}`;\r\n        const template = this.errors[code];\r\n        const message = template ? replaceTemplate(template, customData) : 'Error';\r\n        // Service Name: Error message (service/code).\r\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\r\n        const error = new FirebaseError(fullCode, fullMessage, customData);\r\n        return error;\r\n    }\r\n}\r\nfunction replaceTemplate(template, data) {\r\n    return template.replace(PATTERN, (_, key) => {\r\n        const value = data[key];\r\n        return value != null ? String(value) : `<${key}?>`;\r\n    });\r\n}\r\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\r\nfunction jsonEval(str) {\r\n    return JSON.parse(str);\r\n}\r\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\r\nfunction stringify(data) {\r\n    return JSON.stringify(data);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst decode = function (token) {\r\n    let header = {}, claims = {}, data = {}, signature = '';\r\n    try {\r\n        const parts = token.split('.');\r\n        header = jsonEval(base64Decode(parts[0]) || '');\r\n        claims = jsonEval(base64Decode(parts[1]) || '');\r\n        signature = parts[2];\r\n        data = claims['d'] || {};\r\n        delete claims['d'];\r\n    }\r\n    catch (e) { }\r\n    return {\r\n        header,\r\n        claims,\r\n        data,\r\n        signature\r\n    };\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidTimestamp = function (token) {\r\n    const claims = decode(token).claims;\r\n    const now = Math.floor(new Date().getTime() / 1000);\r\n    let validSince = 0, validUntil = 0;\r\n    if (typeof claims === 'object') {\r\n        if (claims.hasOwnProperty('nbf')) {\r\n            validSince = claims['nbf'];\r\n        }\r\n        else if (claims.hasOwnProperty('iat')) {\r\n            validSince = claims['iat'];\r\n        }\r\n        if (claims.hasOwnProperty('exp')) {\r\n            validUntil = claims['exp'];\r\n        }\r\n        else {\r\n            // token will expire after 24h by default\r\n            validUntil = validSince + 86400;\r\n        }\r\n    }\r\n    return (!!now &&\r\n        !!validSince &&\r\n        !!validUntil &&\r\n        now >= validSince &&\r\n        now <= validUntil);\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst issuedAtTime = function (token) {\r\n    const claims = decode(token).claims;\r\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\r\n        return claims['iat'];\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidFormat = function (token) {\r\n    const decoded = decode(token), claims = decoded.claims;\r\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\r\n};\r\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isAdmin = function (token) {\r\n    const claims = decode(token).claims;\r\n    return typeof claims === 'object' && claims['admin'] === true;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction contains(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\nfunction safeGet(obj, key) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction map(obj, fn, contextObj) {\r\n    const res = {};\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            res[key] = fn.call(contextObj, obj[key], key, obj);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\r\nfunction deepEqual(a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    for (const k of aKeys) {\r\n        if (!bKeys.includes(k)) {\r\n            return false;\r\n        }\r\n        const aProp = a[k];\r\n        const bProp = b[k];\r\n        if (isObject(aProp) && isObject(bProp)) {\r\n            if (!deepEqual(aProp, bProp)) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (aProp !== bProp) {\r\n            return false;\r\n        }\r\n    }\r\n    for (const k of bKeys) {\r\n        if (!aKeys.includes(k)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isObject(thing) {\r\n    return thing !== null && typeof thing === 'object';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */\r\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\r\n    const deferredPromise = new Deferred();\r\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\r\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\r\n    return deferredPromise.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\r\nfunction querystring(querystringParams) {\r\n    const params = [];\r\n    for (const [key, value] of Object.entries(querystringParams)) {\r\n        if (Array.isArray(value)) {\r\n            value.forEach(arrayVal => {\r\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\r\n            });\r\n        }\r\n        else {\r\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        }\r\n    }\r\n    return params.length ? '&' + params.join('&') : '';\r\n}\r\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\r\nfunction querystringDecode(querystring) {\r\n    const obj = {};\r\n    const tokens = querystring.replace(/^\\?/, '').split('&');\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            const [key, value] = token.split('=');\r\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\r\nfunction extractQuerystring(url) {\r\n    const queryStart = url.indexOf('?');\r\n    if (!queryStart) {\r\n        return '';\r\n    }\r\n    const fragmentStart = url.indexOf('#', queryStart);\r\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\r\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\nclass Sha1 {\r\n    constructor() {\r\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */\r\n        this.chain_ = [];\r\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */\r\n        this.buf_ = [];\r\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */\r\n        this.W_ = [];\r\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */\r\n        this.pad_ = [];\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.inbuf_ = 0;\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.total_ = 0;\r\n        this.blockSize = 512 / 8;\r\n        this.pad_[0] = 128;\r\n        for (let i = 1; i < this.blockSize; ++i) {\r\n            this.pad_[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.chain_[0] = 0x67452301;\r\n        this.chain_[1] = 0xefcdab89;\r\n        this.chain_[2] = 0x98badcfe;\r\n        this.chain_[3] = 0x10325476;\r\n        this.chain_[4] = 0xc3d2e1f0;\r\n        this.inbuf_ = 0;\r\n        this.total_ = 0;\r\n    }\r\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\r\n    compress_(buf, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        const W = this.W_;\r\n        // get 16 big endian words\r\n        if (typeof buf === 'string') {\r\n            for (let i = 0; i < 16; i++) {\r\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\r\n                // have a bug that turns the post-increment ++ operator into pre-increment\r\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\r\n                // correctness and which is affected by this bug, so I've removed all uses\r\n                // of post-increment ++ in which the result value is used.  We can revert\r\n                // this change once the Safari bug\r\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\r\n                // most clients have been updated.\r\n                W[i] =\r\n                    (buf.charCodeAt(offset) << 24) |\r\n                        (buf.charCodeAt(offset + 1) << 16) |\r\n                        (buf.charCodeAt(offset + 2) << 8) |\r\n                        buf.charCodeAt(offset + 3);\r\n                offset += 4;\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < 16; i++) {\r\n                W[i] =\r\n                    (buf[offset] << 24) |\r\n                        (buf[offset + 1] << 16) |\r\n                        (buf[offset + 2] << 8) |\r\n                        buf[offset + 3];\r\n                offset += 4;\r\n            }\r\n        }\r\n        // expand to 80 words\r\n        for (let i = 16; i < 80; i++) {\r\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\r\n        }\r\n        let a = this.chain_[0];\r\n        let b = this.chain_[1];\r\n        let c = this.chain_[2];\r\n        let d = this.chain_[3];\r\n        let e = this.chain_[4];\r\n        let f, k;\r\n        // TODO(user): Try to unroll this loop to speed up the computation.\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 40) {\r\n                if (i < 20) {\r\n                    f = d ^ (b & (c ^ d));\r\n                    k = 0x5a827999;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0x6ed9eba1;\r\n                }\r\n            }\r\n            else {\r\n                if (i < 60) {\r\n                    f = (b & c) | (d & (b | c));\r\n                    k = 0x8f1bbcdc;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0xca62c1d6;\r\n                }\r\n            }\r\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\r\n            b = a;\r\n            a = t;\r\n        }\r\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\r\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\r\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\r\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\r\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\r\n    }\r\n    update(bytes, length) {\r\n        // TODO(johnlenz): tighten the function signature and remove this check\r\n        if (bytes == null) {\r\n            return;\r\n        }\r\n        if (length === undefined) {\r\n            length = bytes.length;\r\n        }\r\n        const lengthMinusBlock = length - this.blockSize;\r\n        let n = 0;\r\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\r\n        const buf = this.buf_;\r\n        let inbuf = this.inbuf_;\r\n        // The outer while loop should execute at most twice.\r\n        while (n < length) {\r\n            // When we have no data in the block to top up, we can directly process the\r\n            // input buffer (assuming it contains sufficient data). This gives ~25%\r\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\r\n            // the data is provided in large chunks (or in multiples of 64 bytes).\r\n            if (inbuf === 0) {\r\n                while (n <= lengthMinusBlock) {\r\n                    this.compress_(bytes, n);\r\n                    n += this.blockSize;\r\n                }\r\n            }\r\n            if (typeof bytes === 'string') {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes.charCodeAt(n);\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes[n];\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inbuf_ = inbuf;\r\n        this.total_ += length;\r\n    }\r\n    /** @override */\r\n    digest() {\r\n        const digest = [];\r\n        let totalBits = this.total_ * 8;\r\n        // Add pad 0x80 0x00*.\r\n        if (this.inbuf_ < 56) {\r\n            this.update(this.pad_, 56 - this.inbuf_);\r\n        }\r\n        else {\r\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\r\n        }\r\n        // Add # bits.\r\n        for (let i = this.blockSize - 1; i >= 56; i--) {\r\n            this.buf_[i] = totalBits & 255;\r\n            totalBits /= 256; // Don't use bit-shifting here!\r\n        }\r\n        this.compress_(this.buf_);\r\n        let n = 0;\r\n        for (let i = 0; i < 5; i++) {\r\n            for (let j = 24; j >= 0; j -= 8) {\r\n                digest[n] = (this.chain_[i] >> j) & 255;\r\n                ++n;\r\n            }\r\n        }\r\n        return digest;\r\n    }\r\n}\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\r\nfunction createSubscribe(executor, onNoObservers) {\r\n    const proxy = new ObserverProxy(executor, onNoObservers);\r\n    return proxy.subscribe.bind(proxy);\r\n}\r\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\r\nclass ObserverProxy {\r\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\r\n    constructor(executor, onNoObservers) {\r\n        this.observers = [];\r\n        this.unsubscribes = [];\r\n        this.observerCount = 0;\r\n        // Micro-task scheduling by calling task.then().\r\n        this.task = Promise.resolve();\r\n        this.finalized = false;\r\n        this.onNoObservers = onNoObservers;\r\n        // Call the executor asynchronously so subscribers that are called\r\n        // synchronously after the creation of the subscribe function\r\n        // can still receive the very first value generated in the executor.\r\n        this.task\r\n            .then(() => {\r\n            executor(this);\r\n        })\r\n            .catch(e => {\r\n            this.error(e);\r\n        });\r\n    }\r\n    next(value) {\r\n        this.forEachObserver((observer) => {\r\n            observer.next(value);\r\n        });\r\n    }\r\n    error(error) {\r\n        this.forEachObserver((observer) => {\r\n            observer.error(error);\r\n        });\r\n        this.close(error);\r\n    }\r\n    complete() {\r\n        this.forEachObserver((observer) => {\r\n            observer.complete();\r\n        });\r\n        this.close();\r\n    }\r\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\r\n    subscribe(nextOrObserver, error, complete) {\r\n        let observer;\r\n        if (nextOrObserver === undefined &&\r\n            error === undefined &&\r\n            complete === undefined) {\r\n            throw new Error('Missing Observer.');\r\n        }\r\n        // Assemble an Observer object when passed as callback functions.\r\n        if (implementsAnyMethods(nextOrObserver, [\r\n            'next',\r\n            'error',\r\n            'complete'\r\n        ])) {\r\n            observer = nextOrObserver;\r\n        }\r\n        else {\r\n            observer = {\r\n                next: nextOrObserver,\r\n                error,\r\n                complete\r\n            };\r\n        }\r\n        if (observer.next === undefined) {\r\n            observer.next = noop;\r\n        }\r\n        if (observer.error === undefined) {\r\n            observer.error = noop;\r\n        }\r\n        if (observer.complete === undefined) {\r\n            observer.complete = noop;\r\n        }\r\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\r\n        // Attempt to subscribe to a terminated Observable - we\r\n        // just respond to the Observer with the final error or complete\r\n        // event.\r\n        if (this.finalized) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.task.then(() => {\r\n                try {\r\n                    if (this.finalError) {\r\n                        observer.error(this.finalError);\r\n                    }\r\n                    else {\r\n                        observer.complete();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // nothing\r\n                }\r\n                return;\r\n            });\r\n        }\r\n        this.observers.push(observer);\r\n        return unsub;\r\n    }\r\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\r\n    // any unsubscribed Observer.\r\n    unsubscribeOne(i) {\r\n        if (this.observers === undefined || this.observers[i] === undefined) {\r\n            return;\r\n        }\r\n        delete this.observers[i];\r\n        this.observerCount -= 1;\r\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\r\n            this.onNoObservers(this);\r\n        }\r\n    }\r\n    forEachObserver(fn) {\r\n        if (this.finalized) {\r\n            // Already closed by previous event....just eat the additional values.\r\n            return;\r\n        }\r\n        // Since sendOne calls asynchronously - there is no chance that\r\n        // this.observers will become undefined.\r\n        for (let i = 0; i < this.observers.length; i++) {\r\n            this.sendOne(i, fn);\r\n        }\r\n    }\r\n    // Call the Observer via one of it's callback function. We are careful to\r\n    // confirm that the observe has not been unsubscribed since this asynchronous\r\n    // function had been queued.\r\n    sendOne(i, fn) {\r\n        // Execute the callback asynchronously\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\r\n                try {\r\n                    fn(this.observers[i]);\r\n                }\r\n                catch (e) {\r\n                    // Ignore exceptions raised in Observers or missing methods of an\r\n                    // Observer.\r\n                    // Log error to console. b/31404806\r\n                    if (typeof console !== 'undefined' && console.error) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    close(err) {\r\n        if (this.finalized) {\r\n            return;\r\n        }\r\n        this.finalized = true;\r\n        if (err !== undefined) {\r\n            this.finalError = err;\r\n        }\r\n        // Proxy is no longer needed - garbage collect references\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            this.observers = undefined;\r\n            this.onNoObservers = undefined;\r\n        });\r\n    }\r\n}\r\n/** Turn synchronous function into one called asynchronously. */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction async(fn, onError) {\r\n    return (...args) => {\r\n        Promise.resolve(true)\r\n            .then(() => {\r\n            fn(...args);\r\n        })\r\n            .catch((error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        });\r\n    };\r\n}\r\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    for (const method of methods) {\r\n        if (method in obj && typeof obj[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction noop() {\r\n    // do nothing\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\r\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\r\n    let argError;\r\n    if (argCount < minCount) {\r\n        argError = 'at least ' + minCount;\r\n    }\r\n    else if (argCount > maxCount) {\r\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\r\n    }\r\n    if (argError) {\r\n        const error = fnName +\r\n            ' failed: Was called with ' +\r\n            argCount +\r\n            (argCount === 1 ? ' argument.' : ' arguments.') +\r\n            ' Expects ' +\r\n            argError +\r\n            '.';\r\n        throw new Error(error);\r\n    }\r\n};\r\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\r\nfunction errorPrefix(fnName, argName) {\r\n    return `${fnName} failed: ${argName} argument `;\r\n}\r\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\r\nfunction validateNamespace(fnName, namespace, optional) {\r\n    if (optional && !namespace) {\r\n        return;\r\n    }\r\n    if (typeof namespace !== 'string') {\r\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\r\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\r\n    }\r\n}\r\nfunction validateCallback(fnName, argumentName, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\ncallback, optional) {\r\n    if (optional && !callback) {\r\n        return;\r\n    }\r\n    if (typeof callback !== 'function') {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\r\n    }\r\n}\r\nfunction validateContextObject(fnName, argumentName, context, optional) {\r\n    if (optional && !context) {\r\n        return;\r\n    }\r\n    if (typeof context !== 'object' || context === null) {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\r\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\r\n// so it's been modified.\r\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\r\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\r\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\r\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\r\n// pair).\r\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\r\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\r\nconst stringToByteArray = function (str) {\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        // Is this the lead surrogate in a surrogate pair?\r\n        if (c >= 0xd800 && c <= 0xdbff) {\r\n            const high = c - 0xd800; // the high 10 bits.\r\n            i++;\r\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\r\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\r\n            c = 0x10000 + (high << 10) + low;\r\n        }\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if (c < 65536) {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nconst stringLength = function (str) {\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            p++;\r\n        }\r\n        else if (c < 2048) {\r\n            p += 2;\r\n        }\r\n        else if (c >= 0xd800 && c <= 0xdbff) {\r\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\r\n            p += 4;\r\n            i++; // skip trail surrogate.\r\n        }\r\n        else {\r\n            p += 3;\r\n        }\r\n    }\r\n    return p;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */\r\nconst uuidv4 = function () {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nconst DEFAULT_INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nconst DEFAULT_BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    const randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provide English ordinal letters after a number\r\n */\r\nfunction ordinal(i) {\r\n    if (!Number.isFinite(i)) {\r\n        return `${i}`;\r\n    }\r\n    return i + indicator(i);\r\n}\r\nfunction indicator(i) {\r\n    i = Math.abs(i);\r\n    const cent = i % 100;\r\n    if (cent >= 10 && cent <= 20) {\r\n        return 'th';\r\n    }\r\n    const dec = i % 10;\r\n    if (dec === 1) {\r\n        return 'st';\r\n    }\r\n    if (dec === 2) {\r\n        return 'nd';\r\n    }\r\n    if (dec === 3) {\r\n        return 'rd';\r\n    }\r\n    return 'th';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getModularInstance(service) {\r\n    if (service && service._delegate) {\r\n        return service._delegate;\r\n    }\r\n    else {\r\n        return service;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Overriding the constant (we should be the only ones doing this)\r\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLHdFQUF3RSxLQUFLOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsR0FBRyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUIsSUFBSSxTQUFTLEdBQUcsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZELEtBQUs7QUFDTDtBQUNBLG1CQUFtQixNQUFNLElBQUk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsVUFBVSxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTQ5QjtBQUM1OUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWJsZS1xdWl6Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/ZjY4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxyXG4gKi9cclxuY29uc3QgQ09OU1RBTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XHJcbiAqL1xyXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxyXG4gKi9cclxuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xyXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXHJcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXHJcbiAgICAgICAgbWVzc2FnZSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxyXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcclxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXHJcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cclxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXHJcbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XHJcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxyXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufTtcclxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3RcclxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcclxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcclxuY29uc3QgYmFzZTY0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxyXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxyXG4gICAgICovXHJcbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cclxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcclxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxyXG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXHJcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XHJcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXHJcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XHJcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcclxuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXHJcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cclxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxyXG4gKi9cclxuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xyXG4gKlxyXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcclxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxyXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxyXG4gKi9cclxuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxyXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXHJcbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcclxuICogKGFuZCByZXR1cm5lZCkuXHJcbiAqXHJcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xyXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cclxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNhc2UgRGF0ZTpcclxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcclxuICAgICAgICBjYXNlIE9iamVjdDpcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cclxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cclxuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XHJcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXHJcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcclxuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcclxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxyXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcclxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cclxuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXHJcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxyXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XHJcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XHJcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXHJcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcclxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxyXG4gICAgICovXHJcbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xyXG4gICAgaWYgKHRva2VuLnVpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXHJcbiAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnbm9uZScsXHJcbiAgICAgICAgdHlwZTogJ0pXVCdcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xyXG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XHJcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXHJcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XHJcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0gfSwgdG9rZW4pO1xyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgXS5qb2luKCcuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cclxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VUEoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gKlxyXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxyXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XHJcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xyXG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxyXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXHJcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgTm9kZS5qcy5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcclxuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XHJcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcclxuICAgICAgICA/IGNocm9tZS5ydW50aW1lXHJcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xyXG59XHJcbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xyXG5mdW5jdGlvbiBpc0lFKCkge1xyXG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNVV1AoKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcclxuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcclxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcclxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxyXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcclxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcclxuICogcHJpdmF0ZSBicm93c2luZylcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVFeGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZUV4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICovXHJcbmZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqICAgLy8gVHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xyXG4gKiAgIHR5cGUgRXJyID1cclxuICogICAgICd1bmtub3duJyB8XHJcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcclxuICogICAgIDtcclxuICpcclxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xyXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cclxuICogICB2YXIgRXJyID0ge1xyXG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxyXG4gKiAgIH1cclxuICpcclxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xyXG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcclxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxyXG4gKiAgIH07XHJcbiAqXHJcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cclxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XHJcbiAqXHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xyXG4gKiAgIC4uLlxyXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxyXG4gKlxyXG4gKiAgIGNhdGNoIChlKSB7XHJcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xyXG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcclxuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKi9cclxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcclxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcclxuY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY29kZSwgbWVzc2FnZSwgXHJcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjdXN0b21EYXRhKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSBjdXN0b21EYXRhO1xyXG4gICAgICAgIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xyXG4gICAgICAgIC8vIEZpeCBGb3IgRVM1XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxyXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVycm9yRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcclxuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbURhdGEgPSBkYXRhWzBdIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xyXG4gICAgICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cclxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cclxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgbGV0IGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xyXG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xyXG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcclxuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcixcclxuICAgICAgICBjbGFpbXMsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxyXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICAgIGxldCB2YWxpZFNpbmNlID0gMCwgdmFsaWRVbnRpbCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoISFub3cgJiZcclxuICAgICAgICAhIXZhbGlkU2luY2UgJiZcclxuICAgICAgICAhIXZhbGlkVW50aWwgJiZcclxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgIG5vdyA8PSB2YWxpZFVudGlsKTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICByZXR1cm4gY2xhaW1zWydpYXQnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xyXG4gICAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbWFwKG9iaiwgZm4sIGNvbnRleHRPYmopIHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKipcclxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFQcm9wID0gYVtrXTtcclxuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcclxuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xyXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcclxuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXHJcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxyXG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xyXG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcclxuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxyXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxyXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xyXG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcclxuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XHJcbiAqXHJcbiAqIFBlcmZvcm1hbmNlOlxyXG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xyXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZmluYWxcclxuICogQHN0cnVjdFxyXG4gKi9cclxuY2xhc3MgU2hhMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xyXG4gICAgICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cclxuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuV18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xyXG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcclxuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcclxuICAgIH1cclxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXHJcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xyXG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xyXG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXHJcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXHJcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXHJcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcclxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxyXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcclxuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcclxuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXHJcbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XHJcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xyXG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWdlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcclxuICogVGhlbmFibGUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICogICAgIGFzIGEgcHJveHkuXHJcbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XHJcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXHJcbiAqIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gICAgICogICAgIGFzIGEgcHJveHkuXHJcbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXHJcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xyXG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxyXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxyXG4gICAgICAgIHRoaXMudGFza1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcjtcclxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xyXG4gICAgICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdjb21wbGV0ZSdcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxyXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcclxuICAgICAgICAvLyBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gdW5zdWI7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xyXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cclxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XHJcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXHJcbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xyXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxyXG4gICAgc2VuZE9uZShpLCBmbikge1xyXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsb3NlKGVycikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xyXG4gICAgbGV0IGFyZ0Vycm9yO1xyXG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xyXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICBhcmdDb3VudCArXHJcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcclxuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xyXG4gICAgICAgICAgICBhcmdFcnJvciArXHJcbiAgICAgICAgICAgICcuJztcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XHJcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmbk5hbWVcclxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXHJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcclxuICogQHBhcmFtIG9wdGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcclxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcclxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxyXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cclxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3RcclxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXHJcbi8vIHBhaXIpLlxyXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cclxuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIHArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgcCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxyXG4gICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxyXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXHJcbi8qKlxyXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxyXG4gKiBTZWVcclxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXHJcbiAqIGZvciBjb250ZXh0LlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxyXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXHJcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cclxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XHJcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxyXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXHJcbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcclxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICBSQU5ET01fRkFDVE9SICpcclxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcclxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcclxuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXHJcbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcclxuICAgICAgICAyKTtcclxuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cclxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcclxuICAgICAgICByZXR1cm4gYCR7aX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XHJcbn1cclxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcclxuICAgIGkgPSBNYXRoLmFicyhpKTtcclxuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xyXG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xyXG4gICAgICAgIHJldHVybiAndGgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xyXG4gICAgaWYgKGRlYyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiAnc3QnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiAnbmQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiAncmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0aCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcclxuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXHJcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/esm/index.esm2017.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@firebase/webchannel-wrapper/dist/esm/index.esm2017.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   EventType: () => (/* binding */ EventType),\n/* harmony export */   FetchXmlHttpFactory: () => (/* binding */ FetchXmlHttpFactory),\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Md5: () => (/* binding */ Md5),\n/* harmony export */   Stat: () => (/* binding */ Stat),\n/* harmony export */   WebChannel: () => (/* binding */ WebChannel),\n/* harmony export */   XhrIo: () => (/* binding */ XhrIo),\n/* harmony export */   createWebChannelTransport: () => (/* binding */ createWebChannelTransport),\n/* harmony export */   \"default\": () => (/* binding */ esm),\n/* harmony export */   getStatEventTarget: () => (/* binding */ getStatEventTarget)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar esm = {};\n\n/*\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\n\nvar k,goog=goog||{},l=commonjsGlobal||self;function aa(a){var b=typeof a;b=\"object\"!=b?b:a?Array.isArray(a)?\"array\":b:\"null\";return \"array\"==b||\"object\"==b&&\"number\"==typeof a.length}function p(a){var b=typeof a;return \"object\"==b&&null!=a||\"function\"==b}function ba(a){return Object.prototype.hasOwnProperty.call(a,ca)&&a[ca]||(a[ca]=++da)}var ca=\"closure_uid_\"+(1E9*Math.random()>>>0),da=0;function ea(a,b,c){return a.call.apply(a.bind,arguments)}\nfunction fa(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var e=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(e,d);return a.apply(b,e)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?q=ea:q=fa;return q.apply(null,arguments)}\nfunction ha(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var d=c.slice();d.push.apply(d,arguments);return a.apply(this,d)}}function r(a,b){function c(){}c.prototype=b.prototype;a.$=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.ac=function(d,e,f){for(var h=Array(arguments.length-2),n=2;n<arguments.length;n++)h[n-2]=arguments[n];return b.prototype[e].apply(d,h)};}function v(){this.s=this.s;this.o=this.o;}var ia=0;v.prototype.s=!1;v.prototype.sa=function(){if(!this.s&&(this.s=!0,this.N(),0!=ia)){ba(this);}};v.prototype.N=function(){if(this.o)for(;this.o.length;)this.o.shift()();};const ka=Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b,void 0)}:function(a,b){if(\"string\"===typeof a)return \"string\"!==typeof b||1!=b.length?-1:a.indexOf(b,0);for(let c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};function ma(a){const b=a.length;if(0<b){const c=Array(b);for(let d=0;d<b;d++)c[d]=a[d];return c}return []}\nfunction na(a,b){for(let c=1;c<arguments.length;c++){const d=arguments[c];if(aa(d)){const e=a.length||0,f=d.length||0;a.length=e+f;for(let h=0;h<f;h++)a[e+h]=d[h];}else a.push(d);}}function w(a,b){this.type=a;this.g=this.target=b;this.defaultPrevented=!1;}w.prototype.h=function(){this.defaultPrevented=!0;};var oa=function(){if(!l.addEventListener||!Object.defineProperty)return !1;var a=!1,b=Object.defineProperty({},\"passive\",{get:function(){a=!0;}});try{const c=()=>{};l.addEventListener(\"test\",c,b);l.removeEventListener(\"test\",c,b);}catch(c){}return a}();function x(a){return /^[\\s\\xa0]*$/.test(a)}function pa(){var a=l.navigator;return a&&(a=a.userAgent)?a:\"\"}function y(a){return -1!=pa().indexOf(a)}function qa(a){qa[\" \"](a);return a}qa[\" \"]=function(){};function ra(a,b){var c=sa;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)}var ta=y(\"Opera\"),z=y(\"Trident\")||y(\"MSIE\"),ua=y(\"Edge\"),va=ua||z,wa=y(\"Gecko\")&&!(-1!=pa().toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\"))&&!(y(\"Trident\")||y(\"MSIE\"))&&!y(\"Edge\"),xa=-1!=pa().toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\");function ya(){var a=l.document;return a?a.documentMode:void 0}var za;\na:{var Aa=\"\",Ba=function(){var a=pa();if(wa)return /rv:([^\\);]+)(\\)|;)/.exec(a);if(ua)return /Edge\\/([\\d\\.]+)/.exec(a);if(z)return /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(xa)return /WebKit\\/(\\S+)/.exec(a);if(ta)return /(?:Version)[ \\/]?(\\S+)/.exec(a)}();Ba&&(Aa=Ba?Ba[1]:\"\");if(z){var Ca=ya();if(null!=Ca&&Ca>parseFloat(Aa)){za=String(Ca);break a}}za=Aa;}var Da;if(l.document&&z){var Ea=ya();Da=Ea?Ea:parseInt(za,10)||void 0;}else Da=void 0;var Fa=Da;function A(a,b){w.call(this,a?a.type:\"\");this.relatedTarget=this.g=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key=\"\";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.state=null;this.pointerId=0;this.pointerType=\"\";this.i=null;if(a){var c=this.type=a.type,d=a.changedTouches&&a.changedTouches.length?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.g=b;if(b=a.relatedTarget){if(wa){a:{try{qa(b.nodeName);var e=!0;break a}catch(f){}e=\n!1;}e||(b=null);}}else \"mouseover\"==c?b=a.fromElement:\"mouseout\"==c&&(b=a.toElement);this.relatedTarget=b;d?(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0):(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0);this.button=a.button;this.key=a.key||\"\";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=\na.shiftKey;this.metaKey=a.metaKey;this.pointerId=a.pointerId||0;this.pointerType=\"string\"===typeof a.pointerType?a.pointerType:Ga[a.pointerType]||\"\";this.state=a.state;this.i=a;a.defaultPrevented&&A.$.h.call(this);}}r(A,w);var Ga={2:\"touch\",3:\"pen\",4:\"mouse\"};A.prototype.h=function(){A.$.h.call(this);var a=this.i;a.preventDefault?a.preventDefault():a.returnValue=!1;};var Ha=\"closure_listenable_\"+(1E6*Math.random()|0);var Ia=0;function Ja(a,b,c,d,e){this.listener=a;this.proxy=null;this.src=b;this.type=c;this.capture=!!d;this.la=e;this.key=++Ia;this.fa=this.ia=!1;}function Ma(a){a.fa=!0;a.listener=null;a.proxy=null;a.src=null;a.la=null;}function Na(a,b,c){for(const d in a)b.call(c,a[d],d,a);}function Oa(a,b){for(const c in a)b.call(void 0,a[c],c,a);}function Pa(a){const b={};for(const c in a)b[c]=a[c];return b}const Qa=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");function Ra(a,b){let c,d;for(let e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(let f=0;f<Qa.length;f++)c=Qa[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}}function Sa(a){this.src=a;this.g={};this.h=0;}Sa.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.g[f];a||(a=this.g[f]=[],this.h++);var h=Ta(a,b,d,e);-1<h?(b=a[h],c||(b.ia=!1)):(b=new Ja(b,this.src,f,!!d,e),b.ia=c,a.push(b));return b};function Ua(a,b){var c=b.type;if(c in a.g){var d=a.g[c],e=ka(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(Ma(b),0==a.g[c].length&&(delete a.g[c],a.h--));}}\nfunction Ta(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.fa&&f.listener==b&&f.capture==!!c&&f.la==d)return e}return -1}var Va=\"closure_lm_\"+(1E6*Math.random()|0),Wa={};function Ya(a,b,c,d,e){if(d&&d.once)return Za(a,b,c,d,e);if(Array.isArray(b)){for(var f=0;f<b.length;f++)Ya(a,b[f],c,d,e);return null}c=$a(c);return a&&a[Ha]?a.O(b,c,p(d)?!!d.capture:!!d,e):ab(a,b,c,!1,d,e)}\nfunction ab(a,b,c,d,e,f){if(!b)throw Error(\"Invalid event type\");var h=p(e)?!!e.capture:!!e,n=bb(a);n||(a[Va]=n=new Sa(a));c=n.add(b,c,d,h,f);if(c.proxy)return c;d=cb();c.proxy=d;d.src=a;d.listener=c;if(a.addEventListener)oa||(e=h),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(db(b.toString()),d);else if(a.addListener&&a.removeListener)a.addListener(d);else throw Error(\"addEventListener and attachEvent are unavailable.\");return c}\nfunction cb(){function a(c){return b.call(a.src,a.listener,c)}const b=eb;return a}function Za(a,b,c,d,e){if(Array.isArray(b)){for(var f=0;f<b.length;f++)Za(a,b[f],c,d,e);return null}c=$a(c);return a&&a[Ha]?a.P(b,c,p(d)?!!d.capture:!!d,e):ab(a,b,c,!0,d,e)}\nfunction fb(a,b,c,d,e){if(Array.isArray(b))for(var f=0;f<b.length;f++)fb(a,b[f],c,d,e);else (d=p(d)?!!d.capture:!!d,c=$a(c),a&&a[Ha])?(a=a.i,b=String(b).toString(),b in a.g&&(f=a.g[b],c=Ta(f,c,d,e),-1<c&&(Ma(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.g[b],a.h--)))):a&&(a=bb(a))&&(b=a.g[b.toString()],a=-1,b&&(a=Ta(b,c,d,e)),(c=-1<a?b[a]:null)&&gb(c));}\nfunction gb(a){if(\"number\"!==typeof a&&a&&!a.fa){var b=a.src;if(b&&b[Ha])Ua(b.i,a);else {var c=a.type,d=a.proxy;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent?b.detachEvent(db(c),d):b.addListener&&b.removeListener&&b.removeListener(d);(c=bb(b))?(Ua(c,a),0==c.h&&(c.src=null,b[Va]=null)):Ma(a);}}}function db(a){return a in Wa?Wa[a]:Wa[a]=\"on\"+a}function eb(a,b){if(a.fa)a=!0;else {b=new A(b,this);var c=a.listener,d=a.la||a.src;a.ia&&gb(a);a=c.call(d,b);}return a}\nfunction bb(a){a=a[Va];return a instanceof Sa?a:null}var hb=\"__closure_events_fn_\"+(1E9*Math.random()>>>0);function $a(a){if(\"function\"===typeof a)return a;a[hb]||(a[hb]=function(b){return a.handleEvent(b)});return a[hb]}function B(){v.call(this);this.i=new Sa(this);this.S=this;this.J=null;}r(B,v);B.prototype[Ha]=!0;B.prototype.removeEventListener=function(a,b,c,d){fb(this,a,b,c,d);};\nfunction C(a,b){var c,d=a.J;if(d)for(c=[];d;d=d.J)c.push(d);a=a.S;d=b.type||b;if(\"string\"===typeof b)b=new w(b,a);else if(b instanceof w)b.target=b.target||a;else {var e=b;b=new w(d,a);Ra(b,e);}e=!0;if(c)for(var f=c.length-1;0<=f;f--){var h=b.g=c[f];e=ib(h,d,!0,b)&&e;}h=b.g=a;e=ib(h,d,!0,b)&&e;e=ib(h,d,!1,b)&&e;if(c)for(f=0;f<c.length;f++)h=b.g=c[f],e=ib(h,d,!1,b)&&e;}\nB.prototype.N=function(){B.$.N.call(this);if(this.i){var a=this.i,c;for(c in a.g){for(var d=a.g[c],e=0;e<d.length;e++)Ma(d[e]);delete a.g[c];a.h--;}}this.J=null;};B.prototype.O=function(a,b,c,d){return this.i.add(String(a),b,!1,c,d)};B.prototype.P=function(a,b,c,d){return this.i.add(String(a),b,!0,c,d)};\nfunction ib(a,b,c,d){b=a.i.g[String(b)];if(!b)return !0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var h=b[f];if(h&&!h.fa&&h.capture==c){var n=h.listener,t=h.la||h.src;h.ia&&Ua(a.i,h);e=!1!==n.call(t,d)&&e;}}return e&&!d.defaultPrevented}var jb=l.JSON.stringify;class kb{constructor(a,b){this.i=a;this.j=b;this.h=0;this.g=null;}get(){let a;0<this.h?(this.h--,a=this.g,this.g=a.next,a.next=null):a=this.i();return a}}function lb(){var a=mb;let b=null;a.g&&(b=a.g,a.g=a.g.next,a.g||(a.h=null),b.next=null);return b}class nb{constructor(){this.h=this.g=null;}add(a,b){const c=ob.get();c.set(a,b);this.h?this.h.next=c:this.g=c;this.h=c;}}var ob=new kb(()=>new pb,a=>a.reset());class pb{constructor(){this.next=this.g=this.h=null;}set(a,b){this.h=a;this.g=b;this.next=null;}reset(){this.next=this.g=this.h=null;}}function qb(a){var b=1;a=a.split(\":\");const c=[];for(;0<b&&a.length;)c.push(a.shift()),b--;a.length&&c.push(a.join(\":\"));return c}function rb(a){l.setTimeout(()=>{throw a;},0);}let sb,tb=!1,mb=new nb,vb=()=>{const a=l.Promise.resolve(void 0);sb=()=>{a.then(ub);};};var ub=()=>{for(var a;a=lb();){try{a.h.call(a.g);}catch(c){rb(c);}var b=ob;b.j(a);100>b.h&&(b.h++,a.next=b.g,b.g=a);}tb=!1;};function wb(a,b){B.call(this);this.h=a||1;this.g=b||l;this.j=q(this.qb,this);this.l=Date.now();}r(wb,B);k=wb.prototype;k.ga=!1;k.T=null;k.qb=function(){if(this.ga){var a=Date.now()-this.l;0<a&&a<.8*this.h?this.T=this.g.setTimeout(this.j,this.h-a):(this.T&&(this.g.clearTimeout(this.T),this.T=null),C(this,\"tick\"),this.ga&&(xb(this),this.start()));}};k.start=function(){this.ga=!0;this.T||(this.T=this.g.setTimeout(this.j,this.h),this.l=Date.now());};\nfunction xb(a){a.ga=!1;a.T&&(a.g.clearTimeout(a.T),a.T=null);}k.N=function(){wb.$.N.call(this);xb(this);delete this.g;};function yb(a,b,c){if(\"function\"===typeof a)c&&(a=q(a,c));else if(a&&\"function\"==typeof a.handleEvent)a=q(a.handleEvent,a);else throw Error(\"Invalid listener argument\");return 2147483647<Number(b)?-1:l.setTimeout(a,b||0)}function zb(a){a.g=yb(()=>{a.g=null;a.i&&(a.i=!1,zb(a));},a.j);const b=a.h;a.h=null;a.m.apply(null,b);}class Ab extends v{constructor(a,b){super();this.m=a;this.j=b;this.h=null;this.i=!1;this.g=null;}l(a){this.h=arguments;this.g?this.i=!0:zb(this);}N(){super.N();this.g&&(l.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null);}}function Bb(a){v.call(this);this.h=a;this.g={};}r(Bb,v);var Cb=[];function Eb(a,b,c,d){Array.isArray(c)||(c&&(Cb[0]=c.toString()),c=Cb);for(var e=0;e<c.length;e++){var f=Ya(b,c[e],d||a.handleEvent,!1,a.h||a);if(!f)break;a.g[f.key]=f;}}function Fb(a){Na(a.g,function(b,c){this.g.hasOwnProperty(c)&&gb(b);},a);a.g={};}Bb.prototype.N=function(){Bb.$.N.call(this);Fb(this);};Bb.prototype.handleEvent=function(){throw Error(\"EventHandler.handleEvent not implemented\");};function Gb(){this.g=!0;}Gb.prototype.Ea=function(){this.g=!1;};function Hb(a,b,c,d,e,f){a.info(function(){if(a.g)if(f){var h=\"\";for(var n=f.split(\"&\"),t=0;t<n.length;t++){var m=n[t].split(\"=\");if(1<m.length){var u=m[0];m=m[1];var L=u.split(\"_\");h=2<=L.length&&\"type\"==L[1]?h+(u+\"=\"+m+\"&\"):h+(u+\"=redacted&\");}}}else h=null;else h=f;return \"XMLHTTP REQ (\"+d+\") [attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+h});}\nfunction Ib(a,b,c,d,e,f,h){a.info(function(){return \"XMLHTTP RESP (\"+d+\") [ attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+f+\" \"+h});}function D(a,b,c,d){a.info(function(){return \"XMLHTTP TEXT (\"+b+\"): \"+Jb(a,c)+(d?\" \"+d:\"\")});}function Kb(a,b){a.info(function(){return \"TIMEOUT: \"+b});}Gb.prototype.info=function(){};\nfunction Jb(a,b){if(!a.g)return b;if(!b)return null;try{var c=JSON.parse(b);if(c)for(a=0;a<c.length;a++)if(Array.isArray(c[a])){var d=c[a];if(!(2>d.length)){var e=d[1];if(Array.isArray(e)&&!(1>e.length)){var f=e[0];if(\"noop\"!=f&&\"stop\"!=f&&\"close\"!=f)for(var h=1;h<e.length;h++)e[h]=\"\";}}}return jb(c)}catch(n){return b}}var E={},Lb=null;function Mb(){return Lb=Lb||new B}E.Ta=\"serverreachability\";function Nb(a){w.call(this,E.Ta,a);}r(Nb,w);function Ob(a){const b=Mb();C(b,new Nb(b));}E.STAT_EVENT=\"statevent\";function Pb(a,b){w.call(this,E.STAT_EVENT,a);this.stat=b;}r(Pb,w);function F(a){const b=Mb();C(b,new Pb(b,a));}E.Ua=\"timingevent\";function Qb(a,b){w.call(this,E.Ua,a);this.size=b;}r(Qb,w);\nfunction Rb(a,b){if(\"function\"!==typeof a)throw Error(\"Fn must not be null and must be a function\");return l.setTimeout(function(){a();},b)}var Sb={NO_ERROR:0,rb:1,Eb:2,Db:3,yb:4,Cb:5,Fb:6,Qa:7,TIMEOUT:8,Ib:9};var Tb={wb:\"complete\",Sb:\"success\",Ra:\"error\",Qa:\"abort\",Kb:\"ready\",Lb:\"readystatechange\",TIMEOUT:\"timeout\",Gb:\"incrementaldata\",Jb:\"progress\",zb:\"downloadprogress\",$b:\"uploadprogress\"};function Ub(){}Ub.prototype.h=null;function Vb(a){return a.h||(a.h=a.i())}function Wb(){}var Xb={OPEN:\"a\",vb:\"b\",Ra:\"c\",Hb:\"d\"};function Yb(){w.call(this,\"d\");}r(Yb,w);function Zb(){w.call(this,\"c\");}r(Zb,w);var $b;function ac(){}r(ac,Ub);ac.prototype.g=function(){return new XMLHttpRequest};ac.prototype.i=function(){return {}};$b=new ac;function bc(a,b,c,d){this.l=a;this.j=b;this.m=c;this.W=d||1;this.U=new Bb(this);this.P=cc;a=va?125:void 0;this.V=new wb(a);this.I=null;this.i=!1;this.u=this.B=this.A=this.L=this.G=this.Y=this.C=null;this.F=[];this.g=null;this.o=0;this.s=this.v=null;this.ca=-1;this.J=!1;this.O=0;this.M=null;this.ba=this.K=this.aa=this.S=!1;this.h=new dc;}function dc(){this.i=null;this.g=\"\";this.h=!1;}var cc=45E3,ec={},fc={};k=bc.prototype;k.setTimeout=function(a){this.P=a;};\nfunction gc(a,b,c){a.L=1;a.A=hc(G(b));a.u=c;a.S=!0;ic(a,null);}function ic(a,b){a.G=Date.now();jc(a);a.B=G(a.A);var c=a.B,d=a.W;Array.isArray(d)||(d=[String(d)]);kc(c.i,\"t\",d);a.o=0;c=a.l.J;a.h=new dc;a.g=lc(a.l,c?b:null,!a.u);0<a.O&&(a.M=new Ab(q(a.Pa,a,a.g),a.O));Eb(a.U,a.g,\"readystatechange\",a.nb);b=a.I?Pa(a.I):{};a.u?(a.v||(a.v=\"POST\"),b[\"Content-Type\"]=\"application/x-www-form-urlencoded\",a.g.ha(a.B,a.v,a.u,b)):(a.v=\"GET\",a.g.ha(a.B,a.v,null,b));Ob();Hb(a.j,a.v,a.B,a.m,a.W,a.u);}\nk.nb=function(a){a=a.target;const b=this.M;b&&3==H(a)?b.l():this.Pa(a);};\nk.Pa=function(a){try{if(a==this.g)a:{const u=H(this.g);var b=this.g.Ia();const L=this.g.da();if(!(3>u)&&(3!=u||va||this.g&&(this.h.h||this.g.ja()||mc(this.g)))){this.J||4!=u||7==b||(8==b||0>=L?Ob(3):Ob(2));nc(this);var c=this.g.da();this.ca=c;b:if(oc(this)){var d=mc(this.g);a=\"\";var e=d.length,f=4==H(this.g);if(!this.h.i){if(\"undefined\"===typeof TextDecoder){I(this);pc(this);var h=\"\";break b}this.h.i=new l.TextDecoder;}for(b=0;b<e;b++)this.h.h=!0,a+=this.h.i.decode(d[b],{stream:f&&b==e-1});d.length=\n0;this.h.g+=a;this.o=0;h=this.h.g;}else h=this.g.ja();this.i=200==c;Ib(this.j,this.v,this.B,this.m,this.W,u,c);if(this.i){if(this.aa&&!this.K){b:{if(this.g){var n,t=this.g;if((n=t.g?t.g.getResponseHeader(\"X-HTTP-Initial-Response\"):null)&&!x(n)){var m=n;break b}}m=null;}if(c=m)D(this.j,this.m,c,\"Initial handshake response via X-HTTP-Initial-Response\"),this.K=!0,qc(this,c);else {this.i=!1;this.s=3;F(12);I(this);pc(this);break a}}this.S?(rc(this,u,h),va&&this.i&&3==u&&(Eb(this.U,this.V,\"tick\",this.mb),\nthis.V.start())):(D(this.j,this.m,h,null),qc(this,h));4==u&&I(this);this.i&&!this.J&&(4==u?sc(this.l,this):(this.i=!1,jc(this)));}else tc(this.g),400==c&&0<h.indexOf(\"Unknown SID\")?(this.s=3,F(12)):(this.s=0,F(13)),I(this),pc(this);}}}catch(u){}finally{}};function oc(a){return a.g?\"GET\"==a.v&&2!=a.L&&a.l.Ha:!1}\nfunction rc(a,b,c){let d=!0,e;for(;!a.J&&a.o<c.length;)if(e=uc(a,c),e==fc){4==b&&(a.s=4,F(14),d=!1);D(a.j,a.m,null,\"[Incomplete Response]\");break}else if(e==ec){a.s=4;F(15);D(a.j,a.m,c,\"[Invalid Chunk]\");d=!1;break}else D(a.j,a.m,e,null),qc(a,e);oc(a)&&0!=a.o&&(a.h.g=a.h.g.slice(a.o),a.o=0);4!=b||0!=c.length||a.h.h||(a.s=1,F(16),d=!1);a.i=a.i&&d;d?0<c.length&&!a.ba&&(a.ba=!0,b=a.l,b.g==a&&b.ca&&!b.M&&(b.l.info(\"Great, no buffering proxy detected. Bytes received: \"+c.length),vc(b),b.M=!0,F(11))):(D(a.j,\na.m,c,\"[Invalid Chunked Response]\"),I(a),pc(a));}k.mb=function(){if(this.g){var a=H(this.g),b=this.g.ja();this.o<b.length&&(nc(this),rc(this,a,b),this.i&&4!=a&&jc(this));}};function uc(a,b){var c=a.o,d=b.indexOf(\"\\n\",c);if(-1==d)return fc;c=Number(b.substring(c,d));if(isNaN(c))return ec;d+=1;if(d+c>b.length)return fc;b=b.slice(d,d+c);a.o=d+c;return b}k.cancel=function(){this.J=!0;I(this);};function jc(a){a.Y=Date.now()+a.P;wc(a,a.P);}\nfunction wc(a,b){if(null!=a.C)throw Error(\"WatchDog timer not null\");a.C=Rb(q(a.lb,a),b);}function nc(a){a.C&&(l.clearTimeout(a.C),a.C=null);}k.lb=function(){this.C=null;const a=Date.now();0<=a-this.Y?(Kb(this.j,this.B),2!=this.L&&(Ob(),F(17)),I(this),this.s=2,pc(this)):wc(this,this.Y-a);};function pc(a){0==a.l.H||a.J||sc(a.l,a);}function I(a){nc(a);var b=a.M;b&&\"function\"==typeof b.sa&&b.sa();a.M=null;xb(a.V);Fb(a.U);a.g&&(b=a.g,a.g=null,b.abort(),b.sa());}\nfunction qc(a,b){try{var c=a.l;if(0!=c.H&&(c.g==a||xc(c.i,a)))if(!a.K&&xc(c.i,a)&&3==c.H){try{var d=c.Ja.g.parse(b);}catch(m){d=null;}if(Array.isArray(d)&&3==d.length){var e=d;if(0==e[0])a:{if(!c.u){if(c.g)if(c.g.G+3E3<a.G)yc(c),zc(c);else break a;Ac(c);F(18);}}else c.Fa=e[1],0<c.Fa-c.V&&37500>e[2]&&c.G&&0==c.A&&!c.v&&(c.v=Rb(q(c.ib,c),6E3));if(1>=Bc(c.i)&&c.oa){try{c.oa();}catch(m){}c.oa=void 0;}}else J(c,11);}else if((a.K||c.g==a)&&yc(c),!x(b))for(e=c.Ja.g.parse(b),b=0;b<e.length;b++){let m=e[b];c.V=\nm[0];m=m[1];if(2==c.H)if(\"c\"==m[0]){c.K=m[1];c.pa=m[2];const u=m[3];null!=u&&(c.ra=u,c.l.info(\"VER=\"+c.ra));const L=m[4];null!=L&&(c.Ga=L,c.l.info(\"SVER=\"+c.Ga));const Ka=m[5];null!=Ka&&\"number\"===typeof Ka&&0<Ka&&(d=1.5*Ka,c.L=d,c.l.info(\"backChannelRequestTimeoutMs_=\"+d));d=c;const la=a.g;if(la){const La=la.g?la.g.getResponseHeader(\"X-Client-Wire-Protocol\"):null;if(La){var f=d.i;f.g||-1==La.indexOf(\"spdy\")&&-1==La.indexOf(\"quic\")&&-1==La.indexOf(\"h2\")||(f.j=f.l,f.g=new Set,f.h&&(Cc(f,f.h),f.h=null));}if(d.F){const Db=\nla.g?la.g.getResponseHeader(\"X-HTTP-Session-Id\"):null;Db&&(d.Da=Db,K(d.I,d.F,Db));}}c.H=3;c.h&&c.h.Ba();c.ca&&(c.S=Date.now()-a.G,c.l.info(\"Handshake RTT: \"+c.S+\"ms\"));d=c;var h=a;d.wa=Dc(d,d.J?d.pa:null,d.Y);if(h.K){Ec(d.i,h);var n=h,t=d.L;t&&n.setTimeout(t);n.C&&(nc(n),jc(n));d.g=h;}else Fc(d);0<c.j.length&&Gc(c);}else \"stop\"!=m[0]&&\"close\"!=m[0]||J(c,7);else 3==c.H&&(\"stop\"==m[0]||\"close\"==m[0]?\"stop\"==m[0]?J(c,7):Hc(c):\"noop\"!=m[0]&&c.h&&c.h.Aa(m),c.A=0);}Ob(4);}catch(m){}}function Ic(a){if(a.Z&&\"function\"==typeof a.Z)return a.Z();if(\"undefined\"!==typeof Map&&a instanceof Map||\"undefined\"!==typeof Set&&a instanceof Set)return Array.from(a.values());if(\"string\"===typeof a)return a.split(\"\");if(aa(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}b=[];c=0;for(d in a)b[c++]=a[d];return b}\nfunction Jc(a){if(a.ta&&\"function\"==typeof a.ta)return a.ta();if(!a.Z||\"function\"!=typeof a.Z){if(\"undefined\"!==typeof Map&&a instanceof Map)return Array.from(a.keys());if(!(\"undefined\"!==typeof Set&&a instanceof Set)){if(aa(a)||\"string\"===typeof a){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}b=[];c=0;for(const d in a)b[c++]=d;return b}}}\nfunction Kc(a,b){if(a.forEach&&\"function\"==typeof a.forEach)a.forEach(b,void 0);else if(aa(a)||\"string\"===typeof a)Array.prototype.forEach.call(a,b,void 0);else for(var c=Jc(a),d=Ic(a),e=d.length,f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a);}var Lc=RegExp(\"^(?:([^:/?#.]+):)?(?://(?:([^\\\\\\\\/?#]*)@)?([^\\\\\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\\\\\/?#]|$))?([^?#]+)?(?:\\\\?([^#]*))?(?:#([\\\\s\\\\S]*))?$\");function Mc(a,b){if(a){a=a.split(\"&\");for(var c=0;c<a.length;c++){var d=a[c].indexOf(\"=\"),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1);}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\\+/g,\" \")):\"\");}}}function M(a){this.g=this.s=this.j=\"\";this.m=null;this.o=this.l=\"\";this.h=!1;if(a instanceof M){this.h=a.h;Nc(this,a.j);this.s=a.s;this.g=a.g;Oc(this,a.m);this.l=a.l;var b=a.i;var c=new Pc;c.i=b.i;b.g&&(c.g=new Map(b.g),c.h=b.h);Qc(this,c);this.o=a.o;}else a&&(b=String(a).match(Lc))?(this.h=!1,Nc(this,b[1]||\"\",!0),this.s=Rc(b[2]||\"\"),this.g=Rc(b[3]||\"\",!0),Oc(this,b[4]),this.l=Rc(b[5]||\"\",!0),Qc(this,b[6]||\"\",!0),this.o=Rc(b[7]||\"\")):(this.h=!1,this.i=new Pc(null,this.h));}\nM.prototype.toString=function(){var a=[],b=this.j;b&&a.push(Sc(b,Tc,!0),\":\");var c=this.g;if(c||\"file\"==b)a.push(\"//\"),(b=this.s)&&a.push(Sc(b,Tc,!0),\"@\"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),c=this.m,null!=c&&a.push(\":\",String(c));if(c=this.l)this.g&&\"/\"!=c.charAt(0)&&a.push(\"/\"),a.push(Sc(c,\"/\"==c.charAt(0)?Uc:Vc,!0));(c=this.i.toString())&&a.push(\"?\",c);(c=this.o)&&a.push(\"#\",Sc(c,Wc));return a.join(\"\")};function G(a){return new M(a)}\nfunction Nc(a,b,c){a.j=c?Rc(b,!0):b;a.j&&(a.j=a.j.replace(/:$/,\"\"));}function Oc(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.m=b;}else a.m=null;}function Qc(a,b,c){b instanceof Pc?(a.i=b,Xc(a.i,a.h)):(c||(b=Sc(b,Yc)),a.i=new Pc(b,a.h));}function K(a,b,c){a.i.set(b,c);}function hc(a){K(a,\"zx\",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^Date.now()).toString(36));return a}\nfunction Rc(a,b){return a?b?decodeURI(a.replace(/%25/g,\"%2525\")):decodeURIComponent(a):\"\"}function Sc(a,b,c){return \"string\"===typeof a?(a=encodeURI(a).replace(b,Zc),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function Zc(a){a=a.charCodeAt(0);return \"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var Tc=/[#\\/\\?@]/g,Vc=/[#\\?:]/g,Uc=/[#\\?]/g,Yc=/[#\\?@]/g,Wc=/#/g;function Pc(a,b){this.h=this.g=null;this.i=a||null;this.j=!!b;}\nfunction N(a){a.g||(a.g=new Map,a.h=0,a.i&&Mc(a.i,function(b,c){a.add(decodeURIComponent(b.replace(/\\+/g,\" \")),c);}));}k=Pc.prototype;k.add=function(a,b){N(this);this.i=null;a=O(this,a);var c=this.g.get(a);c||this.g.set(a,c=[]);c.push(b);this.h+=1;return this};function $c(a,b){N(a);b=O(a,b);a.g.has(b)&&(a.i=null,a.h-=a.g.get(b).length,a.g.delete(b));}function ad(a,b){N(a);b=O(a,b);return a.g.has(b)}\nk.forEach=function(a,b){N(this);this.g.forEach(function(c,d){c.forEach(function(e){a.call(b,e,d,this);},this);},this);};k.ta=function(){N(this);const a=Array.from(this.g.values()),b=Array.from(this.g.keys()),c=[];for(let d=0;d<b.length;d++){const e=a[d];for(let f=0;f<e.length;f++)c.push(b[d]);}return c};k.Z=function(a){N(this);let b=[];if(\"string\"===typeof a)ad(this,a)&&(b=b.concat(this.g.get(O(this,a))));else {a=Array.from(this.g.values());for(let c=0;c<a.length;c++)b=b.concat(a[c]);}return b};\nk.set=function(a,b){N(this);this.i=null;a=O(this,a);ad(this,a)&&(this.h-=this.g.get(a).length);this.g.set(a,[b]);this.h+=1;return this};k.get=function(a,b){if(!a)return b;a=this.Z(a);return 0<a.length?String(a[0]):b};function kc(a,b,c){$c(a,b);0<c.length&&(a.i=null,a.g.set(O(a,b),ma(c)),a.h+=c.length);}\nk.toString=function(){if(this.i)return this.i;if(!this.g)return \"\";const a=[],b=Array.from(this.g.keys());for(var c=0;c<b.length;c++){var d=b[c];const f=encodeURIComponent(String(d)),h=this.Z(d);for(d=0;d<h.length;d++){var e=f;\"\"!==h[d]&&(e+=\"=\"+encodeURIComponent(String(h[d])));a.push(e);}}return this.i=a.join(\"&\")};function O(a,b){b=String(b);a.j&&(b=b.toLowerCase());return b}\nfunction Xc(a,b){b&&!a.j&&(N(a),a.i=null,a.g.forEach(function(c,d){var e=d.toLowerCase();d!=e&&($c(this,d),kc(this,e,c));},a));a.j=b;}var bd=class{constructor(a,b){this.g=a;this.map=b;}};function cd(a){this.l=a||dd;l.PerformanceNavigationTiming?(a=l.performance.getEntriesByType(\"navigation\"),a=0<a.length&&(\"hq\"==a[0].nextHopProtocol||\"h2\"==a[0].nextHopProtocol)):a=!!(l.g&&l.g.Ka&&l.g.Ka()&&l.g.Ka().dc);this.j=a?this.l:1;this.g=null;1<this.j&&(this.g=new Set);this.h=null;this.i=[];}var dd=10;function ed(a){return a.h?!0:a.g?a.g.size>=a.j:!1}function Bc(a){return a.h?1:a.g?a.g.size:0}function xc(a,b){return a.h?a.h==b:a.g?a.g.has(b):!1}function Cc(a,b){a.g?a.g.add(b):a.h=b;}\nfunction Ec(a,b){a.h&&a.h==b?a.h=null:a.g&&a.g.has(b)&&a.g.delete(b);}cd.prototype.cancel=function(){this.i=fd(this);if(this.h)this.h.cancel(),this.h=null;else if(this.g&&0!==this.g.size){for(const a of this.g.values())a.cancel();this.g.clear();}};function fd(a){if(null!=a.h)return a.i.concat(a.h.F);if(null!=a.g&&0!==a.g.size){let b=a.i;for(const c of a.g.values())b=b.concat(c.F);return b}return ma(a.i)}var gd=class{stringify(a){return l.JSON.stringify(a,void 0)}parse(a){return l.JSON.parse(a,void 0)}};function hd(){this.g=new gd;}function id(a,b,c){const d=c||\"\";try{Kc(a,function(e,f){let h=e;p(e)&&(h=jb(e));b.push(d+f+\"=\"+encodeURIComponent(h));});}catch(e){throw b.push(d+\"type=\"+encodeURIComponent(\"_badmap\")),e;}}function jd(a,b){const c=new Gb;if(l.Image){const d=new Image;d.onload=ha(kd,c,d,\"TestLoadImage: loaded\",!0,b);d.onerror=ha(kd,c,d,\"TestLoadImage: error\",!1,b);d.onabort=ha(kd,c,d,\"TestLoadImage: abort\",!1,b);d.ontimeout=ha(kd,c,d,\"TestLoadImage: timeout\",!1,b);l.setTimeout(function(){if(d.ontimeout)d.ontimeout();},1E4);d.src=a;}else b(!1);}function kd(a,b,c,d,e){try{b.onload=null,b.onerror=null,b.onabort=null,b.ontimeout=null,e(d);}catch(f){}}function ld(a){this.l=a.ec||null;this.j=a.ob||!1;}r(ld,Ub);ld.prototype.g=function(){return new md(this.l,this.j)};ld.prototype.i=function(a){return function(){return a}}({});function md(a,b){B.call(this);this.F=a;this.u=b;this.m=void 0;this.readyState=nd;this.status=0;this.responseType=this.responseText=this.response=this.statusText=\"\";this.onreadystatechange=null;this.v=new Headers;this.h=null;this.C=\"GET\";this.B=\"\";this.g=!1;this.A=this.j=this.l=null;}r(md,B);var nd=0;k=md.prototype;\nk.open=function(a,b){if(this.readyState!=nd)throw this.abort(),Error(\"Error reopening a connection\");this.C=a;this.B=b;this.readyState=1;od(this);};k.send=function(a){if(1!=this.readyState)throw this.abort(),Error(\"need to call open() first. \");this.g=!0;const b={headers:this.v,method:this.C,credentials:this.m,cache:void 0};a&&(b.body=a);(this.F||l).fetch(new Request(this.B,b)).then(this.$a.bind(this),this.ka.bind(this));};\nk.abort=function(){this.response=this.responseText=\"\";this.v=new Headers;this.status=0;this.j&&this.j.cancel(\"Request was aborted.\").catch(()=>{});1<=this.readyState&&this.g&&4!=this.readyState&&(this.g=!1,pd(this));this.readyState=nd;};\nk.$a=function(a){if(this.g&&(this.l=a,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=a.headers,this.readyState=2,od(this)),this.g&&(this.readyState=3,od(this),this.g)))if(\"arraybuffer\"===this.responseType)a.arrayBuffer().then(this.Ya.bind(this),this.ka.bind(this));else if(\"undefined\"!==typeof l.ReadableStream&&\"body\"in a){this.j=a.body.getReader();if(this.u){if(this.responseType)throw Error('responseType must be empty for \"streamBinaryChunks\" mode responses.');this.response=\n[];}else this.response=this.responseText=\"\",this.A=new TextDecoder;qd(this);}else a.text().then(this.Za.bind(this),this.ka.bind(this));};function qd(a){a.j.read().then(a.Xa.bind(a)).catch(a.ka.bind(a));}k.Xa=function(a){if(this.g){if(this.u&&a.value)this.response.push(a.value);else if(!this.u){var b=a.value?a.value:new Uint8Array(0);if(b=this.A.decode(b,{stream:!a.done}))this.response=this.responseText+=b;}a.done?pd(this):od(this);3==this.readyState&&qd(this);}};\nk.Za=function(a){this.g&&(this.response=this.responseText=a,pd(this));};k.Ya=function(a){this.g&&(this.response=a,pd(this));};k.ka=function(){this.g&&pd(this);};function pd(a){a.readyState=4;a.l=null;a.j=null;a.A=null;od(a);}k.setRequestHeader=function(a,b){this.v.append(a,b);};k.getResponseHeader=function(a){return this.h?this.h.get(a.toLowerCase())||\"\":\"\"};\nk.getAllResponseHeaders=function(){if(!this.h)return \"\";const a=[],b=this.h.entries();for(var c=b.next();!c.done;)c=c.value,a.push(c[0]+\": \"+c[1]),c=b.next();return a.join(\"\\r\\n\")};function od(a){a.onreadystatechange&&a.onreadystatechange.call(a);}Object.defineProperty(md.prototype,\"withCredentials\",{get:function(){return \"include\"===this.m},set:function(a){this.m=a?\"include\":\"same-origin\";}});var rd=l.JSON.parse;function P(a){B.call(this);this.headers=new Map;this.u=a||null;this.h=!1;this.C=this.g=null;this.I=\"\";this.m=0;this.j=\"\";this.l=this.G=this.v=this.F=!1;this.B=0;this.A=null;this.K=sd;this.L=this.M=!1;}r(P,B);var sd=\"\",td=/^https?$/i,ud=[\"POST\",\"PUT\"];k=P.prototype;k.Oa=function(a){this.M=a;};\nk.ha=function(a,b,c,d){if(this.g)throw Error(\"[goog.net.XhrIo] Object is active with another request=\"+this.I+\"; newUri=\"+a);b=b?b.toUpperCase():\"GET\";this.I=a;this.j=\"\";this.m=0;this.F=!1;this.h=!0;this.g=this.u?this.u.g():$b.g();this.C=this.u?Vb(this.u):Vb($b);this.g.onreadystatechange=q(this.La,this);try{this.G=!0,this.g.open(b,String(a),!0),this.G=!1;}catch(f){vd(this,f);return}a=c||\"\";c=new Map(this.headers);if(d)if(Object.getPrototypeOf(d)===Object.prototype)for(var e in d)c.set(e,d[e]);else if(\"function\"===\ntypeof d.keys&&\"function\"===typeof d.get)for(const f of d.keys())c.set(f,d.get(f));else throw Error(\"Unknown input type for opt_headers: \"+String(d));d=Array.from(c.keys()).find(f=>\"content-type\"==f.toLowerCase());e=l.FormData&&a instanceof l.FormData;!(0<=ka(ud,b))||d||e||c.set(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\");for(const [f,h]of c)this.g.setRequestHeader(f,h);this.K&&(this.g.responseType=this.K);\"withCredentials\"in this.g&&this.g.withCredentials!==this.M&&(this.g.withCredentials=\nthis.M);try{wd(this),0<this.B&&((this.L=xd(this.g))?(this.g.timeout=this.B,this.g.ontimeout=q(this.ua,this)):this.A=yb(this.ua,this.B,this)),this.v=!0,this.g.send(a),this.v=!1;}catch(f){vd(this,f);}};function xd(a){return z&&\"number\"===typeof a.timeout&&void 0!==a.ontimeout}k.ua=function(){\"undefined\"!=typeof goog&&this.g&&(this.j=\"Timed out after \"+this.B+\"ms, aborting\",this.m=8,C(this,\"timeout\"),this.abort(8));};function vd(a,b){a.h=!1;a.g&&(a.l=!0,a.g.abort(),a.l=!1);a.j=b;a.m=5;yd(a);zd(a);}\nfunction yd(a){a.F||(a.F=!0,C(a,\"complete\"),C(a,\"error\"));}k.abort=function(a){this.g&&this.h&&(this.h=!1,this.l=!0,this.g.abort(),this.l=!1,this.m=a||7,C(this,\"complete\"),C(this,\"abort\"),zd(this));};k.N=function(){this.g&&(this.h&&(this.h=!1,this.l=!0,this.g.abort(),this.l=!1),zd(this,!0));P.$.N.call(this);};k.La=function(){this.s||(this.G||this.v||this.l?Ad(this):this.kb());};k.kb=function(){Ad(this);};\nfunction Ad(a){if(a.h&&\"undefined\"!=typeof goog&&(!a.C[1]||4!=H(a)||2!=a.da()))if(a.v&&4==H(a))yb(a.La,0,a);else if(C(a,\"readystatechange\"),4==H(a)){a.h=!1;try{const h=a.da();a:switch(h){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var b=!0;break a;default:b=!1;}var c;if(!(c=b)){var d;if(d=0===h){var e=String(a.I).match(Lc)[1]||null;!e&&l.self&&l.self.location&&(e=l.self.location.protocol.slice(0,-1));d=!td.test(e?e.toLowerCase():\"\");}c=d;}if(c)C(a,\"complete\"),C(a,\"success\");else {a.m=\n6;try{var f=2<H(a)?a.g.statusText:\"\";}catch(n){f=\"\";}a.j=f+\" [\"+a.da()+\"]\";yd(a);}}finally{zd(a);}}}function zd(a,b){if(a.g){wd(a);const c=a.g,d=a.C[0]?()=>{}:null;a.g=null;a.C=null;b||C(a,\"ready\");try{c.onreadystatechange=d;}catch(e){}}}function wd(a){a.g&&a.L&&(a.g.ontimeout=null);a.A&&(l.clearTimeout(a.A),a.A=null);}k.isActive=function(){return !!this.g};function H(a){return a.g?a.g.readyState:0}k.da=function(){try{return 2<H(this)?this.g.status:-1}catch(a){return -1}};\nk.ja=function(){try{return this.g?this.g.responseText:\"\"}catch(a){return \"\"}};k.Wa=function(a){if(this.g){var b=this.g.responseText;a&&0==b.indexOf(a)&&(b=b.substring(a.length));return rd(b)}};function mc(a){try{if(!a.g)return null;if(\"response\"in a.g)return a.g.response;switch(a.K){case sd:case \"text\":return a.g.responseText;case \"arraybuffer\":if(\"mozResponseArrayBuffer\"in a.g)return a.g.mozResponseArrayBuffer}return null}catch(b){return null}}\nfunction tc(a){const b={};a=(a.g&&2<=H(a)?a.g.getAllResponseHeaders()||\"\":\"\").split(\"\\r\\n\");for(let d=0;d<a.length;d++){if(x(a[d]))continue;var c=qb(a[d]);const e=c[0];c=c[1];if(\"string\"!==typeof c)continue;c=c.trim();const f=b[e]||[];b[e]=f;f.push(c);}Oa(b,function(d){return d.join(\", \")});}k.Ia=function(){return this.m};k.Sa=function(){return \"string\"===typeof this.j?this.j:String(this.j)};function Bd(a){let b=\"\";Na(a,function(c,d){b+=d;b+=\":\";b+=c;b+=\"\\r\\n\";});return b}function Cd(a,b,c){a:{for(d in c){var d=!1;break a}d=!0;}d||(c=Bd(c),\"string\"===typeof a?(null!=c&&encodeURIComponent(String(c))):K(a,b,c));}function Dd(a,b,c){return c&&c.internalChannelParams?c.internalChannelParams[a]||b:b}\nfunction Ed(a){this.Ga=0;this.j=[];this.l=new Gb;this.pa=this.wa=this.I=this.Y=this.g=this.Da=this.F=this.na=this.o=this.U=this.s=null;this.fb=this.W=0;this.cb=Dd(\"failFast\",!1,a);this.G=this.v=this.u=this.m=this.h=null;this.aa=!0;this.Fa=this.V=-1;this.ba=this.A=this.C=0;this.ab=Dd(\"baseRetryDelayMs\",5E3,a);this.hb=Dd(\"retryDelaySeedMs\",1E4,a);this.eb=Dd(\"forwardChannelMaxRetries\",2,a);this.xa=Dd(\"forwardChannelRequestTimeoutMs\",2E4,a);this.va=a&&a.xmlHttpFactory||void 0;this.Ha=a&&a.useFetchStreams||\n!1;this.L=void 0;this.J=a&&a.supportsCrossDomainXhr||!1;this.K=\"\";this.i=new cd(a&&a.concurrentRequestLimit);this.Ja=new hd;this.P=a&&a.fastHandshake||!1;this.O=a&&a.encodeInitMessageHeaders||!1;this.P&&this.O&&(this.O=!1);this.bb=a&&a.bc||!1;a&&a.Ea&&this.l.Ea();a&&a.forceLongPolling&&(this.aa=!1);this.ca=!this.P&&this.aa&&a&&a.detectBufferingProxy||!1;this.qa=void 0;a&&a.longPollingTimeout&&0<a.longPollingTimeout&&(this.qa=a.longPollingTimeout);this.oa=void 0;this.S=0;this.M=!1;this.ma=this.B=null;}\nk=Ed.prototype;k.ra=8;k.H=1;function Hc(a){Fd(a);if(3==a.H){var b=a.W++,c=G(a.I);K(c,\"SID\",a.K);K(c,\"RID\",b);K(c,\"TYPE\",\"terminate\");Gd(a,c);b=new bc(a,a.l,b);b.L=2;b.A=hc(G(c));c=!1;if(l.navigator&&l.navigator.sendBeacon)try{c=l.navigator.sendBeacon(b.A.toString(),\"\");}catch(d){}!c&&l.Image&&((new Image).src=b.A,c=!0);c||(b.g=lc(b.l,null),b.g.ha(b.A));b.G=Date.now();jc(b);}Hd(a);}function zc(a){a.g&&(vc(a),a.g.cancel(),a.g=null);}\nfunction Fd(a){zc(a);a.u&&(l.clearTimeout(a.u),a.u=null);yc(a);a.i.cancel();a.m&&(\"number\"===typeof a.m&&l.clearTimeout(a.m),a.m=null);}function Gc(a){if(!ed(a.i)&&!a.m){a.m=!0;var b=a.Na;sb||vb();tb||(sb(),tb=!0);mb.add(b,a);a.C=0;}}function Id(a,b){if(Bc(a.i)>=a.i.j-(a.m?1:0))return !1;if(a.m)return a.j=b.F.concat(a.j),!0;if(1==a.H||2==a.H||a.C>=(a.cb?0:a.eb))return !1;a.m=Rb(q(a.Na,a,b),Jd(a,a.C));a.C++;return !0}\nk.Na=function(a){if(this.m)if(this.m=null,1==this.H){if(!a){this.W=Math.floor(1E5*Math.random());a=this.W++;const e=new bc(this,this.l,a);let f=this.s;this.U&&(f?(f=Pa(f),Ra(f,this.U)):f=this.U);null!==this.o||this.O||(e.I=f,f=null);if(this.P)a:{var b=0;for(var c=0;c<this.j.length;c++){b:{var d=this.j[c];if(\"__data__\"in d.map&&(d=d.map.__data__,\"string\"===typeof d)){d=d.length;break b}d=void 0;}if(void 0===d)break;b+=d;if(4096<b){b=c;break a}if(4096===b||c===this.j.length-1){b=c+1;break a}}b=1E3;}else b=\n1E3;b=Kd(this,e,b);c=G(this.I);K(c,\"RID\",a);K(c,\"CVER\",22);this.F&&K(c,\"X-HTTP-Session-Id\",this.F);Gd(this,c);f&&(this.O?b=\"headers=\"+encodeURIComponent(String(Bd(f)))+\"&\"+b:this.o&&Cd(c,this.o,f));Cc(this.i,e);this.bb&&K(c,\"TYPE\",\"init\");this.P?(K(c,\"$req\",b),K(c,\"SID\",\"null\"),e.aa=!0,gc(e,c,null)):gc(e,c,b);this.H=2;}}else 3==this.H&&(a?Ld(this,a):0==this.j.length||ed(this.i)||Ld(this));};\nfunction Ld(a,b){var c;b?c=b.m:c=a.W++;const d=G(a.I);K(d,\"SID\",a.K);K(d,\"RID\",c);K(d,\"AID\",a.V);Gd(a,d);a.o&&a.s&&Cd(d,a.o,a.s);c=new bc(a,a.l,c,a.C+1);null===a.o&&(c.I=a.s);b&&(a.j=b.F.concat(a.j));b=Kd(a,c,1E3);c.setTimeout(Math.round(.5*a.xa)+Math.round(.5*a.xa*Math.random()));Cc(a.i,c);gc(c,d,b);}function Gd(a,b){a.na&&Na(a.na,function(c,d){K(b,d,c);});a.h&&Kc({},function(c,d){K(b,d,c);});}\nfunction Kd(a,b,c){c=Math.min(a.j.length,c);var d=a.h?q(a.h.Va,a.h,a):null;a:{var e=a.j;let f=-1;for(;;){const h=[\"count=\"+c];-1==f?0<c?(f=e[0].g,h.push(\"ofs=\"+f)):f=0:h.push(\"ofs=\"+f);let n=!0;for(let t=0;t<c;t++){let m=e[t].g;const u=e[t].map;m-=f;if(0>m)f=Math.max(0,e[t].g-100),n=!1;else try{id(u,h,\"req\"+m+\"_\");}catch(L){d&&d(u);}}if(n){d=h.join(\"&\");break a}}}a=a.j.splice(0,c);b.F=a;return d}function Fc(a){if(!a.g&&!a.u){a.ba=1;var b=a.Ma;sb||vb();tb||(sb(),tb=!0);mb.add(b,a);a.A=0;}}\nfunction Ac(a){if(a.g||a.u||3<=a.A)return !1;a.ba++;a.u=Rb(q(a.Ma,a),Jd(a,a.A));a.A++;return !0}k.Ma=function(){this.u=null;Md(this);if(this.ca&&!(this.M||null==this.g||0>=this.S)){var a=2*this.S;this.l.info(\"BP detection timer enabled: \"+a);this.B=Rb(q(this.jb,this),a);}};k.jb=function(){this.B&&(this.B=null,this.l.info(\"BP detection timeout reached.\"),this.l.info(\"Buffering proxy detected and switch to long-polling!\"),this.G=!1,this.M=!0,F(10),zc(this),Md(this));};\nfunction vc(a){null!=a.B&&(l.clearTimeout(a.B),a.B=null);}function Md(a){a.g=new bc(a,a.l,\"rpc\",a.ba);null===a.o&&(a.g.I=a.s);a.g.O=0;var b=G(a.wa);K(b,\"RID\",\"rpc\");K(b,\"SID\",a.K);K(b,\"AID\",a.V);K(b,\"CI\",a.G?\"0\":\"1\");!a.G&&a.qa&&K(b,\"TO\",a.qa);K(b,\"TYPE\",\"xmlhttp\");Gd(a,b);a.o&&a.s&&Cd(b,a.o,a.s);a.L&&a.g.setTimeout(a.L);var c=a.g;a=a.pa;c.L=1;c.A=hc(G(b));c.u=null;c.S=!0;ic(c,a);}k.ib=function(){null!=this.v&&(this.v=null,zc(this),Ac(this),F(19));};\nfunction yc(a){null!=a.v&&(l.clearTimeout(a.v),a.v=null);}function sc(a,b){var c=null;if(a.g==b){yc(a);vc(a);a.g=null;var d=2;}else if(xc(a.i,b))c=b.F,Ec(a.i,b),d=1;else return;if(0!=a.H)if(b.i)if(1==d){c=b.u?b.u.length:0;b=Date.now()-b.G;var e=a.C;d=Mb();C(d,new Qb(d,c));Gc(a);}else Fc(a);else if(e=b.s,3==e||0==e&&0<b.ca||!(1==d&&Id(a,b)||2==d&&Ac(a)))switch(c&&0<c.length&&(b=a.i,b.i=b.i.concat(c)),e){case 1:J(a,5);break;case 4:J(a,10);break;case 3:J(a,6);break;default:J(a,2);}}\nfunction Jd(a,b){let c=a.ab+Math.floor(Math.random()*a.hb);a.isActive()||(c*=2);return c*b}function J(a,b){a.l.info(\"Error code \"+b);if(2==b){var c=null;a.h&&(c=null);var d=q(a.pb,a);c||(c=new M(\"//www.google.com/images/cleardot.gif\"),l.location&&\"http\"==l.location.protocol||Nc(c,\"https\"),hc(c));jd(c.toString(),d);}else F(2);a.H=0;a.h&&a.h.za(b);Hd(a);Fd(a);}k.pb=function(a){a?(this.l.info(\"Successfully pinged google.com\"),F(2)):(this.l.info(\"Failed to ping google.com\"),F(1));};\nfunction Hd(a){a.H=0;a.ma=[];if(a.h){const b=fd(a.i);if(0!=b.length||0!=a.j.length)na(a.ma,b),na(a.ma,a.j),a.i.i.length=0,ma(a.j),a.j.length=0;a.h.ya();}}function Dc(a,b,c){var d=c instanceof M?G(c):new M(c);if(\"\"!=d.g)b&&(d.g=b+\".\"+d.g),Oc(d,d.m);else {var e=l.location;d=e.protocol;b=b?b+\".\"+e.hostname:e.hostname;e=+e.port;var f=new M(null);d&&Nc(f,d);b&&(f.g=b);e&&Oc(f,e);c&&(f.l=c);d=f;}c=a.F;b=a.Da;c&&b&&K(d,c,b);K(d,\"VER\",a.ra);Gd(a,d);return d}\nfunction lc(a,b,c){if(b&&!a.J)throw Error(\"Can't create secondary domain capable XhrIo object.\");b=a.Ha&&!a.va?new P(new ld({ob:c})):new P(a.va);b.Oa(a.J);return b}k.isActive=function(){return !!this.h&&this.h.isActive(this)};function Nd(){}k=Nd.prototype;k.Ba=function(){};k.Aa=function(){};k.za=function(){};k.ya=function(){};k.isActive=function(){return !0};k.Va=function(){};function Od(){if(z&&!(10<=Number(Fa)))throw Error(\"Environmental error: no available transport.\");}Od.prototype.g=function(a,b){return new Q(a,b)};\nfunction Q(a,b){B.call(this);this.g=new Ed(b);this.l=a;this.h=b&&b.messageUrlParams||null;a=b&&b.messageHeaders||null;b&&b.clientProtocolHeaderRequired&&(a?a[\"X-Client-Protocol\"]=\"webchannel\":a={\"X-Client-Protocol\":\"webchannel\"});this.g.s=a;a=b&&b.initMessageHeaders||null;b&&b.messageContentType&&(a?a[\"X-WebChannel-Content-Type\"]=b.messageContentType:a={\"X-WebChannel-Content-Type\":b.messageContentType});b&&b.Ca&&(a?a[\"X-WebChannel-Client-Profile\"]=b.Ca:a={\"X-WebChannel-Client-Profile\":b.Ca});this.g.U=\na;(a=b&&b.cc)&&!x(a)&&(this.g.o=a);this.A=b&&b.supportsCrossDomainXhr||!1;this.v=b&&b.sendRawJson||!1;(b=b&&b.httpSessionIdParam)&&!x(b)&&(this.g.F=b,a=this.h,null!==a&&b in a&&(a=this.h,b in a&&delete a[b]));this.j=new R(this);}r(Q,B);Q.prototype.m=function(){this.g.h=this.j;this.A&&(this.g.J=!0);var a=this.g,b=this.l,c=this.h||void 0;F(0);a.Y=b;a.na=c||{};a.G=a.aa;a.I=Dc(a,null,a.Y);Gc(a);};Q.prototype.close=function(){Hc(this.g);};\nQ.prototype.u=function(a){var b=this.g;if(\"string\"===typeof a){var c={};c.__data__=a;a=c;}else this.v&&(c={},c.__data__=jb(a),a=c);b.j.push(new bd(b.fb++,a));3==b.H&&Gc(b);};Q.prototype.N=function(){this.g.h=null;delete this.j;Hc(this.g);delete this.g;Q.$.N.call(this);};\nfunction Pd(a){Yb.call(this);a.__headers__&&(this.headers=a.__headers__,this.statusCode=a.__status__,delete a.__headers__,delete a.__status__);var b=a.__sm__;if(b){a:{for(const c in b){a=c;break a}a=void 0;}if(this.i=a)a=this.i,b=null!==b&&a in b?b[a]:void 0;this.data=b;}else this.data=a;}r(Pd,Yb);function Qd(){Zb.call(this);this.status=1;}r(Qd,Zb);function R(a){this.g=a;}r(R,Nd);R.prototype.Ba=function(){C(this.g,\"a\");};R.prototype.Aa=function(a){C(this.g,new Pd(a));};\nR.prototype.za=function(a){C(this.g,new Qd());};R.prototype.ya=function(){C(this.g,\"b\");};function Rd(){this.blockSize=-1;}function S(){this.blockSize=-1;this.blockSize=64;this.g=Array(4);this.m=Array(this.blockSize);this.i=this.h=0;this.reset();}r(S,Rd);S.prototype.reset=function(){this.g[0]=1732584193;this.g[1]=4023233417;this.g[2]=2562383102;this.g[3]=271733878;this.i=this.h=0;};\nfunction Sd(a,b,c){c||(c=0);var d=Array(16);if(\"string\"===typeof b)for(var e=0;16>e;++e)d[e]=b.charCodeAt(c++)|b.charCodeAt(c++)<<8|b.charCodeAt(c++)<<16|b.charCodeAt(c++)<<24;else for(e=0;16>e;++e)d[e]=b[c++]|b[c++]<<8|b[c++]<<16|b[c++]<<24;b=a.g[0];c=a.g[1];e=a.g[2];var f=a.g[3];var h=b+(f^c&(e^f))+d[0]+3614090360&4294967295;b=c+(h<<7&4294967295|h>>>25);h=f+(e^b&(c^e))+d[1]+3905402710&4294967295;f=b+(h<<12&4294967295|h>>>20);h=e+(c^f&(b^c))+d[2]+606105819&4294967295;e=f+(h<<17&4294967295|h>>>15);\nh=c+(b^e&(f^b))+d[3]+3250441966&4294967295;c=e+(h<<22&4294967295|h>>>10);h=b+(f^c&(e^f))+d[4]+4118548399&4294967295;b=c+(h<<7&4294967295|h>>>25);h=f+(e^b&(c^e))+d[5]+1200080426&4294967295;f=b+(h<<12&4294967295|h>>>20);h=e+(c^f&(b^c))+d[6]+2821735955&4294967295;e=f+(h<<17&4294967295|h>>>15);h=c+(b^e&(f^b))+d[7]+4249261313&4294967295;c=e+(h<<22&4294967295|h>>>10);h=b+(f^c&(e^f))+d[8]+1770035416&4294967295;b=c+(h<<7&4294967295|h>>>25);h=f+(e^b&(c^e))+d[9]+2336552879&4294967295;f=b+(h<<12&4294967295|\nh>>>20);h=e+(c^f&(b^c))+d[10]+4294925233&4294967295;e=f+(h<<17&4294967295|h>>>15);h=c+(b^e&(f^b))+d[11]+2304563134&4294967295;c=e+(h<<22&4294967295|h>>>10);h=b+(f^c&(e^f))+d[12]+1804603682&4294967295;b=c+(h<<7&4294967295|h>>>25);h=f+(e^b&(c^e))+d[13]+4254626195&4294967295;f=b+(h<<12&4294967295|h>>>20);h=e+(c^f&(b^c))+d[14]+2792965006&4294967295;e=f+(h<<17&4294967295|h>>>15);h=c+(b^e&(f^b))+d[15]+1236535329&4294967295;c=e+(h<<22&4294967295|h>>>10);h=b+(e^f&(c^e))+d[1]+4129170786&4294967295;b=c+(h<<\n5&4294967295|h>>>27);h=f+(c^e&(b^c))+d[6]+3225465664&4294967295;f=b+(h<<9&4294967295|h>>>23);h=e+(b^c&(f^b))+d[11]+643717713&4294967295;e=f+(h<<14&4294967295|h>>>18);h=c+(f^b&(e^f))+d[0]+3921069994&4294967295;c=e+(h<<20&4294967295|h>>>12);h=b+(e^f&(c^e))+d[5]+3593408605&4294967295;b=c+(h<<5&4294967295|h>>>27);h=f+(c^e&(b^c))+d[10]+38016083&4294967295;f=b+(h<<9&4294967295|h>>>23);h=e+(b^c&(f^b))+d[15]+3634488961&4294967295;e=f+(h<<14&4294967295|h>>>18);h=c+(f^b&(e^f))+d[4]+3889429448&4294967295;c=\ne+(h<<20&4294967295|h>>>12);h=b+(e^f&(c^e))+d[9]+568446438&4294967295;b=c+(h<<5&4294967295|h>>>27);h=f+(c^e&(b^c))+d[14]+3275163606&4294967295;f=b+(h<<9&4294967295|h>>>23);h=e+(b^c&(f^b))+d[3]+4107603335&4294967295;e=f+(h<<14&4294967295|h>>>18);h=c+(f^b&(e^f))+d[8]+1163531501&4294967295;c=e+(h<<20&4294967295|h>>>12);h=b+(e^f&(c^e))+d[13]+2850285829&4294967295;b=c+(h<<5&4294967295|h>>>27);h=f+(c^e&(b^c))+d[2]+4243563512&4294967295;f=b+(h<<9&4294967295|h>>>23);h=e+(b^c&(f^b))+d[7]+1735328473&4294967295;\ne=f+(h<<14&4294967295|h>>>18);h=c+(f^b&(e^f))+d[12]+2368359562&4294967295;c=e+(h<<20&4294967295|h>>>12);h=b+(c^e^f)+d[5]+4294588738&4294967295;b=c+(h<<4&4294967295|h>>>28);h=f+(b^c^e)+d[8]+2272392833&4294967295;f=b+(h<<11&4294967295|h>>>21);h=e+(f^b^c)+d[11]+1839030562&4294967295;e=f+(h<<16&4294967295|h>>>16);h=c+(e^f^b)+d[14]+4259657740&4294967295;c=e+(h<<23&4294967295|h>>>9);h=b+(c^e^f)+d[1]+2763975236&4294967295;b=c+(h<<4&4294967295|h>>>28);h=f+(b^c^e)+d[4]+1272893353&4294967295;f=b+(h<<11&4294967295|\nh>>>21);h=e+(f^b^c)+d[7]+4139469664&4294967295;e=f+(h<<16&4294967295|h>>>16);h=c+(e^f^b)+d[10]+3200236656&4294967295;c=e+(h<<23&4294967295|h>>>9);h=b+(c^e^f)+d[13]+681279174&4294967295;b=c+(h<<4&4294967295|h>>>28);h=f+(b^c^e)+d[0]+3936430074&4294967295;f=b+(h<<11&4294967295|h>>>21);h=e+(f^b^c)+d[3]+3572445317&4294967295;e=f+(h<<16&4294967295|h>>>16);h=c+(e^f^b)+d[6]+76029189&4294967295;c=e+(h<<23&4294967295|h>>>9);h=b+(c^e^f)+d[9]+3654602809&4294967295;b=c+(h<<4&4294967295|h>>>28);h=f+(b^c^e)+d[12]+\n3873151461&4294967295;f=b+(h<<11&4294967295|h>>>21);h=e+(f^b^c)+d[15]+530742520&4294967295;e=f+(h<<16&4294967295|h>>>16);h=c+(e^f^b)+d[2]+3299628645&4294967295;c=e+(h<<23&4294967295|h>>>9);h=b+(e^(c|~f))+d[0]+4096336452&4294967295;b=c+(h<<6&4294967295|h>>>26);h=f+(c^(b|~e))+d[7]+1126891415&4294967295;f=b+(h<<10&4294967295|h>>>22);h=e+(b^(f|~c))+d[14]+2878612391&4294967295;e=f+(h<<15&4294967295|h>>>17);h=c+(f^(e|~b))+d[5]+4237533241&4294967295;c=e+(h<<21&4294967295|h>>>11);h=b+(e^(c|~f))+d[12]+1700485571&\n4294967295;b=c+(h<<6&4294967295|h>>>26);h=f+(c^(b|~e))+d[3]+2399980690&4294967295;f=b+(h<<10&4294967295|h>>>22);h=e+(b^(f|~c))+d[10]+4293915773&4294967295;e=f+(h<<15&4294967295|h>>>17);h=c+(f^(e|~b))+d[1]+2240044497&4294967295;c=e+(h<<21&4294967295|h>>>11);h=b+(e^(c|~f))+d[8]+1873313359&4294967295;b=c+(h<<6&4294967295|h>>>26);h=f+(c^(b|~e))+d[15]+4264355552&4294967295;f=b+(h<<10&4294967295|h>>>22);h=e+(b^(f|~c))+d[6]+2734768916&4294967295;e=f+(h<<15&4294967295|h>>>17);h=c+(f^(e|~b))+d[13]+1309151649&\n4294967295;c=e+(h<<21&4294967295|h>>>11);h=b+(e^(c|~f))+d[4]+4149444226&4294967295;b=c+(h<<6&4294967295|h>>>26);h=f+(c^(b|~e))+d[11]+3174756917&4294967295;f=b+(h<<10&4294967295|h>>>22);h=e+(b^(f|~c))+d[2]+718787259&4294967295;e=f+(h<<15&4294967295|h>>>17);h=c+(f^(e|~b))+d[9]+3951481745&4294967295;a.g[0]=a.g[0]+b&4294967295;a.g[1]=a.g[1]+(e+(h<<21&4294967295|h>>>11))&4294967295;a.g[2]=a.g[2]+e&4294967295;a.g[3]=a.g[3]+f&4294967295;}\nS.prototype.j=function(a,b){void 0===b&&(b=a.length);for(var c=b-this.blockSize,d=this.m,e=this.h,f=0;f<b;){if(0==e)for(;f<=c;)Sd(this,a,f),f+=this.blockSize;if(\"string\"===typeof a)for(;f<b;){if(d[e++]=a.charCodeAt(f++),e==this.blockSize){Sd(this,d);e=0;break}}else for(;f<b;)if(d[e++]=a[f++],e==this.blockSize){Sd(this,d);e=0;break}}this.h=e;this.i+=b;};\nS.prototype.l=function(){var a=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);a[0]=128;for(var b=1;b<a.length-8;++b)a[b]=0;var c=8*this.i;for(b=a.length-8;b<a.length;++b)a[b]=c&255,c/=256;this.j(a);a=Array(16);for(b=c=0;4>b;++b)for(var d=0;32>d;d+=8)a[c++]=this.g[b]>>>d&255;return a};function T(a,b){this.h=b;for(var c=[],d=!0,e=a.length-1;0<=e;e--){var f=a[e]|0;d&&f==b||(c[e]=f,d=!1);}this.g=c;}var sa={};function Td(a){return -128<=a&&128>a?ra(a,function(b){return new T([b|0],0>b?-1:0)}):new T([a|0],0>a?-1:0)}function U(a){if(isNaN(a)||!isFinite(a))return V;if(0>a)return W(U(-a));for(var b=[],c=1,d=0;a>=c;d++)b[d]=a/c|0,c*=Ud;return new T(b,0)}\nfunction Vd(a,b){if(0==a.length)throw Error(\"number format error: empty string\");b=b||10;if(2>b||36<b)throw Error(\"radix out of range: \"+b);if(\"-\"==a.charAt(0))return W(Vd(a.substring(1),b));if(0<=a.indexOf(\"-\"))throw Error('number format error: interior \"-\" character');for(var c=U(Math.pow(b,8)),d=V,e=0;e<a.length;e+=8){var f=Math.min(8,a.length-e),h=parseInt(a.substring(e,e+f),b);8>f?(f=U(Math.pow(b,f)),d=d.R(f).add(U(h))):(d=d.R(c),d=d.add(U(h)));}return d}\nvar Ud=4294967296,V=Td(0),Wd=Td(1),Xd=Td(16777216);k=T.prototype;k.ea=function(){if(X(this))return -W(this).ea();for(var a=0,b=1,c=0;c<this.g.length;c++){var d=this.D(c);a+=(0<=d?d:Ud+d)*b;b*=Ud;}return a};\nk.toString=function(a){a=a||10;if(2>a||36<a)throw Error(\"radix out of range: \"+a);if(Y(this))return \"0\";if(X(this))return \"-\"+W(this).toString(a);for(var b=U(Math.pow(a,6)),c=this,d=\"\";;){var e=Yd(c,b).g;c=Zd(c,e.R(b));var f=((0<c.g.length?c.g[0]:c.h)>>>0).toString(a);c=e;if(Y(c))return f+d;for(;6>f.length;)f=\"0\"+f;d=f+d;}};k.D=function(a){return 0>a?0:a<this.g.length?this.g[a]:this.h};function Y(a){if(0!=a.h)return !1;for(var b=0;b<a.g.length;b++)if(0!=a.g[b])return !1;return !0}\nfunction X(a){return -1==a.h}k.X=function(a){a=Zd(this,a);return X(a)?-1:Y(a)?0:1};function W(a){for(var b=a.g.length,c=[],d=0;d<b;d++)c[d]=~a.g[d];return (new T(c,~a.h)).add(Wd)}k.abs=function(){return X(this)?W(this):this};k.add=function(a){for(var b=Math.max(this.g.length,a.g.length),c=[],d=0,e=0;e<=b;e++){var f=d+(this.D(e)&65535)+(a.D(e)&65535),h=(f>>>16)+(this.D(e)>>>16)+(a.D(e)>>>16);d=h>>>16;f&=65535;h&=65535;c[e]=h<<16|f;}return new T(c,c[c.length-1]&-2147483648?-1:0)};\nfunction Zd(a,b){return a.add(W(b))}\nk.R=function(a){if(Y(this)||Y(a))return V;if(X(this))return X(a)?W(this).R(W(a)):W(W(this).R(a));if(X(a))return W(this.R(W(a)));if(0>this.X(Xd)&&0>a.X(Xd))return U(this.ea()*a.ea());for(var b=this.g.length+a.g.length,c=[],d=0;d<2*b;d++)c[d]=0;for(d=0;d<this.g.length;d++)for(var e=0;e<a.g.length;e++){var f=this.D(d)>>>16,h=this.D(d)&65535,n=a.D(e)>>>16,t=a.D(e)&65535;c[2*d+2*e]+=h*t;$d(c,2*d+2*e);c[2*d+2*e+1]+=f*t;$d(c,2*d+2*e+1);c[2*d+2*e+1]+=h*n;$d(c,2*d+2*e+1);c[2*d+2*e+2]+=f*n;$d(c,2*d+2*e+2);}for(d=\n0;d<b;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=b;d<2*b;d++)c[d]=0;return new T(c,0)};function $d(a,b){for(;(a[b]&65535)!=a[b];)a[b+1]+=a[b]>>>16,a[b]&=65535,b++;}function ae(a,b){this.g=a;this.h=b;}\nfunction Yd(a,b){if(Y(b))throw Error(\"division by zero\");if(Y(a))return new ae(V,V);if(X(a))return b=Yd(W(a),b),new ae(W(b.g),W(b.h));if(X(b))return b=Yd(a,W(b)),new ae(W(b.g),b.h);if(30<a.g.length){if(X(a)||X(b))throw Error(\"slowDivide_ only works with positive integers.\");for(var c=Wd,d=b;0>=d.X(a);)c=be(c),d=be(d);var e=Z(c,1),f=Z(d,1);d=Z(d,2);for(c=Z(c,2);!Y(d);){var h=f.add(d);0>=h.X(a)&&(e=e.add(c),f=h);d=Z(d,1);c=Z(c,1);}b=Zd(a,e.R(b));return new ae(e,b)}for(e=V;0<=a.X(b);){c=Math.max(1,Math.floor(a.ea()/\nb.ea()));d=Math.ceil(Math.log(c)/Math.LN2);d=48>=d?1:Math.pow(2,d-48);f=U(c);for(h=f.R(b);X(h)||0<h.X(a);)c-=d,f=U(c),h=f.R(b);Y(f)&&(f=Wd);e=e.add(f);a=Zd(a,h);}return new ae(e,a)}k.gb=function(a){return Yd(this,a).h};k.and=function(a){for(var b=Math.max(this.g.length,a.g.length),c=[],d=0;d<b;d++)c[d]=this.D(d)&a.D(d);return new T(c,this.h&a.h)};k.or=function(a){for(var b=Math.max(this.g.length,a.g.length),c=[],d=0;d<b;d++)c[d]=this.D(d)|a.D(d);return new T(c,this.h|a.h)};\nk.xor=function(a){for(var b=Math.max(this.g.length,a.g.length),c=[],d=0;d<b;d++)c[d]=this.D(d)^a.D(d);return new T(c,this.h^a.h)};function be(a){for(var b=a.g.length+1,c=[],d=0;d<b;d++)c[d]=a.D(d)<<1|a.D(d-1)>>>31;return new T(c,a.h)}function Z(a,b){var c=b>>5;b%=32;for(var d=a.g.length-c,e=[],f=0;f<d;f++)e[f]=0<b?a.D(f+c)>>>b|a.D(f+c+1)<<32-b:a.D(f+c);return new T(e,a.h)}Od.prototype.createWebChannel=Od.prototype.g;Q.prototype.send=Q.prototype.u;Q.prototype.open=Q.prototype.m;Q.prototype.close=Q.prototype.close;Sb.NO_ERROR=0;Sb.TIMEOUT=8;Sb.HTTP_ERROR=6;Tb.COMPLETE=\"complete\";Wb.EventType=Xb;Xb.OPEN=\"a\";Xb.CLOSE=\"b\";Xb.ERROR=\"c\";Xb.MESSAGE=\"d\";B.prototype.listen=B.prototype.O;P.prototype.listenOnce=P.prototype.P;P.prototype.getLastError=P.prototype.Sa;P.prototype.getLastErrorCode=P.prototype.Ia;P.prototype.getStatus=P.prototype.da;P.prototype.getResponseJson=P.prototype.Wa;\nP.prototype.getResponseText=P.prototype.ja;P.prototype.send=P.prototype.ha;P.prototype.setWithCredentials=P.prototype.Oa;S.prototype.digest=S.prototype.l;S.prototype.reset=S.prototype.reset;S.prototype.update=S.prototype.j;T.prototype.add=T.prototype.add;T.prototype.multiply=T.prototype.R;T.prototype.modulo=T.prototype.gb;T.prototype.compare=T.prototype.X;T.prototype.toNumber=T.prototype.ea;T.prototype.toString=T.prototype.toString;T.prototype.getBits=T.prototype.D;T.fromNumber=U;T.fromString=Vd;\nvar createWebChannelTransport = esm.createWebChannelTransport=function(){return new Od};var getStatEventTarget = esm.getStatEventTarget=function(){return Mb()};var ErrorCode = esm.ErrorCode=Sb;var EventType = esm.EventType=Tb;var Event = esm.Event=E;var Stat = esm.Stat={xb:0,Ab:1,Bb:2,Ub:3,Zb:4,Wb:5,Xb:6,Vb:7,Tb:8,Yb:9,PROXY:10,NOPROXY:11,Rb:12,Nb:13,Ob:14,Mb:15,Pb:16,Qb:17,tb:18,sb:19,ub:20};var FetchXmlHttpFactory = esm.FetchXmlHttpFactory=ld;var WebChannel = esm.WebChannel=Wb;var XhrIo = esm.XhrIo=P;var Md5 = esm.Md5=S;var Integer = esm.Integer=T;\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCLGVBQWUsZUFBZSxvREFBb0QsMERBQTBELGNBQWMsZUFBZSwyQ0FBMkMsZUFBZSx1RUFBdUUsbURBQW1ELG1CQUFtQjtBQUMzWixtQkFBbUIsb0JBQW9CLHVCQUF1Qiw4Q0FBOEMsa0JBQWtCLDRDQUE0QyxtQ0FBbUMscUJBQXFCLGtCQUFrQiw2QkFBNkIsa0JBQWtCLGlHQUFpRztBQUNwWSxpQkFBaUIsOENBQThDLGtCQUFrQixnQkFBZ0IsMEJBQTBCLHdCQUF3QixnQkFBZ0IsY0FBYyx3QkFBd0IsZ0JBQWdCLGtCQUFrQiwwQkFBMEIscUJBQXFCLHdDQUF3QyxtQkFBbUIsd0JBQXdCLG1DQUFtQyxhQUFhLGNBQWMsZUFBZSxTQUFTLGlCQUFpQiwwQkFBMEIsd0NBQXdDLFlBQVkseUJBQXlCLGVBQWUsY0FBYyxvQkFBb0IsK0NBQStDLGdEQUFnRCxlQUFlLGlGQUFpRixZQUFZLFdBQVcsaUNBQWlDLFdBQVcsZUFBZSxpQkFBaUIsUUFBUSxpQkFBaUIsWUFBWSxJQUFJLGNBQWMsU0FBUztBQUM5OEIsaUJBQWlCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLFVBQVUsa0NBQWtDLGFBQWEsWUFBWSxJQUFJLGlCQUFpQixpQkFBaUIsZ0JBQWdCLFlBQVkscUJBQXFCLDBCQUEwQix5QkFBeUIsMkJBQTJCLGtCQUFrQix5REFBeUQsbUNBQW1DLFlBQVksZUFBZSxPQUFPLEVBQUUsSUFBSSxlQUFlLCtCQUErQixtQ0FBbUMsVUFBVSxTQUFTLEdBQUcsY0FBYyw2QkFBNkIsY0FBYyxrQkFBa0IsK0JBQStCLGNBQWMsMkJBQTJCLGVBQWUsV0FBVyxTQUFTLHFCQUFxQixpQkFBaUIsU0FBUyxnRUFBZ0UseU9BQXlPLGNBQWMsaUJBQWlCLCtCQUErQjtBQUM3bkMsR0FBRyx3QkFBd0IsV0FBVyx1QkFBdUIsUUFBUSxXQUFXLHVDQUF1QyxvQ0FBb0MsUUFBUSxXQUFXLHFDQUFxQyw4Q0FBOEMsR0FBRyxxQkFBcUIsTUFBTSxZQUFZLGdDQUFnQyxjQUFjLFNBQVMsT0FBTyxPQUFPLGtCQUFrQixZQUFZLGtDQUFrQyxlQUFlLFVBQVUsZ0JBQWdCLHlCQUF5QiwyQ0FBMkMsa0VBQWtFLFlBQVksdURBQXVELGdCQUFnQixpQkFBaUIsb0JBQW9CLFlBQVksTUFBTSw0RkFBNEYsbUNBQW1DLFNBQVMsc0JBQXNCLE9BQU8sR0FBRyxJQUFJLGVBQWUsU0FBUyxRQUFRLFVBQVU7QUFDLzdCLElBQUksY0FBYyxtRUFBbUUscUJBQXFCLHNUQUFzVCxxQkFBcUIsbUJBQW1CLHVCQUF1QixxQkFBcUI7QUFDcGYsV0FBVyx1QkFBdUIsOEJBQThCLHFGQUFxRixtQkFBbUIsU0FBUyx1Q0FBdUMsT0FBTyxRQUFRLDZCQUE2Qix5QkFBeUIsaUJBQWlCLGFBQWEsdURBQXVELG1EQUFtRCxTQUFTLHVCQUF1QixnQkFBZ0IsZ0JBQWdCLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxjQUFjLG9CQUFvQixlQUFlLFFBQVEsZ0JBQWdCLGFBQWEsV0FBVyxXQUFXLG1CQUFtQixxQ0FBcUMsaUJBQWlCLDBDQUEwQyxlQUFlLFdBQVcsMkJBQTJCLFNBQVMsb0hBQW9ILGlCQUFpQixRQUFRLFlBQVksbUJBQW1CLEtBQUssZUFBZSxxQkFBcUIsWUFBWSxZQUFZLHFFQUFxRSxlQUFlLFdBQVcsVUFBVSxVQUFVLHFDQUFxQyxtQkFBbUIsWUFBWSw2QkFBNkIsa0JBQWtCLDJFQUEyRSxVQUFVLGlCQUFpQixhQUFhLGFBQWEseUJBQXlCLDZDQUE2QztBQUM3OEMscUJBQXFCLFlBQVksV0FBVyxLQUFLLFdBQVcsMERBQTBELFVBQVUsaURBQWlELHVCQUF1QixrQ0FBa0MscUJBQXFCLFlBQVksV0FBVyxxQkFBcUIsWUFBWSxRQUFRO0FBQy9ULHlCQUF5Qix3Q0FBd0MsbUNBQW1DLHVCQUF1QixtQkFBbUIsb0JBQW9CLE9BQU8sVUFBVSxRQUFRLGFBQWEsd0ZBQXdGLHdEQUF3RCx5REFBeUQsc0VBQXNFO0FBQ3ZkLGNBQWMsY0FBYyxrQ0FBa0MsV0FBVyxTQUFTLHVCQUF1QixxQkFBcUIsWUFBWSxXQUFXLHFCQUFxQixZQUFZLFFBQVE7QUFDOUwsdUJBQXVCLGdDQUFnQyxXQUFXLHFCQUFxQjtBQUN2RixlQUFlLGtDQUFrQyxZQUFZLHNCQUFzQixNQUFNLHVCQUF1QixxSkFBcUosNkRBQTZELGVBQWUsa0NBQWtDLGlCQUFpQixhQUFhLE1BQU0sZ0JBQWdCLCtCQUErQixZQUFZLGVBQWU7QUFDamUsZUFBZSxRQUFRLDhCQUE4QixzREFBc0QsZUFBZSxrQ0FBa0MsMEJBQTBCLHdCQUF3QixFQUFFLGFBQWEsYUFBYSxhQUFhLG9CQUFvQixZQUFZLGFBQWEsT0FBTyxtQkFBbUIsa0RBQWtEO0FBQ2hYLGdCQUFnQixZQUFZLGNBQWMsRUFBRSxnQkFBZ0IsTUFBTSxZQUFZLG9DQUFvQyw0Q0FBNEMsTUFBTSxRQUFRLGFBQWEsU0FBUyxLQUFLLDBCQUEwQixLQUFLLEtBQUssZUFBZSxtQkFBbUIsUUFBUSxrQkFBa0Isa0JBQWtCLGFBQWEsV0FBVztBQUNqVix5QkFBeUIsaUJBQWlCLFdBQVcsZUFBZSxjQUFjLHFCQUFxQixXQUFXLGFBQWEsY0FBYyxRQUFRLGNBQWMsZ0NBQWdDLHVDQUF1QyxnQ0FBZ0M7QUFDMVEscUJBQXFCLG1CQUFtQixnQkFBZ0IsYUFBYSxpQkFBaUIsV0FBVyxLQUFLLFdBQVcsMkJBQTJCLCtCQUErQixnQkFBZ0Isd0JBQXdCLDhCQUE4Qix3QkFBd0IsU0FBUyxpQkFBaUIsU0FBUyxTQUFTLFNBQVMsYUFBYSxNQUFNLE1BQU0sa0VBQWtFLFVBQVUsY0FBYyxTQUFTLFdBQVcsc0RBQXNELFNBQVMsU0FBUyxjQUFjLG9CQUFvQixTQUFTLGlCQUFpQixXQUFXLDhCQUE4QixXQUFXLHVDQUF1QyxTQUFTLGNBQWMsOEJBQThCLFNBQVMsU0FBUyxTQUFTLGdCQUFnQixRQUFRLCtCQUErQixlQUFlLFFBQVEsZUFBZSxXQUFXLEtBQUssY0FBYyx1QkFBdUIsOEJBQThCLFNBQVMsZUFBZSxrQkFBa0IsU0FBUyxLQUFLLCtCQUErQixrQ0FBa0MsUUFBUSxlQUFlLFlBQVksVUFBVSxPQUFPLEVBQUUsSUFBSSxlQUFlLFNBQVMsT0FBTyxTQUFTLE9BQU8sbUNBQW1DLFFBQVEsaUJBQWlCLGFBQWEsWUFBWSxZQUFZLHVCQUF1QixtQkFBbUIsUUFBUSxlQUFlLFFBQVEsU0FBUyxnQkFBZ0IsWUFBWSx3QkFBd0Isa0tBQWtLLG1CQUFtQixXQUFXO0FBQzdpRCxlQUFlLFFBQVEsdUNBQXVDLGVBQWUsa0JBQWtCLFNBQVMsZ0JBQWdCLG1CQUFtQix1Q0FBdUMsaUVBQWlFLDhDQUE4QyxvREFBb0QsZUFBZSxZQUFZLFNBQVMscUJBQXFCLE1BQU0sWUFBWSxTQUFTLG1CQUFtQixtQkFBbUIsaUJBQWlCLFFBQVEsU0FBUyxTQUFTLFlBQVksVUFBVSxhQUFhLEtBQUssaUJBQWlCLDJCQUEyQixJQUFJLFVBQVUscUVBQXFFLGVBQWUsYUFBYSxTQUFTLFdBQVcsUUFBUSxVQUFVLHFCQUFxQixpREFBaUQsWUFBWSxXQUFXLEtBQUssNENBQTRDLFlBQVksZUFBZSxlQUFlLHFCQUFxQixpQ0FBaUMsSUFBSSxRQUFRLDBCQUEwQixrQkFBa0IsV0FBVyxvQ0FBb0MsMERBQTBELGNBQWMsV0FBVywyQkFBMkIsWUFBWSx5QkFBeUIsa0JBQWtCLGFBQWEsU0FBUywyQkFBMkIsV0FBVyxLQUFLLHNCQUFzQixlQUFlLFdBQVcsT0FBTyxtQkFBbUIsa0VBQWtFLFlBQVksU0FBUywrREFBK0Q7QUFDOS9DLDJCQUEyQixrQkFBa0IsdUVBQXVFLEdBQUcsb0JBQW9CLGtCQUFrQixxREFBcUQsR0FBRyxpQkFBaUIsa0JBQWtCLHFCQUFxQixHQUFHO0FBQ2hSLGlCQUFpQixpQkFBaUIsa0JBQWtCLElBQUksb0JBQW9CLGFBQWEsV0FBVyw0QkFBNEIsV0FBVyxrQkFBa0IsV0FBVyxvQ0FBb0MsV0FBVyxnREFBZ0QsV0FBVyxlQUFlLGFBQWEsU0FBUyxVQUFVLFFBQVEsU0FBUyxjQUFjLG9CQUFvQiwwQkFBMEIsZUFBZSxxQkFBcUIsUUFBUSxlQUFlLGFBQWEsZ0JBQWdCLHlCQUF5QixpQkFBaUIsNEJBQTRCLGFBQWEsUUFBUSxjQUFjLGFBQWEsa0JBQWtCLG1CQUFtQixpQkFBaUIsb0JBQW9CLGFBQWE7QUFDbnJCLGlCQUFpQixtRkFBbUYsK0JBQStCLEtBQUssSUFBSSxRQUFRLDhEQUE4RCxRQUFRLGtMQUFrTCxlQUFlLG9CQUFvQixlQUFlLHdCQUF3QixlQUFlLFFBQVEsK0JBQStCLGNBQWMsa0JBQWtCLFFBQVEsY0FBYyxrQkFBa0IsUUFBUSxPQUFPLGVBQWUsU0FBUywwQkFBMEIsMkJBQTJCLDBCQUEwQixXQUFXLFVBQVUscUJBQXFCLFNBQVMsU0FBUyxTQUFTLFlBQVksb0JBQW9CLFVBQVUsZ0JBQWdCLGlCQUFpQixZQUFZLFVBQVUsc0RBQXNELFVBQVUsWUFBWSxTQUFTLG1CQUFtQixXQUFXLFVBQVUsU0FBUyxZQUFZLGlDQUFpQyxlQUFlLGNBQWMsWUFBWSxVQUFVLFdBQVcsaUJBQWlCLE9BQU8sZUFBZSx5QkFBeUI7QUFDanFDLG1CQUFtQixNQUFNLGFBQWEsTUFBTSxPQUFPLFlBQVksaUJBQWlCLGVBQWUsTUFBTSxXQUFXLGdCQUFnQixrQ0FBa0MsY0FBYyxNQUFNLFFBQVEsV0FBVywwQkFBMEIsdUNBQXVDLG9DQUFvQyxpQkFBaUIsdUlBQXVJLEtBQUs7QUFDM2MsaUJBQWlCLFdBQVcsZUFBZTtBQUMzQyxpQkFBaUIsSUFBSSxnQkFBZ0Isa0JBQWtCLGtCQUFrQixvQkFBb0Isb0VBQW9FLDZDQUE2QyxTQUFTLGtCQUFrQixVQUFVLGVBQWUsaUJBQWlCLEtBQUssOEJBQThCLGNBQWMscUNBQXFDLFFBQVEsU0FBUyxTQUFTLFFBQVEsNEJBQTRCLFFBQVEsSUFBSSx5Q0FBeUMsaUJBQWlCLEVBQUU7QUFDL2UsRUFBRSxZQUFZLFNBQVMsWUFBWSxtQkFBbUIsY0FBYywyQ0FBMkMsV0FBVyxxQkFBcUIsR0FBRyxXQUFXLGVBQWUseUVBQXlFLFFBQVEsU0FBUyxRQUFRLHdHQUF3RyxNQUFNLFVBQVUsU0FBUyxNQUFNLFFBQVEsU0FBUyxTQUFTO0FBQy9hLHNEQUFzRCxjQUFjLDhEQUE4RCx5R0FBeUcsVUFBVSxXQUFXLGVBQWU7QUFDL1EsbUJBQW1CLFdBQVcsS0FBSyxtQkFBbUIscUJBQXFCLHlCQUF5Qix3Q0FBd0MsTUFBTSxlQUFlLE1BQU0sTUFBTSwrQkFBK0IsS0FBSyxNQUFNLCtCQUErQiw4Q0FBOEMsNkNBQTZDLFdBQVc7QUFDNVYsaURBQWlELGdCQUFnQixXQUFXLDhCQUE4QixtRUFBbUUsaUJBQWlCLDhCQUE4QixtQkFBbUIsMkJBQTJCLHNCQUFzQixLQUFLLDBCQUEwQixpQkFBaUIsUUFBUSxTQUFTLG9CQUFvQixVQUFVLFVBQVUsZUFBZSxtQkFBbUI7QUFDM2EsaUJBQWlCLG9EQUFvRCxxQkFBcUIsZUFBZSxxQ0FBcUMsZ0JBQWdCLFlBQVksbUJBQW1CLHNHQUFzRyxlQUFlLDBCQUEwQixjQUFjLE1BQU0sVUFBVSxtQ0FBbUMsU0FBUyxRQUFRLFFBQVE7QUFDdGEsaUJBQWlCLElBQUksVUFBVSwyREFBMkQsSUFBSSx1QkFBdUIsU0FBUyxRQUFRLGtDQUFrQyxRQUFRLGNBQWMsU0FBUyxvQ0FBb0MsYUFBYSxNQUFNLFFBQVEsa0ZBQWtGLHFCQUFxQixJQUFJLFFBQVEsVUFBVSxjQUFjLGNBQWMsNkRBQTZELFdBQVcsS0FBSyxXQUFXO0FBQ3ZmLEtBQUssT0FBTyx3QkFBd0IsU0FBUyxVQUFVLGFBQWEsd0NBQXdDLGFBQWEseUNBQXlDLGNBQWMsbUdBQW1HLElBQUksYUFBYSxPQUFPLG9FQUFvRSxPQUFPLFVBQVUsNEhBQTRILFFBQVE7QUFDcGdCLHNEQUFzRCw4QkFBOEIsTUFBTSxjQUFjLGdFQUFnRSxJQUFJLFFBQVEsNkJBQTZCLFFBQVEsVUFBVSxjQUFjLG1CQUFtQixtQkFBbUIsT0FBTyxXQUFXLHFCQUFxQix5Q0FBeUMseUdBQXlHLE9BQU8sV0FBVyxlQUFlLDRDQUE0Qyx3SEFBd0gsMENBQTBDLFVBQVUsNEJBQTRCLElBQUksaUJBQWlCLFNBQVMsS0FBSyxJQUFJLHVCQUF1QjtBQUNueUIsZUFBZSwrQ0FBK0MsaUNBQWlDLDBFQUEwRSxrREFBa0QsK0JBQStCLFNBQVMsV0FBVyxZQUFZLElBQUksY0FBYyxTQUFTLEtBQUssSUFBSSwwQkFBMEI7QUFDeFYsaUJBQWlCLCtEQUErRCw0RUFBNEUsNENBQTRDLElBQUksbUNBQW1DLG1KQUFtSixpQkFBaUIsTUFBTSxlQUFlLFlBQVksV0FBVyxLQUFLLCtCQUErQixTQUFTLDBCQUEwQix1QkFBdUIsWUFBWSxzREFBc0QsY0FBYyx3QkFBd0IsWUFBWSxpQkFBaUIsVUFBVSxtQkFBbUIsV0FBVyxhQUFhLFdBQVcsV0FBVyxhQUFhLFdBQVcsVUFBVSxhQUFhLFFBQVEsZ0NBQWdDLFdBQVcsWUFBWTtBQUMzMUIsZ0NBQWdDLGtCQUFrQiwyQkFBMkIsYUFBYSwrSEFBK0gsRUFBRSxvREFBb0QsMEZBQTBGLHFDQUFxQyxpQ0FBaUMsbUJBQW1CLGNBQWM7QUFDaGQsbUJBQW1CLGlCQUFpQixpQ0FBaUMsaUJBQWlCLE1BQU0sWUFBWSxtREFBbUQsT0FBTyxlQUFlLG1CQUFtQix5RUFBeUUsa0JBQWtCLGNBQWMsZUFBZSxtSUFBbUk7QUFDL2IsaUJBQWlCLHlFQUF5RSxtQkFBbUIsMEZBQTBGLEVBQUUsb0JBQW9CLGVBQWUsa0JBQWtCLHNEQUFzRCxpRUFBaUUsaUJBQWlCLG1CQUFtQixlQUFlO0FBQ3hhLGNBQWMsa0RBQWtELG1EQUFtRCxJQUFJLGVBQWUsb0JBQW9CLFFBQVEsWUFBWSxZQUFZLG9CQUFvQixzQkFBc0IsVUFBVSxVQUFVLGFBQWEsaUJBQWlCLEtBQUssU0FBUyw2REFBNkQsaUJBQWlCLEtBQUssU0FBUztBQUNoWSx3QkFBd0IsUUFBUSw2QkFBNkIsc0JBQXNCLG9CQUFvQixRQUFRLFNBQVMsZ0JBQWdCLFFBQVEscUVBQXFFLFlBQVksV0FBVyxLQUFLLGFBQWEsWUFBWSxXQUFXLGtCQUFrQixVQUFVLGdCQUFnQixRQUFRLFNBQVMsdUVBQXVFLE1BQU0sOEJBQThCLFlBQVksV0FBVyxzQkFBc0I7QUFDMWUsb0JBQW9CLFFBQVEsWUFBWSxZQUFZLDJDQUEyQyxrQkFBa0IsVUFBVSxhQUFhLG9CQUFvQixlQUFlLFlBQVksa0NBQWtDLG1CQUFtQixRQUFRO0FBQ3BQLHNCQUFzQix3QkFBd0IscUJBQXFCLHVDQUF1QyxZQUFZLFdBQVcsS0FBSyxXQUFXLGtEQUFrRCxRQUFRLFdBQVcsS0FBSyxRQUFRLHFEQUFxRCxZQUFZLDJCQUEyQixnQkFBZ0IsWUFBWSx5QkFBeUI7QUFDcFgsaUJBQWlCLGtEQUFrRCxzQkFBc0IsaUNBQWlDLEtBQUssT0FBTyxhQUFhLGlCQUFpQixTQUFTLGNBQWMsZUFBZSxhQUFhLCtMQUErTCxrQkFBa0IsWUFBWSwyQkFBMkIsWUFBWSxXQUFXLFVBQVUsZUFBZSxtQ0FBbUMsZUFBZSw0QkFBNEIsaUJBQWlCLG9DQUFvQyxpQkFBaUI7QUFDbnBCLGlCQUFpQixxREFBcUQsK0JBQStCLGdCQUFnQixzQ0FBc0MsaUNBQWlDLDBDQUEwQyxrQkFBa0IsZUFBZSxzQ0FBc0MsNEJBQTRCLFVBQVUsNENBQTRDLFNBQVMsZUFBZSxhQUFhLGFBQWEsa0NBQWtDLFNBQVMsZ0NBQWdDLGNBQWMsZUFBZSxtQkFBbUIsY0FBYyxJQUFJLG1CQUFtQixRQUFRLGdCQUFnQix1Q0FBdUMsR0FBRyxTQUFTLDBEQUEwRCxpQkFBaUIsZUFBZSxZQUFZLGtCQUFrQixpREFBaUQsaURBQWlELGlEQUFpRCxxREFBcUQsd0JBQXdCLDhCQUE4QixNQUFNLFNBQVMsWUFBWSx1QkFBdUIsSUFBSSxtRUFBbUUsV0FBVyxlQUFlLGtCQUFrQixpQkFBaUIsU0FBUywwQkFBMEIsOEJBQThCLDJCQUEyQixrQkFBa0IsVUFBVSxHQUFHLEVBQUUsaUJBQWlCLGFBQWEsU0FBUyxTQUFTLGNBQWMsbUJBQW1CLGNBQWMscUVBQXFFLDZCQUE2QixtQkFBbUIsWUFBWSxhQUFhLFVBQVUsVUFBVSwyQkFBMkIsUUFBUSxTQUFTO0FBQ2xuRCxxQkFBcUIsZ0ZBQWdGLFNBQVMsU0FBUyxrQkFBa0IsV0FBVyxtQkFBbUIsOEVBQThFLFVBQVUsU0FBUyw4REFBOEQsY0FBYztBQUNwVixtQkFBbUIsbUNBQW1DLG1CQUFtQixjQUFjLDBEQUEwRCxFQUFFLHFFQUFxRTtBQUN4TixpQkFBaUIscVJBQXFSLDJEQUEyRCwwQkFBMEIsV0FBVyx3R0FBd0c7QUFDOWUsSUFBSSwrREFBK0QsVUFBVSw0REFBNEQsZUFBZSxtREFBbUQsaUJBQWlCLFdBQVcsK0NBQStDLGlCQUFpQix3Q0FBd0Msc0JBQXNCLGVBQWUsc0NBQXNDLHlCQUF5QjtBQUNuYixpQkFBaUIsdURBQXVELGlCQUFpQixxQ0FBcUMsZ0JBQWdCLG1CQUFtQixlQUFlLGVBQWUsU0FBUyxTQUFTLFNBQVMsT0FBTyxpQ0FBaUMscUJBQXFCLGdDQUFnQztBQUN2VCxtQ0FBbUMscUJBQXFCLDhCQUE4QixtQkFBbUIsUUFBUSw2Q0FBNkMsdUJBQXVCLGVBQWUsb0RBQW9ELHNEQUFzRCxlQUFlLDBCQUEwQixpQkFBaUIsbUNBQW1DLEVBQUUsb0JBQW9CLGNBQWMsYUFBYSxxQkFBcUIsZUFBZSxVQUFVLG1CQUFtQixVQUFVLFNBQVMsVUFBVSwrQkFBK0IsU0FBUyxZQUFZLFVBQVUsa0JBQWtCLE9BQU8sMkNBQTJDLGNBQWMsaUJBQWlCO0FBQzNyQix1QkFBdUIsMEZBQTBGLFlBQVksMEJBQTBCLFNBQVMsVUFBVSxTQUFTLFVBQVUsVUFBVSxnQ0FBZ0MsZ0NBQWdDLDBDQUEwQyxJQUFJLGlEQUFpRCxTQUFTLFdBQVcsT0FBTyxRQUFRLHdCQUF3QixpRkFBaUY7QUFDbGYsbUZBQW1GLG1FQUFtRSxnRUFBZ0Usc0NBQXNDLDhFQUE4RSxnQkFBZ0IsaURBQWlELHFDQUFxQztBQUNoYixRQUFRLElBQUkscUtBQXFLLFNBQVMsY0FBYyxlQUFlLDREQUE0RCxnQkFBZ0IsK0hBQStILGlCQUFpQixPQUFPLGlDQUFpQyxNQUFNLE1BQU0sTUFBTTtBQUM3ZSxlQUFlLDRDQUE0QyxvQkFBb0IseUhBQXlILGVBQWUsNkVBQTZFLG1CQUFtQixnQkFBZ0Isc0RBQXNELGdCQUFnQjtBQUM3WSxlQUFlLDZGQUE2Rix5Q0FBeUMsT0FBTyxJQUFJLGVBQWUsWUFBWSx5RUFBeUUsUUFBUSxjQUFjLE1BQU0sV0FBVyxNQUFNLFlBQVkscUNBQXFDLHNFQUFzRSxrQ0FBa0MsS0FBSyxvQ0FBb0MsTUFBTTtBQUN6ZixFQUFFLElBQUksZ0NBQWdDLFNBQVMsTUFBTSxzQkFBc0IsUUFBUSxRQUFRLFNBQVMsaUJBQWlCLFFBQVEsTUFBTSwyQkFBMkIsTUFBTSxTQUFTLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLFlBQVksZUFBZSwrQkFBK0IscUNBQXFDLHNCQUFzQixpQkFBaUIsY0FBYyw0QkFBNEIsZ0JBQWdCLElBQUksa0NBQWtDLFNBQVM7QUFDamQsZ0JBQWdCLElBQUkscUNBQXFDLFNBQVMsWUFBWSxpQkFBaUIsV0FBVywwQkFBMEIsOENBQThDLGVBQWUsZUFBZSxJQUFJLG9CQUFvQix3Q0FBd0MsWUFBWSw0Q0FBNEMsdUZBQXVGLFlBQVksU0FBUztBQUNwYixlQUFlLFdBQVcsa0VBQWtFLFlBQVksV0FBVyxLQUFLLG9CQUFvQixlQUFlLGFBQWEsT0FBTyxnQ0FBZ0MsV0FBVyxpQkFBaUIsT0FBTyxXQUFXLGlCQUFpQixvQkFBb0IsR0FBRyxnQkFBZ0IsZUFBZSxnQkFBZ0IsdURBQXVELGVBQWUsU0FBUyxtQkFBbUIsS0FBSyxPQUFPLEtBQUssV0FBVyxFQUFFLFNBQVMsbUJBQW1CLEdBQUcsWUFBWSxTQUFTLFFBQVEsTUFBTSxvRkFBb0YsbUJBQW1CO0FBQzduQixlQUFlLFVBQVUsVUFBVSxjQUFjLHNGQUFzRixpQkFBaUIsNEJBQTRCLHdDQUF3QyxXQUFXLGtCQUFrQix3QkFBd0IscUNBQXFDLHFDQUFxQywyQ0FBMkMsbURBQW1ELG9DQUFvQztBQUM3ZCxHQUFHLGNBQWMsdUNBQXVDLFVBQVUsMkNBQTJDLGVBQWUsOEJBQThCLHlDQUF5Qyw0QkFBNEIsb0JBQW9CLHFCQUFxQixvQ0FBb0Msd0RBQXdELGVBQWUsZ0ZBQWdGLGVBQWUsU0FBUyxVQUFVO0FBQ3JlLGVBQWUsT0FBTyxNQUFNLGVBQWUsTUFBTSxXQUFXLHFCQUFxQixlQUFlLGFBQWEsd0JBQXdCLFFBQVEsa0JBQWtCLE1BQU0sYUFBYSxLQUFLLDJDQUEyQyw2Q0FBNkMsVUFBVSx3Q0FBd0Msa0NBQWtDLGVBQWUsT0FBTyxPQUFPLGVBQWU7QUFDL1ksZUFBZSxNQUFNLG9DQUFvQyxNQUFNLGFBQWEsNERBQTRELGVBQWUsbUJBQW1CLE9BQU8sV0FBVyxTQUFTLGlCQUFpQixZQUFZLFFBQVEsaUJBQWlCLHNDQUFzQyxxQ0FBcUMsZ0RBQWdELDhCQUE4QixNQUFNO0FBQzFaLGlCQUFpQixvQ0FBb0MsT0FBTyxxQ0FBcUMsV0FBVyw4QkFBOEIsYUFBYSw0Q0FBNEMsc0NBQXNDLGFBQWEsUUFBUSxZQUFZLGdCQUFnQixLQUFLLEdBQUcsZ0JBQWdCLCtEQUErRCxXQUFXLFFBQVEsVUFBVSxvQkFBb0IsS0FBSyxXQUFXLElBQUksUUFBUSxrQ0FBa0MsTUFBTSxTQUFTLE9BQU87QUFDdGYsSUFBSSxlQUFlLFlBQVksYUFBYSxlQUFlLHdDQUF3QyxXQUFXLHdGQUF3RixhQUFhLDRCQUE0Qix3RUFBd0UsV0FBVztBQUNsVSxpQkFBaUIsTUFBTSxnQkFBZ0IsZUFBZSxlQUFlLGFBQWEsZUFBZSxRQUFRLHdCQUF3Qix3QkFBd0Isc0JBQXNCLHlCQUF5QixjQUFjLG9FQUFvRSxVQUFVLFdBQVcsaUJBQWlCLDRCQUE0QixVQUFVLEVBQUUsVUFBVSxlQUFlLFVBQVU7QUFDM1ksbUJBQW1CLHlCQUF5QiwrQkFBK0IsR0FBRyxVQUFVLFNBQVMsTUFBTSxFQUFFLHFCQUFxQiwyREFBMkQsU0FBUyxZQUFZLElBQUksS0FBSyxhQUFhLGlCQUFpQixLQUFLLHFDQUFxQyxTQUFTLHFCQUFxQixTQUFTLFVBQVUsTUFBTSxjQUFjLFVBQVUsa0JBQWtCLE1BQU0sU0FBUyxlQUFlLGVBQWUsT0FBTyxXQUFXLFNBQVMsaUJBQWlCLFlBQVk7QUFDcmUsZUFBZSw4QkFBOEIsT0FBTyw0QkFBNEIsTUFBTSxVQUFVLGdCQUFnQixZQUFZLFNBQVMsZ0RBQWdELGVBQWUsOENBQThDLGdDQUFnQyxnQkFBZ0I7QUFDbFMsZUFBZSwyQ0FBMkMsZUFBZSw2QkFBNkIsd0JBQXdCLFFBQVEsY0FBYyxpQkFBaUIsZUFBZSxlQUFlLHNCQUFzQiwyQkFBMkIsc0JBQXNCLFFBQVEsd0JBQXdCLHlCQUF5QixVQUFVLE9BQU8sTUFBTSxhQUFhLFNBQVMsT0FBTyxTQUFTLGdCQUFnQjtBQUNoWixlQUFlLDJDQUEyQyxpQkFBaUIsV0FBVyxXQUFXLE1BQU0sTUFBTSxTQUFTLFNBQVMsc0NBQXNDLFlBQVksMEJBQTBCLG1CQUFtQixpQkFBaUIsVUFBVSxPQUFPLGlCQUFpQixPQUFPLFdBQVcsbUhBQW1ILGNBQWMsTUFBTSxlQUFlLE1BQU0sY0FBYyxNQUFNO0FBQ25kLGlCQUFpQiwwQ0FBMEMscUJBQXFCLFdBQVcsZ0JBQWdCLDBCQUEwQixTQUFTLFdBQVcsY0FBYyxnQkFBZ0Isa0hBQWtILG9CQUFvQixVQUFVLE1BQU0sZUFBZSxNQUFNLE9BQU8saUJBQWlCO0FBQzFYLGVBQWUsTUFBTSxRQUFRLFFBQVEsZ0JBQWdCLDBGQUEwRixXQUFXLG1CQUFtQixtQ0FBbUMsd0NBQXdDLE1BQU0saUJBQWlCLGFBQWEsZ0NBQWdDLFVBQVUsa0JBQWtCLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLE9BQU8sZUFBZSxnQkFBZ0IsUUFBUTtBQUM3YixtQkFBbUIsOEVBQThFLDRCQUE0QixLQUFLLGVBQWUsVUFBVSxTQUFTLHNCQUFzQix3Q0FBd0MsZUFBZSxlQUFlLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtCQUFrQixzQkFBc0IsV0FBVyxrQkFBa0IsY0FBYyxxRkFBcUYsNkJBQTZCO0FBQzNmLGdCQUFnQixhQUFhLGlCQUFpQixTQUFTLG1DQUFtQyw0QkFBNEIsNkVBQTZFLGlDQUFpQyxFQUFFLFdBQVcsZ0NBQWdDLG1GQUFtRixpREFBaUQsRUFBRSxxREFBcUQsbUNBQW1DLEVBQUU7QUFDamYsRUFBRSxpQ0FBaUMsdUNBQXVDLDRCQUE0QiwyR0FBMkcsb0JBQW9CLE9BQU8seUJBQXlCLGdCQUFnQixzQkFBc0IsdUNBQXVDLEtBQUssTUFBTSxXQUFXLFNBQVMsbUJBQW1CLFFBQVEsNkJBQTZCO0FBQ3phLDBCQUEwQixhQUFhLHdCQUF3QixTQUFTLGFBQWEsS0FBSyxrQkFBa0IsdUJBQXVCLDJCQUEyQixnQkFBZ0IseUJBQXlCLGNBQWMsY0FBYyxXQUFXLGNBQWM7QUFDNVAsZUFBZSxjQUFjLGtIQUFrSCxlQUFlLE1BQU0sR0FBRyxrQkFBa0IsSUFBSSxRQUFRLFVBQVUsb0RBQW9ELGFBQWEsa0JBQWtCLFNBQVMsY0FBYyxjQUFjLGVBQWUsU0FBUyxjQUFjLFVBQVUsUUFBUSwwQkFBMEIsZ0JBQWdCLDJCQUEyQjtBQUNwYywyQkFBMkIscUJBQXFCLDBCQUEwQixnQkFBZ0IsY0FBYyxtQkFBbUIsYUFBYSxrQkFBa0Isa0JBQWtCLGdCQUFnQiw2QkFBNkIsZ0JBQWdCLGNBQWMsUUFBUSw2QkFBNkIscUJBQXFCLHFCQUFxQixxQkFBcUIsb0JBQW9CO0FBQy9XLG1CQUFtQixTQUFTLGdCQUFnQixtQ0FBbUMsS0FBSyw0RkFBNEYsYUFBYSxLQUFLLGdEQUFnRCxTQUFTLFNBQVMsU0FBUyxhQUFhLCtDQUErQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwwQ0FBMEM7QUFDemQsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMkNBQTJDO0FBQy9kLFFBQVEsNENBQTRDLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw2QkFBNkIsNENBQTRDLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsMkNBQTJDO0FBQzllLHFCQUFxQiwyQ0FBMkMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsNkJBQTZCLDBDQUEwQyw2QkFBNkIsNENBQTRDLDhCQUE4QiwyQ0FBMkM7QUFDbmYsNEJBQTRCLDBDQUEwQyw2QkFBNkIsNENBQTRDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw4QkFBOEIsNENBQTRDLDZCQUE2QiwyQ0FBMkMsNkJBQTZCO0FBQy9jLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsdUNBQXVDLDhCQUE4Qix3Q0FBd0MsOEJBQThCLHdDQUF3Qyw2QkFBNkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUM7QUFDdmUsUUFBUSx1Q0FBdUMsOEJBQThCLHdDQUF3Qyw2QkFBNkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw4QkFBOEIscUNBQXFDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCO0FBQ3RlLHNCQUFzQiw4QkFBOEIsdUNBQXVDLDhCQUE4Qix1Q0FBdUMsNkJBQTZCLDBDQUEwQyw2QkFBNkIsMENBQTBDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEI7QUFDN2QsV0FBVyw2QkFBNkIsMENBQTBDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEIsMENBQTBDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEI7QUFDemQsV0FBVyw4QkFBOEIsMENBQTBDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLHlDQUF5Qyw4QkFBOEIsMENBQTBDLDJCQUEyQix1REFBdUQsMkJBQTJCO0FBQ3ZaLDRCQUE0Qix5QkFBeUIsaURBQWlELElBQUksRUFBRSxhQUFhLEtBQUssZ0NBQWdDLDRCQUE0QixJQUFJLEVBQUUsK0NBQStDLFdBQVcsSUFBSSxPQUFPLFVBQVUsSUFBSSxxQ0FBcUMsV0FBVyxJQUFJLE9BQU8sU0FBUztBQUN2Vix5QkFBeUIsZ0VBQWdFLFNBQVMsWUFBWSxhQUFhLFdBQVcsZUFBZSxpQkFBaUIsV0FBVyxzQkFBc0IsVUFBVSxZQUFZLFVBQVUsSUFBSSxnQkFBZ0IsS0FBSyw4QkFBOEIsVUFBVSxnQkFBZ0IsU0FBUywrQkFBK0IsS0FBSyxLQUFLLGFBQWEsd0JBQXdCLFVBQVUsVUFBVSxlQUFlLHVDQUF1Qyw2QkFBNkIsd0JBQXdCLGNBQWMsbUNBQW1DLHVCQUF1QixxQkFBcUIsS0FBSyxxQkFBcUI7QUFDcm9CLGlCQUFpQixnRUFBZ0UsUUFBUSxtREFBbUQsbURBQW1ELGdGQUFnRixtQ0FBbUMsV0FBVyxNQUFNLDhEQUE4RCxzRUFBc0U7QUFDdmMsbURBQW1ELGNBQWMsZ0JBQWdCLGdDQUFnQyxvQkFBb0IsZ0JBQWdCLEtBQUssZ0JBQWdCLG1CQUFtQixPQUFPO0FBQ3BNLHVCQUF1QixRQUFRLG1EQUFtRCxzQkFBc0IsMENBQTBDLHdDQUF3QyxFQUFFLGdCQUFnQixlQUFlLGtEQUFrRCxJQUFJLG1CQUFtQixLQUFLLFdBQVcsU0FBUyxTQUFTLGdCQUFnQiwrQ0FBK0MsY0FBYyxvQkFBb0IsWUFBWSxhQUFhLDJCQUEyQjtBQUMzZCxjQUFjLGVBQWUsZ0JBQWdCLGFBQWEseUJBQXlCLGNBQWMsOEJBQThCLElBQUksaUJBQWlCLCtCQUErQixpQkFBaUIsNkJBQTZCLGtCQUFrQiwwREFBMEQsS0FBSyxLQUFLLG1GQUFtRixTQUFTLFNBQVMsU0FBUyxjQUFjO0FBQ25iLGlCQUFpQjtBQUNqQixnQkFBZ0IsMEJBQTBCLHVEQUF1RCwrQkFBK0Isc0RBQXNELDRDQUE0QyxNQUFNLFdBQVcsUUFBUSxnQkFBZ0IsZ0JBQWdCLGFBQWEsS0FBSyxvRUFBb0UsZ0JBQWdCLGNBQWMsa0JBQWtCLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGtCQUFrQixpQkFBaUI7QUFDdGYsRUFBRSxJQUFJLDZCQUE2QixRQUFRLE1BQU0sV0FBVyxtQkFBbUIsaUJBQWlCLEtBQUssbUJBQW1CLG9DQUFvQyxpQkFBaUIsU0FBUztBQUN0TCxpQkFBaUIsd0NBQXdDLDJCQUEyQixrREFBa0QsK0NBQStDLGtCQUFrQiw0RUFBNEUsaUJBQWlCLFVBQVUsaUJBQWlCLHNCQUFzQixTQUFTLGFBQWEsTUFBTSxFQUFFLGVBQWUsNEJBQTRCLFNBQVMsVUFBVSxlQUFlLG1CQUFtQixRQUFRLFVBQVUsRUFBRTtBQUN2ZSxTQUFTLGtDQUFrQywyQkFBMkIsT0FBTyxhQUFhLGVBQWUsc0JBQXNCLGFBQWEsV0FBVyxXQUFXLG1CQUFtQixpQkFBaUIscUJBQXFCLGtCQUFrQixzREFBc0QsSUFBSSwwQkFBMEIsNEJBQTRCLGlCQUFpQixzREFBc0QsSUFBSSwwQkFBMEI7QUFDbGMsa0JBQWtCLHNEQUFzRCxJQUFJLDBCQUEwQiw0QkFBNEIsZUFBZSxnQ0FBZ0MsSUFBSSxpQ0FBaUMsb0JBQW9CLGdCQUFnQixXQUFXLE1BQU0sZ0NBQWdDLElBQUksb0RBQW9ELG9CQUFvQiw2Q0FBNkMsK0JBQStCLCtCQUErQixvQ0FBb0MsY0FBYyxhQUFhLGdCQUFnQix1QkFBdUIsZ0JBQWdCLFlBQVksYUFBYSxhQUFhLGVBQWUsaUNBQWlDLHFDQUFxQyx3Q0FBd0MsNENBQTRDLHFDQUFxQztBQUM1MEIsMkNBQTJDLGdDQUFnQyw4Q0FBOEMsaUNBQWlDLG9DQUFvQyxpQ0FBaUMsZ0NBQWdDLG1DQUFtQyxrQ0FBa0Msa0NBQWtDLG9DQUFvQywwQ0FBMEMsa0NBQWtDLGVBQWU7QUFDcmUseUVBQXlFLGVBQWUsMkRBQTJELGFBQWEsaUNBQWlDLGlDQUFpQyx3QkFBd0IscUJBQXFCLDZIQUE2SCxxREFBcUQsbUNBQW1DLHdCQUF3QixvQkFBb0I7O0FBRTlXO0FBQ2xLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlibGUtcXVpei8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvd2ViY2hhbm5lbC13cmFwcGVyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MzJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGVzbSA9IHt9O1xuXG4vKlxuXG4gQ29weXJpZ2h0IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy5cbiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cblxudmFyIGssZ29vZz1nb29nfHx7fSxsPWNvbW1vbmpzR2xvYmFsfHxzZWxmO2Z1bmN0aW9uIGFhKGEpe3ZhciBiPXR5cGVvZiBhO2I9XCJvYmplY3RcIiE9Yj9iOmE/QXJyYXkuaXNBcnJheShhKT9cImFycmF5XCI6YjpcIm51bGxcIjtyZXR1cm4gXCJhcnJheVwiPT1ifHxcIm9iamVjdFwiPT1iJiZcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGh9ZnVuY3Rpb24gcChhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm4gXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGJhKGEpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjYSkmJmFbY2FdfHwoYVtjYV09KytkYSl9dmFyIGNhPVwiY2xvc3VyZV91aWRfXCIrKDFFOSpNYXRoLnJhbmRvbSgpPj4+MCksZGE9MDtmdW5jdGlvbiBlYShhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIGZhKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoZSxkKTtyZXR1cm4gYS5hcHBseShiLGUpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHEoYSxiLGMpe0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/cT1lYTpxPWZhO3JldHVybiBxLmFwcGx5KG51bGwsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIGhhKGEsYil7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBmdW5jdGlvbigpe3ZhciBkPWMuc2xpY2UoKTtkLnB1c2guYXBwbHkoZCxhcmd1bWVudHMpO3JldHVybiBhLmFwcGx5KHRoaXMsZCl9fWZ1bmN0aW9uIHIoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuJD1iLnByb3RvdHlwZTthLnByb3RvdHlwZT1uZXcgYzthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuYWM9ZnVuY3Rpb24oZCxlLGYpe2Zvcih2YXIgaD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLG49MjtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWhbbi0yXT1hcmd1bWVudHNbbl07cmV0dXJuIGIucHJvdG90eXBlW2VdLmFwcGx5KGQsaCl9O31mdW5jdGlvbiB2KCl7dGhpcy5zPXRoaXMuczt0aGlzLm89dGhpcy5vO312YXIgaWE9MDt2LnByb3RvdHlwZS5zPSExO3YucHJvdG90eXBlLnNhPWZ1bmN0aW9uKCl7aWYoIXRoaXMucyYmKHRoaXMucz0hMCx0aGlzLk4oKSwwIT1pYSkpe2JhKHRoaXMpO319O3YucHJvdG90eXBlLk49ZnVuY3Rpb24oKXtpZih0aGlzLm8pZm9yKDt0aGlzLm8ubGVuZ3RoOyl0aGlzLm8uc2hpZnQoKSgpO307Y29uc3Qga2E9QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhLGIsdm9pZCAwKX06ZnVuY3Rpb24oYSxiKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIFwic3RyaW5nXCIhPT10eXBlb2YgYnx8MSE9Yi5sZW5ndGg/LTE6YS5pbmRleE9mKGIsMCk7Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4gLTF9O2Z1bmN0aW9uIG1hKGEpe2NvbnN0IGI9YS5sZW5ndGg7aWYoMDxiKXtjb25zdCBjPUFycmF5KGIpO2ZvcihsZXQgZD0wO2Q8YjtkKyspY1tkXT1hW2RdO3JldHVybiBjfXJldHVybiBbXX1cbmZ1bmN0aW9uIG5hKGEsYil7Zm9yKGxldCBjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyl7Y29uc3QgZD1hcmd1bWVudHNbY107aWYoYWEoZCkpe2NvbnN0IGU9YS5sZW5ndGh8fDAsZj1kLmxlbmd0aHx8MDthLmxlbmd0aD1lK2Y7Zm9yKGxldCBoPTA7aDxmO2grKylhW2UraF09ZFtoXTt9ZWxzZSBhLnB1c2goZCk7fX1mdW5jdGlvbiB3KGEsYil7dGhpcy50eXBlPWE7dGhpcy5nPXRoaXMudGFyZ2V0PWI7dGhpcy5kZWZhdWx0UHJldmVudGVkPSExO313LnByb3RvdHlwZS5oPWZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO307dmFyIG9hPWZ1bmN0aW9uKCl7aWYoIWwuYWRkRXZlbnRMaXN0ZW5lcnx8IU9iamVjdC5kZWZpbmVQcm9wZXJ0eSlyZXR1cm4gITE7dmFyIGE9ITEsYj1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe2E9ITA7fX0pO3RyeXtjb25zdCBjPSgpPT57fTtsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsYyxiKTtsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsYyxiKTt9Y2F0Y2goYyl7fXJldHVybiBhfSgpO2Z1bmN0aW9uIHgoYSl7cmV0dXJuIC9eW1xcc1xceGEwXSokLy50ZXN0KGEpfWZ1bmN0aW9uIHBhKCl7dmFyIGE9bC5uYXZpZ2F0b3I7cmV0dXJuIGEmJihhPWEudXNlckFnZW50KT9hOlwiXCJ9ZnVuY3Rpb24geShhKXtyZXR1cm4gLTEhPXBhKCkuaW5kZXhPZihhKX1mdW5jdGlvbiBxYShhKXtxYVtcIiBcIl0oYSk7cmV0dXJuIGF9cWFbXCIgXCJdPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiByYShhLGIpe3ZhciBjPXNhO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYyxhKT9jW2FdOmNbYV09YihhKX12YXIgdGE9eShcIk9wZXJhXCIpLHo9eShcIlRyaWRlbnRcIil8fHkoXCJNU0lFXCIpLHVhPXkoXCJFZGdlXCIpLHZhPXVhfHx6LHdhPXkoXCJHZWNrb1wiKSYmISgtMSE9cGEoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIikmJiF5KFwiRWRnZVwiKSkmJiEoeShcIlRyaWRlbnRcIil8fHkoXCJNU0lFXCIpKSYmIXkoXCJFZGdlXCIpLHhhPS0xIT1wYSgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIXkoXCJFZGdlXCIpO2Z1bmN0aW9uIHlhKCl7dmFyIGE9bC5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9dmFyIHphO1xuYTp7dmFyIEFhPVwiXCIsQmE9ZnVuY3Rpb24oKXt2YXIgYT1wYSgpO2lmKHdhKXJldHVybiAvcnY6KFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYodWEpcmV0dXJuIC9FZGdlXFwvKFtcXGRcXC5dKykvLmV4ZWMoYSk7aWYoeilyZXR1cm4gL1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKHhhKXJldHVybiAvV2ViS2l0XFwvKFxcUyspLy5leGVjKGEpO2lmKHRhKXJldHVybiAvKD86VmVyc2lvbilbIFxcL10/KFxcUyspLy5leGVjKGEpfSgpO0JhJiYoQWE9QmE/QmFbMV06XCJcIik7aWYoeil7dmFyIENhPXlhKCk7aWYobnVsbCE9Q2EmJkNhPnBhcnNlRmxvYXQoQWEpKXt6YT1TdHJpbmcoQ2EpO2JyZWFrIGF9fXphPUFhO312YXIgRGE7aWYobC5kb2N1bWVudCYmeil7dmFyIEVhPXlhKCk7RGE9RWE/RWE6cGFyc2VJbnQoemEsMTApfHx2b2lkIDA7fWVsc2UgRGE9dm9pZCAwO3ZhciBGYT1EYTtmdW5jdGlvbiBBKGEsYil7dy5jYWxsKHRoaXMsYT9hLnR5cGU6XCJcIik7dGhpcy5yZWxhdGVkVGFyZ2V0PXRoaXMuZz10aGlzLnRhcmdldD1udWxsO3RoaXMuYnV0dG9uPXRoaXMuc2NyZWVuWT10aGlzLnNjcmVlblg9dGhpcy5jbGllbnRZPXRoaXMuY2xpZW50WD0wO3RoaXMua2V5PVwiXCI7dGhpcy5tZXRhS2V5PXRoaXMuc2hpZnRLZXk9dGhpcy5hbHRLZXk9dGhpcy5jdHJsS2V5PSExO3RoaXMuc3RhdGU9bnVsbDt0aGlzLnBvaW50ZXJJZD0wO3RoaXMucG9pbnRlclR5cGU9XCJcIjt0aGlzLmk9bnVsbDtpZihhKXt2YXIgYz10aGlzLnR5cGU9YS50eXBlLGQ9YS5jaGFuZ2VkVG91Y2hlcyYmYS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg/YS5jaGFuZ2VkVG91Y2hlc1swXTpudWxsO3RoaXMudGFyZ2V0PWEudGFyZ2V0fHxhLnNyY0VsZW1lbnQ7dGhpcy5nPWI7aWYoYj1hLnJlbGF0ZWRUYXJnZXQpe2lmKHdhKXthOnt0cnl7cWEoYi5ub2RlTmFtZSk7dmFyIGU9ITA7YnJlYWsgYX1jYXRjaChmKXt9ZT1cbiExO31lfHwoYj1udWxsKTt9fWVsc2UgXCJtb3VzZW92ZXJcIj09Yz9iPWEuZnJvbUVsZW1lbnQ6XCJtb3VzZW91dFwiPT1jJiYoYj1hLnRvRWxlbWVudCk7dGhpcy5yZWxhdGVkVGFyZ2V0PWI7ZD8odGhpcy5jbGllbnRYPXZvaWQgMCE9PWQuY2xpZW50WD9kLmNsaWVudFg6ZC5wYWdlWCx0aGlzLmNsaWVudFk9dm9pZCAwIT09ZC5jbGllbnRZP2QuY2xpZW50WTpkLnBhZ2VZLHRoaXMuc2NyZWVuWD1kLnNjcmVlblh8fDAsdGhpcy5zY3JlZW5ZPWQuc2NyZWVuWXx8MCk6KHRoaXMuY2xpZW50WD12b2lkIDAhPT1hLmNsaWVudFg/YS5jbGllbnRYOmEucGFnZVgsdGhpcy5jbGllbnRZPXZvaWQgMCE9PWEuY2xpZW50WT9hLmNsaWVudFk6YS5wYWdlWSx0aGlzLnNjcmVlblg9YS5zY3JlZW5YfHwwLHRoaXMuc2NyZWVuWT1hLnNjcmVlbll8fDApO3RoaXMuYnV0dG9uPWEuYnV0dG9uO3RoaXMua2V5PWEua2V5fHxcIlwiO3RoaXMuY3RybEtleT1hLmN0cmxLZXk7dGhpcy5hbHRLZXk9YS5hbHRLZXk7dGhpcy5zaGlmdEtleT1cbmEuc2hpZnRLZXk7dGhpcy5tZXRhS2V5PWEubWV0YUtleTt0aGlzLnBvaW50ZXJJZD1hLnBvaW50ZXJJZHx8MDt0aGlzLnBvaW50ZXJUeXBlPVwic3RyaW5nXCI9PT10eXBlb2YgYS5wb2ludGVyVHlwZT9hLnBvaW50ZXJUeXBlOkdhW2EucG9pbnRlclR5cGVdfHxcIlwiO3RoaXMuc3RhdGU9YS5zdGF0ZTt0aGlzLmk9YTthLmRlZmF1bHRQcmV2ZW50ZWQmJkEuJC5oLmNhbGwodGhpcyk7fX1yKEEsdyk7dmFyIEdhPXsyOlwidG91Y2hcIiwzOlwicGVuXCIsNDpcIm1vdXNlXCJ9O0EucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtBLiQuaC5jYWxsKHRoaXMpO3ZhciBhPXRoaXMuaTthLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExO307dmFyIEhhPVwiY2xvc3VyZV9saXN0ZW5hYmxlX1wiKygxRTYqTWF0aC5yYW5kb20oKXwwKTt2YXIgSWE9MDtmdW5jdGlvbiBKYShhLGIsYyxkLGUpe3RoaXMubGlzdGVuZXI9YTt0aGlzLnByb3h5PW51bGw7dGhpcy5zcmM9Yjt0aGlzLnR5cGU9Yzt0aGlzLmNhcHR1cmU9ISFkO3RoaXMubGE9ZTt0aGlzLmtleT0rK0lhO3RoaXMuZmE9dGhpcy5pYT0hMTt9ZnVuY3Rpb24gTWEoYSl7YS5mYT0hMDthLmxpc3RlbmVyPW51bGw7YS5wcm94eT1udWxsO2Euc3JjPW51bGw7YS5sYT1udWxsO31mdW5jdGlvbiBOYShhLGIsYyl7Zm9yKGNvbnN0IGQgaW4gYSliLmNhbGwoYyxhW2RdLGQsYSk7fWZ1bmN0aW9uIE9hKGEsYil7Zm9yKGNvbnN0IGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKTt9ZnVuY3Rpb24gUGEoYSl7Y29uc3QgYj17fTtmb3IoY29uc3QgYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn1jb25zdCBRYT1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtmdW5jdGlvbiBSYShhLGIpe2xldCBjLGQ7Zm9yKGxldCBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKGxldCBmPTA7ZjxRYS5sZW5ndGg7ZisrKWM9UWFbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pO319ZnVuY3Rpb24gU2EoYSl7dGhpcy5zcmM9YTt0aGlzLmc9e307dGhpcy5oPTA7fVNhLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLnRvU3RyaW5nKCk7YT10aGlzLmdbZl07YXx8KGE9dGhpcy5nW2ZdPVtdLHRoaXMuaCsrKTt2YXIgaD1UYShhLGIsZCxlKTstMTxoPyhiPWFbaF0sY3x8KGIuaWE9ITEpKTooYj1uZXcgSmEoYix0aGlzLnNyYyxmLCEhZCxlKSxiLmlhPWMsYS5wdXNoKGIpKTtyZXR1cm4gYn07ZnVuY3Rpb24gVWEoYSxiKXt2YXIgYz1iLnR5cGU7aWYoYyBpbiBhLmcpe3ZhciBkPWEuZ1tjXSxlPWthKGQsYiksZjsoZj0wPD1lKSYmQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGQsZSwxKTtmJiYoTWEoYiksMD09YS5nW2NdLmxlbmd0aCYmKGRlbGV0ZSBhLmdbY10sYS5oLS0pKTt9fVxuZnVuY3Rpb24gVGEoYSxiLGMsZCl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoIWYuZmEmJmYubGlzdGVuZXI9PWImJmYuY2FwdHVyZT09ISFjJiZmLmxhPT1kKXJldHVybiBlfXJldHVybiAtMX12YXIgVmE9XCJjbG9zdXJlX2xtX1wiKygxRTYqTWF0aC5yYW5kb20oKXwwKSxXYT17fTtmdW5jdGlvbiBZYShhLGIsYyxkLGUpe2lmKGQmJmQub25jZSlyZXR1cm4gWmEoYSxiLGMsZCxlKTtpZihBcnJheS5pc0FycmF5KGIpKXtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKylZYShhLGJbZl0sYyxkLGUpO3JldHVybiBudWxsfWM9JGEoYyk7cmV0dXJuIGEmJmFbSGFdP2EuTyhiLGMscChkKT8hIWQuY2FwdHVyZTohIWQsZSk6YWIoYSxiLGMsITEsZCxlKX1cbmZ1bmN0aW9uIGFiKGEsYixjLGQsZSxmKXtpZighYil0aHJvdyBFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTt2YXIgaD1wKGUpPyEhZS5jYXB0dXJlOiEhZSxuPWJiKGEpO258fChhW1ZhXT1uPW5ldyBTYShhKSk7Yz1uLmFkZChiLGMsZCxoLGYpO2lmKGMucHJveHkpcmV0dXJuIGM7ZD1jYigpO2MucHJveHk9ZDtkLnNyYz1hO2QubGlzdGVuZXI9YztpZihhLmFkZEV2ZW50TGlzdGVuZXIpb2F8fChlPWgpLHZvaWQgMD09PWUmJihlPSExKSxhLmFkZEV2ZW50TGlzdGVuZXIoYi50b1N0cmluZygpLGQsZSk7ZWxzZSBpZihhLmF0dGFjaEV2ZW50KWEuYXR0YWNoRXZlbnQoZGIoYi50b1N0cmluZygpKSxkKTtlbHNlIGlmKGEuYWRkTGlzdGVuZXImJmEucmVtb3ZlTGlzdGVuZXIpYS5hZGRMaXN0ZW5lcihkKTtlbHNlIHRocm93IEVycm9yKFwiYWRkRXZlbnRMaXN0ZW5lciBhbmQgYXR0YWNoRXZlbnQgYXJlIHVuYXZhaWxhYmxlLlwiKTtyZXR1cm4gY31cbmZ1bmN0aW9uIGNiKCl7ZnVuY3Rpb24gYShjKXtyZXR1cm4gYi5jYWxsKGEuc3JjLGEubGlzdGVuZXIsYyl9Y29uc3QgYj1lYjtyZXR1cm4gYX1mdW5jdGlvbiBaYShhLGIsYyxkLGUpe2lmKEFycmF5LmlzQXJyYXkoYikpe2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKVphKGEsYltmXSxjLGQsZSk7cmV0dXJuIG51bGx9Yz0kYShjKTtyZXR1cm4gYSYmYVtIYV0/YS5QKGIsYyxwKGQpPyEhZC5jYXB0dXJlOiEhZCxlKTphYihhLGIsYywhMCxkLGUpfVxuZnVuY3Rpb24gZmIoYSxiLGMsZCxlKXtpZihBcnJheS5pc0FycmF5KGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKWZiKGEsYltmXSxjLGQsZSk7ZWxzZSAoZD1wKGQpPyEhZC5jYXB0dXJlOiEhZCxjPSRhKGMpLGEmJmFbSGFdKT8oYT1hLmksYj1TdHJpbmcoYikudG9TdHJpbmcoKSxiIGluIGEuZyYmKGY9YS5nW2JdLGM9VGEoZixjLGQsZSksLTE8YyYmKE1hKGZbY10pLEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChmLGMsMSksMD09Zi5sZW5ndGgmJihkZWxldGUgYS5nW2JdLGEuaC0tKSkpKTphJiYoYT1iYihhKSkmJihiPWEuZ1tiLnRvU3RyaW5nKCldLGE9LTEsYiYmKGE9VGEoYixjLGQsZSkpLChjPS0xPGE/YlthXTpudWxsKSYmZ2IoYykpO31cbmZ1bmN0aW9uIGdiKGEpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYSYmYSYmIWEuZmEpe3ZhciBiPWEuc3JjO2lmKGImJmJbSGFdKVVhKGIuaSxhKTtlbHNlIHt2YXIgYz1hLnR5cGUsZD1hLnByb3h5O2IucmVtb3ZlRXZlbnRMaXN0ZW5lcj9iLnJlbW92ZUV2ZW50TGlzdGVuZXIoYyxkLGEuY2FwdHVyZSk6Yi5kZXRhY2hFdmVudD9iLmRldGFjaEV2ZW50KGRiKGMpLGQpOmIuYWRkTGlzdGVuZXImJmIucmVtb3ZlTGlzdGVuZXImJmIucmVtb3ZlTGlzdGVuZXIoZCk7KGM9YmIoYikpPyhVYShjLGEpLDA9PWMuaCYmKGMuc3JjPW51bGwsYltWYV09bnVsbCkpOk1hKGEpO319fWZ1bmN0aW9uIGRiKGEpe3JldHVybiBhIGluIFdhP1dhW2FdOldhW2FdPVwib25cIithfWZ1bmN0aW9uIGViKGEsYil7aWYoYS5mYSlhPSEwO2Vsc2Uge2I9bmV3IEEoYix0aGlzKTt2YXIgYz1hLmxpc3RlbmVyLGQ9YS5sYXx8YS5zcmM7YS5pYSYmZ2IoYSk7YT1jLmNhbGwoZCxiKTt9cmV0dXJuIGF9XG5mdW5jdGlvbiBiYihhKXthPWFbVmFdO3JldHVybiBhIGluc3RhbmNlb2YgU2E/YTpudWxsfXZhciBoYj1cIl9fY2xvc3VyZV9ldmVudHNfZm5fXCIrKDFFOSpNYXRoLnJhbmRvbSgpPj4+MCk7ZnVuY3Rpb24gJGEoYSl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGE7YVtoYl18fChhW2hiXT1mdW5jdGlvbihiKXtyZXR1cm4gYS5oYW5kbGVFdmVudChiKX0pO3JldHVybiBhW2hiXX1mdW5jdGlvbiBCKCl7di5jYWxsKHRoaXMpO3RoaXMuaT1uZXcgU2EodGhpcyk7dGhpcy5TPXRoaXM7dGhpcy5KPW51bGw7fXIoQix2KTtCLnByb3RvdHlwZVtIYV09ITA7Qi5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyxkKXtmYih0aGlzLGEsYixjLGQpO307XG5mdW5jdGlvbiBDKGEsYil7dmFyIGMsZD1hLko7aWYoZClmb3IoYz1bXTtkO2Q9ZC5KKWMucHVzaChkKTthPWEuUztkPWIudHlwZXx8YjtpZihcInN0cmluZ1wiPT09dHlwZW9mIGIpYj1uZXcgdyhiLGEpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIHcpYi50YXJnZXQ9Yi50YXJnZXR8fGE7ZWxzZSB7dmFyIGU9YjtiPW5ldyB3KGQsYSk7UmEoYixlKTt9ZT0hMDtpZihjKWZvcih2YXIgZj1jLmxlbmd0aC0xOzA8PWY7Zi0tKXt2YXIgaD1iLmc9Y1tmXTtlPWliKGgsZCwhMCxiKSYmZTt9aD1iLmc9YTtlPWliKGgsZCwhMCxiKSYmZTtlPWliKGgsZCwhMSxiKSYmZTtpZihjKWZvcihmPTA7ZjxjLmxlbmd0aDtmKyspaD1iLmc9Y1tmXSxlPWliKGgsZCwhMSxiKSYmZTt9XG5CLnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7Qi4kLk4uY2FsbCh0aGlzKTtpZih0aGlzLmkpe3ZhciBhPXRoaXMuaSxjO2ZvcihjIGluIGEuZyl7Zm9yKHZhciBkPWEuZ1tjXSxlPTA7ZTxkLmxlbmd0aDtlKyspTWEoZFtlXSk7ZGVsZXRlIGEuZ1tjXTthLmgtLTt9fXRoaXMuSj1udWxsO307Qi5wcm90b3R5cGUuTz1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5pLmFkZChTdHJpbmcoYSksYiwhMSxjLGQpfTtCLnByb3RvdHlwZS5QPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLmkuYWRkKFN0cmluZyhhKSxiLCEwLGMsZCl9O1xuZnVuY3Rpb24gaWIoYSxiLGMsZCl7Yj1hLmkuZ1tTdHJpbmcoYildO2lmKCFiKXJldHVybiAhMDtiPWIuY29uY2F0KCk7Zm9yKHZhciBlPSEwLGY9MDtmPGIubGVuZ3RoOysrZil7dmFyIGg9YltmXTtpZihoJiYhaC5mYSYmaC5jYXB0dXJlPT1jKXt2YXIgbj1oLmxpc3RlbmVyLHQ9aC5sYXx8aC5zcmM7aC5pYSYmVWEoYS5pLGgpO2U9ITEhPT1uLmNhbGwodCxkKSYmZTt9fXJldHVybiBlJiYhZC5kZWZhdWx0UHJldmVudGVkfXZhciBqYj1sLkpTT04uc3RyaW5naWZ5O2NsYXNzIGtie2NvbnN0cnVjdG9yKGEsYil7dGhpcy5pPWE7dGhpcy5qPWI7dGhpcy5oPTA7dGhpcy5nPW51bGw7fWdldCgpe2xldCBhOzA8dGhpcy5oPyh0aGlzLmgtLSxhPXRoaXMuZyx0aGlzLmc9YS5uZXh0LGEubmV4dD1udWxsKTphPXRoaXMuaSgpO3JldHVybiBhfX1mdW5jdGlvbiBsYigpe3ZhciBhPW1iO2xldCBiPW51bGw7YS5nJiYoYj1hLmcsYS5nPWEuZy5uZXh0LGEuZ3x8KGEuaD1udWxsKSxiLm5leHQ9bnVsbCk7cmV0dXJuIGJ9Y2xhc3MgbmJ7Y29uc3RydWN0b3IoKXt0aGlzLmg9dGhpcy5nPW51bGw7fWFkZChhLGIpe2NvbnN0IGM9b2IuZ2V0KCk7Yy5zZXQoYSxiKTt0aGlzLmg/dGhpcy5oLm5leHQ9Yzp0aGlzLmc9Yzt0aGlzLmg9Yzt9fXZhciBvYj1uZXcga2IoKCk9Pm5ldyBwYixhPT5hLnJlc2V0KCkpO2NsYXNzIHBie2NvbnN0cnVjdG9yKCl7dGhpcy5uZXh0PXRoaXMuZz10aGlzLmg9bnVsbDt9c2V0KGEsYil7dGhpcy5oPWE7dGhpcy5nPWI7dGhpcy5uZXh0PW51bGw7fXJlc2V0KCl7dGhpcy5uZXh0PXRoaXMuZz10aGlzLmg9bnVsbDt9fWZ1bmN0aW9uIHFiKGEpe3ZhciBiPTE7YT1hLnNwbGl0KFwiOlwiKTtjb25zdCBjPVtdO2Zvcig7MDxiJiZhLmxlbmd0aDspYy5wdXNoKGEuc2hpZnQoKSksYi0tO2EubGVuZ3RoJiZjLnB1c2goYS5qb2luKFwiOlwiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gcmIoYSl7bC5zZXRUaW1lb3V0KCgpPT57dGhyb3cgYTt9LDApO31sZXQgc2IsdGI9ITEsbWI9bmV3IG5iLHZiPSgpPT57Y29uc3QgYT1sLlByb21pc2UucmVzb2x2ZSh2b2lkIDApO3NiPSgpPT57YS50aGVuKHViKTt9O307dmFyIHViPSgpPT57Zm9yKHZhciBhO2E9bGIoKTspe3RyeXthLmguY2FsbChhLmcpO31jYXRjaChjKXtyYihjKTt9dmFyIGI9b2I7Yi5qKGEpOzEwMD5iLmgmJihiLmgrKyxhLm5leHQ9Yi5nLGIuZz1hKTt9dGI9ITE7fTtmdW5jdGlvbiB3YihhLGIpe0IuY2FsbCh0aGlzKTt0aGlzLmg9YXx8MTt0aGlzLmc9Ynx8bDt0aGlzLmo9cSh0aGlzLnFiLHRoaXMpO3RoaXMubD1EYXRlLm5vdygpO31yKHdiLEIpO2s9d2IucHJvdG90eXBlO2suZ2E9ITE7ay5UPW51bGw7ay5xYj1mdW5jdGlvbigpe2lmKHRoaXMuZ2Epe3ZhciBhPURhdGUubm93KCktdGhpcy5sOzA8YSYmYTwuOCp0aGlzLmg/dGhpcy5UPXRoaXMuZy5zZXRUaW1lb3V0KHRoaXMuaix0aGlzLmgtYSk6KHRoaXMuVCYmKHRoaXMuZy5jbGVhclRpbWVvdXQodGhpcy5UKSx0aGlzLlQ9bnVsbCksQyh0aGlzLFwidGlja1wiKSx0aGlzLmdhJiYoeGIodGhpcyksdGhpcy5zdGFydCgpKSk7fX07ay5zdGFydD1mdW5jdGlvbigpe3RoaXMuZ2E9ITA7dGhpcy5UfHwodGhpcy5UPXRoaXMuZy5zZXRUaW1lb3V0KHRoaXMuaix0aGlzLmgpLHRoaXMubD1EYXRlLm5vdygpKTt9O1xuZnVuY3Rpb24geGIoYSl7YS5nYT0hMTthLlQmJihhLmcuY2xlYXJUaW1lb3V0KGEuVCksYS5UPW51bGwpO31rLk49ZnVuY3Rpb24oKXt3Yi4kLk4uY2FsbCh0aGlzKTt4Yih0aGlzKTtkZWxldGUgdGhpcy5nO307ZnVuY3Rpb24geWIoYSxiLGMpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKWMmJihhPXEoYSxjKSk7ZWxzZSBpZihhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmhhbmRsZUV2ZW50KWE9cShhLmhhbmRsZUV2ZW50LGEpO2Vsc2UgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpO3JldHVybiAyMTQ3NDgzNjQ3PE51bWJlcihiKT8tMTpsLnNldFRpbWVvdXQoYSxifHwwKX1mdW5jdGlvbiB6YihhKXthLmc9eWIoKCk9PnthLmc9bnVsbDthLmkmJihhLmk9ITEsemIoYSkpO30sYS5qKTtjb25zdCBiPWEuaDthLmg9bnVsbDthLm0uYXBwbHkobnVsbCxiKTt9Y2xhc3MgQWIgZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKGEsYil7c3VwZXIoKTt0aGlzLm09YTt0aGlzLmo9Yjt0aGlzLmg9bnVsbDt0aGlzLmk9ITE7dGhpcy5nPW51bGw7fWwoYSl7dGhpcy5oPWFyZ3VtZW50czt0aGlzLmc/dGhpcy5pPSEwOnpiKHRoaXMpO31OKCl7c3VwZXIuTigpO3RoaXMuZyYmKGwuY2xlYXJUaW1lb3V0KHRoaXMuZyksdGhpcy5nPW51bGwsdGhpcy5pPSExLHRoaXMuaD1udWxsKTt9fWZ1bmN0aW9uIEJiKGEpe3YuY2FsbCh0aGlzKTt0aGlzLmg9YTt0aGlzLmc9e307fXIoQmIsdik7dmFyIENiPVtdO2Z1bmN0aW9uIEViKGEsYixjLGQpe0FycmF5LmlzQXJyYXkoYyl8fChjJiYoQ2JbMF09Yy50b1N0cmluZygpKSxjPUNiKTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9WWEoYixjW2VdLGR8fGEuaGFuZGxlRXZlbnQsITEsYS5ofHxhKTtpZighZilicmVhazthLmdbZi5rZXldPWY7fX1mdW5jdGlvbiBGYihhKXtOYShhLmcsZnVuY3Rpb24oYixjKXt0aGlzLmcuaGFzT3duUHJvcGVydHkoYykmJmdiKGIpO30sYSk7YS5nPXt9O31CYi5wcm90b3R5cGUuTj1mdW5jdGlvbigpe0JiLiQuTi5jYWxsKHRoaXMpO0ZiKHRoaXMpO307QmIucHJvdG90eXBlLmhhbmRsZUV2ZW50PWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJFdmVudEhhbmRsZXIuaGFuZGxlRXZlbnQgbm90IGltcGxlbWVudGVkXCIpO307ZnVuY3Rpb24gR2IoKXt0aGlzLmc9ITA7fUdiLnByb3RvdHlwZS5FYT1mdW5jdGlvbigpe3RoaXMuZz0hMTt9O2Z1bmN0aW9uIEhiKGEsYixjLGQsZSxmKXthLmluZm8oZnVuY3Rpb24oKXtpZihhLmcpaWYoZil7dmFyIGg9XCJcIjtmb3IodmFyIG49Zi5zcGxpdChcIiZcIiksdD0wO3Q8bi5sZW5ndGg7dCsrKXt2YXIgbT1uW3RdLnNwbGl0KFwiPVwiKTtpZigxPG0ubGVuZ3RoKXt2YXIgdT1tWzBdO209bVsxXTt2YXIgTD11LnNwbGl0KFwiX1wiKTtoPTI8PUwubGVuZ3RoJiZcInR5cGVcIj09TFsxXT9oKyh1K1wiPVwiK20rXCImXCIpOmgrKHUrXCI9cmVkYWN0ZWQmXCIpO319fWVsc2UgaD1udWxsO2Vsc2UgaD1mO3JldHVybiBcIlhNTEhUVFAgUkVRIChcIitkK1wiKSBbYXR0ZW1wdCBcIitlK1wiXTogXCIrYitcIlxcblwiK2MrXCJcXG5cIitofSk7fVxuZnVuY3Rpb24gSWIoYSxiLGMsZCxlLGYsaCl7YS5pbmZvKGZ1bmN0aW9uKCl7cmV0dXJuIFwiWE1MSFRUUCBSRVNQIChcIitkK1wiKSBbIGF0dGVtcHQgXCIrZStcIl06IFwiK2IrXCJcXG5cIitjK1wiXFxuXCIrZitcIiBcIitofSk7fWZ1bmN0aW9uIEQoYSxiLGMsZCl7YS5pbmZvKGZ1bmN0aW9uKCl7cmV0dXJuIFwiWE1MSFRUUCBURVhUIChcIitiK1wiKTogXCIrSmIoYSxjKSsoZD9cIiBcIitkOlwiXCIpfSk7fWZ1bmN0aW9uIEtiKGEsYil7YS5pbmZvKGZ1bmN0aW9uKCl7cmV0dXJuIFwiVElNRU9VVDogXCIrYn0pO31HYi5wcm90b3R5cGUuaW5mbz1mdW5jdGlvbigpe307XG5mdW5jdGlvbiBKYihhLGIpe2lmKCFhLmcpcmV0dXJuIGI7aWYoIWIpcmV0dXJuIG51bGw7dHJ5e3ZhciBjPUpTT04ucGFyc2UoYik7aWYoYylmb3IoYT0wO2E8Yy5sZW5ndGg7YSsrKWlmKEFycmF5LmlzQXJyYXkoY1thXSkpe3ZhciBkPWNbYV07aWYoISgyPmQubGVuZ3RoKSl7dmFyIGU9ZFsxXTtpZihBcnJheS5pc0FycmF5KGUpJiYhKDE+ZS5sZW5ndGgpKXt2YXIgZj1lWzBdO2lmKFwibm9vcFwiIT1mJiZcInN0b3BcIiE9ZiYmXCJjbG9zZVwiIT1mKWZvcih2YXIgaD0xO2g8ZS5sZW5ndGg7aCsrKWVbaF09XCJcIjt9fX1yZXR1cm4gamIoYyl9Y2F0Y2gobil7cmV0dXJuIGJ9fXZhciBFPXt9LExiPW51bGw7ZnVuY3Rpb24gTWIoKXtyZXR1cm4gTGI9TGJ8fG5ldyBCfUUuVGE9XCJzZXJ2ZXJyZWFjaGFiaWxpdHlcIjtmdW5jdGlvbiBOYihhKXt3LmNhbGwodGhpcyxFLlRhLGEpO31yKE5iLHcpO2Z1bmN0aW9uIE9iKGEpe2NvbnN0IGI9TWIoKTtDKGIsbmV3IE5iKGIpKTt9RS5TVEFUX0VWRU5UPVwic3RhdGV2ZW50XCI7ZnVuY3Rpb24gUGIoYSxiKXt3LmNhbGwodGhpcyxFLlNUQVRfRVZFTlQsYSk7dGhpcy5zdGF0PWI7fXIoUGIsdyk7ZnVuY3Rpb24gRihhKXtjb25zdCBiPU1iKCk7QyhiLG5ldyBQYihiLGEpKTt9RS5VYT1cInRpbWluZ2V2ZW50XCI7ZnVuY3Rpb24gUWIoYSxiKXt3LmNhbGwodGhpcyxFLlVhLGEpO3RoaXMuc2l6ZT1iO31yKFFiLHcpO1xuZnVuY3Rpb24gUmIoYSxiKXtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcihcIkZuIG11c3Qgbm90IGJlIG51bGwgYW5kIG11c3QgYmUgYSBmdW5jdGlvblwiKTtyZXR1cm4gbC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSgpO30sYil9dmFyIFNiPXtOT19FUlJPUjowLHJiOjEsRWI6MixEYjozLHliOjQsQ2I6NSxGYjo2LFFhOjcsVElNRU9VVDo4LEliOjl9O3ZhciBUYj17d2I6XCJjb21wbGV0ZVwiLFNiOlwic3VjY2Vzc1wiLFJhOlwiZXJyb3JcIixRYTpcImFib3J0XCIsS2I6XCJyZWFkeVwiLExiOlwicmVhZHlzdGF0ZWNoYW5nZVwiLFRJTUVPVVQ6XCJ0aW1lb3V0XCIsR2I6XCJpbmNyZW1lbnRhbGRhdGFcIixKYjpcInByb2dyZXNzXCIsemI6XCJkb3dubG9hZHByb2dyZXNzXCIsJGI6XCJ1cGxvYWRwcm9ncmVzc1wifTtmdW5jdGlvbiBVYigpe31VYi5wcm90b3R5cGUuaD1udWxsO2Z1bmN0aW9uIFZiKGEpe3JldHVybiBhLmh8fChhLmg9YS5pKCkpfWZ1bmN0aW9uIFdiKCl7fXZhciBYYj17T1BFTjpcImFcIix2YjpcImJcIixSYTpcImNcIixIYjpcImRcIn07ZnVuY3Rpb24gWWIoKXt3LmNhbGwodGhpcyxcImRcIik7fXIoWWIsdyk7ZnVuY3Rpb24gWmIoKXt3LmNhbGwodGhpcyxcImNcIik7fXIoWmIsdyk7dmFyICRiO2Z1bmN0aW9uIGFjKCl7fXIoYWMsVWIpO2FjLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdH07YWMucHJvdG90eXBlLmk9ZnVuY3Rpb24oKXtyZXR1cm4ge319OyRiPW5ldyBhYztmdW5jdGlvbiBiYyhhLGIsYyxkKXt0aGlzLmw9YTt0aGlzLmo9Yjt0aGlzLm09Yzt0aGlzLlc9ZHx8MTt0aGlzLlU9bmV3IEJiKHRoaXMpO3RoaXMuUD1jYzthPXZhPzEyNTp2b2lkIDA7dGhpcy5WPW5ldyB3YihhKTt0aGlzLkk9bnVsbDt0aGlzLmk9ITE7dGhpcy51PXRoaXMuQj10aGlzLkE9dGhpcy5MPXRoaXMuRz10aGlzLlk9dGhpcy5DPW51bGw7dGhpcy5GPVtdO3RoaXMuZz1udWxsO3RoaXMubz0wO3RoaXMucz10aGlzLnY9bnVsbDt0aGlzLmNhPS0xO3RoaXMuSj0hMTt0aGlzLk89MDt0aGlzLk09bnVsbDt0aGlzLmJhPXRoaXMuSz10aGlzLmFhPXRoaXMuUz0hMTt0aGlzLmg9bmV3IGRjO31mdW5jdGlvbiBkYygpe3RoaXMuaT1udWxsO3RoaXMuZz1cIlwiO3RoaXMuaD0hMTt9dmFyIGNjPTQ1RTMsZWM9e30sZmM9e307az1iYy5wcm90b3R5cGU7ay5zZXRUaW1lb3V0PWZ1bmN0aW9uKGEpe3RoaXMuUD1hO307XG5mdW5jdGlvbiBnYyhhLGIsYyl7YS5MPTE7YS5BPWhjKEcoYikpO2EudT1jO2EuUz0hMDtpYyhhLG51bGwpO31mdW5jdGlvbiBpYyhhLGIpe2EuRz1EYXRlLm5vdygpO2pjKGEpO2EuQj1HKGEuQSk7dmFyIGM9YS5CLGQ9YS5XO0FycmF5LmlzQXJyYXkoZCl8fChkPVtTdHJpbmcoZCldKTtrYyhjLmksXCJ0XCIsZCk7YS5vPTA7Yz1hLmwuSjthLmg9bmV3IGRjO2EuZz1sYyhhLmwsYz9iOm51bGwsIWEudSk7MDxhLk8mJihhLk09bmV3IEFiKHEoYS5QYSxhLGEuZyksYS5PKSk7RWIoYS5VLGEuZyxcInJlYWR5c3RhdGVjaGFuZ2VcIixhLm5iKTtiPWEuST9QYShhLkkpOnt9O2EudT8oYS52fHwoYS52PVwiUE9TVFwiKSxiW1wiQ29udGVudC1UeXBlXCJdPVwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsYS5nLmhhKGEuQixhLnYsYS51LGIpKTooYS52PVwiR0VUXCIsYS5nLmhhKGEuQixhLnYsbnVsbCxiKSk7T2IoKTtIYihhLmosYS52LGEuQixhLm0sYS5XLGEudSk7fVxuay5uYj1mdW5jdGlvbihhKXthPWEudGFyZ2V0O2NvbnN0IGI9dGhpcy5NO2ImJjM9PUgoYSk/Yi5sKCk6dGhpcy5QYShhKTt9O1xuay5QYT1mdW5jdGlvbihhKXt0cnl7aWYoYT09dGhpcy5nKWE6e2NvbnN0IHU9SCh0aGlzLmcpO3ZhciBiPXRoaXMuZy5JYSgpO2NvbnN0IEw9dGhpcy5nLmRhKCk7aWYoISgzPnUpJiYoMyE9dXx8dmF8fHRoaXMuZyYmKHRoaXMuaC5ofHx0aGlzLmcuamEoKXx8bWModGhpcy5nKSkpKXt0aGlzLkp8fDQhPXV8fDc9PWJ8fCg4PT1ifHwwPj1MP09iKDMpOk9iKDIpKTtuYyh0aGlzKTt2YXIgYz10aGlzLmcuZGEoKTt0aGlzLmNhPWM7YjppZihvYyh0aGlzKSl7dmFyIGQ9bWModGhpcy5nKTthPVwiXCI7dmFyIGU9ZC5sZW5ndGgsZj00PT1IKHRoaXMuZyk7aWYoIXRoaXMuaC5pKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIFRleHREZWNvZGVyKXtJKHRoaXMpO3BjKHRoaXMpO3ZhciBoPVwiXCI7YnJlYWsgYn10aGlzLmguaT1uZXcgbC5UZXh0RGVjb2Rlcjt9Zm9yKGI9MDtiPGU7YisrKXRoaXMuaC5oPSEwLGErPXRoaXMuaC5pLmRlY29kZShkW2JdLHtzdHJlYW06ZiYmYj09ZS0xfSk7ZC5sZW5ndGg9XG4wO3RoaXMuaC5nKz1hO3RoaXMubz0wO2g9dGhpcy5oLmc7fWVsc2UgaD10aGlzLmcuamEoKTt0aGlzLmk9MjAwPT1jO0liKHRoaXMuaix0aGlzLnYsdGhpcy5CLHRoaXMubSx0aGlzLlcsdSxjKTtpZih0aGlzLmkpe2lmKHRoaXMuYWEmJiF0aGlzLkspe2I6e2lmKHRoaXMuZyl7dmFyIG4sdD10aGlzLmc7aWYoKG49dC5nP3QuZy5nZXRSZXNwb25zZUhlYWRlcihcIlgtSFRUUC1Jbml0aWFsLVJlc3BvbnNlXCIpOm51bGwpJiYheChuKSl7dmFyIG09bjticmVhayBifX1tPW51bGw7fWlmKGM9bSlEKHRoaXMuaix0aGlzLm0sYyxcIkluaXRpYWwgaGFuZHNoYWtlIHJlc3BvbnNlIHZpYSBYLUhUVFAtSW5pdGlhbC1SZXNwb25zZVwiKSx0aGlzLks9ITAscWModGhpcyxjKTtlbHNlIHt0aGlzLmk9ITE7dGhpcy5zPTM7RigxMik7SSh0aGlzKTtwYyh0aGlzKTticmVhayBhfX10aGlzLlM/KHJjKHRoaXMsdSxoKSx2YSYmdGhpcy5pJiYzPT11JiYoRWIodGhpcy5VLHRoaXMuVixcInRpY2tcIix0aGlzLm1iKSxcbnRoaXMuVi5zdGFydCgpKSk6KEQodGhpcy5qLHRoaXMubSxoLG51bGwpLHFjKHRoaXMsaCkpOzQ9PXUmJkkodGhpcyk7dGhpcy5pJiYhdGhpcy5KJiYoND09dT9zYyh0aGlzLmwsdGhpcyk6KHRoaXMuaT0hMSxqYyh0aGlzKSkpO31lbHNlIHRjKHRoaXMuZyksNDAwPT1jJiYwPGguaW5kZXhPZihcIlVua25vd24gU0lEXCIpPyh0aGlzLnM9MyxGKDEyKSk6KHRoaXMucz0wLEYoMTMpKSxJKHRoaXMpLHBjKHRoaXMpO319fWNhdGNoKHUpe31maW5hbGx5e319O2Z1bmN0aW9uIG9jKGEpe3JldHVybiBhLmc/XCJHRVRcIj09YS52JiYyIT1hLkwmJmEubC5IYTohMX1cbmZ1bmN0aW9uIHJjKGEsYixjKXtsZXQgZD0hMCxlO2Zvcig7IWEuSiYmYS5vPGMubGVuZ3RoOylpZihlPXVjKGEsYyksZT09ZmMpezQ9PWImJihhLnM9NCxGKDE0KSxkPSExKTtEKGEuaixhLm0sbnVsbCxcIltJbmNvbXBsZXRlIFJlc3BvbnNlXVwiKTticmVha31lbHNlIGlmKGU9PWVjKXthLnM9NDtGKDE1KTtEKGEuaixhLm0sYyxcIltJbnZhbGlkIENodW5rXVwiKTtkPSExO2JyZWFrfWVsc2UgRChhLmosYS5tLGUsbnVsbCkscWMoYSxlKTtvYyhhKSYmMCE9YS5vJiYoYS5oLmc9YS5oLmcuc2xpY2UoYS5vKSxhLm89MCk7NCE9Ynx8MCE9Yy5sZW5ndGh8fGEuaC5ofHwoYS5zPTEsRigxNiksZD0hMSk7YS5pPWEuaSYmZDtkPzA8Yy5sZW5ndGgmJiFhLmJhJiYoYS5iYT0hMCxiPWEubCxiLmc9PWEmJmIuY2EmJiFiLk0mJihiLmwuaW5mbyhcIkdyZWF0LCBubyBidWZmZXJpbmcgcHJveHkgZGV0ZWN0ZWQuIEJ5dGVzIHJlY2VpdmVkOiBcIitjLmxlbmd0aCksdmMoYiksYi5NPSEwLEYoMTEpKSk6KEQoYS5qLFxuYS5tLGMsXCJbSW52YWxpZCBDaHVua2VkIFJlc3BvbnNlXVwiKSxJKGEpLHBjKGEpKTt9ay5tYj1mdW5jdGlvbigpe2lmKHRoaXMuZyl7dmFyIGE9SCh0aGlzLmcpLGI9dGhpcy5nLmphKCk7dGhpcy5vPGIubGVuZ3RoJiYobmModGhpcykscmModGhpcyxhLGIpLHRoaXMuaSYmNCE9YSYmamModGhpcykpO319O2Z1bmN0aW9uIHVjKGEsYil7dmFyIGM9YS5vLGQ9Yi5pbmRleE9mKFwiXFxuXCIsYyk7aWYoLTE9PWQpcmV0dXJuIGZjO2M9TnVtYmVyKGIuc3Vic3RyaW5nKGMsZCkpO2lmKGlzTmFOKGMpKXJldHVybiBlYztkKz0xO2lmKGQrYz5iLmxlbmd0aClyZXR1cm4gZmM7Yj1iLnNsaWNlKGQsZCtjKTthLm89ZCtjO3JldHVybiBifWsuY2FuY2VsPWZ1bmN0aW9uKCl7dGhpcy5KPSEwO0kodGhpcyk7fTtmdW5jdGlvbiBqYyhhKXthLlk9RGF0ZS5ub3coKSthLlA7d2MoYSxhLlApO31cbmZ1bmN0aW9uIHdjKGEsYil7aWYobnVsbCE9YS5DKXRocm93IEVycm9yKFwiV2F0Y2hEb2cgdGltZXIgbm90IG51bGxcIik7YS5DPVJiKHEoYS5sYixhKSxiKTt9ZnVuY3Rpb24gbmMoYSl7YS5DJiYobC5jbGVhclRpbWVvdXQoYS5DKSxhLkM9bnVsbCk7fWsubGI9ZnVuY3Rpb24oKXt0aGlzLkM9bnVsbDtjb25zdCBhPURhdGUubm93KCk7MDw9YS10aGlzLlk/KEtiKHRoaXMuaix0aGlzLkIpLDIhPXRoaXMuTCYmKE9iKCksRigxNykpLEkodGhpcyksdGhpcy5zPTIscGModGhpcykpOndjKHRoaXMsdGhpcy5ZLWEpO307ZnVuY3Rpb24gcGMoYSl7MD09YS5sLkh8fGEuSnx8c2MoYS5sLGEpO31mdW5jdGlvbiBJKGEpe25jKGEpO3ZhciBiPWEuTTtiJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLnNhJiZiLnNhKCk7YS5NPW51bGw7eGIoYS5WKTtGYihhLlUpO2EuZyYmKGI9YS5nLGEuZz1udWxsLGIuYWJvcnQoKSxiLnNhKCkpO31cbmZ1bmN0aW9uIHFjKGEsYil7dHJ5e3ZhciBjPWEubDtpZigwIT1jLkgmJihjLmc9PWF8fHhjKGMuaSxhKSkpaWYoIWEuSyYmeGMoYy5pLGEpJiYzPT1jLkgpe3RyeXt2YXIgZD1jLkphLmcucGFyc2UoYik7fWNhdGNoKG0pe2Q9bnVsbDt9aWYoQXJyYXkuaXNBcnJheShkKSYmMz09ZC5sZW5ndGgpe3ZhciBlPWQ7aWYoMD09ZVswXSlhOntpZighYy51KXtpZihjLmcpaWYoYy5nLkcrM0UzPGEuRyl5YyhjKSx6YyhjKTtlbHNlIGJyZWFrIGE7QWMoYyk7RigxOCk7fX1lbHNlIGMuRmE9ZVsxXSwwPGMuRmEtYy5WJiYzNzUwMD5lWzJdJiZjLkcmJjA9PWMuQSYmIWMudiYmKGMudj1SYihxKGMuaWIsYyksNkUzKSk7aWYoMT49QmMoYy5pKSYmYy5vYSl7dHJ5e2Mub2EoKTt9Y2F0Y2gobSl7fWMub2E9dm9pZCAwO319ZWxzZSBKKGMsMTEpO31lbHNlIGlmKChhLkt8fGMuZz09YSkmJnljKGMpLCF4KGIpKWZvcihlPWMuSmEuZy5wYXJzZShiKSxiPTA7YjxlLmxlbmd0aDtiKyspe2xldCBtPWVbYl07Yy5WPVxubVswXTttPW1bMV07aWYoMj09Yy5IKWlmKFwiY1wiPT1tWzBdKXtjLks9bVsxXTtjLnBhPW1bMl07Y29uc3QgdT1tWzNdO251bGwhPXUmJihjLnJhPXUsYy5sLmluZm8oXCJWRVI9XCIrYy5yYSkpO2NvbnN0IEw9bVs0XTtudWxsIT1MJiYoYy5HYT1MLGMubC5pbmZvKFwiU1ZFUj1cIitjLkdhKSk7Y29uc3QgS2E9bVs1XTtudWxsIT1LYSYmXCJudW1iZXJcIj09PXR5cGVvZiBLYSYmMDxLYSYmKGQ9MS41KkthLGMuTD1kLGMubC5pbmZvKFwiYmFja0NoYW5uZWxSZXF1ZXN0VGltZW91dE1zXz1cIitkKSk7ZD1jO2NvbnN0IGxhPWEuZztpZihsYSl7Y29uc3QgTGE9bGEuZz9sYS5nLmdldFJlc3BvbnNlSGVhZGVyKFwiWC1DbGllbnQtV2lyZS1Qcm90b2NvbFwiKTpudWxsO2lmKExhKXt2YXIgZj1kLmk7Zi5nfHwtMT09TGEuaW5kZXhPZihcInNwZHlcIikmJi0xPT1MYS5pbmRleE9mKFwicXVpY1wiKSYmLTE9PUxhLmluZGV4T2YoXCJoMlwiKXx8KGYuaj1mLmwsZi5nPW5ldyBTZXQsZi5oJiYoQ2MoZixmLmgpLGYuaD1udWxsKSk7fWlmKGQuRil7Y29uc3QgRGI9XG5sYS5nP2xhLmcuZ2V0UmVzcG9uc2VIZWFkZXIoXCJYLUhUVFAtU2Vzc2lvbi1JZFwiKTpudWxsO0RiJiYoZC5EYT1EYixLKGQuSSxkLkYsRGIpKTt9fWMuSD0zO2MuaCYmYy5oLkJhKCk7Yy5jYSYmKGMuUz1EYXRlLm5vdygpLWEuRyxjLmwuaW5mbyhcIkhhbmRzaGFrZSBSVFQ6IFwiK2MuUytcIm1zXCIpKTtkPWM7dmFyIGg9YTtkLndhPURjKGQsZC5KP2QucGE6bnVsbCxkLlkpO2lmKGguSyl7RWMoZC5pLGgpO3ZhciBuPWgsdD1kLkw7dCYmbi5zZXRUaW1lb3V0KHQpO24uQyYmKG5jKG4pLGpjKG4pKTtkLmc9aDt9ZWxzZSBGYyhkKTswPGMuai5sZW5ndGgmJkdjKGMpO31lbHNlIFwic3RvcFwiIT1tWzBdJiZcImNsb3NlXCIhPW1bMF18fEooYyw3KTtlbHNlIDM9PWMuSCYmKFwic3RvcFwiPT1tWzBdfHxcImNsb3NlXCI9PW1bMF0/XCJzdG9wXCI9PW1bMF0/SihjLDcpOkhjKGMpOlwibm9vcFwiIT1tWzBdJiZjLmgmJmMuaC5BYShtKSxjLkE9MCk7fU9iKDQpO31jYXRjaChtKXt9fWZ1bmN0aW9uIEljKGEpe2lmKGEuWiYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5aKXJldHVybiBhLlooKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1hcCYmYSBpbnN0YW5jZW9mIE1hcHx8XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBTZXQmJmEgaW5zdGFuY2VvZiBTZXQpcmV0dXJuIEFycmF5LmZyb20oYS52YWx1ZXMoKSk7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVybiBhLnNwbGl0KFwiXCIpO2lmKGFhKGEpKXtmb3IodmFyIGI9W10sYz1hLmxlbmd0aCxkPTA7ZDxjO2QrKyliLnB1c2goYVtkXSk7cmV0dXJuIGJ9Yj1bXTtjPTA7Zm9yKGQgaW4gYSliW2MrK109YVtkXTtyZXR1cm4gYn1cbmZ1bmN0aW9uIEpjKGEpe2lmKGEudGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGEpcmV0dXJuIGEudGEoKTtpZighYS5afHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLlope2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgTWFwJiZhIGluc3RhbmNlb2YgTWFwKXJldHVybiBBcnJheS5mcm9tKGEua2V5cygpKTtpZighKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgU2V0JiZhIGluc3RhbmNlb2YgU2V0KSl7aWYoYWEoYSl8fFwic3RyaW5nXCI9PT10eXBlb2YgYSl7dmFyIGI9W107YT1hLmxlbmd0aDtmb3IodmFyIGM9MDtjPGE7YysrKWIucHVzaChjKTtyZXR1cm4gYn1iPVtdO2M9MDtmb3IoY29uc3QgZCBpbiBhKWJbYysrXT1kO3JldHVybiBifX19XG5mdW5jdGlvbiBLYyhhLGIpe2lmKGEuZm9yRWFjaCYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5mb3JFYWNoKWEuZm9yRWFjaChiLHZvaWQgMCk7ZWxzZSBpZihhYShhKXx8XCJzdHJpbmdcIj09PXR5cGVvZiBhKUFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxiLHZvaWQgMCk7ZWxzZSBmb3IodmFyIGM9SmMoYSksZD1JYyhhKSxlPWQubGVuZ3RoLGY9MDtmPGU7ZisrKWIuY2FsbCh2b2lkIDAsZFtmXSxjJiZjW2ZdLGEpO312YXIgTGM9UmVnRXhwKFwiXig/OihbXjovPyMuXSspOik/KD86Ly8oPzooW15cXFxcXFxcXC8/I10qKUApPyhbXlxcXFxcXFxcLz8jXSo/KSg/OjooWzAtOV0rKSk/KD89W1xcXFxcXFxcLz8jXXwkKSk/KFtePyNdKyk/KD86XFxcXD8oW14jXSopKT8oPzojKFtcXFxcc1xcXFxTXSopKT8kXCIpO2Z1bmN0aW9uIE1jKGEsYil7aWYoYSl7YT1hLnNwbGl0KFwiJlwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5pbmRleE9mKFwiPVwiKSxlPW51bGw7aWYoMDw9ZCl7dmFyIGY9YVtjXS5zdWJzdHJpbmcoMCxkKTtlPWFbY10uc3Vic3RyaW5nKGQrMSk7fWVsc2UgZj1hW2NdO2IoZixlP2RlY29kZVVSSUNvbXBvbmVudChlLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSk6XCJcIik7fX19ZnVuY3Rpb24gTShhKXt0aGlzLmc9dGhpcy5zPXRoaXMuaj1cIlwiO3RoaXMubT1udWxsO3RoaXMubz10aGlzLmw9XCJcIjt0aGlzLmg9ITE7aWYoYSBpbnN0YW5jZW9mIE0pe3RoaXMuaD1hLmg7TmModGhpcyxhLmopO3RoaXMucz1hLnM7dGhpcy5nPWEuZztPYyh0aGlzLGEubSk7dGhpcy5sPWEubDt2YXIgYj1hLmk7dmFyIGM9bmV3IFBjO2MuaT1iLmk7Yi5nJiYoYy5nPW5ldyBNYXAoYi5nKSxjLmg9Yi5oKTtRYyh0aGlzLGMpO3RoaXMubz1hLm87fWVsc2UgYSYmKGI9U3RyaW5nKGEpLm1hdGNoKExjKSk/KHRoaXMuaD0hMSxOYyh0aGlzLGJbMV18fFwiXCIsITApLHRoaXMucz1SYyhiWzJdfHxcIlwiKSx0aGlzLmc9UmMoYlszXXx8XCJcIiwhMCksT2ModGhpcyxiWzRdKSx0aGlzLmw9UmMoYls1XXx8XCJcIiwhMCksUWModGhpcyxiWzZdfHxcIlwiLCEwKSx0aGlzLm89UmMoYls3XXx8XCJcIikpOih0aGlzLmg9ITEsdGhpcy5pPW5ldyBQYyhudWxsLHRoaXMuaCkpO31cbk0ucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj10aGlzLmo7YiYmYS5wdXNoKFNjKGIsVGMsITApLFwiOlwiKTt2YXIgYz10aGlzLmc7aWYoY3x8XCJmaWxlXCI9PWIpYS5wdXNoKFwiLy9cIiksKGI9dGhpcy5zKSYmYS5wdXNoKFNjKGIsVGMsITApLFwiQFwiKSxhLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjKSkucmVwbGFjZSgvJTI1KFswLTlhLWZBLUZdezJ9KS9nLFwiJSQxXCIpKSxjPXRoaXMubSxudWxsIT1jJiZhLnB1c2goXCI6XCIsU3RyaW5nKGMpKTtpZihjPXRoaXMubCl0aGlzLmcmJlwiL1wiIT1jLmNoYXJBdCgwKSYmYS5wdXNoKFwiL1wiKSxhLnB1c2goU2MoYyxcIi9cIj09Yy5jaGFyQXQoMCk/VWM6VmMsITApKTsoYz10aGlzLmkudG9TdHJpbmcoKSkmJmEucHVzaChcIj9cIixjKTsoYz10aGlzLm8pJiZhLnB1c2goXCIjXCIsU2MoYyxXYykpO3JldHVybiBhLmpvaW4oXCJcIil9O2Z1bmN0aW9uIEcoYSl7cmV0dXJuIG5ldyBNKGEpfVxuZnVuY3Rpb24gTmMoYSxiLGMpe2Euaj1jP1JjKGIsITApOmI7YS5qJiYoYS5qPWEuai5yZXBsYWNlKC86JC8sXCJcIikpO31mdW5jdGlvbiBPYyhhLGIpe2lmKGIpe2I9TnVtYmVyKGIpO2lmKGlzTmFOKGIpfHwwPmIpdGhyb3cgRXJyb3IoXCJCYWQgcG9ydCBudW1iZXIgXCIrYik7YS5tPWI7fWVsc2UgYS5tPW51bGw7fWZ1bmN0aW9uIFFjKGEsYixjKXtiIGluc3RhbmNlb2YgUGM/KGEuaT1iLFhjKGEuaSxhLmgpKTooY3x8KGI9U2MoYixZYykpLGEuaT1uZXcgUGMoYixhLmgpKTt9ZnVuY3Rpb24gSyhhLGIsYyl7YS5pLnNldChiLGMpO31mdW5jdGlvbiBoYyhhKXtLKGEsXCJ6eFwiLE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikrTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4Kk1hdGgucmFuZG9tKCkpXkRhdGUubm93KCkpLnRvU3RyaW5nKDM2KSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBSYyhhLGIpe3JldHVybiBhP2I/ZGVjb2RlVVJJKGEucmVwbGFjZSgvJTI1L2csXCIlMjUyNVwiKSk6ZGVjb2RlVVJJQ29tcG9uZW50KGEpOlwiXCJ9ZnVuY3Rpb24gU2MoYSxiLGMpe3JldHVybiBcInN0cmluZ1wiPT09dHlwZW9mIGE/KGE9ZW5jb2RlVVJJKGEpLnJlcGxhY2UoYixaYyksYyYmKGE9YS5yZXBsYWNlKC8lMjUoWzAtOWEtZkEtRl17Mn0pL2csXCIlJDFcIikpLGEpOm51bGx9ZnVuY3Rpb24gWmMoYSl7YT1hLmNoYXJDb2RlQXQoMCk7cmV0dXJuIFwiJVwiKyhhPj40JjE1KS50b1N0cmluZygxNikrKGEmMTUpLnRvU3RyaW5nKDE2KX12YXIgVGM9L1sjXFwvXFw/QF0vZyxWYz0vWyNcXD86XS9nLFVjPS9bI1xcP10vZyxZYz0vWyNcXD9AXS9nLFdjPS8jL2c7ZnVuY3Rpb24gUGMoYSxiKXt0aGlzLmg9dGhpcy5nPW51bGw7dGhpcy5pPWF8fG51bGw7dGhpcy5qPSEhYjt9XG5mdW5jdGlvbiBOKGEpe2EuZ3x8KGEuZz1uZXcgTWFwLGEuaD0wLGEuaSYmTWMoYS5pLGZ1bmN0aW9uKGIsYyl7YS5hZGQoZGVjb2RlVVJJQ29tcG9uZW50KGIucmVwbGFjZSgvXFwrL2csXCIgXCIpKSxjKTt9KSk7fWs9UGMucHJvdG90eXBlO2suYWRkPWZ1bmN0aW9uKGEsYil7Tih0aGlzKTt0aGlzLmk9bnVsbDthPU8odGhpcyxhKTt2YXIgYz10aGlzLmcuZ2V0KGEpO2N8fHRoaXMuZy5zZXQoYSxjPVtdKTtjLnB1c2goYik7dGhpcy5oKz0xO3JldHVybiB0aGlzfTtmdW5jdGlvbiAkYyhhLGIpe04oYSk7Yj1PKGEsYik7YS5nLmhhcyhiKSYmKGEuaT1udWxsLGEuaC09YS5nLmdldChiKS5sZW5ndGgsYS5nLmRlbGV0ZShiKSk7fWZ1bmN0aW9uIGFkKGEsYil7TihhKTtiPU8oYSxiKTtyZXR1cm4gYS5nLmhhcyhiKX1cbmsuZm9yRWFjaD1mdW5jdGlvbihhLGIpe04odGhpcyk7dGhpcy5nLmZvckVhY2goZnVuY3Rpb24oYyxkKXtjLmZvckVhY2goZnVuY3Rpb24oZSl7YS5jYWxsKGIsZSxkLHRoaXMpO30sdGhpcyk7fSx0aGlzKTt9O2sudGE9ZnVuY3Rpb24oKXtOKHRoaXMpO2NvbnN0IGE9QXJyYXkuZnJvbSh0aGlzLmcudmFsdWVzKCkpLGI9QXJyYXkuZnJvbSh0aGlzLmcua2V5cygpKSxjPVtdO2ZvcihsZXQgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXtjb25zdCBlPWFbZF07Zm9yKGxldCBmPTA7ZjxlLmxlbmd0aDtmKyspYy5wdXNoKGJbZF0pO31yZXR1cm4gY307ay5aPWZ1bmN0aW9uKGEpe04odGhpcyk7bGV0IGI9W107aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWFkKHRoaXMsYSkmJihiPWIuY29uY2F0KHRoaXMuZy5nZXQoTyh0aGlzLGEpKSkpO2Vsc2Uge2E9QXJyYXkuZnJvbSh0aGlzLmcudmFsdWVzKCkpO2ZvcihsZXQgYz0wO2M8YS5sZW5ndGg7YysrKWI9Yi5jb25jYXQoYVtjXSk7fXJldHVybiBifTtcbmsuc2V0PWZ1bmN0aW9uKGEsYil7Tih0aGlzKTt0aGlzLmk9bnVsbDthPU8odGhpcyxhKTthZCh0aGlzLGEpJiYodGhpcy5oLT10aGlzLmcuZ2V0KGEpLmxlbmd0aCk7dGhpcy5nLnNldChhLFtiXSk7dGhpcy5oKz0xO3JldHVybiB0aGlzfTtrLmdldD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBiO2E9dGhpcy5aKGEpO3JldHVybiAwPGEubGVuZ3RoP1N0cmluZyhhWzBdKTpifTtmdW5jdGlvbiBrYyhhLGIsYyl7JGMoYSxiKTswPGMubGVuZ3RoJiYoYS5pPW51bGwsYS5nLnNldChPKGEsYiksbWEoYykpLGEuaCs9Yy5sZW5ndGgpO31cbmsudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLmkpcmV0dXJuIHRoaXMuaTtpZighdGhpcy5nKXJldHVybiBcIlwiO2NvbnN0IGE9W10sYj1BcnJheS5mcm9tKHRoaXMuZy5rZXlzKCkpO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1iW2NdO2NvbnN0IGY9ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSksaD10aGlzLlooZCk7Zm9yKGQ9MDtkPGgubGVuZ3RoO2QrKyl7dmFyIGU9ZjtcIlwiIT09aFtkXSYmKGUrPVwiPVwiK2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoaFtkXSkpKTthLnB1c2goZSk7fX1yZXR1cm4gdGhpcy5pPWEuam9pbihcIiZcIil9O2Z1bmN0aW9uIE8oYSxiKXtiPVN0cmluZyhiKTthLmomJihiPWIudG9Mb3dlckNhc2UoKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBYYyhhLGIpe2ImJiFhLmomJihOKGEpLGEuaT1udWxsLGEuZy5mb3JFYWNoKGZ1bmN0aW9uKGMsZCl7dmFyIGU9ZC50b0xvd2VyQ2FzZSgpO2QhPWUmJigkYyh0aGlzLGQpLGtjKHRoaXMsZSxjKSk7fSxhKSk7YS5qPWI7fXZhciBiZD1jbGFzc3tjb25zdHJ1Y3RvcihhLGIpe3RoaXMuZz1hO3RoaXMubWFwPWI7fX07ZnVuY3Rpb24gY2QoYSl7dGhpcy5sPWF8fGRkO2wuUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nPyhhPWwucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZShcIm5hdmlnYXRpb25cIiksYT0wPGEubGVuZ3RoJiYoXCJocVwiPT1hWzBdLm5leHRIb3BQcm90b2NvbHx8XCJoMlwiPT1hWzBdLm5leHRIb3BQcm90b2NvbCkpOmE9ISEobC5nJiZsLmcuS2EmJmwuZy5LYSgpJiZsLmcuS2EoKS5kYyk7dGhpcy5qPWE/dGhpcy5sOjE7dGhpcy5nPW51bGw7MTx0aGlzLmomJih0aGlzLmc9bmV3IFNldCk7dGhpcy5oPW51bGw7dGhpcy5pPVtdO312YXIgZGQ9MTA7ZnVuY3Rpb24gZWQoYSl7cmV0dXJuIGEuaD8hMDphLmc/YS5nLnNpemU+PWEuajohMX1mdW5jdGlvbiBCYyhhKXtyZXR1cm4gYS5oPzE6YS5nP2EuZy5zaXplOjB9ZnVuY3Rpb24geGMoYSxiKXtyZXR1cm4gYS5oP2EuaD09YjphLmc/YS5nLmhhcyhiKTohMX1mdW5jdGlvbiBDYyhhLGIpe2EuZz9hLmcuYWRkKGIpOmEuaD1iO31cbmZ1bmN0aW9uIEVjKGEsYil7YS5oJiZhLmg9PWI/YS5oPW51bGw6YS5nJiZhLmcuaGFzKGIpJiZhLmcuZGVsZXRlKGIpO31jZC5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKCl7dGhpcy5pPWZkKHRoaXMpO2lmKHRoaXMuaCl0aGlzLmguY2FuY2VsKCksdGhpcy5oPW51bGw7ZWxzZSBpZih0aGlzLmcmJjAhPT10aGlzLmcuc2l6ZSl7Zm9yKGNvbnN0IGEgb2YgdGhpcy5nLnZhbHVlcygpKWEuY2FuY2VsKCk7dGhpcy5nLmNsZWFyKCk7fX07ZnVuY3Rpb24gZmQoYSl7aWYobnVsbCE9YS5oKXJldHVybiBhLmkuY29uY2F0KGEuaC5GKTtpZihudWxsIT1hLmcmJjAhPT1hLmcuc2l6ZSl7bGV0IGI9YS5pO2Zvcihjb25zdCBjIG9mIGEuZy52YWx1ZXMoKSliPWIuY29uY2F0KGMuRik7cmV0dXJuIGJ9cmV0dXJuIG1hKGEuaSl9dmFyIGdkPWNsYXNze3N0cmluZ2lmeShhKXtyZXR1cm4gbC5KU09OLnN0cmluZ2lmeShhLHZvaWQgMCl9cGFyc2UoYSl7cmV0dXJuIGwuSlNPTi5wYXJzZShhLHZvaWQgMCl9fTtmdW5jdGlvbiBoZCgpe3RoaXMuZz1uZXcgZ2Q7fWZ1bmN0aW9uIGlkKGEsYixjKXtjb25zdCBkPWN8fFwiXCI7dHJ5e0tjKGEsZnVuY3Rpb24oZSxmKXtsZXQgaD1lO3AoZSkmJihoPWpiKGUpKTtiLnB1c2goZCtmK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChoKSk7fSk7fWNhdGNoKGUpe3Rocm93IGIucHVzaChkK1widHlwZT1cIitlbmNvZGVVUklDb21wb25lbnQoXCJfYmFkbWFwXCIpKSxlO319ZnVuY3Rpb24gamQoYSxiKXtjb25zdCBjPW5ldyBHYjtpZihsLkltYWdlKXtjb25zdCBkPW5ldyBJbWFnZTtkLm9ubG9hZD1oYShrZCxjLGQsXCJUZXN0TG9hZEltYWdlOiBsb2FkZWRcIiwhMCxiKTtkLm9uZXJyb3I9aGEoa2QsYyxkLFwiVGVzdExvYWRJbWFnZTogZXJyb3JcIiwhMSxiKTtkLm9uYWJvcnQ9aGEoa2QsYyxkLFwiVGVzdExvYWRJbWFnZTogYWJvcnRcIiwhMSxiKTtkLm9udGltZW91dD1oYShrZCxjLGQsXCJUZXN0TG9hZEltYWdlOiB0aW1lb3V0XCIsITEsYik7bC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoZC5vbnRpbWVvdXQpZC5vbnRpbWVvdXQoKTt9LDFFNCk7ZC5zcmM9YTt9ZWxzZSBiKCExKTt9ZnVuY3Rpb24ga2QoYSxiLGMsZCxlKXt0cnl7Yi5vbmxvYWQ9bnVsbCxiLm9uZXJyb3I9bnVsbCxiLm9uYWJvcnQ9bnVsbCxiLm9udGltZW91dD1udWxsLGUoZCk7fWNhdGNoKGYpe319ZnVuY3Rpb24gbGQoYSl7dGhpcy5sPWEuZWN8fG51bGw7dGhpcy5qPWEub2J8fCExO31yKGxkLFViKTtsZC5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3JldHVybiBuZXcgbWQodGhpcy5sLHRoaXMuail9O2xkLnByb3RvdHlwZS5pPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhfX0oe30pO2Z1bmN0aW9uIG1kKGEsYil7Qi5jYWxsKHRoaXMpO3RoaXMuRj1hO3RoaXMudT1iO3RoaXMubT12b2lkIDA7dGhpcy5yZWFkeVN0YXRlPW5kO3RoaXMuc3RhdHVzPTA7dGhpcy5yZXNwb25zZVR5cGU9dGhpcy5yZXNwb25zZVRleHQ9dGhpcy5yZXNwb25zZT10aGlzLnN0YXR1c1RleHQ9XCJcIjt0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO3RoaXMudj1uZXcgSGVhZGVyczt0aGlzLmg9bnVsbDt0aGlzLkM9XCJHRVRcIjt0aGlzLkI9XCJcIjt0aGlzLmc9ITE7dGhpcy5BPXRoaXMuaj10aGlzLmw9bnVsbDt9cihtZCxCKTt2YXIgbmQ9MDtrPW1kLnByb3RvdHlwZTtcbmsub3Blbj1mdW5jdGlvbihhLGIpe2lmKHRoaXMucmVhZHlTdGF0ZSE9bmQpdGhyb3cgdGhpcy5hYm9ydCgpLEVycm9yKFwiRXJyb3IgcmVvcGVuaW5nIGEgY29ubmVjdGlvblwiKTt0aGlzLkM9YTt0aGlzLkI9Yjt0aGlzLnJlYWR5U3RhdGU9MTtvZCh0aGlzKTt9O2suc2VuZD1mdW5jdGlvbihhKXtpZigxIT10aGlzLnJlYWR5U3RhdGUpdGhyb3cgdGhpcy5hYm9ydCgpLEVycm9yKFwibmVlZCB0byBjYWxsIG9wZW4oKSBmaXJzdC4gXCIpO3RoaXMuZz0hMDtjb25zdCBiPXtoZWFkZXJzOnRoaXMudixtZXRob2Q6dGhpcy5DLGNyZWRlbnRpYWxzOnRoaXMubSxjYWNoZTp2b2lkIDB9O2EmJihiLmJvZHk9YSk7KHRoaXMuRnx8bCkuZmV0Y2gobmV3IFJlcXVlc3QodGhpcy5CLGIpKS50aGVuKHRoaXMuJGEuYmluZCh0aGlzKSx0aGlzLmthLmJpbmQodGhpcykpO307XG5rLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5yZXNwb25zZT10aGlzLnJlc3BvbnNlVGV4dD1cIlwiO3RoaXMudj1uZXcgSGVhZGVyczt0aGlzLnN0YXR1cz0wO3RoaXMuaiYmdGhpcy5qLmNhbmNlbChcIlJlcXVlc3Qgd2FzIGFib3J0ZWQuXCIpLmNhdGNoKCgpPT57fSk7MTw9dGhpcy5yZWFkeVN0YXRlJiZ0aGlzLmcmJjQhPXRoaXMucmVhZHlTdGF0ZSYmKHRoaXMuZz0hMSxwZCh0aGlzKSk7dGhpcy5yZWFkeVN0YXRlPW5kO307XG5rLiRhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZyYmKHRoaXMubD1hLHRoaXMuaHx8KHRoaXMuc3RhdHVzPXRoaXMubC5zdGF0dXMsdGhpcy5zdGF0dXNUZXh0PXRoaXMubC5zdGF0dXNUZXh0LHRoaXMuaD1hLmhlYWRlcnMsdGhpcy5yZWFkeVN0YXRlPTIsb2QodGhpcykpLHRoaXMuZyYmKHRoaXMucmVhZHlTdGF0ZT0zLG9kKHRoaXMpLHRoaXMuZykpKWlmKFwiYXJyYXlidWZmZXJcIj09PXRoaXMucmVzcG9uc2VUeXBlKWEuYXJyYXlCdWZmZXIoKS50aGVuKHRoaXMuWWEuYmluZCh0aGlzKSx0aGlzLmthLmJpbmQodGhpcykpO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsLlJlYWRhYmxlU3RyZWFtJiZcImJvZHlcImluIGEpe3RoaXMuaj1hLmJvZHkuZ2V0UmVhZGVyKCk7aWYodGhpcy51KXtpZih0aGlzLnJlc3BvbnNlVHlwZSl0aHJvdyBFcnJvcigncmVzcG9uc2VUeXBlIG11c3QgYmUgZW1wdHkgZm9yIFwic3RyZWFtQmluYXJ5Q2h1bmtzXCIgbW9kZSByZXNwb25zZXMuJyk7dGhpcy5yZXNwb25zZT1cbltdO31lbHNlIHRoaXMucmVzcG9uc2U9dGhpcy5yZXNwb25zZVRleHQ9XCJcIix0aGlzLkE9bmV3IFRleHREZWNvZGVyO3FkKHRoaXMpO31lbHNlIGEudGV4dCgpLnRoZW4odGhpcy5aYS5iaW5kKHRoaXMpLHRoaXMua2EuYmluZCh0aGlzKSk7fTtmdW5jdGlvbiBxZChhKXthLmoucmVhZCgpLnRoZW4oYS5YYS5iaW5kKGEpKS5jYXRjaChhLmthLmJpbmQoYSkpO31rLlhhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZyl7aWYodGhpcy51JiZhLnZhbHVlKXRoaXMucmVzcG9uc2UucHVzaChhLnZhbHVlKTtlbHNlIGlmKCF0aGlzLnUpe3ZhciBiPWEudmFsdWU/YS52YWx1ZTpuZXcgVWludDhBcnJheSgwKTtpZihiPXRoaXMuQS5kZWNvZGUoYix7c3RyZWFtOiFhLmRvbmV9KSl0aGlzLnJlc3BvbnNlPXRoaXMucmVzcG9uc2VUZXh0Kz1iO31hLmRvbmU/cGQodGhpcyk6b2QodGhpcyk7Mz09dGhpcy5yZWFkeVN0YXRlJiZxZCh0aGlzKTt9fTtcbmsuWmE9ZnVuY3Rpb24oYSl7dGhpcy5nJiYodGhpcy5yZXNwb25zZT10aGlzLnJlc3BvbnNlVGV4dD1hLHBkKHRoaXMpKTt9O2suWWE9ZnVuY3Rpb24oYSl7dGhpcy5nJiYodGhpcy5yZXNwb25zZT1hLHBkKHRoaXMpKTt9O2sua2E9ZnVuY3Rpb24oKXt0aGlzLmcmJnBkKHRoaXMpO307ZnVuY3Rpb24gcGQoYSl7YS5yZWFkeVN0YXRlPTQ7YS5sPW51bGw7YS5qPW51bGw7YS5BPW51bGw7b2QoYSk7fWsuc2V0UmVxdWVzdEhlYWRlcj1mdW5jdGlvbihhLGIpe3RoaXMudi5hcHBlbmQoYSxiKTt9O2suZ2V0UmVzcG9uc2VIZWFkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaD90aGlzLmguZ2V0KGEudG9Mb3dlckNhc2UoKSl8fFwiXCI6XCJcIn07XG5rLmdldEFsbFJlc3BvbnNlSGVhZGVycz1mdW5jdGlvbigpe2lmKCF0aGlzLmgpcmV0dXJuIFwiXCI7Y29uc3QgYT1bXSxiPXRoaXMuaC5lbnRyaWVzKCk7Zm9yKHZhciBjPWIubmV4dCgpOyFjLmRvbmU7KWM9Yy52YWx1ZSxhLnB1c2goY1swXStcIjogXCIrY1sxXSksYz1iLm5leHQoKTtyZXR1cm4gYS5qb2luKFwiXFxyXFxuXCIpfTtmdW5jdGlvbiBvZChhKXthLm9ucmVhZHlzdGF0ZWNoYW5nZSYmYS5vbnJlYWR5c3RhdGVjaGFuZ2UuY2FsbChhKTt9T2JqZWN0LmRlZmluZVByb3BlcnR5KG1kLnByb3RvdHlwZSxcIndpdGhDcmVkZW50aWFsc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gXCJpbmNsdWRlXCI9PT10aGlzLm19LHNldDpmdW5jdGlvbihhKXt0aGlzLm09YT9cImluY2x1ZGVcIjpcInNhbWUtb3JpZ2luXCI7fX0pO3ZhciByZD1sLkpTT04ucGFyc2U7ZnVuY3Rpb24gUChhKXtCLmNhbGwodGhpcyk7dGhpcy5oZWFkZXJzPW5ldyBNYXA7dGhpcy51PWF8fG51bGw7dGhpcy5oPSExO3RoaXMuQz10aGlzLmc9bnVsbDt0aGlzLkk9XCJcIjt0aGlzLm09MDt0aGlzLmo9XCJcIjt0aGlzLmw9dGhpcy5HPXRoaXMudj10aGlzLkY9ITE7dGhpcy5CPTA7dGhpcy5BPW51bGw7dGhpcy5LPXNkO3RoaXMuTD10aGlzLk09ITE7fXIoUCxCKTt2YXIgc2Q9XCJcIix0ZD0vXmh0dHBzPyQvaSx1ZD1bXCJQT1NUXCIsXCJQVVRcIl07az1QLnByb3RvdHlwZTtrLk9hPWZ1bmN0aW9uKGEpe3RoaXMuTT1hO307XG5rLmhhPWZ1bmN0aW9uKGEsYixjLGQpe2lmKHRoaXMuZyl0aHJvdyBFcnJvcihcIltnb29nLm5ldC5YaHJJb10gT2JqZWN0IGlzIGFjdGl2ZSB3aXRoIGFub3RoZXIgcmVxdWVzdD1cIit0aGlzLkkrXCI7IG5ld1VyaT1cIithKTtiPWI/Yi50b1VwcGVyQ2FzZSgpOlwiR0VUXCI7dGhpcy5JPWE7dGhpcy5qPVwiXCI7dGhpcy5tPTA7dGhpcy5GPSExO3RoaXMuaD0hMDt0aGlzLmc9dGhpcy51P3RoaXMudS5nKCk6JGIuZygpO3RoaXMuQz10aGlzLnU/VmIodGhpcy51KTpWYigkYik7dGhpcy5nLm9ucmVhZHlzdGF0ZWNoYW5nZT1xKHRoaXMuTGEsdGhpcyk7dHJ5e3RoaXMuRz0hMCx0aGlzLmcub3BlbihiLFN0cmluZyhhKSwhMCksdGhpcy5HPSExO31jYXRjaChmKXt2ZCh0aGlzLGYpO3JldHVybn1hPWN8fFwiXCI7Yz1uZXcgTWFwKHRoaXMuaGVhZGVycyk7aWYoZClpZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZCk9PT1PYmplY3QucHJvdG90eXBlKWZvcih2YXIgZSBpbiBkKWMuc2V0KGUsZFtlXSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT1cbnR5cGVvZiBkLmtleXMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmdldClmb3IoY29uc3QgZiBvZiBkLmtleXMoKSljLnNldChmLGQuZ2V0KGYpKTtlbHNlIHRocm93IEVycm9yKFwiVW5rbm93biBpbnB1dCB0eXBlIGZvciBvcHRfaGVhZGVyczogXCIrU3RyaW5nKGQpKTtkPUFycmF5LmZyb20oYy5rZXlzKCkpLmZpbmQoZj0+XCJjb250ZW50LXR5cGVcIj09Zi50b0xvd2VyQ2FzZSgpKTtlPWwuRm9ybURhdGEmJmEgaW5zdGFuY2VvZiBsLkZvcm1EYXRhOyEoMDw9a2EodWQsYikpfHxkfHxlfHxjLnNldChcIkNvbnRlbnQtVHlwZVwiLFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLThcIik7Zm9yKGNvbnN0IFtmLGhdb2YgYyl0aGlzLmcuc2V0UmVxdWVzdEhlYWRlcihmLGgpO3RoaXMuSyYmKHRoaXMuZy5yZXNwb25zZVR5cGU9dGhpcy5LKTtcIndpdGhDcmVkZW50aWFsc1wiaW4gdGhpcy5nJiZ0aGlzLmcud2l0aENyZWRlbnRpYWxzIT09dGhpcy5NJiYodGhpcy5nLndpdGhDcmVkZW50aWFscz1cbnRoaXMuTSk7dHJ5e3dkKHRoaXMpLDA8dGhpcy5CJiYoKHRoaXMuTD14ZCh0aGlzLmcpKT8odGhpcy5nLnRpbWVvdXQ9dGhpcy5CLHRoaXMuZy5vbnRpbWVvdXQ9cSh0aGlzLnVhLHRoaXMpKTp0aGlzLkE9eWIodGhpcy51YSx0aGlzLkIsdGhpcykpLHRoaXMudj0hMCx0aGlzLmcuc2VuZChhKSx0aGlzLnY9ITE7fWNhdGNoKGYpe3ZkKHRoaXMsZik7fX07ZnVuY3Rpb24geGQoYSl7cmV0dXJuIHomJlwibnVtYmVyXCI9PT10eXBlb2YgYS50aW1lb3V0JiZ2b2lkIDAhPT1hLm9udGltZW91dH1rLnVhPWZ1bmN0aW9uKCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdvb2cmJnRoaXMuZyYmKHRoaXMuaj1cIlRpbWVkIG91dCBhZnRlciBcIit0aGlzLkIrXCJtcywgYWJvcnRpbmdcIix0aGlzLm09OCxDKHRoaXMsXCJ0aW1lb3V0XCIpLHRoaXMuYWJvcnQoOCkpO307ZnVuY3Rpb24gdmQoYSxiKXthLmg9ITE7YS5nJiYoYS5sPSEwLGEuZy5hYm9ydCgpLGEubD0hMSk7YS5qPWI7YS5tPTU7eWQoYSk7emQoYSk7fVxuZnVuY3Rpb24geWQoYSl7YS5GfHwoYS5GPSEwLEMoYSxcImNvbXBsZXRlXCIpLEMoYSxcImVycm9yXCIpKTt9ay5hYm9ydD1mdW5jdGlvbihhKXt0aGlzLmcmJnRoaXMuaCYmKHRoaXMuaD0hMSx0aGlzLmw9ITAsdGhpcy5nLmFib3J0KCksdGhpcy5sPSExLHRoaXMubT1hfHw3LEModGhpcyxcImNvbXBsZXRlXCIpLEModGhpcyxcImFib3J0XCIpLHpkKHRoaXMpKTt9O2suTj1mdW5jdGlvbigpe3RoaXMuZyYmKHRoaXMuaCYmKHRoaXMuaD0hMSx0aGlzLmw9ITAsdGhpcy5nLmFib3J0KCksdGhpcy5sPSExKSx6ZCh0aGlzLCEwKSk7UC4kLk4uY2FsbCh0aGlzKTt9O2suTGE9ZnVuY3Rpb24oKXt0aGlzLnN8fCh0aGlzLkd8fHRoaXMudnx8dGhpcy5sP0FkKHRoaXMpOnRoaXMua2IoKSk7fTtrLmtiPWZ1bmN0aW9uKCl7QWQodGhpcyk7fTtcbmZ1bmN0aW9uIEFkKGEpe2lmKGEuaCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdvb2cmJighYS5DWzFdfHw0IT1IKGEpfHwyIT1hLmRhKCkpKWlmKGEudiYmND09SChhKSl5YihhLkxhLDAsYSk7ZWxzZSBpZihDKGEsXCJyZWFkeXN0YXRlY2hhbmdlXCIpLDQ9PUgoYSkpe2EuaD0hMTt0cnl7Y29uc3QgaD1hLmRhKCk7YTpzd2l0Y2goaCl7Y2FzZSAyMDA6Y2FzZSAyMDE6Y2FzZSAyMDI6Y2FzZSAyMDQ6Y2FzZSAyMDY6Y2FzZSAzMDQ6Y2FzZSAxMjIzOnZhciBiPSEwO2JyZWFrIGE7ZGVmYXVsdDpiPSExO312YXIgYztpZighKGM9Yikpe3ZhciBkO2lmKGQ9MD09PWgpe3ZhciBlPVN0cmluZyhhLkkpLm1hdGNoKExjKVsxXXx8bnVsbDshZSYmbC5zZWxmJiZsLnNlbGYubG9jYXRpb24mJihlPWwuc2VsZi5sb2NhdGlvbi5wcm90b2NvbC5zbGljZSgwLC0xKSk7ZD0hdGQudGVzdChlP2UudG9Mb3dlckNhc2UoKTpcIlwiKTt9Yz1kO31pZihjKUMoYSxcImNvbXBsZXRlXCIpLEMoYSxcInN1Y2Nlc3NcIik7ZWxzZSB7YS5tPVxuNjt0cnl7dmFyIGY9MjxIKGEpP2EuZy5zdGF0dXNUZXh0OlwiXCI7fWNhdGNoKG4pe2Y9XCJcIjt9YS5qPWYrXCIgW1wiK2EuZGEoKStcIl1cIjt5ZChhKTt9fWZpbmFsbHl7emQoYSk7fX19ZnVuY3Rpb24gemQoYSxiKXtpZihhLmcpe3dkKGEpO2NvbnN0IGM9YS5nLGQ9YS5DWzBdPygpPT57fTpudWxsO2EuZz1udWxsO2EuQz1udWxsO2J8fEMoYSxcInJlYWR5XCIpO3RyeXtjLm9ucmVhZHlzdGF0ZWNoYW5nZT1kO31jYXRjaChlKXt9fX1mdW5jdGlvbiB3ZChhKXthLmcmJmEuTCYmKGEuZy5vbnRpbWVvdXQ9bnVsbCk7YS5BJiYobC5jbGVhclRpbWVvdXQoYS5BKSxhLkE9bnVsbCk7fWsuaXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gISF0aGlzLmd9O2Z1bmN0aW9uIEgoYSl7cmV0dXJuIGEuZz9hLmcucmVhZHlTdGF0ZTowfWsuZGE9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIDI8SCh0aGlzKT90aGlzLmcuc3RhdHVzOi0xfWNhdGNoKGEpe3JldHVybiAtMX19O1xuay5qYT1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdGhpcy5nP3RoaXMuZy5yZXNwb25zZVRleHQ6XCJcIn1jYXRjaChhKXtyZXR1cm4gXCJcIn19O2suV2E9ZnVuY3Rpb24oYSl7aWYodGhpcy5nKXt2YXIgYj10aGlzLmcucmVzcG9uc2VUZXh0O2EmJjA9PWIuaW5kZXhPZihhKSYmKGI9Yi5zdWJzdHJpbmcoYS5sZW5ndGgpKTtyZXR1cm4gcmQoYil9fTtmdW5jdGlvbiBtYyhhKXt0cnl7aWYoIWEuZylyZXR1cm4gbnVsbDtpZihcInJlc3BvbnNlXCJpbiBhLmcpcmV0dXJuIGEuZy5yZXNwb25zZTtzd2l0Y2goYS5LKXtjYXNlIHNkOmNhc2UgXCJ0ZXh0XCI6cmV0dXJuIGEuZy5yZXNwb25zZVRleHQ7Y2FzZSBcImFycmF5YnVmZmVyXCI6aWYoXCJtb3pSZXNwb25zZUFycmF5QnVmZmVyXCJpbiBhLmcpcmV0dXJuIGEuZy5tb3pSZXNwb25zZUFycmF5QnVmZmVyfXJldHVybiBudWxsfWNhdGNoKGIpe3JldHVybiBudWxsfX1cbmZ1bmN0aW9uIHRjKGEpe2NvbnN0IGI9e307YT0oYS5nJiYyPD1IKGEpP2EuZy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKXx8XCJcIjpcIlwiKS5zcGxpdChcIlxcclxcblwiKTtmb3IobGV0IGQ9MDtkPGEubGVuZ3RoO2QrKyl7aWYoeChhW2RdKSljb250aW51ZTt2YXIgYz1xYihhW2RdKTtjb25zdCBlPWNbMF07Yz1jWzFdO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYyljb250aW51ZTtjPWMudHJpbSgpO2NvbnN0IGY9YltlXXx8W107YltlXT1mO2YucHVzaChjKTt9T2EoYixmdW5jdGlvbihkKXtyZXR1cm4gZC5qb2luKFwiLCBcIil9KTt9ay5JYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm19O2suU2E9ZnVuY3Rpb24oKXtyZXR1cm4gXCJzdHJpbmdcIj09PXR5cGVvZiB0aGlzLmo/dGhpcy5qOlN0cmluZyh0aGlzLmopfTtmdW5jdGlvbiBCZChhKXtsZXQgYj1cIlwiO05hKGEsZnVuY3Rpb24oYyxkKXtiKz1kO2IrPVwiOlwiO2IrPWM7Yis9XCJcXHJcXG5cIjt9KTtyZXR1cm4gYn1mdW5jdGlvbiBDZChhLGIsYyl7YTp7Zm9yKGQgaW4gYyl7dmFyIGQ9ITE7YnJlYWsgYX1kPSEwO31kfHwoYz1CZChjKSxcInN0cmluZ1wiPT09dHlwZW9mIGE/KG51bGwhPWMmJmVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYykpKTpLKGEsYixjKSk7fWZ1bmN0aW9uIERkKGEsYixjKXtyZXR1cm4gYyYmYy5pbnRlcm5hbENoYW5uZWxQYXJhbXM/Yy5pbnRlcm5hbENoYW5uZWxQYXJhbXNbYV18fGI6Yn1cbmZ1bmN0aW9uIEVkKGEpe3RoaXMuR2E9MDt0aGlzLmo9W107dGhpcy5sPW5ldyBHYjt0aGlzLnBhPXRoaXMud2E9dGhpcy5JPXRoaXMuWT10aGlzLmc9dGhpcy5EYT10aGlzLkY9dGhpcy5uYT10aGlzLm89dGhpcy5VPXRoaXMucz1udWxsO3RoaXMuZmI9dGhpcy5XPTA7dGhpcy5jYj1EZChcImZhaWxGYXN0XCIsITEsYSk7dGhpcy5HPXRoaXMudj10aGlzLnU9dGhpcy5tPXRoaXMuaD1udWxsO3RoaXMuYWE9ITA7dGhpcy5GYT10aGlzLlY9LTE7dGhpcy5iYT10aGlzLkE9dGhpcy5DPTA7dGhpcy5hYj1EZChcImJhc2VSZXRyeURlbGF5TXNcIiw1RTMsYSk7dGhpcy5oYj1EZChcInJldHJ5RGVsYXlTZWVkTXNcIiwxRTQsYSk7dGhpcy5lYj1EZChcImZvcndhcmRDaGFubmVsTWF4UmV0cmllc1wiLDIsYSk7dGhpcy54YT1EZChcImZvcndhcmRDaGFubmVsUmVxdWVzdFRpbWVvdXRNc1wiLDJFNCxhKTt0aGlzLnZhPWEmJmEueG1sSHR0cEZhY3Rvcnl8fHZvaWQgMDt0aGlzLkhhPWEmJmEudXNlRmV0Y2hTdHJlYW1zfHxcbiExO3RoaXMuTD12b2lkIDA7dGhpcy5KPWEmJmEuc3VwcG9ydHNDcm9zc0RvbWFpblhocnx8ITE7dGhpcy5LPVwiXCI7dGhpcy5pPW5ldyBjZChhJiZhLmNvbmN1cnJlbnRSZXF1ZXN0TGltaXQpO3RoaXMuSmE9bmV3IGhkO3RoaXMuUD1hJiZhLmZhc3RIYW5kc2hha2V8fCExO3RoaXMuTz1hJiZhLmVuY29kZUluaXRNZXNzYWdlSGVhZGVyc3x8ITE7dGhpcy5QJiZ0aGlzLk8mJih0aGlzLk89ITEpO3RoaXMuYmI9YSYmYS5iY3x8ITE7YSYmYS5FYSYmdGhpcy5sLkVhKCk7YSYmYS5mb3JjZUxvbmdQb2xsaW5nJiYodGhpcy5hYT0hMSk7dGhpcy5jYT0hdGhpcy5QJiZ0aGlzLmFhJiZhJiZhLmRldGVjdEJ1ZmZlcmluZ1Byb3h5fHwhMTt0aGlzLnFhPXZvaWQgMDthJiZhLmxvbmdQb2xsaW5nVGltZW91dCYmMDxhLmxvbmdQb2xsaW5nVGltZW91dCYmKHRoaXMucWE9YS5sb25nUG9sbGluZ1RpbWVvdXQpO3RoaXMub2E9dm9pZCAwO3RoaXMuUz0wO3RoaXMuTT0hMTt0aGlzLm1hPXRoaXMuQj1udWxsO31cbms9RWQucHJvdG90eXBlO2sucmE9ODtrLkg9MTtmdW5jdGlvbiBIYyhhKXtGZChhKTtpZigzPT1hLkgpe3ZhciBiPWEuVysrLGM9RyhhLkkpO0soYyxcIlNJRFwiLGEuSyk7SyhjLFwiUklEXCIsYik7SyhjLFwiVFlQRVwiLFwidGVybWluYXRlXCIpO0dkKGEsYyk7Yj1uZXcgYmMoYSxhLmwsYik7Yi5MPTI7Yi5BPWhjKEcoYykpO2M9ITE7aWYobC5uYXZpZ2F0b3ImJmwubmF2aWdhdG9yLnNlbmRCZWFjb24pdHJ5e2M9bC5uYXZpZ2F0b3Iuc2VuZEJlYWNvbihiLkEudG9TdHJpbmcoKSxcIlwiKTt9Y2F0Y2goZCl7fSFjJiZsLkltYWdlJiYoKG5ldyBJbWFnZSkuc3JjPWIuQSxjPSEwKTtjfHwoYi5nPWxjKGIubCxudWxsKSxiLmcuaGEoYi5BKSk7Yi5HPURhdGUubm93KCk7amMoYik7fUhkKGEpO31mdW5jdGlvbiB6YyhhKXthLmcmJih2YyhhKSxhLmcuY2FuY2VsKCksYS5nPW51bGwpO31cbmZ1bmN0aW9uIEZkKGEpe3pjKGEpO2EudSYmKGwuY2xlYXJUaW1lb3V0KGEudSksYS51PW51bGwpO3ljKGEpO2EuaS5jYW5jZWwoKTthLm0mJihcIm51bWJlclwiPT09dHlwZW9mIGEubSYmbC5jbGVhclRpbWVvdXQoYS5tKSxhLm09bnVsbCk7fWZ1bmN0aW9uIEdjKGEpe2lmKCFlZChhLmkpJiYhYS5tKXthLm09ITA7dmFyIGI9YS5OYTtzYnx8dmIoKTt0Ynx8KHNiKCksdGI9ITApO21iLmFkZChiLGEpO2EuQz0wO319ZnVuY3Rpb24gSWQoYSxiKXtpZihCYyhhLmkpPj1hLmkuai0oYS5tPzE6MCkpcmV0dXJuICExO2lmKGEubSlyZXR1cm4gYS5qPWIuRi5jb25jYXQoYS5qKSwhMDtpZigxPT1hLkh8fDI9PWEuSHx8YS5DPj0oYS5jYj8wOmEuZWIpKXJldHVybiAhMTthLm09UmIocShhLk5hLGEsYiksSmQoYSxhLkMpKTthLkMrKztyZXR1cm4gITB9XG5rLk5hPWZ1bmN0aW9uKGEpe2lmKHRoaXMubSlpZih0aGlzLm09bnVsbCwxPT10aGlzLkgpe2lmKCFhKXt0aGlzLlc9TWF0aC5mbG9vcigxRTUqTWF0aC5yYW5kb20oKSk7YT10aGlzLlcrKztjb25zdCBlPW5ldyBiYyh0aGlzLHRoaXMubCxhKTtsZXQgZj10aGlzLnM7dGhpcy5VJiYoZj8oZj1QYShmKSxSYShmLHRoaXMuVSkpOmY9dGhpcy5VKTtudWxsIT09dGhpcy5vfHx0aGlzLk98fChlLkk9ZixmPW51bGwpO2lmKHRoaXMuUClhOnt2YXIgYj0wO2Zvcih2YXIgYz0wO2M8dGhpcy5qLmxlbmd0aDtjKyspe2I6e3ZhciBkPXRoaXMualtjXTtpZihcIl9fZGF0YV9fXCJpbiBkLm1hcCYmKGQ9ZC5tYXAuX19kYXRhX18sXCJzdHJpbmdcIj09PXR5cGVvZiBkKSl7ZD1kLmxlbmd0aDticmVhayBifWQ9dm9pZCAwO31pZih2b2lkIDA9PT1kKWJyZWFrO2IrPWQ7aWYoNDA5NjxiKXtiPWM7YnJlYWsgYX1pZig0MDk2PT09Ynx8Yz09PXRoaXMuai5sZW5ndGgtMSl7Yj1jKzE7YnJlYWsgYX19Yj0xRTM7fWVsc2UgYj1cbjFFMztiPUtkKHRoaXMsZSxiKTtjPUcodGhpcy5JKTtLKGMsXCJSSURcIixhKTtLKGMsXCJDVkVSXCIsMjIpO3RoaXMuRiYmSyhjLFwiWC1IVFRQLVNlc3Npb24tSWRcIix0aGlzLkYpO0dkKHRoaXMsYyk7ZiYmKHRoaXMuTz9iPVwiaGVhZGVycz1cIitlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKEJkKGYpKSkrXCImXCIrYjp0aGlzLm8mJkNkKGMsdGhpcy5vLGYpKTtDYyh0aGlzLmksZSk7dGhpcy5iYiYmSyhjLFwiVFlQRVwiLFwiaW5pdFwiKTt0aGlzLlA/KEsoYyxcIiRyZXFcIixiKSxLKGMsXCJTSURcIixcIm51bGxcIiksZS5hYT0hMCxnYyhlLGMsbnVsbCkpOmdjKGUsYyxiKTt0aGlzLkg9Mjt9fWVsc2UgMz09dGhpcy5IJiYoYT9MZCh0aGlzLGEpOjA9PXRoaXMuai5sZW5ndGh8fGVkKHRoaXMuaSl8fExkKHRoaXMpKTt9O1xuZnVuY3Rpb24gTGQoYSxiKXt2YXIgYztiP2M9Yi5tOmM9YS5XKys7Y29uc3QgZD1HKGEuSSk7SyhkLFwiU0lEXCIsYS5LKTtLKGQsXCJSSURcIixjKTtLKGQsXCJBSURcIixhLlYpO0dkKGEsZCk7YS5vJiZhLnMmJkNkKGQsYS5vLGEucyk7Yz1uZXcgYmMoYSxhLmwsYyxhLkMrMSk7bnVsbD09PWEubyYmKGMuST1hLnMpO2ImJihhLmo9Yi5GLmNvbmNhdChhLmopKTtiPUtkKGEsYywxRTMpO2Muc2V0VGltZW91dChNYXRoLnJvdW5kKC41KmEueGEpK01hdGgucm91bmQoLjUqYS54YSpNYXRoLnJhbmRvbSgpKSk7Q2MoYS5pLGMpO2djKGMsZCxiKTt9ZnVuY3Rpb24gR2QoYSxiKXthLm5hJiZOYShhLm5hLGZ1bmN0aW9uKGMsZCl7SyhiLGQsYyk7fSk7YS5oJiZLYyh7fSxmdW5jdGlvbihjLGQpe0soYixkLGMpO30pO31cbmZ1bmN0aW9uIEtkKGEsYixjKXtjPU1hdGgubWluKGEuai5sZW5ndGgsYyk7dmFyIGQ9YS5oP3EoYS5oLlZhLGEuaCxhKTpudWxsO2E6e3ZhciBlPWEuajtsZXQgZj0tMTtmb3IoOzspe2NvbnN0IGg9W1wiY291bnQ9XCIrY107LTE9PWY/MDxjPyhmPWVbMF0uZyxoLnB1c2goXCJvZnM9XCIrZikpOmY9MDpoLnB1c2goXCJvZnM9XCIrZik7bGV0IG49ITA7Zm9yKGxldCB0PTA7dDxjO3QrKyl7bGV0IG09ZVt0XS5nO2NvbnN0IHU9ZVt0XS5tYXA7bS09ZjtpZigwPm0pZj1NYXRoLm1heCgwLGVbdF0uZy0xMDApLG49ITE7ZWxzZSB0cnl7aWQodSxoLFwicmVxXCIrbStcIl9cIik7fWNhdGNoKEwpe2QmJmQodSk7fX1pZihuKXtkPWguam9pbihcIiZcIik7YnJlYWsgYX19fWE9YS5qLnNwbGljZSgwLGMpO2IuRj1hO3JldHVybiBkfWZ1bmN0aW9uIEZjKGEpe2lmKCFhLmcmJiFhLnUpe2EuYmE9MTt2YXIgYj1hLk1hO3NifHx2YigpO3RifHwoc2IoKSx0Yj0hMCk7bWIuYWRkKGIsYSk7YS5BPTA7fX1cbmZ1bmN0aW9uIEFjKGEpe2lmKGEuZ3x8YS51fHwzPD1hLkEpcmV0dXJuICExO2EuYmErKzthLnU9UmIocShhLk1hLGEpLEpkKGEsYS5BKSk7YS5BKys7cmV0dXJuICEwfWsuTWE9ZnVuY3Rpb24oKXt0aGlzLnU9bnVsbDtNZCh0aGlzKTtpZih0aGlzLmNhJiYhKHRoaXMuTXx8bnVsbD09dGhpcy5nfHwwPj10aGlzLlMpKXt2YXIgYT0yKnRoaXMuUzt0aGlzLmwuaW5mbyhcIkJQIGRldGVjdGlvbiB0aW1lciBlbmFibGVkOiBcIithKTt0aGlzLkI9UmIocSh0aGlzLmpiLHRoaXMpLGEpO319O2suamI9ZnVuY3Rpb24oKXt0aGlzLkImJih0aGlzLkI9bnVsbCx0aGlzLmwuaW5mbyhcIkJQIGRldGVjdGlvbiB0aW1lb3V0IHJlYWNoZWQuXCIpLHRoaXMubC5pbmZvKFwiQnVmZmVyaW5nIHByb3h5IGRldGVjdGVkIGFuZCBzd2l0Y2ggdG8gbG9uZy1wb2xsaW5nIVwiKSx0aGlzLkc9ITEsdGhpcy5NPSEwLEYoMTApLHpjKHRoaXMpLE1kKHRoaXMpKTt9O1xuZnVuY3Rpb24gdmMoYSl7bnVsbCE9YS5CJiYobC5jbGVhclRpbWVvdXQoYS5CKSxhLkI9bnVsbCk7fWZ1bmN0aW9uIE1kKGEpe2EuZz1uZXcgYmMoYSxhLmwsXCJycGNcIixhLmJhKTtudWxsPT09YS5vJiYoYS5nLkk9YS5zKTthLmcuTz0wO3ZhciBiPUcoYS53YSk7SyhiLFwiUklEXCIsXCJycGNcIik7SyhiLFwiU0lEXCIsYS5LKTtLKGIsXCJBSURcIixhLlYpO0soYixcIkNJXCIsYS5HP1wiMFwiOlwiMVwiKTshYS5HJiZhLnFhJiZLKGIsXCJUT1wiLGEucWEpO0soYixcIlRZUEVcIixcInhtbGh0dHBcIik7R2QoYSxiKTthLm8mJmEucyYmQ2QoYixhLm8sYS5zKTthLkwmJmEuZy5zZXRUaW1lb3V0KGEuTCk7dmFyIGM9YS5nO2E9YS5wYTtjLkw9MTtjLkE9aGMoRyhiKSk7Yy51PW51bGw7Yy5TPSEwO2ljKGMsYSk7fWsuaWI9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnYmJih0aGlzLnY9bnVsbCx6Yyh0aGlzKSxBYyh0aGlzKSxGKDE5KSk7fTtcbmZ1bmN0aW9uIHljKGEpe251bGwhPWEudiYmKGwuY2xlYXJUaW1lb3V0KGEudiksYS52PW51bGwpO31mdW5jdGlvbiBzYyhhLGIpe3ZhciBjPW51bGw7aWYoYS5nPT1iKXt5YyhhKTt2YyhhKTthLmc9bnVsbDt2YXIgZD0yO31lbHNlIGlmKHhjKGEuaSxiKSljPWIuRixFYyhhLmksYiksZD0xO2Vsc2UgcmV0dXJuO2lmKDAhPWEuSClpZihiLmkpaWYoMT09ZCl7Yz1iLnU/Yi51Lmxlbmd0aDowO2I9RGF0ZS5ub3coKS1iLkc7dmFyIGU9YS5DO2Q9TWIoKTtDKGQsbmV3IFFiKGQsYykpO0djKGEpO31lbHNlIEZjKGEpO2Vsc2UgaWYoZT1iLnMsMz09ZXx8MD09ZSYmMDxiLmNhfHwhKDE9PWQmJklkKGEsYil8fDI9PWQmJkFjKGEpKSlzd2l0Y2goYyYmMDxjLmxlbmd0aCYmKGI9YS5pLGIuaT1iLmkuY29uY2F0KGMpKSxlKXtjYXNlIDE6SihhLDUpO2JyZWFrO2Nhc2UgNDpKKGEsMTApO2JyZWFrO2Nhc2UgMzpKKGEsNik7YnJlYWs7ZGVmYXVsdDpKKGEsMik7fX1cbmZ1bmN0aW9uIEpkKGEsYil7bGV0IGM9YS5hYitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqYS5oYik7YS5pc0FjdGl2ZSgpfHwoYyo9Mik7cmV0dXJuIGMqYn1mdW5jdGlvbiBKKGEsYil7YS5sLmluZm8oXCJFcnJvciBjb2RlIFwiK2IpO2lmKDI9PWIpe3ZhciBjPW51bGw7YS5oJiYoYz1udWxsKTt2YXIgZD1xKGEucGIsYSk7Y3x8KGM9bmV3IE0oXCIvL3d3dy5nb29nbGUuY29tL2ltYWdlcy9jbGVhcmRvdC5naWZcIiksbC5sb2NhdGlvbiYmXCJodHRwXCI9PWwubG9jYXRpb24ucHJvdG9jb2x8fE5jKGMsXCJodHRwc1wiKSxoYyhjKSk7amQoYy50b1N0cmluZygpLGQpO31lbHNlIEYoMik7YS5IPTA7YS5oJiZhLmguemEoYik7SGQoYSk7RmQoYSk7fWsucGI9ZnVuY3Rpb24oYSl7YT8odGhpcy5sLmluZm8oXCJTdWNjZXNzZnVsbHkgcGluZ2VkIGdvb2dsZS5jb21cIiksRigyKSk6KHRoaXMubC5pbmZvKFwiRmFpbGVkIHRvIHBpbmcgZ29vZ2xlLmNvbVwiKSxGKDEpKTt9O1xuZnVuY3Rpb24gSGQoYSl7YS5IPTA7YS5tYT1bXTtpZihhLmgpe2NvbnN0IGI9ZmQoYS5pKTtpZigwIT1iLmxlbmd0aHx8MCE9YS5qLmxlbmd0aCluYShhLm1hLGIpLG5hKGEubWEsYS5qKSxhLmkuaS5sZW5ndGg9MCxtYShhLmopLGEuai5sZW5ndGg9MDthLmgueWEoKTt9fWZ1bmN0aW9uIERjKGEsYixjKXt2YXIgZD1jIGluc3RhbmNlb2YgTT9HKGMpOm5ldyBNKGMpO2lmKFwiXCIhPWQuZyliJiYoZC5nPWIrXCIuXCIrZC5nKSxPYyhkLGQubSk7ZWxzZSB7dmFyIGU9bC5sb2NhdGlvbjtkPWUucHJvdG9jb2w7Yj1iP2IrXCIuXCIrZS5ob3N0bmFtZTplLmhvc3RuYW1lO2U9K2UucG9ydDt2YXIgZj1uZXcgTShudWxsKTtkJiZOYyhmLGQpO2ImJihmLmc9Yik7ZSYmT2MoZixlKTtjJiYoZi5sPWMpO2Q9Zjt9Yz1hLkY7Yj1hLkRhO2MmJmImJksoZCxjLGIpO0soZCxcIlZFUlwiLGEucmEpO0dkKGEsZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiBsYyhhLGIsYyl7aWYoYiYmIWEuSil0aHJvdyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZWNvbmRhcnkgZG9tYWluIGNhcGFibGUgWGhySW8gb2JqZWN0LlwiKTtiPWEuSGEmJiFhLnZhP25ldyBQKG5ldyBsZCh7b2I6Y30pKTpuZXcgUChhLnZhKTtiLk9hKGEuSik7cmV0dXJuIGJ9ay5pc0FjdGl2ZT1mdW5jdGlvbigpe3JldHVybiAhIXRoaXMuaCYmdGhpcy5oLmlzQWN0aXZlKHRoaXMpfTtmdW5jdGlvbiBOZCgpe31rPU5kLnByb3RvdHlwZTtrLkJhPWZ1bmN0aW9uKCl7fTtrLkFhPWZ1bmN0aW9uKCl7fTtrLnphPWZ1bmN0aW9uKCl7fTtrLnlhPWZ1bmN0aW9uKCl7fTtrLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuICEwfTtrLlZhPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBPZCgpe2lmKHomJiEoMTA8PU51bWJlcihGYSkpKXRocm93IEVycm9yKFwiRW52aXJvbm1lbnRhbCBlcnJvcjogbm8gYXZhaWxhYmxlIHRyYW5zcG9ydC5cIik7fU9kLnByb3RvdHlwZS5nPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBRKGEsYil9O1xuZnVuY3Rpb24gUShhLGIpe0IuY2FsbCh0aGlzKTt0aGlzLmc9bmV3IEVkKGIpO3RoaXMubD1hO3RoaXMuaD1iJiZiLm1lc3NhZ2VVcmxQYXJhbXN8fG51bGw7YT1iJiZiLm1lc3NhZ2VIZWFkZXJzfHxudWxsO2ImJmIuY2xpZW50UHJvdG9jb2xIZWFkZXJSZXF1aXJlZCYmKGE/YVtcIlgtQ2xpZW50LVByb3RvY29sXCJdPVwid2ViY2hhbm5lbFwiOmE9e1wiWC1DbGllbnQtUHJvdG9jb2xcIjpcIndlYmNoYW5uZWxcIn0pO3RoaXMuZy5zPWE7YT1iJiZiLmluaXRNZXNzYWdlSGVhZGVyc3x8bnVsbDtiJiZiLm1lc3NhZ2VDb250ZW50VHlwZSYmKGE/YVtcIlgtV2ViQ2hhbm5lbC1Db250ZW50LVR5cGVcIl09Yi5tZXNzYWdlQ29udGVudFR5cGU6YT17XCJYLVdlYkNoYW5uZWwtQ29udGVudC1UeXBlXCI6Yi5tZXNzYWdlQ29udGVudFR5cGV9KTtiJiZiLkNhJiYoYT9hW1wiWC1XZWJDaGFubmVsLUNsaWVudC1Qcm9maWxlXCJdPWIuQ2E6YT17XCJYLVdlYkNoYW5uZWwtQ2xpZW50LVByb2ZpbGVcIjpiLkNhfSk7dGhpcy5nLlU9XG5hOyhhPWImJmIuY2MpJiYheChhKSYmKHRoaXMuZy5vPWEpO3RoaXMuQT1iJiZiLnN1cHBvcnRzQ3Jvc3NEb21haW5YaHJ8fCExO3RoaXMudj1iJiZiLnNlbmRSYXdKc29ufHwhMTsoYj1iJiZiLmh0dHBTZXNzaW9uSWRQYXJhbSkmJiF4KGIpJiYodGhpcy5nLkY9YixhPXRoaXMuaCxudWxsIT09YSYmYiBpbiBhJiYoYT10aGlzLmgsYiBpbiBhJiZkZWxldGUgYVtiXSkpO3RoaXMuaj1uZXcgUih0aGlzKTt9cihRLEIpO1EucHJvdG90eXBlLm09ZnVuY3Rpb24oKXt0aGlzLmcuaD10aGlzLmo7dGhpcy5BJiYodGhpcy5nLko9ITApO3ZhciBhPXRoaXMuZyxiPXRoaXMubCxjPXRoaXMuaHx8dm9pZCAwO0YoMCk7YS5ZPWI7YS5uYT1jfHx7fTthLkc9YS5hYTthLkk9RGMoYSxudWxsLGEuWSk7R2MoYSk7fTtRLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe0hjKHRoaXMuZyk7fTtcblEucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSl7dmFyIGM9e307Yy5fX2RhdGFfXz1hO2E9Yzt9ZWxzZSB0aGlzLnYmJihjPXt9LGMuX19kYXRhX189amIoYSksYT1jKTtiLmoucHVzaChuZXcgYmQoYi5mYisrLGEpKTszPT1iLkgmJkdjKGIpO307US5wcm90b3R5cGUuTj1mdW5jdGlvbigpe3RoaXMuZy5oPW51bGw7ZGVsZXRlIHRoaXMuajtIYyh0aGlzLmcpO2RlbGV0ZSB0aGlzLmc7US4kLk4uY2FsbCh0aGlzKTt9O1xuZnVuY3Rpb24gUGQoYSl7WWIuY2FsbCh0aGlzKTthLl9faGVhZGVyc19fJiYodGhpcy5oZWFkZXJzPWEuX19oZWFkZXJzX18sdGhpcy5zdGF0dXNDb2RlPWEuX19zdGF0dXNfXyxkZWxldGUgYS5fX2hlYWRlcnNfXyxkZWxldGUgYS5fX3N0YXR1c19fKTt2YXIgYj1hLl9fc21fXztpZihiKXthOntmb3IoY29uc3QgYyBpbiBiKXthPWM7YnJlYWsgYX1hPXZvaWQgMDt9aWYodGhpcy5pPWEpYT10aGlzLmksYj1udWxsIT09YiYmYSBpbiBiP2JbYV06dm9pZCAwO3RoaXMuZGF0YT1iO31lbHNlIHRoaXMuZGF0YT1hO31yKFBkLFliKTtmdW5jdGlvbiBRZCgpe1piLmNhbGwodGhpcyk7dGhpcy5zdGF0dXM9MTt9cihRZCxaYik7ZnVuY3Rpb24gUihhKXt0aGlzLmc9YTt9cihSLE5kKTtSLnByb3RvdHlwZS5CYT1mdW5jdGlvbigpe0ModGhpcy5nLFwiYVwiKTt9O1IucHJvdG90eXBlLkFhPWZ1bmN0aW9uKGEpe0ModGhpcy5nLG5ldyBQZChhKSk7fTtcblIucHJvdG90eXBlLnphPWZ1bmN0aW9uKGEpe0ModGhpcy5nLG5ldyBRZCgpKTt9O1IucHJvdG90eXBlLnlhPWZ1bmN0aW9uKCl7Qyh0aGlzLmcsXCJiXCIpO307ZnVuY3Rpb24gUmQoKXt0aGlzLmJsb2NrU2l6ZT0tMTt9ZnVuY3Rpb24gUygpe3RoaXMuYmxvY2tTaXplPS0xO3RoaXMuYmxvY2tTaXplPTY0O3RoaXMuZz1BcnJheSg0KTt0aGlzLm09QXJyYXkodGhpcy5ibG9ja1NpemUpO3RoaXMuaT10aGlzLmg9MDt0aGlzLnJlc2V0KCk7fXIoUyxSZCk7Uy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmdbMF09MTczMjU4NDE5Mzt0aGlzLmdbMV09NDAyMzIzMzQxNzt0aGlzLmdbMl09MjU2MjM4MzEwMjt0aGlzLmdbM109MjcxNzMzODc4O3RoaXMuaT10aGlzLmg9MDt9O1xuZnVuY3Rpb24gU2QoYSxiLGMpe2N8fChjPTApO3ZhciBkPUFycmF5KDE2KTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGIpZm9yKHZhciBlPTA7MTY+ZTsrK2UpZFtlXT1iLmNoYXJDb2RlQXQoYysrKXxiLmNoYXJDb2RlQXQoYysrKTw8OHxiLmNoYXJDb2RlQXQoYysrKTw8MTZ8Yi5jaGFyQ29kZUF0KGMrKyk8PDI0O2Vsc2UgZm9yKGU9MDsxNj5lOysrZSlkW2VdPWJbYysrXXxiW2MrK108PDh8YltjKytdPDwxNnxiW2MrK108PDI0O2I9YS5nWzBdO2M9YS5nWzFdO2U9YS5nWzJdO3ZhciBmPWEuZ1szXTt2YXIgaD1iKyhmXmMmKGVeZikpK2RbMF0rMzYxNDA5MDM2MCY0Mjk0OTY3Mjk1O2I9YysoaDw8NyY0Mjk0OTY3Mjk1fGg+Pj4yNSk7aD1mKyhlXmImKGNeZSkpK2RbMV0rMzkwNTQwMjcxMCY0Mjk0OTY3Mjk1O2Y9YisoaDw8MTImNDI5NDk2NzI5NXxoPj4+MjApO2g9ZSsoY15mJihiXmMpKStkWzJdKzYwNjEwNTgxOSY0Mjk0OTY3Mjk1O2U9ZisoaDw8MTcmNDI5NDk2NzI5NXxoPj4+MTUpO1xuaD1jKyhiXmUmKGZeYikpK2RbM10rMzI1MDQ0MTk2NiY0Mjk0OTY3Mjk1O2M9ZSsoaDw8MjImNDI5NDk2NzI5NXxoPj4+MTApO2g9YisoZl5jJihlXmYpKStkWzRdKzQxMTg1NDgzOTkmNDI5NDk2NzI5NTtiPWMrKGg8PDcmNDI5NDk2NzI5NXxoPj4+MjUpO2g9ZisoZV5iJihjXmUpKStkWzVdKzEyMDAwODA0MjYmNDI5NDk2NzI5NTtmPWIrKGg8PDEyJjQyOTQ5NjcyOTV8aD4+PjIwKTtoPWUrKGNeZiYoYl5jKSkrZFs2XSsyODIxNzM1OTU1JjQyOTQ5NjcyOTU7ZT1mKyhoPDwxNyY0Mjk0OTY3Mjk1fGg+Pj4xNSk7aD1jKyhiXmUmKGZeYikpK2RbN10rNDI0OTI2MTMxMyY0Mjk0OTY3Mjk1O2M9ZSsoaDw8MjImNDI5NDk2NzI5NXxoPj4+MTApO2g9YisoZl5jJihlXmYpKStkWzhdKzE3NzAwMzU0MTYmNDI5NDk2NzI5NTtiPWMrKGg8PDcmNDI5NDk2NzI5NXxoPj4+MjUpO2g9ZisoZV5iJihjXmUpKStkWzldKzIzMzY1NTI4NzkmNDI5NDk2NzI5NTtmPWIrKGg8PDEyJjQyOTQ5NjcyOTV8XG5oPj4+MjApO2g9ZSsoY15mJihiXmMpKStkWzEwXSs0Mjk0OTI1MjMzJjQyOTQ5NjcyOTU7ZT1mKyhoPDwxNyY0Mjk0OTY3Mjk1fGg+Pj4xNSk7aD1jKyhiXmUmKGZeYikpK2RbMTFdKzIzMDQ1NjMxMzQmNDI5NDk2NzI5NTtjPWUrKGg8PDIyJjQyOTQ5NjcyOTV8aD4+PjEwKTtoPWIrKGZeYyYoZV5mKSkrZFsxMl0rMTgwNDYwMzY4MiY0Mjk0OTY3Mjk1O2I9YysoaDw8NyY0Mjk0OTY3Mjk1fGg+Pj4yNSk7aD1mKyhlXmImKGNeZSkpK2RbMTNdKzQyNTQ2MjYxOTUmNDI5NDk2NzI5NTtmPWIrKGg8PDEyJjQyOTQ5NjcyOTV8aD4+PjIwKTtoPWUrKGNeZiYoYl5jKSkrZFsxNF0rMjc5Mjk2NTAwNiY0Mjk0OTY3Mjk1O2U9ZisoaDw8MTcmNDI5NDk2NzI5NXxoPj4+MTUpO2g9YysoYl5lJihmXmIpKStkWzE1XSsxMjM2NTM1MzI5JjQyOTQ5NjcyOTU7Yz1lKyhoPDwyMiY0Mjk0OTY3Mjk1fGg+Pj4xMCk7aD1iKyhlXmYmKGNeZSkpK2RbMV0rNDEyOTE3MDc4NiY0Mjk0OTY3Mjk1O2I9YysoaDw8XG41JjQyOTQ5NjcyOTV8aD4+PjI3KTtoPWYrKGNeZSYoYl5jKSkrZFs2XSszMjI1NDY1NjY0JjQyOTQ5NjcyOTU7Zj1iKyhoPDw5JjQyOTQ5NjcyOTV8aD4+PjIzKTtoPWUrKGJeYyYoZl5iKSkrZFsxMV0rNjQzNzE3NzEzJjQyOTQ5NjcyOTU7ZT1mKyhoPDwxNCY0Mjk0OTY3Mjk1fGg+Pj4xOCk7aD1jKyhmXmImKGVeZikpK2RbMF0rMzkyMTA2OTk5NCY0Mjk0OTY3Mjk1O2M9ZSsoaDw8MjAmNDI5NDk2NzI5NXxoPj4+MTIpO2g9YisoZV5mJihjXmUpKStkWzVdKzM1OTM0MDg2MDUmNDI5NDk2NzI5NTtiPWMrKGg8PDUmNDI5NDk2NzI5NXxoPj4+MjcpO2g9ZisoY15lJihiXmMpKStkWzEwXSszODAxNjA4MyY0Mjk0OTY3Mjk1O2Y9YisoaDw8OSY0Mjk0OTY3Mjk1fGg+Pj4yMyk7aD1lKyhiXmMmKGZeYikpK2RbMTVdKzM2MzQ0ODg5NjEmNDI5NDk2NzI5NTtlPWYrKGg8PDE0JjQyOTQ5NjcyOTV8aD4+PjE4KTtoPWMrKGZeYiYoZV5mKSkrZFs0XSszODg5NDI5NDQ4JjQyOTQ5NjcyOTU7Yz1cbmUrKGg8PDIwJjQyOTQ5NjcyOTV8aD4+PjEyKTtoPWIrKGVeZiYoY15lKSkrZFs5XSs1Njg0NDY0MzgmNDI5NDk2NzI5NTtiPWMrKGg8PDUmNDI5NDk2NzI5NXxoPj4+MjcpO2g9ZisoY15lJihiXmMpKStkWzE0XSszMjc1MTYzNjA2JjQyOTQ5NjcyOTU7Zj1iKyhoPDw5JjQyOTQ5NjcyOTV8aD4+PjIzKTtoPWUrKGJeYyYoZl5iKSkrZFszXSs0MTA3NjAzMzM1JjQyOTQ5NjcyOTU7ZT1mKyhoPDwxNCY0Mjk0OTY3Mjk1fGg+Pj4xOCk7aD1jKyhmXmImKGVeZikpK2RbOF0rMTE2MzUzMTUwMSY0Mjk0OTY3Mjk1O2M9ZSsoaDw8MjAmNDI5NDk2NzI5NXxoPj4+MTIpO2g9YisoZV5mJihjXmUpKStkWzEzXSsyODUwMjg1ODI5JjQyOTQ5NjcyOTU7Yj1jKyhoPDw1JjQyOTQ5NjcyOTV8aD4+PjI3KTtoPWYrKGNeZSYoYl5jKSkrZFsyXSs0MjQzNTYzNTEyJjQyOTQ5NjcyOTU7Zj1iKyhoPDw5JjQyOTQ5NjcyOTV8aD4+PjIzKTtoPWUrKGJeYyYoZl5iKSkrZFs3XSsxNzM1MzI4NDczJjQyOTQ5NjcyOTU7XG5lPWYrKGg8PDE0JjQyOTQ5NjcyOTV8aD4+PjE4KTtoPWMrKGZeYiYoZV5mKSkrZFsxMl0rMjM2ODM1OTU2MiY0Mjk0OTY3Mjk1O2M9ZSsoaDw8MjAmNDI5NDk2NzI5NXxoPj4+MTIpO2g9YisoY15lXmYpK2RbNV0rNDI5NDU4ODczOCY0Mjk0OTY3Mjk1O2I9YysoaDw8NCY0Mjk0OTY3Mjk1fGg+Pj4yOCk7aD1mKyhiXmNeZSkrZFs4XSsyMjcyMzkyODMzJjQyOTQ5NjcyOTU7Zj1iKyhoPDwxMSY0Mjk0OTY3Mjk1fGg+Pj4yMSk7aD1lKyhmXmJeYykrZFsxMV0rMTgzOTAzMDU2MiY0Mjk0OTY3Mjk1O2U9ZisoaDw8MTYmNDI5NDk2NzI5NXxoPj4+MTYpO2g9YysoZV5mXmIpK2RbMTRdKzQyNTk2NTc3NDAmNDI5NDk2NzI5NTtjPWUrKGg8PDIzJjQyOTQ5NjcyOTV8aD4+PjkpO2g9YisoY15lXmYpK2RbMV0rMjc2Mzk3NTIzNiY0Mjk0OTY3Mjk1O2I9YysoaDw8NCY0Mjk0OTY3Mjk1fGg+Pj4yOCk7aD1mKyhiXmNeZSkrZFs0XSsxMjcyODkzMzUzJjQyOTQ5NjcyOTU7Zj1iKyhoPDwxMSY0Mjk0OTY3Mjk1fFxuaD4+PjIxKTtoPWUrKGZeYl5jKStkWzddKzQxMzk0Njk2NjQmNDI5NDk2NzI5NTtlPWYrKGg8PDE2JjQyOTQ5NjcyOTV8aD4+PjE2KTtoPWMrKGVeZl5iKStkWzEwXSszMjAwMjM2NjU2JjQyOTQ5NjcyOTU7Yz1lKyhoPDwyMyY0Mjk0OTY3Mjk1fGg+Pj45KTtoPWIrKGNeZV5mKStkWzEzXSs2ODEyNzkxNzQmNDI5NDk2NzI5NTtiPWMrKGg8PDQmNDI5NDk2NzI5NXxoPj4+MjgpO2g9ZisoYl5jXmUpK2RbMF0rMzkzNjQzMDA3NCY0Mjk0OTY3Mjk1O2Y9YisoaDw8MTEmNDI5NDk2NzI5NXxoPj4+MjEpO2g9ZSsoZl5iXmMpK2RbM10rMzU3MjQ0NTMxNyY0Mjk0OTY3Mjk1O2U9ZisoaDw8MTYmNDI5NDk2NzI5NXxoPj4+MTYpO2g9YysoZV5mXmIpK2RbNl0rNzYwMjkxODkmNDI5NDk2NzI5NTtjPWUrKGg8PDIzJjQyOTQ5NjcyOTV8aD4+PjkpO2g9YisoY15lXmYpK2RbOV0rMzY1NDYwMjgwOSY0Mjk0OTY3Mjk1O2I9YysoaDw8NCY0Mjk0OTY3Mjk1fGg+Pj4yOCk7aD1mKyhiXmNeZSkrZFsxMl0rXG4zODczMTUxNDYxJjQyOTQ5NjcyOTU7Zj1iKyhoPDwxMSY0Mjk0OTY3Mjk1fGg+Pj4yMSk7aD1lKyhmXmJeYykrZFsxNV0rNTMwNzQyNTIwJjQyOTQ5NjcyOTU7ZT1mKyhoPDwxNiY0Mjk0OTY3Mjk1fGg+Pj4xNik7aD1jKyhlXmZeYikrZFsyXSszMjk5NjI4NjQ1JjQyOTQ5NjcyOTU7Yz1lKyhoPDwyMyY0Mjk0OTY3Mjk1fGg+Pj45KTtoPWIrKGVeKGN8fmYpKStkWzBdKzQwOTYzMzY0NTImNDI5NDk2NzI5NTtiPWMrKGg8PDYmNDI5NDk2NzI5NXxoPj4+MjYpO2g9ZisoY14oYnx+ZSkpK2RbN10rMTEyNjg5MTQxNSY0Mjk0OTY3Mjk1O2Y9YisoaDw8MTAmNDI5NDk2NzI5NXxoPj4+MjIpO2g9ZSsoYl4oZnx+YykpK2RbMTRdKzI4Nzg2MTIzOTEmNDI5NDk2NzI5NTtlPWYrKGg8PDE1JjQyOTQ5NjcyOTV8aD4+PjE3KTtoPWMrKGZeKGV8fmIpKStkWzVdKzQyMzc1MzMyNDEmNDI5NDk2NzI5NTtjPWUrKGg8PDIxJjQyOTQ5NjcyOTV8aD4+PjExKTtoPWIrKGVeKGN8fmYpKStkWzEyXSsxNzAwNDg1NTcxJlxuNDI5NDk2NzI5NTtiPWMrKGg8PDYmNDI5NDk2NzI5NXxoPj4+MjYpO2g9ZisoY14oYnx+ZSkpK2RbM10rMjM5OTk4MDY5MCY0Mjk0OTY3Mjk1O2Y9YisoaDw8MTAmNDI5NDk2NzI5NXxoPj4+MjIpO2g9ZSsoYl4oZnx+YykpK2RbMTBdKzQyOTM5MTU3NzMmNDI5NDk2NzI5NTtlPWYrKGg8PDE1JjQyOTQ5NjcyOTV8aD4+PjE3KTtoPWMrKGZeKGV8fmIpKStkWzFdKzIyNDAwNDQ0OTcmNDI5NDk2NzI5NTtjPWUrKGg8PDIxJjQyOTQ5NjcyOTV8aD4+PjExKTtoPWIrKGVeKGN8fmYpKStkWzhdKzE4NzMzMTMzNTkmNDI5NDk2NzI5NTtiPWMrKGg8PDYmNDI5NDk2NzI5NXxoPj4+MjYpO2g9ZisoY14oYnx+ZSkpK2RbMTVdKzQyNjQzNTU1NTImNDI5NDk2NzI5NTtmPWIrKGg8PDEwJjQyOTQ5NjcyOTV8aD4+PjIyKTtoPWUrKGJeKGZ8fmMpKStkWzZdKzI3MzQ3Njg5MTYmNDI5NDk2NzI5NTtlPWYrKGg8PDE1JjQyOTQ5NjcyOTV8aD4+PjE3KTtoPWMrKGZeKGV8fmIpKStkWzEzXSsxMzA5MTUxNjQ5JlxuNDI5NDk2NzI5NTtjPWUrKGg8PDIxJjQyOTQ5NjcyOTV8aD4+PjExKTtoPWIrKGVeKGN8fmYpKStkWzRdKzQxNDk0NDQyMjYmNDI5NDk2NzI5NTtiPWMrKGg8PDYmNDI5NDk2NzI5NXxoPj4+MjYpO2g9ZisoY14oYnx+ZSkpK2RbMTFdKzMxNzQ3NTY5MTcmNDI5NDk2NzI5NTtmPWIrKGg8PDEwJjQyOTQ5NjcyOTV8aD4+PjIyKTtoPWUrKGJeKGZ8fmMpKStkWzJdKzcxODc4NzI1OSY0Mjk0OTY3Mjk1O2U9ZisoaDw8MTUmNDI5NDk2NzI5NXxoPj4+MTcpO2g9YysoZl4oZXx+YikpK2RbOV0rMzk1MTQ4MTc0NSY0Mjk0OTY3Mjk1O2EuZ1swXT1hLmdbMF0rYiY0Mjk0OTY3Mjk1O2EuZ1sxXT1hLmdbMV0rKGUrKGg8PDIxJjQyOTQ5NjcyOTV8aD4+PjExKSkmNDI5NDk2NzI5NTthLmdbMl09YS5nWzJdK2UmNDI5NDk2NzI5NTthLmdbM109YS5nWzNdK2YmNDI5NDk2NzI5NTt9XG5TLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9YS5sZW5ndGgpO2Zvcih2YXIgYz1iLXRoaXMuYmxvY2tTaXplLGQ9dGhpcy5tLGU9dGhpcy5oLGY9MDtmPGI7KXtpZigwPT1lKWZvcig7Zjw9YzspU2QodGhpcyxhLGYpLGYrPXRoaXMuYmxvY2tTaXplO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlmb3IoO2Y8Yjspe2lmKGRbZSsrXT1hLmNoYXJDb2RlQXQoZisrKSxlPT10aGlzLmJsb2NrU2l6ZSl7U2QodGhpcyxkKTtlPTA7YnJlYWt9fWVsc2UgZm9yKDtmPGI7KWlmKGRbZSsrXT1hW2YrK10sZT09dGhpcy5ibG9ja1NpemUpe1NkKHRoaXMsZCk7ZT0wO2JyZWFrfX10aGlzLmg9ZTt0aGlzLmkrPWI7fTtcblMucHJvdG90eXBlLmw9ZnVuY3Rpb24oKXt2YXIgYT1BcnJheSgoNTY+dGhpcy5oP3RoaXMuYmxvY2tTaXplOjIqdGhpcy5ibG9ja1NpemUpLXRoaXMuaCk7YVswXT0xMjg7Zm9yKHZhciBiPTE7YjxhLmxlbmd0aC04OysrYilhW2JdPTA7dmFyIGM9OCp0aGlzLmk7Zm9yKGI9YS5sZW5ndGgtODtiPGEubGVuZ3RoOysrYilhW2JdPWMmMjU1LGMvPTI1Njt0aGlzLmooYSk7YT1BcnJheSgxNik7Zm9yKGI9Yz0wOzQ+YjsrK2IpZm9yKHZhciBkPTA7MzI+ZDtkKz04KWFbYysrXT10aGlzLmdbYl0+Pj5kJjI1NTtyZXR1cm4gYX07ZnVuY3Rpb24gVChhLGIpe3RoaXMuaD1iO2Zvcih2YXIgYz1bXSxkPSEwLGU9YS5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGY9YVtlXXwwO2QmJmY9PWJ8fChjW2VdPWYsZD0hMSk7fXRoaXMuZz1jO312YXIgc2E9e307ZnVuY3Rpb24gVGQoYSl7cmV0dXJuIC0xMjg8PWEmJjEyOD5hP3JhKGEsZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBUKFtifDBdLDA+Yj8tMTowKX0pOm5ldyBUKFthfDBdLDA+YT8tMTowKX1mdW5jdGlvbiBVKGEpe2lmKGlzTmFOKGEpfHwhaXNGaW5pdGUoYSkpcmV0dXJuIFY7aWYoMD5hKXJldHVybiBXKFUoLWEpKTtmb3IodmFyIGI9W10sYz0xLGQ9MDthPj1jO2QrKyliW2RdPWEvY3wwLGMqPVVkO3JldHVybiBuZXcgVChiLDApfVxuZnVuY3Rpb24gVmQoYSxiKXtpZigwPT1hLmxlbmd0aCl0aHJvdyBFcnJvcihcIm51bWJlciBmb3JtYXQgZXJyb3I6IGVtcHR5IHN0cmluZ1wiKTtiPWJ8fDEwO2lmKDI+Ynx8MzY8Yil0aHJvdyBFcnJvcihcInJhZGl4IG91dCBvZiByYW5nZTogXCIrYik7aWYoXCItXCI9PWEuY2hhckF0KDApKXJldHVybiBXKFZkKGEuc3Vic3RyaW5nKDEpLGIpKTtpZigwPD1hLmluZGV4T2YoXCItXCIpKXRocm93IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXInKTtmb3IodmFyIGM9VShNYXRoLnBvdyhiLDgpKSxkPVYsZT0wO2U8YS5sZW5ndGg7ZSs9OCl7dmFyIGY9TWF0aC5taW4oOCxhLmxlbmd0aC1lKSxoPXBhcnNlSW50KGEuc3Vic3RyaW5nKGUsZStmKSxiKTs4PmY/KGY9VShNYXRoLnBvdyhiLGYpKSxkPWQuUihmKS5hZGQoVShoKSkpOihkPWQuUihjKSxkPWQuYWRkKFUoaCkpKTt9cmV0dXJuIGR9XG52YXIgVWQ9NDI5NDk2NzI5NixWPVRkKDApLFdkPVRkKDEpLFhkPVRkKDE2Nzc3MjE2KTtrPVQucHJvdG90eXBlO2suZWE9ZnVuY3Rpb24oKXtpZihYKHRoaXMpKXJldHVybiAtVyh0aGlzKS5lYSgpO2Zvcih2YXIgYT0wLGI9MSxjPTA7Yzx0aGlzLmcubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5EKGMpO2ErPSgwPD1kP2Q6VWQrZCkqYjtiKj1VZDt9cmV0dXJuIGF9O1xuay50b1N0cmluZz1mdW5jdGlvbihhKXthPWF8fDEwO2lmKDI+YXx8MzY8YSl0aHJvdyBFcnJvcihcInJhZGl4IG91dCBvZiByYW5nZTogXCIrYSk7aWYoWSh0aGlzKSlyZXR1cm4gXCIwXCI7aWYoWCh0aGlzKSlyZXR1cm4gXCItXCIrVyh0aGlzKS50b1N0cmluZyhhKTtmb3IodmFyIGI9VShNYXRoLnBvdyhhLDYpKSxjPXRoaXMsZD1cIlwiOzspe3ZhciBlPVlkKGMsYikuZztjPVpkKGMsZS5SKGIpKTt2YXIgZj0oKDA8Yy5nLmxlbmd0aD9jLmdbMF06Yy5oKT4+PjApLnRvU3RyaW5nKGEpO2M9ZTtpZihZKGMpKXJldHVybiBmK2Q7Zm9yKDs2PmYubGVuZ3RoOylmPVwiMFwiK2Y7ZD1mK2Q7fX07ay5EPWZ1bmN0aW9uKGEpe3JldHVybiAwPmE/MDphPHRoaXMuZy5sZW5ndGg/dGhpcy5nW2FdOnRoaXMuaH07ZnVuY3Rpb24gWShhKXtpZigwIT1hLmgpcmV0dXJuICExO2Zvcih2YXIgYj0wO2I8YS5nLmxlbmd0aDtiKyspaWYoMCE9YS5nW2JdKXJldHVybiAhMTtyZXR1cm4gITB9XG5mdW5jdGlvbiBYKGEpe3JldHVybiAtMT09YS5ofWsuWD1mdW5jdGlvbihhKXthPVpkKHRoaXMsYSk7cmV0dXJuIFgoYSk/LTE6WShhKT8wOjF9O2Z1bmN0aW9uIFcoYSl7Zm9yKHZhciBiPWEuZy5sZW5ndGgsYz1bXSxkPTA7ZDxiO2QrKyljW2RdPX5hLmdbZF07cmV0dXJuIChuZXcgVChjLH5hLmgpKS5hZGQoV2QpfWsuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIFgodGhpcyk/Vyh0aGlzKTp0aGlzfTtrLmFkZD1mdW5jdGlvbihhKXtmb3IodmFyIGI9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxhLmcubGVuZ3RoKSxjPVtdLGQ9MCxlPTA7ZTw9YjtlKyspe3ZhciBmPWQrKHRoaXMuRChlKSY2NTUzNSkrKGEuRChlKSY2NTUzNSksaD0oZj4+PjE2KSsodGhpcy5EKGUpPj4+MTYpKyhhLkQoZSk+Pj4xNik7ZD1oPj4+MTY7ZiY9NjU1MzU7aCY9NjU1MzU7Y1tlXT1oPDwxNnxmO31yZXR1cm4gbmV3IFQoYyxjW2MubGVuZ3RoLTFdJi0yMTQ3NDgzNjQ4Py0xOjApfTtcbmZ1bmN0aW9uIFpkKGEsYil7cmV0dXJuIGEuYWRkKFcoYikpfVxuay5SPWZ1bmN0aW9uKGEpe2lmKFkodGhpcyl8fFkoYSkpcmV0dXJuIFY7aWYoWCh0aGlzKSlyZXR1cm4gWChhKT9XKHRoaXMpLlIoVyhhKSk6VyhXKHRoaXMpLlIoYSkpO2lmKFgoYSkpcmV0dXJuIFcodGhpcy5SKFcoYSkpKTtpZigwPnRoaXMuWChYZCkmJjA+YS5YKFhkKSlyZXR1cm4gVSh0aGlzLmVhKCkqYS5lYSgpKTtmb3IodmFyIGI9dGhpcy5nLmxlbmd0aCthLmcubGVuZ3RoLGM9W10sZD0wO2Q8MipiO2QrKyljW2RdPTA7Zm9yKGQ9MDtkPHRoaXMuZy5sZW5ndGg7ZCsrKWZvcih2YXIgZT0wO2U8YS5nLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMuRChkKT4+PjE2LGg9dGhpcy5EKGQpJjY1NTM1LG49YS5EKGUpPj4+MTYsdD1hLkQoZSkmNjU1MzU7Y1syKmQrMiplXSs9aCp0OyRkKGMsMipkKzIqZSk7Y1syKmQrMiplKzFdKz1mKnQ7JGQoYywyKmQrMiplKzEpO2NbMipkKzIqZSsxXSs9aCpuOyRkKGMsMipkKzIqZSsxKTtjWzIqZCsyKmUrMl0rPWYqbjskZChjLDIqZCsyKmUrMik7fWZvcihkPVxuMDtkPGI7ZCsrKWNbZF09Y1syKmQrMV08PDE2fGNbMipkXTtmb3IoZD1iO2Q8MipiO2QrKyljW2RdPTA7cmV0dXJuIG5ldyBUKGMsMCl9O2Z1bmN0aW9uICRkKGEsYil7Zm9yKDsoYVtiXSY2NTUzNSkhPWFbYl07KWFbYisxXSs9YVtiXT4+PjE2LGFbYl0mPTY1NTM1LGIrKzt9ZnVuY3Rpb24gYWUoYSxiKXt0aGlzLmc9YTt0aGlzLmg9Yjt9XG5mdW5jdGlvbiBZZChhLGIpe2lmKFkoYikpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO2lmKFkoYSkpcmV0dXJuIG5ldyBhZShWLFYpO2lmKFgoYSkpcmV0dXJuIGI9WWQoVyhhKSxiKSxuZXcgYWUoVyhiLmcpLFcoYi5oKSk7aWYoWChiKSlyZXR1cm4gYj1ZZChhLFcoYikpLG5ldyBhZShXKGIuZyksYi5oKTtpZigzMDxhLmcubGVuZ3RoKXtpZihYKGEpfHxYKGIpKXRocm93IEVycm9yKFwic2xvd0RpdmlkZV8gb25seSB3b3JrcyB3aXRoIHBvc2l0aXZlIGludGVnZXJzLlwiKTtmb3IodmFyIGM9V2QsZD1iOzA+PWQuWChhKTspYz1iZShjKSxkPWJlKGQpO3ZhciBlPVooYywxKSxmPVooZCwxKTtkPVooZCwyKTtmb3IoYz1aKGMsMik7IVkoZCk7KXt2YXIgaD1mLmFkZChkKTswPj1oLlgoYSkmJihlPWUuYWRkKGMpLGY9aCk7ZD1aKGQsMSk7Yz1aKGMsMSk7fWI9WmQoYSxlLlIoYikpO3JldHVybiBuZXcgYWUoZSxiKX1mb3IoZT1WOzA8PWEuWChiKTspe2M9TWF0aC5tYXgoMSxNYXRoLmZsb29yKGEuZWEoKS9cbmIuZWEoKSkpO2Q9TWF0aC5jZWlsKE1hdGgubG9nKGMpL01hdGguTE4yKTtkPTQ4Pj1kPzE6TWF0aC5wb3coMixkLTQ4KTtmPVUoYyk7Zm9yKGg9Zi5SKGIpO1goaCl8fDA8aC5YKGEpOyljLT1kLGY9VShjKSxoPWYuUihiKTtZKGYpJiYoZj1XZCk7ZT1lLmFkZChmKTthPVpkKGEsaCk7fXJldHVybiBuZXcgYWUoZSxhKX1rLmdiPWZ1bmN0aW9uKGEpe3JldHVybiBZZCh0aGlzLGEpLmh9O2suYW5kPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGEuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YjtkKyspY1tkXT10aGlzLkQoZCkmYS5EKGQpO3JldHVybiBuZXcgVChjLHRoaXMuaCZhLmgpfTtrLm9yPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGEuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YjtkKyspY1tkXT10aGlzLkQoZCl8YS5EKGQpO3JldHVybiBuZXcgVChjLHRoaXMuaHxhLmgpfTtcbmsueG9yPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1NYXRoLm1heCh0aGlzLmcubGVuZ3RoLGEuZy5sZW5ndGgpLGM9W10sZD0wO2Q8YjtkKyspY1tkXT10aGlzLkQoZCleYS5EKGQpO3JldHVybiBuZXcgVChjLHRoaXMuaF5hLmgpfTtmdW5jdGlvbiBiZShhKXtmb3IodmFyIGI9YS5nLmxlbmd0aCsxLGM9W10sZD0wO2Q8YjtkKyspY1tkXT1hLkQoZCk8PDF8YS5EKGQtMSk+Pj4zMTtyZXR1cm4gbmV3IFQoYyxhLmgpfWZ1bmN0aW9uIFooYSxiKXt2YXIgYz1iPj41O2IlPTMyO2Zvcih2YXIgZD1hLmcubGVuZ3RoLWMsZT1bXSxmPTA7ZjxkO2YrKyllW2ZdPTA8Yj9hLkQoZitjKT4+PmJ8YS5EKGYrYysxKTw8MzItYjphLkQoZitjKTtyZXR1cm4gbmV3IFQoZSxhLmgpfU9kLnByb3RvdHlwZS5jcmVhdGVXZWJDaGFubmVsPU9kLnByb3RvdHlwZS5nO1EucHJvdG90eXBlLnNlbmQ9US5wcm90b3R5cGUudTtRLnByb3RvdHlwZS5vcGVuPVEucHJvdG90eXBlLm07US5wcm90b3R5cGUuY2xvc2U9US5wcm90b3R5cGUuY2xvc2U7U2IuTk9fRVJST1I9MDtTYi5USU1FT1VUPTg7U2IuSFRUUF9FUlJPUj02O1RiLkNPTVBMRVRFPVwiY29tcGxldGVcIjtXYi5FdmVudFR5cGU9WGI7WGIuT1BFTj1cImFcIjtYYi5DTE9TRT1cImJcIjtYYi5FUlJPUj1cImNcIjtYYi5NRVNTQUdFPVwiZFwiO0IucHJvdG90eXBlLmxpc3Rlbj1CLnByb3RvdHlwZS5PO1AucHJvdG90eXBlLmxpc3Rlbk9uY2U9UC5wcm90b3R5cGUuUDtQLnByb3RvdHlwZS5nZXRMYXN0RXJyb3I9UC5wcm90b3R5cGUuU2E7UC5wcm90b3R5cGUuZ2V0TGFzdEVycm9yQ29kZT1QLnByb3RvdHlwZS5JYTtQLnByb3RvdHlwZS5nZXRTdGF0dXM9UC5wcm90b3R5cGUuZGE7UC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VKc29uPVAucHJvdG90eXBlLldhO1xuUC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VUZXh0PVAucHJvdG90eXBlLmphO1AucHJvdG90eXBlLnNlbmQ9UC5wcm90b3R5cGUuaGE7UC5wcm90b3R5cGUuc2V0V2l0aENyZWRlbnRpYWxzPVAucHJvdG90eXBlLk9hO1MucHJvdG90eXBlLmRpZ2VzdD1TLnByb3RvdHlwZS5sO1MucHJvdG90eXBlLnJlc2V0PVMucHJvdG90eXBlLnJlc2V0O1MucHJvdG90eXBlLnVwZGF0ZT1TLnByb3RvdHlwZS5qO1QucHJvdG90eXBlLmFkZD1ULnByb3RvdHlwZS5hZGQ7VC5wcm90b3R5cGUubXVsdGlwbHk9VC5wcm90b3R5cGUuUjtULnByb3RvdHlwZS5tb2R1bG89VC5wcm90b3R5cGUuZ2I7VC5wcm90b3R5cGUuY29tcGFyZT1ULnByb3RvdHlwZS5YO1QucHJvdG90eXBlLnRvTnVtYmVyPVQucHJvdG90eXBlLmVhO1QucHJvdG90eXBlLnRvU3RyaW5nPVQucHJvdG90eXBlLnRvU3RyaW5nO1QucHJvdG90eXBlLmdldEJpdHM9VC5wcm90b3R5cGUuRDtULmZyb21OdW1iZXI9VTtULmZyb21TdHJpbmc9VmQ7XG52YXIgY3JlYXRlV2ViQ2hhbm5lbFRyYW5zcG9ydCA9IGVzbS5jcmVhdGVXZWJDaGFubmVsVHJhbnNwb3J0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBPZH07dmFyIGdldFN0YXRFdmVudFRhcmdldCA9IGVzbS5nZXRTdGF0RXZlbnRUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWIoKX07dmFyIEVycm9yQ29kZSA9IGVzbS5FcnJvckNvZGU9U2I7dmFyIEV2ZW50VHlwZSA9IGVzbS5FdmVudFR5cGU9VGI7dmFyIEV2ZW50ID0gZXNtLkV2ZW50PUU7dmFyIFN0YXQgPSBlc20uU3RhdD17eGI6MCxBYjoxLEJiOjIsVWI6MyxaYjo0LFdiOjUsWGI6NixWYjo3LFRiOjgsWWI6OSxQUk9YWToxMCxOT1BST1hZOjExLFJiOjEyLE5iOjEzLE9iOjE0LE1iOjE1LFBiOjE2LFFiOjE3LHRiOjE4LHNiOjE5LHViOjIwfTt2YXIgRmV0Y2hYbWxIdHRwRmFjdG9yeSA9IGVzbS5GZXRjaFhtbEh0dHBGYWN0b3J5PWxkO3ZhciBXZWJDaGFubmVsID0gZXNtLldlYkNoYW5uZWw9V2I7dmFyIFhocklvID0gZXNtLlhocklvPVA7dmFyIE1kNSA9IGVzbS5NZDU9Uzt2YXIgSW50ZWdlciA9IGVzbS5JbnRlZ2VyPVQ7XG5cbmV4cG9ydCB7IEVycm9yQ29kZSwgRXZlbnQsIEV2ZW50VHlwZSwgRmV0Y2hYbWxIdHRwRmFjdG9yeSwgSW50ZWdlciwgTWQ1LCBTdGF0LCBXZWJDaGFubmVsLCBYaHJJbywgY3JlYXRlV2ViQ2hhbm5lbFRyYW5zcG9ydCwgZXNtIGFzIGRlZmF1bHQsIGdldFN0YXRFdmVudFRhcmdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/webchannel-wrapper/dist/esm/index.esm2017.js\n");

/***/ })

};
;